/**
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in `ts-for-gir` or create a bug report on https://github.com/gjsify/ts-for-gir
 *
 * The based EJS template file is used for the generated .d.ts file of each GIR module like Gtk-4.0, GObject-2.0, ...
 */

// Module dependencies
import type Qrtr from '@girs/qrtr-1.0';
import type Gio from '@girs/gio-2.0';
import type GObject from '@girs/gobject-2.0';
import type GLib from '@girs/glib-2.0';
import type GModule from '@girs/gmodule-2.0';

export namespace Qmi {
    /**
     * Qmi-1.0
     */

    /**
     * Common errors that may be reported by libqmi-glib.
     */
    class CoreError extends GLib.Error {
        static $gtype: GObject.GType<CoreError>;

        // Static fields

        /**
         * Operation failed.
         */
        static FAILED: number;
        /**
         * Operation cannot be executed in the current state.
         */
        static WRONGSTATE: number;
        /**
         * Operation timed out.
         */
        static TIMEOUT: number;
        /**
         * Invalid arguments given.
         */
        static INVALIDARGS: number;
        /**
         * QMI message is invalid.
         */
        static INVALIDMESSAGE: number;
        /**
         * TLV not found.
         */
        static TLVNOTFOUND: number;
        /**
         * TLV is too long.
         */
        static TLVTOOLONG: number;
        /**
         * Not supported.
         */
        static UNSUPPORTED: number;
        /**
         * TLV has no value. Empty TLVs are not a real error, so this error type is never generated. Since: 1.12. Deprecated: 1.22.
         */
        static TLVEMPTY: number;
        /**
         * QMI message is unexpected. Since: 1.16.
         */
        static UNEXPECTEDMESSAGE: number;
        /**
         * Invalid data found in the message. Since: 1.24.6.
         */
        static INVALIDDATA: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        /**
         * Gets the nickname string for the #QmiCoreError specified at `val`.
         * @param val a QmiCoreError.
         */
        static get_string(val: CoreError): string;
        static quark(): GLib.Quark;
    }

    /**
     * Controls whether the network port data format includes a QoS header or not.
     * Should normally be set to ABSENT.
     */

    /**
     * Controls whether the network port data format includes a QoS header or not.
     * Should normally be set to ABSENT.
     */
    export namespace CtlDataFormat {
        export const $gtype: GObject.GType<CtlDataFormat>;
    }

    enum CtlDataFormat {
        /**
         * QoS header absent
         */
        ABSENT,
        /**
         * QoS header present
         */
        PRESENT,
    }
    /**
     * Determines the network port data format.
     */

    /**
     * Determines the network port data format.
     */
    export namespace CtlDataLinkProtocol {
        export const $gtype: GObject.GType<CtlDataLinkProtocol>;
    }

    enum CtlDataLinkProtocol {
        UNKNOWN,
        /**
         * data frames formatted as 802.3 Ethernet
         */
        '802_3',
        /**
         * data frames are raw IP packets
         */
        RAW_IP,
    }
    /**
     * Data Endpoint Type.
     */

    /**
     * Data Endpoint Type.
     */
    export namespace DataEndpointType {
        export const $gtype: GObject.GType<DataEndpointType>;
    }

    enum DataEndpointType {
        /**
         * Unknown. Since 1.30.
         */
        UNKNOWN,
        /**
         * High-speed inter-chip interface. Since 1.30.
         */
        HSIC,
        /**
         * High-speed USB.
         */
        HSUSB,
        /**
         * PCIe. Since: 1.28.
         */
        PCIE,
        /**
         * Embedded. Since 1.28.
         */
        EMBEDDED,
        /**
         * BAM/DMUX. Since 1.30.
         */
        BAM_DMUX,
        /**
         * Undefined.
         */
        UNDEFINED,
    }
    /**
     * Data format expected by the kernel.
     *
     * <note><para>
     * This type is only applicable when using the qmi_wwan kernel driver.
     * </para></note>
     */

    /**
     * Data format expected by the kernel.
     *
     * <note><para>
     * This type is only applicable when using the qmi_wwan kernel driver.
     * </para></note>
     */
    export namespace DeviceExpectedDataFormat {
        export const $gtype: GObject.GType<DeviceExpectedDataFormat>;
    }

    enum DeviceExpectedDataFormat {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * 802.3.
         */
        '802_3',
        /**
         * Raw IP.
         */
        RAW_IP,
        /**
         * QMAP pass-through. Since 1.28.
         */
        QMAP_PASS_THROUGH,
    }
    /**
     * State of the service activation.
     */

    /**
     * State of the service activation.
     */
    export namespace DmsActivationState {
        export const $gtype: GObject.GType<DmsActivationState>;
    }

    enum DmsActivationState {
        /**
         * Service not activated.
         */
        NOT_ACTIVATED,
        /**
         * Service is activated.
         */
        ACTIVATED,
        /**
         * Connection in progress for automatic activation.
         */
        CONNECTING,
        /**
         * Connection connected for automatic activation.
         */
        CONNECTED,
        /**
         * OTASP security authenticated.
         */
        OTASP_AUTHENTICATED,
        /**
         * OTASP NAM downloaded.
         */
        OTASP_NAM,
        /**
         * OTASP MDN downloaded.
         */
        OTASP_MDN,
        /**
         * OTASP IMSI downloaded.
         */
        OTASP_IMSI,
        /**
         * OTASP PRL downloaded.
         */
        OTASP_PRL,
        /**
         * OTASP SPC downloaded.
         */
        OTASP_SPC,
        /**
         * OTASP settings committed.
         */
        OTASP_COMMITED,
    }
    /**
     * Specifies the mode for the next boot.
     */

    /**
     * Specifies the mode for the next boot.
     */
    export namespace DmsBootImageDownloadMode {
        export const $gtype: GObject.GType<DmsBootImageDownloadMode>;
    }

    enum DmsBootImageDownloadMode {
        /**
         * Normal operation.
         */
        NORMAL,
        /**
         * Boot and recovery image download mode.
         */
        BOOT_AND_RECOVERY,
    }
    /**
     * Data service capability.
     */

    /**
     * Data service capability.
     */
    export namespace DmsDataServiceCapability {
        export const $gtype: GObject.GType<DmsDataServiceCapability>;
    }

    enum DmsDataServiceCapability {
        /**
         * No data services supported.
         */
        NONE,
        /**
         * Only CS supported.
         */
        CS,
        /**
         * Only PS supported.
         */
        PS,
        /**
         * Simultaneous CS and PS supported.
         */
        SIMULTANEOUS_CS_PS,
        /**
         * Non simultaneous CS and PS supported.
         */
        NON_SIMULTANEOUS_CS_PS,
    }
    /**
     * Type of firmware image.
     */

    /**
     * Type of firmware image.
     */
    export namespace DmsFirmwareImageType {
        export const $gtype: GObject.GType<DmsFirmwareImageType>;
    }

    enum DmsFirmwareImageType {
        /**
         * Modem image.
         */
        MODEM,
        /**
         * PRI image.
         */
        PRI,
    }
    /**
     * Foxconn specific device modes.
     */

    /**
     * Foxconn specific device modes.
     */
    export namespace DmsFoxconnDeviceMode {
        export const $gtype: GObject.GType<DmsFoxconnDeviceMode>;
    }

    enum DmsFoxconnDeviceMode {
        /**
         * Unknown mode.
         */
        UNKNOWN,
        /**
         * Fastboot download mode for full partition files.
         */
        FASTBOOT_ONLINE,
        /**
         * Fastboot download mode for OTA files.
         */
        FASTBOOT_OTA,
    }
    /**
     * Foxconn specific firmware version types.
     */

    /**
     * Foxconn specific firmware version types.
     */
    export namespace DmsFoxconnFirmwareVersionType {
        export const $gtype: GObject.GType<DmsFoxconnFirmwareVersionType>;
    }

    enum DmsFoxconnFirmwareVersionType {
        /**
         * E.g. T77W968.F0.0.0.2.3.GC.004.
         */
        FIRMWARE_MCFG,
        /**
         * E.g. T77W968.F0.0.0.2.3.GC.004.011.
         */
        FIRMWARE_MCFG_APPS,
        /**
         * E.g. 011.
         */
        APPS,
    }
    /**
     * HP specific device modes.
     */

    /**
     * HP specific device modes.
     */
    export namespace DmsHpDeviceMode {
        export const $gtype: GObject.GType<DmsHpDeviceMode>;
    }

    enum DmsHpDeviceMode {
        /**
         * Fastboot download mode.
         */
        FASTBOOT,
    }
    /**
     * Specifies the device from which the MAC address should be queried.
     */

    /**
     * Specifies the device from which the MAC address should be queried.
     */
    export namespace DmsMacType {
        export const $gtype: GObject.GType<DmsMacType>;
    }

    enum DmsMacType {
        /**
         * WLAN MAC address.
         */
        WLAN,
        /**
         * Bluetooth MAC address.
         */
        BT,
    }
    /**
     * Operating mode of the device.
     */

    /**
     * Operating mode of the device.
     */
    export namespace DmsOperatingMode {
        export const $gtype: GObject.GType<DmsOperatingMode>;
    }

    enum DmsOperatingMode {
        /**
         * Device can acquire a system and make calls.
         */
        ONLINE,
        /**
         * Device has temporarily disabled RF.
         */
        LOW_POWER,
        /**
         * Special mode for manufacturer tests.
         */
        FACTORY_TEST,
        /**
         * Device has deactivated RF and is partially shutdown.
         */
        OFFLINE,
        /**
         * Device is in the process of power cycling.
         */
        RESET,
        /**
         * Device is in the process of shutting down.
         */
        SHUTTING_DOWN,
        /**
         * Device has disabled RF and state persists even after a reset.
         */
        PERSISTENT_LOW_POWER,
        /**
         * Mode-only Low Power.
         */
        MODE_ONLY_LOW_POWER,
        /**
         * Unknown.
         */
        UNKNOWN,
    }
    /**
     * Radio interface type.
     */

    /**
     * Radio interface type.
     */
    export namespace DmsRadioInterface {
        export const $gtype: GObject.GType<DmsRadioInterface>;
    }

    enum DmsRadioInterface {
        /**
         * CDMA2000 1x.
         */
        CDMA20001X,
        /**
         * CDMA2000 HRPD (1xEV-DO)
         */
        EVDO,
        /**
         * GSM.
         */
        GSM,
        /**
         * UMTS.
         */
        UMTS,
        /**
         * LTE.
         */
        LTE,
        /**
         * TDS. Since 1.32.
         */
        TDS,
        /**
         * 5G NR. Since 1.26.
         */
        '5GNR',
    }
    /**
     * SIM capability.
     */

    /**
     * SIM capability.
     */
    export namespace DmsSimCapability {
        export const $gtype: GObject.GType<DmsSimCapability>;
    }

    enum DmsSimCapability {
        /**
         * SIM not supported.
         */
        NOT_SUPPORTED,
        /**
         * SIM is supported.
         */
        SUPPORTED,
    }
    /**
     * Sierra Wireless USB composition modes.
     */
    /**
     * Sierra Wireless USB composition modes.
     */
    class DmsSwiUsbComposition {
        static $gtype: GObject.GType<DmsSwiUsbComposition>;

        // Static fields

        /**
         * Unknown.
         */
        static UNKNOWN: number;
        /**
         * HIP, DM, NMEA, AT, MDM1, MDM2, MDM3, MS.
         */
        static '0': number;
        /**
         * HIP, DM, NMEA, AT, MDM1, MS.
         */
        static '1': number;
        /**
         * HIP, DM, NMEA, AT, NIC1, MS.
         */
        static '2': number;
        /**
         * HIP, DM, NMEA, AT, MDM1, NIC1, MS.
         */
        static '3': number;
        /**
         * HIP, DM, NMEA, AT, NIC1, NIC2, NIC3, MS.
         */
        static '4': number;
        /**
         * HIP, DM, NMEA, AT, ECM1, MS.
         */
        static '5': number;
        /**
         * DM, NMEA, AT, QMI.
         */
        static '6': number;
        /**
         * DM, NMEA, AT, RMNET1, RMNET2, RMNET3.
         */
        static '7': number;
        /**
         * DM, NMEA, AT, MBIM.
         */
        static '8': number;
        /**
         * MBIM.
         */
        static '9': number;
        /**
         * NMEA, MBIM.
         */
        static '10': number;
        /**
         * DM, MBIM.
         */
        static '11': number;
        /**
         * DM, NMEA, MBIM.
         */
        static '12': number;
        /**
         * Dual configuration: USB composition 6 and USB composition 8.
         */
        static '13': number;
        /**
         * Dual configuration: USB composition 6 and USB composition 9.
         */
        static '14': number;
        /**
         * Dual configuration: USB composition 6 and USB composition 10.
         */
        static '15': number;
        /**
         * Dual configuration: USB composition 6 and USB composition 11.
         */
        static '16': number;
        /**
         * Dual configuration: USB composition 6 and USB composition 12.
         */
        static '17': number;
        /**
         * Dual configuration: USB composition 7 and USB composition 8.
         */
        static '18': number;
        /**
         * Dual configuration: USB composition 7 and USB composition 9.
         */
        static '19': number;
        /**
         * Dual configuration: USB composition 7 and USB composition 10.
         */
        static '20': number;
        /**
         * Dual configuration: USB composition 7 and USB composition 11.
         */
        static '21': number;
        /**
         * Dual configuration: USB composition 7 and USB composition 12.
         */
        static '22': number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Time reference type.
     */

    /**
     * Time reference type.
     */
    export namespace DmsTimeReferenceType {
        export const $gtype: GObject.GType<DmsTimeReferenceType>;
    }

    enum DmsTimeReferenceType {
        /**
         * User time.
         */
        USER,
    }
    /**
     * Source of the timestamp.
     */

    /**
     * Source of the timestamp.
     */
    export namespace DmsTimeSource {
        export const $gtype: GObject.GType<DmsTimeSource>;
    }

    enum DmsTimeSource {
        /**
         * 32 kHz device clock.
         */
        DEVICE,
        /**
         * CDMA network.
         */
        CDMA_NETWORK,
        /**
         * HDR network.
         */
        HDR_NETWORK,
    }
    /**
     * UIM personalization facilities.
     */

    /**
     * UIM personalization facilities.
     */
    export namespace DmsUimFacility {
        export const $gtype: GObject.GType<DmsUimFacility>;
    }

    enum DmsUimFacility {
        /**
         * Network personalization facility.
         */
        PN,
        /**
         * Network subset personalization facility.
         */
        PU,
        /**
         * Service provider facility.
         */
        PP,
        /**
         * Corporate personalization facility.
         */
        PC,
        /**
         * UIM personalization facility.
         */
        PF,
    }
    /**
     * State of the UIM facility.
     */

    /**
     * State of the UIM facility.
     */
    export namespace DmsUimFacilityState {
        export const $gtype: GObject.GType<DmsUimFacilityState>;
    }

    enum DmsUimFacilityState {
        /**
         * Facility is deactivated.
         */
        DEACTIVATED,
        /**
         * Facility is activated.
         */
        ACTIVATED,
        /**
         * Facility is blocked.
         */
        BLOCKED,
    }
    /**
     * The PIN identifier.
     */

    /**
     * The PIN identifier.
     */
    export namespace DmsUimPinId {
        export const $gtype: GObject.GType<DmsUimPinId>;
    }

    enum DmsUimPinId {
        /**
         * PIN.
         */
        PIN,
        /**
         * PIN2.
         */
        PIN2,
    }
    /**
     * The PIN status.
     */

    /**
     * The PIN status.
     */
    export namespace DmsUimPinStatus {
        export const $gtype: GObject.GType<DmsUimPinStatus>;
    }

    enum DmsUimPinStatus {
        /**
         * Not initialized.
         */
        NOT_INITIALIZED,
        /**
         * Enabled, not verified.
         */
        ENABLED_NOT_VERIFIED,
        /**
         * Enabled, verified.
         */
        ENABLED_VERIFIED,
        /**
         * Disabled.
         */
        DISABLED,
        /**
         * Blocked.
         */
        BLOCKED,
        /**
         * Permanently Blocked.
         */
        PERMANENTLY_BLOCKED,
        /**
         * Unblocked.
         */
        UNBLOCKED,
        /**
         * Changed.
         */
        CHANGED,
    }
    /**
     * State of the UIM.
     */

    /**
     * State of the UIM.
     */
    export namespace DmsUimState {
        export const $gtype: GObject.GType<DmsUimState>;
    }

    enum DmsUimState {
        /**
         * UIM initialization completed.
         */
        INITIALIZATION_COMPLETED,
        /**
         * UIM is locked or failed.
         */
        LOCKED_OR_FAILED,
        /**
         * No UIM in the device.
         */
        NOT_PRESENT,
        /**
         * Reserved, unknown.
         */
        RESERVED,
        /**
         * UIM state currently unavailable.
         */
        UNKNOWN,
    }
    /**
     * APN type.
     */

    /**
     * APN type.
     */
    export namespace DsdApnType {
        export const $gtype: GObject.GType<DsdApnType>;
    }

    enum DsdApnType {
        /**
         * Default/Internet traffic.
         */
        DEFAULT,
        /**
         * IMS.
         */
        IMS,
        /**
         * Multimedia Messaging Service.
         */
        MMS,
        /**
         * Dial Up Network.
         */
        DUN,
        /**
         * Secure User Plane Location.
         */
        SUPL,
        /**
         * High Priority Mobile Data.
         */
        HIPRI,
        /**
         * over the air administration.
         */
        FOTA,
        /**
         * Carrier Branded Services.
         */
        CBS,
        /**
         * Initial Attach.
         */
        IA,
        /**
         * Emergency.
         */
        EMERGENCY,
    }
    /**
     * Network type of the data system.
     */

    /**
     * Network type of the data system.
     */
    export namespace DsdDataSystemNetworkType {
        export const $gtype: GObject.GType<DsdDataSystemNetworkType>;
    }

    enum DsdDataSystemNetworkType {
        /**
         * 3GPP network type.
         */
        '3GPP',
        /**
         * 3GPP2 network type.
         */
        '3GPP2',
        /**
         * WLAN network type.
         */
        WLAN,
    }
    /**
     * Radio access technology.
     */

    /**
     * Radio access technology.
     */
    export namespace DsdRadioAccessTechnology {
        export const $gtype: GObject.GType<DsdRadioAccessTechnology>;
    }

    enum DsdRadioAccessTechnology {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * WCDMA.
         */
        '3GPP_WCDMA',
        /**
         * GERAN.
         */
        '3GPP_GERAN',
        /**
         * LTE.
         */
        '3GPP_LTE',
        /**
         * TD-SDCMA.
         */
        '3GPP_TDSCDMA',
        /**
         * 3GPP WLAN.
         */
        '3GPP_WLAN',
        /**
         * 5G.
         */
        '3GPP_5G',
        /**
         * CDMA 1x.
         */
        '3GPP2_1X',
        /**
         * CDMA EVDO, HRPD.
         */
        '3GPP2_HRPD',
        /**
         * CDMA EVDO with eHRPD.
         */
        '3GPP2_EHRPD',
        /**
         * 3GPP2 WLAN.
         */
        '3GPP2_WLAN',
    }
    /**
     * Type of endianness.
     */

    /**
     * Type of endianness.
     */
    export namespace Endian {
        export const $gtype: GObject.GType<Endian>;
    }

    enum Endian {
        /**
         * Little endian.
         */
        LITTLE,
        /**
         * Big endian.
         */
        BIG,
    }
    /**
     * Foxconn specific firmware version types.
     */

    /**
     * Foxconn specific firmware version types.
     */
    export namespace FoxFirmwareVersionType {
        export const $gtype: GObject.GType<FoxFirmwareVersionType>;
    }

    enum FoxFirmwareVersionType {
        /**
         * E.g. T99W265.F0.0.0.0.1.GC.004.
         */
        FIRMWARE_MCFG,
        /**
         * E.g. T99W265.F0.0.0.0.1.GC.004.001.
         */
        FIRMWARE_MCFG_APPS,
        /**
         * E.g. 001.
         */
        APPS,
    }
    /**
     * Mode when retrieving a list of stored firmwares.
     */

    /**
     * Mode when retrieving a list of stored firmwares.
     */
    export namespace GasFirmwareListingMode {
        export const $gtype: GObject.GType<GasFirmwareListingMode>;
    }

    enum GasFirmwareListingMode {
        /**
         * List only the active firmware.
         */
        ACTIVE_FIRMWARE,
        /**
         * List all stored firmwares.
         */
        ALL_FIRMWARE,
        /**
         * List only specific firmware with condition.
         */
        SPECIFIC_FIRMWARE,
    }
    /**
     * Peripheral endpoint type.
     */

    /**
     * Peripheral endpoint type.
     */
    export namespace GasUsbCompositionEndpointType {
        export const $gtype: GObject.GType<GasUsbCompositionEndpointType>;
    }

    enum GasUsbCompositionEndpointType {
        /**
         * High-speed USB.
         */
        HSUSB,
        /**
         * High-speed inter-chip interface.
         */
        HSIC,
    }
    /**
     * IMS registration status.
     */

    /**
     * IMS registration status.
     */
    export namespace ImsaImsRegistrationStatus {
        export const $gtype: GObject.GType<ImsaImsRegistrationStatus>;
    }

    enum ImsaImsRegistrationStatus {
        /**
         * no registration for IMS.
         */
        NOT_REGISTERED,
        /**
         * IMS is registering.
         */
        REGISTERING,
        /**
         * IMS is fully registered.
         */
        REGISTERED,
        /**
         * IMS is limited registered, expect limited services.
         */
        LIMITED_REGISTERED,
    }
    /**
     * Network technology on which service is available.
     */

    /**
     * Network technology on which service is available.
     */
    export namespace ImsaRegistrationTechnology {
        export const $gtype: GObject.GType<ImsaRegistrationTechnology>;
    }

    enum ImsaRegistrationTechnology {
        /**
         * registered on WLAN interface.
         */
        WLAN,
        /**
         * registered on WWAN interface.
         */
        WWAN,
        /**
         * registered on Interworking WLAN interface.
         */
        INTERWORKING_WLAN,
    }
    /**
     * IMS Application Service availibility status.
     */

    /**
     * IMS Application Service availibility status.
     */
    export namespace ImsaServiceStatus {
        export const $gtype: GObject.GType<ImsaServiceStatus>;
    }

    enum ImsaServiceStatus {
        /**
         * Service unavailable.
         */
        UNAVAILABLE,
        /**
         * Service limited available.
         */
        LIMITED,
        /**
         * Service available.
         */
        AVAILABLE,
    }
    /**
     * IMS Presence enabler state.
     */

    /**
     * IMS Presence enabler state.
     */
    export namespace ImspEnablerState {
        export const $gtype: GObject.GType<ImspEnablerState>;
    }

    enum ImspEnablerState {
        /**
         * IMS is not initialized yet.
         */
        UNINITIALIZED,
        /**
         * IMS is initialized, but not registered yet with the network IMS service.
         */
        INITIALIZED,
        /**
         * IMS is initialized but device is in airplane mode.
         */
        AIRPLANE,
        /**
         * IMS is initialized and registered.
         */
        REGISTERED,
    }
    /**
     * State of the engine.
     *
     * Since 1.22
     */

    /**
     * State of the engine.
     *
     * Since 1.22
     */
    export namespace LocEngineState {
        export const $gtype: GObject.GType<LocEngineState>;
    }

    enum LocEngineState {
        /**
         * On.
         */
        ON,
        /**
         * Off.
         */
        OFF,
    }
    /**
     * Whether to request a single or periodic fixes.
     *
     * Since 1.22
     */

    /**
     * Whether to request a single or periodic fixes.
     *
     * Since 1.22
     */
    export namespace LocFixRecurrenceType {
        export const $gtype: GObject.GType<LocFixRecurrenceType>;
    }

    enum LocFixRecurrenceType {
        /**
         * Periodic fixes.
         */
        PERIODIC_FIXES,
        /**
         * Single fix.
         */
        SINGLE_FIX,
    }
    /**
     * Whether a satellite is healthy or unhealthy.
     *
     * Since 1.22
     */

    /**
     * Whether a satellite is healthy or unhealthy.
     *
     * Since 1.22
     */
    export namespace LocHealthStatus {
        export const $gtype: GObject.GType<LocHealthStatus>;
    }

    enum LocHealthStatus {
        /**
         * Unhealthy.
         */
        UNHEALTHY,
        /**
         * Healthy.
         */
        HEALTHY,
    }
    /**
     * General result of a received indication.
     *
     * Since 1.22
     */

    /**
     * General result of a received indication.
     *
     * Since 1.22
     */
    export namespace LocIndicationStatus {
        export const $gtype: GObject.GType<LocIndicationStatus>;
    }

    enum LocIndicationStatus {
        /**
         * Success.
         */
        SUCCESS,
        /**
         * General Failure.
         */
        GENERAL_FAILURE,
        /**
         * Unsupported.
         */
        UNSUPPORTED,
        /**
         * Invalid Parameter.
         */
        INVALID_PARAMETER,
        /**
         * Engine is busy.
         */
        ENGINE_BUSY,
        /**
         * Phone is offline.
         */
        PHONE_OFFLINE,
        /**
         * Timeout.
         */
        TIMEOUT,
    }
    /**
     * Whether to enable or disable intermediate state reporting.
     */

    /**
     * Whether to enable or disable intermediate state reporting.
     */
    export namespace LocIntermediateReportState {
        export const $gtype: GObject.GType<LocIntermediateReportState>;
    }

    enum LocIntermediateReportState {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * Enable intermediate state reporting.
         */
        ENABLE,
        /**
         * Disable intermediate state reporting.
         */
        DISABLE,
    }
    /**
     * Location engine lock type.
     */

    /**
     * Location engine lock type.
     */
    export namespace LocLockType {
        export const $gtype: GObject.GType<LocLockType>;
    }

    enum LocLockType {
        /**
         * Do not lock any position sessions.
         */
        NONE,
        /**
         * Lock mobile-initiated position sessions.
         */
        MI,
        /**
         * Lock mobile-terminated position sessions.
         */
        MT,
        /**
         * Lock all position sessions.
         */
        ALL,
    }
    /**
     * Whether the ephemeris or almanac exist for a satellite.
     *
     * Since 1.22
     */

    /**
     * Whether the ephemeris or almanac exist for a satellite.
     *
     * Since 1.22
     */
    export namespace LocNavigationData {
        export const $gtype: GObject.GType<LocNavigationData>;
    }

    enum LocNavigationData {
        /**
         * Has ephemeris.
         */
        EPHEMERIS,
        /**
         * Has almanac.
         */
        ALMANAC,
    }
    /**
     * Which operation mode to use.
     *
     * Since 1.22
     */

    /**
     * Which operation mode to use.
     *
     * Since 1.22
     */
    export namespace LocOperationMode {
        export const $gtype: GObject.GType<LocOperationMode>;
    }

    enum LocOperationMode {
        /**
         * Default.
         */
        DEFAULT,
        /**
         * Mobile Station Based (MSB) A-GPS.
         */
        MSB,
        /**
         * Mobile Station Assisted (MSA) A-GPS.
         */
        MSA,
        /**
         * Standalone.
         */
        STANDALONE,
        /**
         * Cell ID.
         */
        CELLID,
        /**
         * WWAN.
         */
        WWAN,
    }
    /**
     * Type of predicted orbits data.
     */

    /**
     * Type of predicted orbits data.
     */
    export namespace LocPredictedOrbitsDataFormat {
        export const $gtype: GObject.GType<LocPredictedOrbitsDataFormat>;
    }

    enum LocPredictedOrbitsDataFormat {
        /**
         * Qualcomm XTRA database.
         */
        XTRA,
    }
    /**
     * Reliability of the provided information.
     *
     * Since 1.22
     */

    /**
     * Reliability of the provided information.
     *
     * Since 1.22
     */
    export namespace LocReliability {
        export const $gtype: GObject.GType<LocReliability>;
    }

    enum LocReliability {
        /**
         * Not set.
         */
        NOT_SET,
        /**
         * Very low.
         */
        VERY_LOW,
        /**
         * Low.
         */
        LOW,
        /**
         * Medium.
         */
        MEDIUM,
        /**
         * High.
         */
        HIGH,
    }
    /**
     * Whether the engine searches or tracks a satellite.
     *
     * Since 1.22
     */

    /**
     * Whether the engine searches or tracks a satellite.
     *
     * Since 1.22
     */
    export namespace LocSatelliteStatus {
        export const $gtype: GObject.GType<LocSatelliteStatus>;
    }

    enum LocSatelliteStatus {
        /**
         * Idle.
         */
        IDLE,
        /**
         * Searching.
         */
        SEARCHING,
        /**
         * Tracking.
         */
        TRACKING,
    }
    /**
     * Server type for Assisted-GPS.
     */

    /**
     * Server type for Assisted-GPS.
     */
    export namespace LocServerType {
        export const $gtype: GObject.GType<LocServerType>;
    }

    enum LocServerType {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * CDMA Position Determining System.
         */
        CDMA_PDE,
        /**
         * CDMA Mobile Positioning Center.
         */
        CDMA_MPC,
        /**
         * SUPL Location Platform.
         */
        UMTS_SLP,
        /**
         * Custom position determining system.
         */
        CUSTOM_PDE,
    }
    /**
     * Status of a received session indication.
     *
     * Since 1.22
     */

    /**
     * Status of a received session indication.
     *
     * Since 1.22
     */
    export namespace LocSessionStatus {
        export const $gtype: GObject.GType<LocSessionStatus>;
    }

    enum LocSessionStatus {
        /**
         * Success
         */
        SUCCESS,
        /**
         * Operation in Progress.
         */
        IN_PROGRESS,
        /**
         * General Failure.
         */
        GENERAL_FAILURE,
        /**
         * Timeout.
         */
        TIMEOUT,
        /**
         * User ended.
         */
        USER_ENDED,
        /**
         * Bad Parameter.
         */
        BAD_PARAMETER,
        /**
         * Phone is offline.
         */
        PHONE_OFFLINE,
        /**
         * Engine is locked.
         */
        ENGINE_LOCKED,
    }
    /**
     * Which location system a satellite is part of.
     *
     * Since 1.22
     */

    /**
     * Which location system a satellite is part of.
     *
     * Since 1.22
     */
    export namespace LocSystem {
        export const $gtype: GObject.GType<LocSystem>;
    }

    enum LocSystem {
        /**
         * GPS.
         */
        GPS,
        /**
         * Galileo.
         */
        GALILEO,
        /**
         * SBAS.
         */
        SBAS,
        /**
         * COMPASS (BeiDou).
         */
        COMPASS,
        /**
         * GLONASS.
         */
        GLONASS,
    }
    /**
     * Source of the used time.
     *
     * Since 1.22
     */

    /**
     * Source of the used time.
     *
     * Since 1.22
     */
    export namespace LocTimeSource {
        export const $gtype: GObject.GType<LocTimeSource>;
    }

    enum LocTimeSource {
        /**
         * Invalid.
         */
        INVALID,
        /**
         * Time is set by the 1X system.
         */
        NETWORK_TIME_TRANSFER,
        /**
         * Time is set by WCDMA/GSM time tagging.
         */
        NETWORK_TIME_TAGGING,
        /**
         * Time set by external injection.
         */
        EXTERNAL_INPUT,
        /**
         * Time is set after decoding over-the-air GPS navigation data from one GPS satellite.
         */
        TOW_DECODE,
        /**
         * Time is set after decoding over-the-air GPS navigation data from multiple satellites.
         */
        TOW_CONFIRMED,
        /**
         * Both time of the week and GPS week number are known.
         */
        TOW_AND_WEEK_CONFIRMED,
        /**
         * Time is set by the position engine after the fix is obtained.
         */
        NAVIGATION_SOLUTION,
        /**
         * Time is set by the position engine after performing SFT.
         */
        SOLVE_FOR_TIME,
        /**
         * Time is set after decoding QZSS satellites.
         */
        GLO_TOW_DECODE,
        /**
         * Time is set after transforming the GPS to GLO time.
         */
        TIME_TRANSFORM,
        /**
         * Time is set by the sleep time tag provided by the WCDMA network.
         */
        WCDMA_SLEEP_TIME_TAG,
        /**
         * Time is set by the sleep time tag provided by the GSM network.
         */
        GSM_SLEEP_TIME_TAG,
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * Time is derived from the system clock.
         */
        SYSTEM_TIMETICK,
        /**
         * Time set after decoding QZSS satellites.
         */
        QZSS_TOW_DECODE,
        /**
         * Time set after decoding BDS satellites.
         */
        BDS_TOW_DECODE,
    }
    /**
     * Band classes.
     */

    /**
     * Band classes.
     */
    export namespace NasActiveBand {
        export const $gtype: GObject.GType<NasActiveBand>;
    }

    enum NasActiveBand {
        /**
         * Band class 0.
         */
        BC_0,
        /**
         * Band class 1.
         */
        BC_1,
        /**
         * Band class 2.
         */
        BC_2,
        /**
         * Band class 3.
         */
        BC_3,
        /**
         * Band class 4.
         */
        BC_4,
        /**
         * Band class 5.
         */
        BC_5,
        /**
         * Band class 6.
         */
        BC_6,
        /**
         * Band class 7.
         */
        BC_7,
        /**
         * Band class 8.
         */
        BC_8,
        /**
         * Band class 9.
         */
        BC_9,
        /**
         * Band class 10.
         */
        BC_10,
        /**
         * Band class 11.
         */
        BC_11,
        /**
         * Band class 12.
         */
        BC_12,
        /**
         * Band class 13.
         */
        BC_13,
        /**
         * Band class 14.
         */
        BC_14,
        /**
         * Band class 15.
         */
        BC_15,
        /**
         * Band class 16.
         */
        BC_16,
        /**
         * Band class 17.
         */
        BC_17,
        /**
         * Band class 18.
         */
        BC_18,
        /**
         * Band class 19.
         */
        BC_19,
        /**
         * GSM 450.
         */
        GSM_450,
        /**
         * GSM 480.
         */
        GSM_480,
        /**
         * GSM 750.
         */
        GSM_750,
        /**
         * GSM 850.
         */
        GSM_850,
        /**
         * GSM 900 (Extended).
         */
        GSM_900_EXTENDED,
        /**
         * GSM 900 (Primary).
         */
        GSM_900_PRIMARY,
        /**
         * GSM 900 (Railways).
         */
        GSM_900_RAILWAYS,
        /**
         * GSM 1800.
         */
        GSM_DCS_1800,
        /**
         * GSM 1900.
         */
        GSM_PCS_1900,
        /**
         * WCDMA 2100.
         */
        WCDMA_2100,
        /**
         * WCDMA PCS 1900.
         */
        WCDMA_PCS_1900,
        /**
         * WCDMA DCS 1800.
         */
        WCDMA_DCS_1800,
        /**
         * WCDMA 1700 (U.S.).
         */
        WCDMA_1700_US,
        /**
         * WCDMA 850.
         */
        WCDMA_850,
        /**
         * WCDMA 800.
         */
        WCDMA_800,
        /**
         * WCDMA 2600.
         */
        WCDMA_2600,
        /**
         * WCDMA 900.
         */
        WCDMA_900,
        /**
         * WCDMA 1700 (Japan).
         */
        WCDMA_1700_JAPAN,
        /**
         * WCDMA 1500 (Japan).
         */
        WCDMA_1500_JAPAN,
        /**
         * WCDMA 850 (Japan).
         */
        WCDMA_850_JAPAN,
        /**
         * EUTRAN band 1.
         */
        EUTRAN_1,
        /**
         * EUTRAN band 2.
         */
        EUTRAN_2,
        /**
         * EUTRAN band 3.
         */
        EUTRAN_3,
        /**
         * EUTRAN band 4.
         */
        EUTRAN_4,
        /**
         * EUTRAN band 5.
         */
        EUTRAN_5,
        /**
         * EUTRAN band 6.
         */
        EUTRAN_6,
        /**
         * EUTRAN band 7.
         */
        EUTRAN_7,
        /**
         * EUTRAN band 8.
         */
        EUTRAN_8,
        /**
         * EUTRAN band 9.
         */
        EUTRAN_9,
        /**
         * EUTRAN band 10.
         */
        EUTRAN_10,
        /**
         * EUTRAN band 11.
         */
        EUTRAN_11,
        /**
         * EUTRAN band 12.
         */
        EUTRAN_12,
        /**
         * EUTRAN band 13.
         */
        EUTRAN_13,
        /**
         * EUTRAN band 14.
         */
        EUTRAN_14,
        /**
         * EUTRAN band 17.
         */
        EUTRAN_17,
        /**
         * EUTRAN band 18.
         */
        EUTRAN_18,
        /**
         * EUTRAN band 19.
         */
        EUTRAN_19,
        /**
         * EUTRAN band 20.
         */
        EUTRAN_20,
        /**
         * EUTRAN band 21.
         */
        EUTRAN_21,
        /**
         * EUTRAN band 23.
         */
        EUTRAN_23,
        /**
         * EUTRAN band 24.
         */
        EUTRAN_24,
        /**
         * EUTRAN band 25.
         */
        EUTRAN_25,
        /**
         * EUTRAN band 26.
         */
        EUTRAN_26,
        /**
         * EUTRAN band 27.
         */
        EUTRAN_27,
        /**
         * EUTRAN band 28.
         */
        EUTRAN_28,
        /**
         * EUTRAN band 29.
         */
        EUTRAN_29,
        /**
         * EUTRAN band 30.
         */
        EUTRAN_30,
        /**
         * EUTRAN band 31.
         */
        EUTRAN_31,
        /**
         * EUTRAN band 32.
         */
        EUTRAN_32,
        /**
         * EUTRAN band 33.
         */
        EUTRAN_33,
        /**
         * EUTRAN band 34.
         */
        EUTRAN_34,
        /**
         * EUTRAN band 35.
         */
        EUTRAN_35,
        /**
         * EUTRAN band 36.
         */
        EUTRAN_36,
        /**
         * EUTRAN band 37.
         */
        EUTRAN_37,
        /**
         * EUTRAN band 38.
         */
        EUTRAN_38,
        /**
         * EUTRAN band 39.
         */
        EUTRAN_39,
        /**
         * EUTRAN band 40.
         */
        EUTRAN_40,
        /**
         * EUTRAN band 41.
         */
        EUTRAN_41,
        /**
         * EUTRAN band 42.
         */
        EUTRAN_42,
        /**
         * EUTRAN band 43.
         */
        EUTRAN_43,
        /**
         * EUTRAN band 46.
         */
        EUTRAN_46,
        /**
         * EUTRAN band 47.
         */
        EUTRAN_47,
        /**
         * EUTRAN band 48.
         */
        EUTRAN_48,
        /**
         * EUTRAN band 66.
         */
        EUTRAN_66,
        /**
         * EUTRAN band 71.
         */
        EUTRAN_71,
        /**
         * EUTRAN band 125.
         */
        EUTRAN_125,
        /**
         * EUTRAN band 126.
         */
        EUTRAN_126,
        /**
         * EUTRAN band 127.
         */
        EUTRAN_127,
        /**
         * EUTRAN band 250.
         */
        EUTRAN_250,
        /**
         * TD-SCDMA Band A.
         */
        TDSCDMA_A,
        /**
         * TD-SCDMA Band B.
         */
        TDSCDMA_B,
        /**
         * TD-SCDMA Band C.
         */
        TDSCDMA_C,
        /**
         * TD-SCDMA Band D.
         */
        TDSCDMA_D,
        /**
         * TD-SCDMA Band E.
         */
        TDSCDMA_E,
        /**
         * TD-SCDMA Band F.
         */
        TDSCDMA_F,
        /**
         * NR5G Band 1. Since 1.32.
         */
        NR5G_1,
        /**
         * NR5G Band 2. Since 1.32.
         */
        NR5G_2,
        /**
         * NR5G Band 3. Since 1.32.
         */
        NR5G_3,
        /**
         * NR5G Band 5. Since 1.32.
         */
        NR5G_5,
        /**
         * NR5G Band 7. Since 1.32.
         */
        NR5G_7,
        /**
         * NR5G Band 8. Since 1.32.
         */
        NR5G_8,
        /**
         * NR5G Band 20. Since 1.32.
         */
        NR5G_20,
        /**
         * NR5G Band 28. Since 1.32.
         */
        NR5G_28,
        /**
         * NR5G Band 38. Since 1.32.
         */
        NR5G_38,
        /**
         * NR5G Band 41. Since 1.32.
         */
        NR5G_41,
        /**
         * NR5G Band 50. Since 1.32.
         */
        NR5G_50,
        /**
         * NR5G Band 51. Since 1.32.
         */
        NR5G_51,
        /**
         * NR5G Band 66. Since 1.32.
         */
        NR5G_66,
        /**
         * NR5G Band 70. Since 1.32.
         */
        NR5G_70,
        /**
         * NR5G Band 71. Since 1.32.
         */
        NR5G_71,
        /**
         * NR5G Band 74. Since 1.32.
         */
        NR5G_74,
        /**
         * NR5G Band 75. Since 1.32.
         */
        NR5G_75,
        /**
         * NR5G Band 76. Since 1.32.
         */
        NR5G_76,
        /**
         * NR5G Band 77. Since 1.32.
         */
        NR5G_77,
        /**
         * NR5G Band 78. Since 1.32.
         */
        NR5G_78,
        /**
         * NR5G Band 79. Since 1.32.
         */
        NR5G_79,
        /**
         * NR5G Band 80. Since 1.32.
         */
        NR5G_80,
        /**
         * NR5G Band 81. Since 1.32.
         */
        NR5G_81,
        /**
         * NR5G Band 82. Since 1.32.
         */
        NR5G_82,
        /**
         * NR5G Band 83. Since 1.32.
         */
        NR5G_83,
        /**
         * NR5G Band 84. Since 1.32.
         */
        NR5G_84,
        /**
         * NR5G Band 85. Since 1.32.
         */
        NR5G_85,
        /**
         * NR5G Band 257. Since 1.32.
         */
        NR5G_257,
        /**
         * NR5G Band 258. Since 1.32.
         */
        NR5G_258,
        /**
         * NR5G Band 259. Since 1.32.
         */
        NR5G_259,
        /**
         * NR5G Band 260. Since 1.32.
         */
        NR5G_260,
        /**
         * NR5G Band 261. Since 1.32.
         */
        NR5G_261,
        /**
         * NR5G Band 12. Since 1.32.
         */
        NR5G_12,
        /**
         * NR5G Band 25. Since 1.32.
         */
        NR5G_25,
        /**
         * NR5G Band 34. Since 1.32.
         */
        NR5G_34,
        /**
         * NR5G Band 39. Since 1.32.
         */
        NR5G_39,
        /**
         * NR5G Band 40. Since 1.32.
         */
        NR5G_40,
        /**
         * NR5G Band 65. Since 1.32.
         */
        NR5G_65,
        /**
         * NR5G Band 86. Since 1.32.
         */
        NR5G_86,
        /**
         * NR5G Band 48. Since 1.32.
         */
        NR5G_48,
        /**
         * NR5G Band 14. Since 1.32.
         */
        NR5G_14,
        /**
         * NR5G Band 13. Since 1.32.
         */
        NR5G_13,
        /**
         * NR5G Band 18. Since 1.32.
         */
        NR5G_18,
        /**
         * NR5G Band 26. Since 1.32.
         */
        NR5G_26,
        /**
         * NR5G Band 30. Since 1.32.
         */
        NR5G_30,
        /**
         * NR5G Band 29. Since 1.32.
         */
        NR5G_29,
        /**
         * NR5G Band 53. Since 1.32.
         */
        NR5G_53,
    }
    /**
     * Domain attach state.
     */

    /**
     * Domain attach state.
     */
    export namespace NasAttachState {
        export const $gtype: GObject.GType<NasAttachState>;
    }

    enum NasAttachState {
        /**
         * Unknown attach state.
         */
        UNKNOWN,
        /**
         * Attached.
         */
        ATTACHED,
        /**
         * Detached.
         */
        DETACHED,
    }
    /**
     * Boolean flag with validity info.
     */

    /**
     * Boolean flag with validity info.
     */
    export namespace NasBoolean {
        export const $gtype: GObject.GType<NasBoolean>;
    }

    enum NasBoolean {
        /**
         * Status FALSE.
         */
        FALSE,
        /**
         * Status TRUE.
         */
        TRUE,
        /**
         * Status Unknown.
         */
        UNKNOWN,
    }
    /**
     * Status of the call barring functionality.
     */

    /**
     * Status of the call barring functionality.
     */
    export namespace NasCallBarringStatus {
        export const $gtype: GObject.GType<NasCallBarringStatus>;
    }

    enum NasCallBarringStatus {
        /**
         * Normal calls only.
         */
        NORMAL_ONLY,
        /**
         * Emergency calls only.
         */
        EMERGENCY_ONLY,
        /**
         * No calls allowed.
         */
        NO_CALLS,
        /**
         * All calls allowed.
         */
        ALL_CALLS,
        /**
         * Unknown.
         */
        UNKNOWN,
    }
    /**
     * The pilot set the pilot belongs to.
     */

    /**
     * The pilot set the pilot belongs to.
     */
    export namespace NasCdmaPilotType {
        export const $gtype: GObject.GType<NasCdmaPilotType>;
    }

    enum NasCdmaPilotType {
        /**
         * the pilot is part of the active set.
         */
        ACTIVE,
        /**
         * the pilot is part of the neighbor set.
         */
        NEIGHBOR,
    }
    /**
     * Flags specifying the preference when using CDMA Band Class 0.
     */

    /**
     * Flags specifying the preference when using CDMA Band Class 0.
     */
    export namespace NasCdmaPrlPreference {
        export const $gtype: GObject.GType<NasCdmaPrlPreference>;
    }

    enum NasCdmaPrlPreference {
        /**
         * System A only.
         */
        A_SIDE_ONLY,
        /**
         * System B only.
         */
        B_SIDE_ONLY,
        /**
         * Any system.
         */
        ANY,
    }
    /**
     * Cell broadcast support.
     */

    /**
     * Cell broadcast support.
     */
    export namespace NasCellBroadcastCapability {
        export const $gtype: GObject.GType<NasCellBroadcastCapability>;
    }

    enum NasCellBroadcastCapability {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * Cell broadcast not supported.
         */
        OFF,
        /**
         * Cell broadcast supported.
         */
        ON,
    }
    /**
     * Duration of the change setting.
     */

    /**
     * Duration of the change setting.
     */
    export namespace NasChangeDuration {
        export const $gtype: GObject.GType<NasChangeDuration>;
    }

    enum NasChangeDuration {
        /**
         * Until the next power cycle.
         */
        POWER_CYCLE,
        /**
         * Permanent.
         */
        PERMANENT,
    }
    /**
     * DL Bandwidth.
     */
    /**
     * DL Bandwidth.
     */
    class NasDLBandwidth {
        static $gtype: GObject.GType<NasDLBandwidth>;

        // Static fields

        /**
         * 1.4 MHz
         */
        static '1_4': number;
        /**
         * 3 MHz
         */
        static '3': number;
        /**
         * 5 MHz
         */
        static '5': number;
        /**
         * 10 MHz
         */
        static '10': number;
        /**
         * 15 MHz
         */
        static '15': number;
        /**
         * 20 MHz
         */
        static '20': number;
        /**
         * Invalid
         */
        static INVALID: number;
        /**
         * Unknown
         */
        static UNKNOWN: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Data capability of the network.
     */

    /**
     * Data capability of the network.
     */
    export namespace NasDataCapability {
        export const $gtype: GObject.GType<NasDataCapability>;
    }

    enum NasDataCapability {
        /**
         * None or unknown.
         */
        NONE,
        /**
         * GPRS.
         */
        GPRS,
        /**
         * EDGE.
         */
        EDGE,
        /**
         * HSDPA.
         */
        HSDPA,
        /**
         * HSUPA.
         */
        HSUPA,
        /**
         * WCDMA.
         */
        WCDMA,
        /**
         * CDMA.
         */
        CDMA,
        /**
         * EV-DO revision 0.
         */
        EVDO_REV_0,
        /**
         * EV-DO revision A.
         */
        EVDO_REV_A,
        /**
         * GSM.
         */
        GSM,
        /**
         * EV-DO revision B.
         */
        EVDO_REV_B,
        /**
         * LTE.
         */
        LTE,
        /**
         * HSDPA+.
         */
        HSDPA_PLUS,
        /**
         * DC-HSDPA+.
         */
        DC_HSDPA_PLUS,
    }
    /**
     * The day of the week.
     */

    /**
     * The day of the week.
     */
    export namespace NasDayOfWeek {
        export const $gtype: GObject.GType<NasDayOfWeek>;
    }

    enum NasDayOfWeek {
        /**
         * Monday
         */
        MONDAY,
        /**
         * Tuesday
         */
        TUESDAY,
        /**
         * Wednesday
         */
        WEDNESDAY,
        /**
         * Thursday
         */
        THURSDAY,
        /**
         * Friday
         */
        FRIDAY,
        /**
         * Saturday
         */
        SATURDAY,
        /**
         * Sunday
         */
        SUNDAY,
    }
    /**
     * The number of hours a time is adjusted for daylight savings.
     */

    /**
     * The number of hours a time is adjusted for daylight savings.
     */
    export namespace NasDaylightSavingsAdjustment {
        export const $gtype: GObject.GType<NasDaylightSavingsAdjustment>;
    }

    enum NasDaylightSavingsAdjustment {
        /**
         * no adjustment
         */
        NONE,
        /**
         * one hour adjustment
         */
        ONE_HOUR,
        /**
         * two hours adjustment
         */
        TWO_HOURS,
    }
    /**
     * DRX setting of the device.
     */

    /**
     * DRX setting of the device.
     */
    export namespace NasDrx {
        export const $gtype: GObject.GType<NasDrx>;
    }

    enum NasDrx {
        /**
         * Unknown or not specified.
         */
        UNKNOWN,
        /**
         * CN=6, T=32.
         */
        CN6_T32,
        /**
         * CN=7, T=64.
         */
        CN7_T64,
        /**
         * CN=8, T=128.
         */
        CN8_T128,
        /**
         * CN=9, T=256.
         */
        CN9_T256,
    }
    /**
     * EV-DO SINR level.
     */
    /**
     * EV-DO SINR level.
     */
    class NasEvdoSinrLevel {
        static $gtype: GObject.GType<NasEvdoSinrLevel>;

        // Static fields

        /**
         * -9 dB.
         */
        static '0': number;
        /**
         * -6 dB.
         */
        static '1': number;
        /**
         * -4.5 dB.
         */
        static '2': number;
        /**
         * -3 dB.
         */
        static '3': number;
        /**
         * -2 dB.
         */
        static '4': number;
        /**
         * +1 dB.
         */
        static '5': number;
        /**
         * +3 dB.
         */
        static '6': number;
        /**
         * +6 dB.
         */
        static '7': number;
        /**
         * +9 dB.
         */
        static '8': number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * GSM/WCDMA acquisition order preference.
     */

    /**
     * GSM/WCDMA acquisition order preference.
     */
    export namespace NasGsmWcdmaAcquisitionOrderPreference {
        export const $gtype: GObject.GType<NasGsmWcdmaAcquisitionOrderPreference>;
    }

    enum NasGsmWcdmaAcquisitionOrderPreference {
        /**
         * Automatic.
         */
        AUTOMATIC,
        /**
         * GSM first, then WCDMA.
         */
        GSM,
        /**
         * WCDMA first, then GSM.
         */
        WCDMA,
    }
    /**
     * HDR personality type.
     */

    /**
     * HDR personality type.
     */
    export namespace NasHdrPersonality {
        export const $gtype: GObject.GType<NasHdrPersonality>;
    }

    enum NasHdrPersonality {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * HRPD.
         */
        HRPD,
        /**
         * eHRPD.
         */
        EHRPD,
    }
    /**
     * HDR protocol revision.
     */

    /**
     * HDR protocol revision.
     */
    export namespace NasHdrProtocolRevision {
        export const $gtype: GObject.GType<NasHdrProtocolRevision>;
    }

    enum NasHdrProtocolRevision {
        /**
         * None.
         */
        NONE,
        /**
         * HDR Rel 0.
         */
        REL_0,
        /**
         * HDR Rel A.
         */
        REL_A,
        /**
         * HDR Rel B.
         */
        REL_B,
    }
    /**
     * Cell access status for LTE calls.
     */

    /**
     * Cell access status for LTE calls.
     */
    export namespace NasLteCellAccessStatus {
        export const $gtype: GObject.GType<NasLteCellAccessStatus>;
    }

    enum NasLteCellAccessStatus {
        /**
         * Access is allowed for normal calls only.
         */
        NORMAL_ONLY,
        /**
         * Access is allowed for emergency calls only.
         */
        EMERGENCY_ONLY,
        /**
         * Access is not allowed for any call type.
         */
        NO_CALLS,
        /**
         * Access is allowed for all call types.
         */
        ALL_CALLS,
        /**
         * Unknown.
         */
        UNKNOWN,
    }
    /**
     * LTE registration domain.
     */

    /**
     * LTE registration domain.
     */
    export namespace NasLteRegistrationDomain {
        export const $gtype: GObject.GType<NasLteRegistrationDomain>;
    }

    enum NasLteRegistrationDomain {
        /**
         * Not applicable since the UE is not in "Camp Only" mode.
         */
        NOT_APPLICABLE,
        /**
         * UE is in "Camp Only" mode and the PLMN can provide CS service only.
         */
        CS_ONLY,
        /**
         * UE is in "Camp Only" mode and the PLMN can provide PS service only.
         */
        PS_ONLY,
        /**
         * UE is in "Camp Only" mode and the PLMN can provide CS and PS service.
         */
        CS_PS,
        /**
         * UE is in "Camp Only" mode but the PLMN cannot provide any service.
         */
        LIMITED_SERVICE,
    }
    /**
     * LTE voice domain.
     */

    /**
     * LTE voice domain.
     */
    export namespace NasLteVoiceDomain {
        export const $gtype: GObject.GType<NasLteVoiceDomain>;
    }

    enum NasLteVoiceDomain {
        /**
         * No voice.
         */
        NONE,
        /**
         * Voice is supported over IMS network.
         */
        IMS,
        /**
         * Voice is supported over the 1X network.
         */
        '1X',
        /**
         * Voice is supported over the 3GPP network.
         */
        '3GPP',
    }
    /**
     * Setup to define whether the network description should be displayed.
     */

    /**
     * Setup to define whether the network description should be displayed.
     */
    export namespace NasNetworkDescriptionDisplay {
        export const $gtype: GObject.GType<NasNetworkDescriptionDisplay>;
    }

    enum NasNetworkDescriptionDisplay {
        /**
         * Don't display.
         */
        NO,
        /**
         * Display.
         */
        YES,
        /**
         * Unknown.
         */
        UNKNOWN,
    }
    /**
     * Type of encoding used in the network description.
     */

    /**
     * Type of encoding used in the network description.
     */
    export namespace NasNetworkDescriptionEncoding {
        export const $gtype: GObject.GType<NasNetworkDescriptionEncoding>;
    }

    enum NasNetworkDescriptionEncoding {
        /**
         * Unspecified.
         */
        UNSPECIFIED,
        /**
         * ASCII-7.
         */
        ASCII7,
        /**
         * Unicode.
         */
        UNICODE,
        /**
         * GSM 7-bit.
         */
        GSM,
    }
    /**
     * Network name source.
     */

    /**
     * Network name source.
     */
    export namespace NasNetworkNameSource {
        export const $gtype: GObject.GType<NasNetworkNameSource>;
    }

    enum NasNetworkNameSource {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * Operator PLMN list and PLMN network name.
         */
        OPERATOR_PLMN_LIST_AND_PLMN_NETWORK_NAME,
        /**
         * Common PCN handset specification and operator name string.
         */
        COMMON_PCN_HANDSET_SPECIFICATION_AND_OPERATOR_NAME_STRING,
        /**
         * Network identity and time zone.
         */
        NITZ,
        /**
         * GSMA SE13 table.
         */
        SE13,
        /**
         * MCC and MNC.
         */
        MCC_MNC,
        /**
         * Service provider name.
         */
        SERVICE_PROVIDER_NAME,
    }
    /**
     * Type of network registration.
     */

    /**
     * Type of network registration.
     */
    export namespace NasNetworkRegisterType {
        export const $gtype: GObject.GType<NasNetworkRegisterType>;
    }

    enum NasNetworkRegisterType {
        /**
         * Automatic network registration.
         */
        AUTOMATIC,
        /**
         * Manual network registration.
         */
        MANUAL,
    }
    /**
     * Network scan result.
     */

    /**
     * Network scan result.
     */
    export namespace NasNetworkScanResult {
        export const $gtype: GObject.GType<NasNetworkScanResult>;
    }

    enum NasNetworkScanResult {
        /**
         * Success.
         */
        SUCCESS,
        /**
         * Abort.
         */
        ABORT,
        /**
         * Radio link failure.
         */
        RADIO_LINK_FAILURE,
    }
    /**
     * Network selection preference.
     */

    /**
     * Network selection preference.
     */
    export namespace NasNetworkSelectionPreference {
        export const $gtype: GObject.GType<NasNetworkSelectionPreference>;
    }

    enum NasNetworkSelectionPreference {
        /**
         * Automatic.
         */
        AUTOMATIC,
        /**
         * Manual.
         */
        MANUAL,
    }
    /**
     * Registration restriction.
     */

    /**
     * Registration restriction.
     */
    export namespace NasNetworkSelectionRegistrationRestriction {
        export const $gtype: GObject.GType<NasNetworkSelectionRegistrationRestriction>;
    }

    enum NasNetworkSelectionRegistrationRestriction {
        /**
         * Device follows the normal registration process.
         */
        UNRESTRICTED,
        /**
         * Device camps on the network according to its provisioning, but does not register.
         */
        CAMPED_ONLY,
        /**
         * Device selects the network for limited service.
         */
        LIMITED,
    }
    /**
     * Network Service Domain.
     */

    /**
     * Network Service Domain.
     */
    export namespace NasNetworkServiceDomain {
        export const $gtype: GObject.GType<NasNetworkServiceDomain>;
    }

    enum NasNetworkServiceDomain {
        /**
         * No service.
         */
        NONE,
        /**
         * Circuit switched.
         */
        CS,
        /**
         * Packet switched.
         */
        PS,
        /**
         * Circuit and packet switched.
         */
        CS_PS,
        /**
         * Unknown service.
         */
        UNKNOWN,
    }
    /**
     * Type of network.
     */

    /**
     * Type of network.
     */
    export namespace NasNetworkType {
        export const $gtype: GObject.GType<NasNetworkType>;
    }

    enum NasNetworkType {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * 3GPP2 network.
         */
        '3GPP2',
        /**
         * 3GPP network.
         */
        '3GPP',
    }
    /**
     * PLMN name encoding schemes.  See 3GPP TS 24.008 section "Network Name
     * information element".
     */

    /**
     * PLMN name encoding schemes.  See 3GPP TS 24.008 section "Network Name
     * information element".
     */
    export namespace NasPlmnEncodingScheme {
        export const $gtype: GObject.GType<NasPlmnEncodingScheme>;
    }

    enum NasPlmnEncodingScheme {
        /**
         * GSM default alphabet packed encoding (ETSI GSM 03.38)
         */
        GSM,
        /**
         * UCS-2 little-endian
         */
        UCS2LE,
    }
    /**
     * Language ID used when encoding the PLMN.
     */

    /**
     * Language ID used when encoding the PLMN.
     */
    export namespace NasPlmnLanguageId {
        export const $gtype: GObject.GType<NasPlmnLanguageId>;
    }

    enum NasPlmnLanguageId {
        /**
         * Language Unknown.
         */
        UNKNOWN,
        /**
         * Traditional Chinese.
         */
        ZH_TRAD,
        /**
         * Simplified Chinese.
         */
        ZH_SIMP,
    }
    /**
     * PLMN name country initials options. See 3GPP TS 24.008
     * section "Network Name information element".
     */

    /**
     * PLMN name country initials options. See 3GPP TS 24.008
     * section "Network Name information element".
     */
    export namespace NasPlmnNameCountryInitials {
        export const $gtype: GObject.GType<NasPlmnNameCountryInitials>;
    }

    enum NasPlmnNameCountryInitials {
        /**
         * don't add country initials
         */
        INITIALS_DO_NOT_ADD,
        /**
         * add country initials
         */
        INIITALS_ADD,
        /**
         * unspecified
         */
        INIITALS_UNSPECIFIED,
    }
    /**
     * PLMN name spare bits in last octet of a network name.  See 3GPP TS 24.008
     * section "Network Name information element".
     */

    /**
     * PLMN name spare bits in last octet of a network name.  See 3GPP TS 24.008
     * section "Network Name information element".
     */
    export namespace NasPlmnNameSpareBits {
        export const $gtype: GObject.GType<NasPlmnNameSpareBits>;
    }

    enum NasPlmnNameSpareBits {
        /**
         * unknown
         */
        UNKNOWN,
        /**
         * bit 8 is spare
         */
        BIT_8,
        /**
         * bits 7 - 8 are spare
         */
        BITS_78,
        /**
         * bits 6 - 8 are spare
         */
        BITS_68,
        /**
         * bits 5 - 8 are spare
         */
        BITS_58,
        /**
         * bits 4 - 8 are spare
         */
        BITS_48,
        /**
         * bits 3 - 8 are spare
         */
        BITS_38,
        /**
         * bits 2 - 8 are spare
         */
        BITS_28,
    }
    /**
     * Duration of the preference setting.
     */

    /**
     * Duration of the preference setting.
     */
    export namespace NasPreferenceDuration {
        export const $gtype: GObject.GType<NasPreferenceDuration>;
    }

    enum NasPreferenceDuration {
        /**
         * Permanent.
         */
        PERMANENT,
        /**
         * Until the next power cycle.
         */
        POWER_CYCLE,
        /**
         * Until end of call.
         */
        ONE_CALL,
        /**
         * Until end of call or a specified time.
         */
        ONE_CALL_OR_TIME,
        /**
         * Internal reason 1, one call.
         */
        INTERNAL_ONE_CALL_1,
        /**
         * Internal reason 2, one call.
         */
        INTERNAL_ONE_CALL_2,
        /**
         * Internal reason 3, one call.
         */
        INTERNAL_ONE_CALL_3,
    }
    /**
     * Packet Switched domain attach/detach action.
     */

    /**
     * Packet Switched domain attach/detach action.
     */
    export namespace NasPsAttachAction {
        export const $gtype: GObject.GType<NasPsAttachAction>;
    }

    enum NasPsAttachAction {
        /**
         * Attach the PS domain.
         */
        ATTACH,
        /**
         * Detach the PS domain.
         */
        DETACH,
    }
    /**
     * Radio interface technology.
     */

    /**
     * Radio interface technology.
     */
    export namespace NasRadioInterface {
        export const $gtype: GObject.GType<NasRadioInterface>;
    }

    enum NasRadioInterface {
        /**
         * Not known or not needed.
         */
        UNKNOWN,
        /**
         * None, no service.
         */
        NONE,
        /**
         * CDMA2000 1X.
         */
        CDMA_1X,
        /**
         * CDMA2000 HRPD (1xEV-DO).
         */
        CDMA_1XEVDO,
        /**
         * AMPS.
         */
        AMPS,
        /**
         * GSM.
         */
        GSM,
        /**
         * UMTS.
         */
        UMTS,
        /**
         * LTE.
         */
        LTE,
        /**
         * TD-SCDMA.
         */
        TD_SCDMA,
        /**
         * 5G NR. Since 1.26.
         */
        '5GNR',
    }
    /**
     * Status of the network registration.
     */

    /**
     * Status of the network registration.
     */
    export namespace NasRegistrationState {
        export const $gtype: GObject.GType<NasRegistrationState>;
    }

    enum NasRegistrationState {
        /**
         * Not registered.
         */
        NOT_REGISTERED,
        /**
         * Registered.
         */
        REGISTERED,
        /**
         * Searching.
         */
        NOT_REGISTERED_SEARCHING,
        /**
         * Registration denied.
         */
        REGISTRATION_DENIED,
        /**
         * Unknown.
         */
        UNKNOWN,
    }
    /**
     * Reason why a request from the mobile station is rejected by the network.
     *
     * Defined in 3GPP TS 24.008 in sections 10.5.3.6 and 10.5.5.14 (detailed in
     * annex G) and in 3GPP TS 24.301 in section 9.9.3.9.
     */

    /**
     * Reason why a request from the mobile station is rejected by the network.
     *
     * Defined in 3GPP TS 24.008 in sections 10.5.3.6 and 10.5.5.14 (detailed in
     * annex G) and in 3GPP TS 24.301 in section 9.9.3.9.
     */
    export namespace NasRejectCause {
        export const $gtype: GObject.GType<NasRejectCause>;
    }

    enum NasRejectCause {
        /**
         * None.
         */
        NONE,
        /**
         * IMSI unknown in HLR/HSS.
         */
        IMSI_UNKNOWN_IN_HLR,
        /**
         * Illegal MS/UE.
         */
        ILLEGAL_UE,
        /**
         * IMSI unknown in VLR.
         */
        IMSI_UNKNOWN_IN_VLR,
        /**
         * IMEI not accepted.
         */
        IMEI_NOT_ACCEPTED,
        /**
         * Illegal ME.
         */
        ILLEGAL_ME,
        /**
         * GPRS/EPS services not allowed.
         */
        PS_SERVICES_NOT_ALLOWED,
        /**
         * GPRS/EPS and non-GPRS/EPS services not allowed.
         */
        PS_AND_NON_PS_SERVICES_NOT_ALLOWED,
        /**
         * MS/UE identity not derived by network.
         */
        UE_IDENTITY_NOT_DERIVED_BY_NETWORK,
        /**
         * Implicitly detached.
         */
        IMPLICITLY_DETACHED,
        /**
         * PLMN not allowed.
         */
        PLMN_NOT_ALLOWED,
        /**
         * Location/tracking area not allowed.
         */
        LOCATION_AREA_NOT_ALLOWED,
        /**
         * Roaming in location/tracking area not allowed.
         */
        ROAMING_IN_LOCATION_AREA_NOT_ALLOWED,
        /**
         * GPRS/EPS services in location/tracking area not allowed.
         */
        PS_SERVICES_IN_LOCATION_AREA_NOT_ALLOWED,
        /**
         * No suitable cells in location/tracking area.
         */
        NO_SUITABLE_CELLS_IN_LOCATION_AREA,
        /**
         * MSC temporarily not reachable.
         */
        MSC_TEMPORARILY_NOT_REACHABLE,
        /**
         * Network failure.
         */
        NETWORK_FAILURE,
        /**
         * CS domain not available.
         */
        CS_DOMAIN_NOT_AVAILABLE,
        /**
         * ESM failure.
         */
        ESM_FAILURE,
        /**
         * MAC failure.
         */
        MAC_FAILURE,
        /**
         * Synch failure.
         */
        SYNCH_FAILURE,
        /**
         * Congestion.
         */
        CONGESTION,
        /**
         * GSM authentication unacceptable, UE security capabilities mismatch.
         */
        UE_SECURITY_CAPABILITIES_MISMATCH,
        /**
         * Security mode rejected or unspecified.
         */
        SECURITY_MODE_REJECTED_UNSPECIFIED,
        /**
         * CSG not authorized.
         */
        CSG_NOT_AUTHORIZED,
        /**
         * Non-EPS authentication unacceptable.
         */
        NON_EPS_AUTHENTICATION_UNACCEPTABLE,
        /**
         * SMS provided by GPRS in routing area.
         */
        SMS_PROVIDED_BY_GPRS_IN_ROUTING_AREA,
        /**
         * Redirection to 5GCN required.
         */
        REDIRECTION_TO_5GCN_REQUIRED,
        /**
         * Service option not supported.
         */
        SERVICE_OPTION_NOT_SUPPORTED,
        /**
         * Requested service option not subscribed.
         */
        REQUESTED_SERVICE_OPTION_NOT_SUBSCRIBED,
        /**
         * Service option temporarily out of order.
         */
        SERVICE_OPTION_TEMPORARILY_OUT_OF_ORDER,
        /**
         * Requested service option not authorized.
         */
        REQUESTED_SERVICE_OPTION_NOT_AUTHORIZED,
        /**
         * Call cannot be identified.
         */
        CALL_CANNOT_BE_IDENTIFIED,
        /**
         * CS service temporarily not available.
         */
        CS_SERVICE_TEMPORARILY_NOT_AVAILABLE,
        /**
         * No EPS bearer context activated.
         */
        NO_EPS_BEARER_CONTEXT_ACTIVATED,
        /**
         * Severe network failure.
         */
        SEVERE_NETWORK_FAILURE,
        /**
         * Retry upon entry 0.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_0,
        /**
         * Retry upon entry 1.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_1,
        /**
         * Retry upon entry 2.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_2,
        /**
         * Retry upon entry 3.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_3,
        /**
         * Retry upon entry 4.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_4,
        /**
         * Retry upon entry 5.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_5,
        /**
         * Retry upon entry 6.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_6,
        /**
         * Retry upon entry 7.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_7,
        /**
         * Retry upon entry 8.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_8,
        /**
         * Retry upon entry 9.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_9,
        /**
         * Retry upon entry 10.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_10,
        /**
         * Retry upon entry 11.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_11,
        /**
         * Retry upon entry 12.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_12,
        /**
         * Retry upon entry 13.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_13,
        /**
         * Retry upon entry 14.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_14,
        /**
         * Retry upon entry 15.
         */
        RETRY_UPON_ENTRY_INTO_NEW_CELL_15,
        /**
         * Semantically incorrect message.
         */
        SEMANTICALLY_INCORRECT_MESSAGE,
        /**
         * Invalid mandatory information.
         */
        INVALID_MANDATORY_INFORMATION,
        /**
         * Message type non existent.
         */
        MESSAGE_TYPE_NON_EXISTENT,
        /**
         * Message type not compatible.
         */
        MESSAGE_TYPE_NOT_COMPATIBLE,
        /**
         * Information element non existent.
         */
        INFORMATION_ELEMENT_NON_EXISTENT,
        /**
         * Conditional information element error.
         */
        CONDITIONAL_INFORMATION_ELEMENT_ERROR,
        /**
         * Message not compatible.
         */
        MESSAGE_NOT_COMPATIBLE,
        /**
         * Unspecified protocol error.
         */
        UNSPECIFIED_PROTOCOL_ERROR,
    }
    /**
     * Status of the roaming indication.
     */

    /**
     * Status of the roaming indication.
     */
    export namespace NasRoamingIndicatorStatus {
        export const $gtype: GObject.GType<NasRoamingIndicatorStatus>;
    }

    enum NasRoamingIndicatorStatus {
        /**
         * Roaming.
         */
        ON,
        /**
         * Home.
         */
        OFF,
    }
    /**
     * Roaming preference.
     */

    /**
     * Roaming preference.
     */
    export namespace NasRoamingPreference {
        export const $gtype: GObject.GType<NasRoamingPreference>;
    }

    enum NasRoamingPreference {
        /**
         * Only non-roaming networks.
         */
        OFF,
        /**
         * Only roaming networks.
         */
        NOT_OFF,
        /**
         * Only non-roaming networks or not flashing.
         */
        NOT_FLASHING,
        /**
         * Don't filter by roaming when acquiring networks.
         */
        ANY,
    }
    /**
     * Roaming status.
     */

    /**
     * Roaming status.
     */
    export namespace NasRoamingStatus {
        export const $gtype: GObject.GType<NasRoamingStatus>;
    }

    enum NasRoamingStatus {
        /**
         * Off.
         */
        OFF,
        /**
         * On.
         */
        ON,
        /**
         * Blinking.
         */
        BLINK,
        /**
         * Out of neighborhood.
         */
        OUT_OF_NEIGHBORHOOD,
        /**
         * Out of building.
         */
        OUT_OF_BUILDING,
        /**
         * Preferred system.
         */
        PREFERRED_SYSTEM,
        /**
         * Available system.
         */
        AVAILABLE_SYSTEM,
        /**
         * Alliance partner.
         */
        ALLIANCE_PARTNER,
        /**
         * Premium partner.
         */
        PREMIUM_PARTNER,
        /**
         * Full service.
         */
        FULL_SERVICE,
        /**
         * Partial service.
         */
        PARTIAL_SERVICE,
        /**
         * Banner on.
         */
        BANNER_ON,
        /**
         * Banner off.
         */
        BANNER_OFF,
    }
    /**
     * SCell State.
     */

    /**
     * SCell State.
     */
    export namespace NasScellState {
        export const $gtype: GObject.GType<NasScellState>;
    }

    enum NasScellState {
        /**
         * Deconfigured
         */
        DECONFIGURED,
        /**
         * Deactivated
         */
        DEACTIVATED,
        /**
         * Activated
         */
        ACTIVATED,
    }
    /**
     * Service domain preference.
     */

    /**
     * Service domain preference.
     */
    export namespace NasServiceDomainPreference {
        export const $gtype: GObject.GType<NasServiceDomainPreference>;
    }

    enum NasServiceDomainPreference {
        /**
         * Circuit-switched only.
         */
        CS_ONLY,
        /**
         * Packet-switched only.
         */
        PS_ONLY,
        /**
         * Circuit-switched and packet-switched.
         */
        CS_PS,
        /**
         * Packet-switched attach.
         */
        PS_ATTACH,
        /**
         * Packet-switched dettach.
         */
        PS_DETACH,
    }
    /**
     * Status of the service.
     */

    /**
     * Status of the service.
     */
    export namespace NasServiceStatus {
        export const $gtype: GObject.GType<NasServiceStatus>;
    }

    enum NasServiceStatus {
        /**
         * No service.
         */
        NONE,
        /**
         * Limited service.
         */
        LIMITED,
        /**
         * Service available.
         */
        AVAILABLE,
        /**
         * Limited regional service.
         */
        LIMITED_REGIONAL,
        /**
         * Device in power save mode.
         */
        POWER_SAVE,
    }
    /**
     * Reject information of the SIM.
     */

    /**
     * Reject information of the SIM.
     */
    export namespace NasSimRejectState {
        export const $gtype: GObject.GType<NasSimRejectState>;
    }

    enum NasSimRejectState {
        /**
         * SIM not available.
         */
        UNAVAILABLE,
        /**
         * SIM available.
         */
        AVAILABLE,
        /**
         * SIM invalid for circuit-switched connections.
         */
        CS_INVALID,
        /**
         * SIM invalid for packet-switched connections.
         */
        PS_INVALID,
        /**
         * SIM invalid for circuit-switched and packet-switched connections.
         */
        CS_PS_INVALID,
    }
    /**
     * EMM connection state state. (Sierra Wireless specific).
     */

    /**
     * EMM connection state state. (Sierra Wireless specific).
     */
    export namespace NasSwiEmmConnectionState {
        export const $gtype: GObject.GType<NasSwiEmmConnectionState>;
    }

    enum NasSwiEmmConnectionState {
        /**
         * RRC idle
         */
        RRC_IDLE,
        /**
         * Waiting RRC Cfm
         */
        WAITING_RRC_CFM,
        /**
         * RRC connecting
         */
        RRC_CONNECTING,
        /**
         * RRC releasing
         */
        RRC_RELEASING,
        /**
         * Unknown
         */
        UNKNOWN,
    }
    /**
     * EMM registration state. (Sierra Wireless specific).
     */

    /**
     * EMM registration state. (Sierra Wireless specific).
     */
    export namespace NasSwiEmmState {
        export const $gtype: GObject.GType<NasSwiEmmState>;
    }

    enum NasSwiEmmState {
        /**
         * Deregistered
         */
        DEREGISTERED,
        /**
         * Registration initiated
         */
        REG_INITIATED,
        /**
         * Registered
         */
        REGISTERED,
        /**
         * TAU initiated
         */
        TAU_INITIATED,
        /**
         * SR initiated
         */
        SR_INITIATED,
        /**
         * Deregistration initiated
         */
        DEREG_INITIATED,
        /**
         * Invalid
         */
        INVALID,
        /**
         * Unknown
         */
        UNKNOWN,
    }
    /**
     * IMS registration state. (Sierra Wireless specific).
     */

    /**
     * IMS registration state. (Sierra Wireless specific).
     */
    export namespace NasSwiImsRegState {
        export const $gtype: GObject.GType<NasSwiImsRegState>;
    }

    enum NasSwiImsRegState {
        /**
         * No service
         */
        NO_SRV,
        /**
         * In prog
         */
        IN_PROG,
        /**
         * Failed
         */
        FAILED,
        /**
         * Limited
         */
        LIMITED,
        /**
         * Full service
         */
        FULL_SRV,
        /**
         * Unknown
         */
        _UNKNOWN,
    }
    /**
     * Modem mode (Sierra Wireless specific).
     */

    /**
     * Modem mode (Sierra Wireless specific).
     */
    export namespace NasSwiModemMode {
        export const $gtype: GObject.GType<NasSwiModemMode>;
    }

    enum NasSwiModemMode {
        /**
         * Powering off
         */
        POWERING_OFF,
        /**
         * Factory test
         */
        FACTORY_TEST,
        /**
         * Offline
         */
        OFFLINE,
        /**
         * Offline AMPS
         */
        OFFLINE_AMPS,
        /**
         * Offline CDMA
         */
        OFFLINE_CDMA,
        /**
         * Online
         */
        ONLINE,
        /**
         * Low power
         */
        LOW_POWER,
        /**
         * Resetting
         */
        RESETTING,
        /**
         * Network test
         */
        NETWORK_TEST,
        /**
         * Offline request
         */
        OFFLINE_REQUEST,
        /**
         * Pseudo online
         */
        PSEUDO_ONLINE,
        /**
         * Resetting modem
         */
        RESETTING_MODEM,
        /**
         * Unknown
         */
        UNKNOWN,
    }
    /**
     * PS registration state. (Sierra Wireless specific).
     */

    /**
     * PS registration state. (Sierra Wireless specific).
     */
    export namespace NasSwiPsState {
        export const $gtype: GObject.GType<NasSwiPsState>;
    }

    enum NasSwiPsState {
        /**
         * Attached
         */
        ATTACHED,
        /**
         * Detached
         */
        DETACHED,
        /**
         * Unknown
         */
        UNKNOWN,
    }
    /**
     * System mode (Sierra Wireless specific).
     */

    /**
     * System mode (Sierra Wireless specific).
     */
    export namespace NasSwiSystemMode {
        export const $gtype: GObject.GType<NasSwiSystemMode>;
    }

    enum NasSwiSystemMode {
        /**
         * No service
         */
        NO_SERVICE,
        /**
         * AMPS
         */
        AMPS,
        /**
         * CDMA
         */
        CDMA,
        /**
         * GSM
         */
        GSM,
        /**
         * HDR
         */
        HDR,
        /**
         * WCDMA
         */
        WCDMA,
        /**
         * GPS
         */
        GPS,
        /**
         * WLAN
         */
        WLAN,
        /**
         * LTE
         */
        LTE,
        /**
         * Unknown
         */
        UNKNOWN,
    }
    /**
     * Modem usage preference.
     */

    /**
     * Modem usage preference.
     */
    export namespace NasUsagePreference {
        export const $gtype: GObject.GType<NasUsagePreference>;
    }

    enum NasUsagePreference {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * Voice centric.
         */
        VOICE_CENTRIC,
        /**
         * Data centric.
         */
        DATA_CENTRIC,
    }
    /**
     * Voice domain preference.
     */

    /**
     * Voice domain preference.
     */
    export namespace NasVoiceDomainPreference {
        export const $gtype: GObject.GType<NasVoiceDomainPreference>;
    }

    enum NasVoiceDomainPreference {
        /**
         * Circuit-switched voice only
         */
        CS_ONLY,
        /**
         * Packet-switched voice only.
         */
        PS_ONLY,
        /**
         * Circuit-switched voice is preferred.
         */
        CS_PREFERRED,
        /**
         * Packet-switched voice is preferred.
         */
        PS_PREFERRED,
    }
    /**
     * Call status on high speed.
     */

    /**
     * Call status on high speed.
     */
    export namespace NasWcdmaHsService {
        export const $gtype: GObject.GType<NasWcdmaHsService>;
    }

    enum NasWcdmaHsService {
        /**
         * HSDPA and HSUPA not supported.
         */
        HSDPA_HSUPA_UNSUPPORTED,
        /**
         * HSDPA supported.
         */
        HSDPA_SUPPORTED,
        /**
         * HSUPA supported.
         */
        HSUPA_SUPPORTED,
        /**
         * HSDPA and HSUPA supported.
         */
        HSDPA_HSUPA_SUPPORTED,
        /**
         * HSDPA+ supported.
         */
        HSDPA_PLUS_SUPPORTED,
        /**
         * HSDPA+ and HSUPA supported.
         */
        HSDPA_PLUS_HSUPA_SUPPORTED,
        /**
         * DC-HSDPA+ supported.
         */
        DC_HSDPA_PLUS_SUPPORTED,
        /**
         * DC-HSDPA+ and HSUPA supported.
         */
        DC_HSDPA_PLUS_HSUPA_SUPPORTED,
    }
    /**
     * RRC state.
     */

    /**
     * RRC state.
     */
    export namespace NasWcdmaRrcState {
        export const $gtype: GObject.GType<NasWcdmaRrcState>;
    }

    enum NasWcdmaRrcState {
        /**
         * Disconnected.
         */
        DISCONNECTED,
        /**
         * WCDMA RRC state is CELL_PCH.
         */
        CELL_PCH,
        /**
         * WCDMA RRC state is URA_PCH.
         */
        URA_PCH,
        /**
         * WCDMA RRC state is CELL_FACH.
         */
        CELL_FACH,
        /**
         * WCDMA RRC state is CELL_DCH.
         */
        CELL_DCH,
    }
    /**
     * HFA feature done state.
     */

    /**
     * HFA feature done state.
     */
    export namespace OmaHfaFeatureDoneState {
        export const $gtype: GObject.GType<OmaHfaFeatureDoneState>;
    }

    enum OmaHfaFeatureDoneState {
        /**
         * None.
         */
        NONE,
        /**
         * Succeeded.
         */
        SUCCEEDED,
        /**
         * Failed.
         */
        FAILED,
    }
    /**
     * Session failure reason.
     */

    /**
     * Session failure reason.
     */
    export namespace OmaSessionFailedReason {
        export const $gtype: GObject.GType<OmaSessionFailedReason>;
    }

    enum OmaSessionFailedReason {
        /**
         * Unknown reason.
         */
        UNKNOWN,
        /**
         * Network unavailable.
         */
        NETWORK_UNAVAILABLE,
        /**
         * Server unavailable.
         */
        SERVER_UNAVAILABLE,
        /**
         * Authentication failed.
         */
        AUTHENTICATION_FAILED,
        /**
         * Maximum retries exceeded.
         */
        MAX_RETRY_EXCEEDED,
        /**
         * Session cancelled.
         */
        SESSION_CANCELLED,
    }
    /**
     * State of the OMA-DM session.
     */

    /**
     * State of the OMA-DM session.
     */
    export namespace OmaSessionState {
        export const $gtype: GObject.GType<OmaSessionState>;
    }

    enum OmaSessionState {
        /**
         * Session complete and information updated.
         */
        COMPLETE_INFORMATION_UPDATED,
        /**
         * Session complete but updated information not available.
         */
        COMPLETE_UPDATED_INFORMATION_UNAVAILABLE,
        /**
         * Session failed.
         */
        FAILED,
        /**
         * Session retrying.
         */
        RETRYING,
        /**
         * Session connecting.
         */
        CONNECTING,
        /**
         * Session connected.
         */
        CONNECTED,
        /**
         * Session authenticated.
         */
        AUTHENTICATED,
        /**
         * MDN downloaded.
         */
        MDN_DOWNLOADED,
        /**
         * MSID downloaded.
         */
        MSID_DOWNLOADED,
        /**
         * PRL downloaded.
         */
        PRL_DOWNLOADED,
        /**
         * MIP profile downloaded.
         */
        MIP_PROFILE_DOWNLOADED,
    }
    /**
     * Type of OMA-DM session.
     */

    /**
     * Type of OMA-DM session.
     */
    export namespace OmaSessionType {
        export const $gtype: GObject.GType<OmaSessionType>;
    }

    enum OmaSessionType {
        /**
         * Client-initiated device configure.
         */
        CLIENT_INITIATED_DEVICE_CONFIGURE,
        /**
         * Client-initiated PRL update.
         */
        CLIENT_INITIATED_PRL_UPDATE,
        /**
         * Client-initiated hands free activation.
         */
        CLIENT_INITIATED_HANDS_FREE_ACTIVATION,
        /**
         * Device-initiated hands free activation.
         */
        DEVICE_INITIATED_HANDS_FREE_ACTIVATION,
        /**
         * Network-initiated PRL update.
         */
        NETWORK_INITIATED_PRL_UPDATE,
        /**
         * Network-initiated device configure.
         */
        NETWORK_INITIATED_DEVICE_CONFIGURE,
        /**
         * Device-initiated PRL update.
         */
        DEVICE_INITIATED_PRL_UPDATE,
    }
    /**
     * Type of phonebook management session.
     */

    /**
     * Type of phonebook management session.
     */
    export namespace PbmSessionType {
        export const $gtype: GObject.GType<PbmSessionType>;
    }

    enum PbmSessionType {
        /**
         * Access phonebooks under GSM DF (ICC) or USIM application (UICC).
         */
        GW_PRIMARY,
        /**
         * Access phonebooks under CDMA DF (ICC) or CSIM application (UICC).
         */
        '1X_PRIMARY',
        /**
         * Access phonebooks under GSM DF (ICC) or USIM application (UICC). Dual standby.
         */
        GW_SECONDARY,
        /**
         * Access phonebooks under CDMA DF (ICC) or CSIM application (UICC). Dual standby.
         */
        '1X_SECONDARY',
        /**
         * Access phonebooks under a nonprovisioning application in slot 1.
         */
        NONPROVISIONING_SLOT_1,
        /**
         * Access phonebooks under a nonprovisioning application in slot 2.
         */
        NONPROVISIONING_SLOT_2,
        /**
         * Access phonebooks that are not in any application of the card in slot 1.
         */
        GLOBAL_PHONEBOOK_SLOT_1,
        /**
         * Access phonebooks that are not in any application of the card in slot 2.
         */
        GLOBAL_PHONEBOOK_SLOT_2,
    }
    /**
     * Configuration type for change/load configuration.
     */

    /**
     * Configuration type for change/load configuration.
     */
    export namespace PdcConfigurationType {
        export const $gtype: GObject.GType<PdcConfigurationType>;
    }

    enum PdcConfigurationType {
        /**
         * Platform
         */
        PLATFORM,
        /**
         * Software
         */
        SOFTWARE,
    }
    /**
     * Refresh event type.
     */

    /**
     * Refresh event type.
     */
    export namespace PdcRefreshEventType {
        export const $gtype: GObject.GType<PdcRefreshEventType>;
    }

    enum PdcRefreshEventType {
        /**
         * Refresh start event
         */
        START,
        /**
         * Refresh complete event
         */
        COMPLETE,
        /**
         * Client refresh event
         */
        CLIENT_REFRESH,
    }
    /**
     * Network mode used during the A-GPS setup.
     */

    /**
     * Network mode used during the A-GPS setup.
     */
    export namespace PdsNetworkMode {
        export const $gtype: GObject.GType<PdsNetworkMode>;
    }

    enum PdsNetworkMode {
        /**
         * UMTS.
         */
        UMTS,
        /**
         * CDMA.
         */
        CDMA,
    }
    /**
     * GPS operating mode.
     */

    /**
     * GPS operating mode.
     */
    export namespace PdsOperatingMode {
        export const $gtype: GObject.GType<PdsOperatingMode>;
    }

    enum PdsOperatingMode {
        /**
         * Standalone (GPS only).
         */
        STANDALONE,
        /**
         * Mobile Station Based (MSB) A-GPS
         */
        MS_BASED,
        /**
         * Mobile Station Assisted (MSA) A-GPS.
         */
        MS_ASSISTED,
    }
    /**
     * Operation mode used to compute the position.
     */

    /**
     * Operation mode used to compute the position.
     */
    export namespace PdsOperationMode {
        export const $gtype: GObject.GType<PdsOperationMode>;
    }

    enum PdsOperationMode {
        /**
         * Unknown (position not fixed yet).
         */
        UNKNOWN,
        /**
         * Standalone.
         */
        STANDALONE,
        /**
         * Mobile Station Based (MSB) A-GPS.
         */
        MS_BASED,
        /**
         * Mobile Station Assisted (MSA) A-GPS.
         */
        MS_ASSISTED,
    }
    /**
     * Status of the positioning session.
     */

    /**
     * Status of the positioning session.
     */
    export namespace PdsPositionSessionStatus {
        export const $gtype: GObject.GType<PdsPositionSessionStatus>;
    }

    enum PdsPositionSessionStatus {
        /**
         * Success.
         */
        SUCCESS,
        /**
         * In progress.
         */
        IN_PROGRESS,
        /**
         * General failure.
         */
        GENERAL_FAILURE,
        /**
         * Timeout.
         */
        TIMEOUT,
        /**
         * User ended session.
         */
        USER_ENDED_SESSION,
        /**
         * Bad parameter.
         */
        BAD_PARAMETER,
        /**
         * Phone is offline.
         */
        PHONE_OFFLINE,
        /**
         * Engine locked.
         */
        ENGINE_LOCKED,
        /**
         * Emergency call in progress.
         */
        E911_SESSION_IN_PROGRESS,
    }
    /**
     * State of the tracking session.
     */

    /**
     * State of the tracking session.
     */
    export namespace PdsTrackingSessionState {
        export const $gtype: GObject.GType<PdsTrackingSessionState>;
    }

    enum PdsTrackingSessionState {
        /**
         * Unknown state.
         */
        UNKNOWN,
        /**
         * Session inactive.
         */
        INACTIVE,
        /**
         * Session active.
         */
        ACTIVE,
    }
    /**
     * QMI protocol errors.
     */
    class ProtocolError extends GLib.Error {
        static $gtype: GObject.GType<ProtocolError>;

        // Static fields

        /**
         * No error.
         */
        static NONE: number;
        /**
         * Malformed message.
         */
        static MALFORMEDMESSAGE: number;
        /**
         * No memory.
         */
        static NOMEMORY: number;
        /**
         * Internal.
         */
        static INTERNAL: number;
        /**
         * Aborted.
         */
        static ABORTED: number;
        /**
         * Client IDs exhausted.
         */
        static CLIENTIDSEXHAUSTED: number;
        /**
         * Unabortable transaction.
         */
        static UNABORTABLETRANSACTION: number;
        /**
         * Invalid client ID.
         */
        static INVALIDCLIENTID: number;
        /**
         * No thresholds provided.
         */
        static NOTHRESHOLDSPROVIDED: number;
        /**
         * Invalid handle.
         */
        static INVALIDHANDLE: number;
        /**
         * Invalid profile.
         */
        static INVALIDPROFILE: number;
        /**
         * Invalid PIN ID.
         */
        static INVALIDPINID: number;
        /**
         * Incorrect PIN.
         */
        static INCORRECTPIN: number;
        /**
         * No network found.
         */
        static NONETWORKFOUND: number;
        /**
         * Call failed.
         */
        static CALLFAILED: number;
        /**
         * Out of call.
         */
        static OUTOFCALL: number;
        /**
         * Not provisioned.
         */
        static NOTPROVISIONED: number;
        /**
         * Missing argument.
         */
        static MISSINGARGUMENT: number;
        /**
         * Argument too long.
         */
        static ARGUMENTTOOLONG: number;
        /**
         * Invalid transaction ID.
         */
        static INVALIDTRANSACTIONID: number;
        /**
         * Device in use.
         */
        static DEVICEINUSE: number;
        /**
         * Network unsupported.
         */
        static NETWORKUNSUPPORTED: number;
        /**
         * Device unsupported.
         */
        static DEVICEUNSUPPORTED: number;
        /**
         * No effect.
         */
        static NOEFFECT: number;
        /**
         * No free profile.
         */
        static NOFREEPROFILE: number;
        /**
         * Invalid PDP type.
         */
        static INVALIDPDPTYPE: number;
        /**
         * Invalid technology preference.
         */
        static INVALIDTECHNOLOGYPREFERENCE: number;
        /**
         * Invalid profile type.
         */
        static INVALIDPROFILETYPE: number;
        /**
         * Invalid service type.
         */
        static INVALIDSERVICETYPE: number;
        /**
         * Invalid register action.
         */
        static INVALIDREGISTERACTION: number;
        /**
         * Invalid PS attach action.
         */
        static INVALIDPSATTACHACTION: number;
        /**
         * Authentication failed.
         */
        static AUTHENTICATIONFAILED: number;
        /**
         * PIN blocked.
         */
        static PINBLOCKED: number;
        /**
         * PIN always blocked.
         */
        static PINALWAYSBLOCKED: number;
        /**
         * UIM uninitialized.
         */
        static UIMUNINITIALIZED: number;
        /**
         * Maximum QoS requests in use.
         */
        static MAXIMUMQOSREQUESTSINUSE: number;
        /**
         * Incorrect flow filter.
         */
        static INCORRECTFLOWFILTER: number;
        /**
         * Network QoS unaware.
         */
        static NETWORKQOSUNAWARE: number;
        /**
         * Invalid QoS ID.
         */
        static INVALIDQOSID: number;
        /**
         * Requested number unsupported. Since: 1.22.
         */
        static REQUESTEDNUMBERUNSUPPORTED: number;
        /**
         * Interface not found. Since: 1.22.
         */
        static INTERFACENOTFOUND: number;
        /**
         * Flow suspended.
         */
        static FLOWSUSPENDED: number;
        /**
         * Invalid data format. Since: 1.22.
         */
        static INVALIDDATAFORMAT: number;
        /**
         * General error.
         */
        static GENERALERROR: number;
        /**
         * Unknown error.
         */
        static UNKNOWNERROR: number;
        /**
         * Invalid argument.
         */
        static INVALIDARGUMENT: number;
        /**
         * Invalid index.
         */
        static INVALIDINDEX: number;
        /**
         * No entry.
         */
        static NOENTRY: number;
        /**
         * Device storage full.
         */
        static DEVICESTORAGEFULL: number;
        /**
         * Device not ready.
         */
        static DEVICENOTREADY: number;
        /**
         * Network not ready.
         */
        static NETWORKNOTREADY: number;
        /**
         * WMS cause code.
         */
        static WMSCAUSECODE: number;
        /**
         * WMS message not sent.
         */
        static WMSMESSAGENOTSENT: number;
        /**
         * WMS message delivery failure.
         */
        static WMSMESSAGEDELIVERYFAILURE: number;
        /**
         * WMS invalid message ID.
         */
        static WMSINVALIDMESSAGEID: number;
        /**
         * WMS encoding.
         */
        static WMSENCODING: number;
        /**
         * Authentication lock.
         */
        static AUTHENTICATIONLOCK: number;
        /**
         * Invalid transition.
         */
        static INVALIDTRANSITION: number;
        /**
         * Not a multicast interface. Since: 1.22.
         */
        static NOTMCASTINTERFACE: number;
        /**
         * Maximum multicast requests in use. Since: 1.22.
         */
        static MAXIMUMMCASTREQUESTSINUSE: number;
        /**
         * Invalid mulitcast handle. Since: 1.22.
         */
        static INVALIDMCASTHANDLE: number;
        /**
         * Invalid IP family preference. Since: 1.22.
         */
        static INVALIDIPFAMILYPREFERENCE: number;
        /**
         * Session inactive.
         */
        static SESSIONINACTIVE: number;
        /**
         * Session invalid.
         */
        static SESSIONINVALID: number;
        /**
         * Session ownership.
         */
        static SESSIONOWNERSHIP: number;
        /**
         * Insufficient resources.
         */
        static INSUFFICIENTRESOURCES: number;
        /**
         * Disabled.
         */
        static DISABLED: number;
        /**
         * Invalid operation.
         */
        static INVALIDOPERATION: number;
        /**
         * Invalid QMI command.
         */
        static INVALIDQMICOMMAND: number;
        /**
         * WMS T-PDU type.
         */
        static WMSTPDUTYPE: number;
        /**
         * WMS SMSC address.
         */
        static WMSSMSCADDRESS: number;
        /**
         * Information unavailable.
         */
        static INFORMATIONUNAVAILABLE: number;
        /**
         * Segment too long.
         */
        static SEGMENTTOOLONG: number;
        /**
         * Segment order.
         */
        static SEGMENTORDER: number;
        /**
         * Bundling not supported.
         */
        static BUNDLINGNOTSUPPORTED: number;
        /**
         * Operation partial failure. Since: 1.22.
         */
        static OPERATIONPARTIALFAILURE: number;
        /**
         * Policy mismatch. Since: 1.6.
         */
        static POLICYMISMATCH: number;
        /**
         * SIM file not found.
         */
        static SIMFILENOTFOUND: number;
        /**
         * Extended internal error. Since: 1.6.
         */
        static EXTENDEDINTERNAL: number;
        /**
         * Access denied.
         */
        static ACCESSDENIED: number;
        /**
         * Hardware restricted.
         */
        static HARDWARERESTRICTED: number;
        /**
         * ACK not sent. Since: 1.6.
         */
        static ACKNOTSENT: number;
        /**
         * Inject timeout. Since: 1.6.
         */
        static INJECTTIMEOUT: number;
        /**
         * Incompatible state. Since: 1.6.
         */
        static INCOMPATIBLESTATE: number;
        /**
         * FDN restrict. Since: 1.6.
         */
        static FDNRESTRICT: number;
        /**
         * SUPS failure case. Since: 1.6.
         */
        static SUPSFAILURECASE: number;
        /**
         * No radio. Since: 1.6.
         */
        static NORADIO: number;
        /**
         * Not supported. Since: 1.6.
         */
        static NOTSUPPORTED: number;
        /**
         * No subscription. Since: 1.6.
         */
        static NOSUBSCRIPTION: number;
        /**
         * Card call control failed. Since: 1.6.
         */
        static CARDCALLCONTROLFAILED: number;
        /**
         * Network aborted. Since: 1.6.
         */
        static NETWORKABORTED: number;
        /**
         * Message blocked. Since: 1.6.
         */
        static MSGBLOCKED: number;
        /**
         * Invalid session type. Since: 1.6.
         */
        static INVALIDSESSIONTYPE: number;
        /**
         * Invalid PB type. Since: 1.6.
         */
        static INVALIDPBTYPE: number;
        /**
         * No SIM. Since: 1.6.
         */
        static NOSIM: number;
        /**
         * PB not ready. Since: 1.6.
         */
        static PBNOTREADY: number;
        /**
         * PIN restriction. Since: 1.6.
         */
        static PINRESTRICTION: number;
        /**
         * PIN2 restriction. Since: 1.6.
         */
        static PIN1RESTRICTION: number;
        /**
         * PUK restriction. Since: 1.6.
         */
        static PUKRESTRICTION: number;
        /**
         * PUK2 restriction. Since: 1.6.
         */
        static PUK2RESTRICTION: number;
        /**
         * PB access restricted. Since: 1.6.
         */
        static PBACCESSRESTRICTED: number;
        /**
         * PB delete in progress. Since: 1.22.
         */
        static PBDELETEINPROGRESS: number;
        /**
         * PB text too long. Since: 1.6.
         */
        static PBTEXTTOOLONG: number;
        /**
         * PB number too long. Since: 1.6.
         */
        static PBNUMBERTOOLONG: number;
        /**
         * PB hidden key restriction. Since: 1.6.
         */
        static PBHIDDENKEYRESTRICTION: number;
        /**
         * PB not available. Since: 1.22.
         */
        static PBNOTAVAILABLE: number;
        /**
         * Device memory error. Since: 1.22.
         */
        static DEVICEMEMORYERROR: number;
        /**
         * No permission. Since: 1.22.
         */
        static NOPERMISSION: number;
        /**
         * Too soon. Since: 1.22.
         */
        static TOOSOON: number;
        /**
         * Time not acquired. Since: 1.22.
         */
        static TIMENOTACQUIRED: number;
        /**
         * Operation in progress. Since: 1.22.
         */
        static OPERATIONINPROGRESS: number;
        /**
         * Firmware write failed. Since: 1.22.
         */
        static FWWRITEFAILED: number;
        /**
         * Firmware info read failed. Since: 1.22.
         */
        static FWINFOREADFAILED: number;
        /**
         * Firmware file not found. Since: 1.22.
         */
        static FWFILENOTFOUND: number;
        /**
         * Firmware dir not found. Since: 1.22.
         */
        static FWDIRNOTFOUND: number;
        /**
         * Firmware already activated. Since: 1.22.
         */
        static FWALREADYACTIVATED: number;
        /**
         * Firmware cannot generic image. Since: 1.22.
         */
        static FWCANNOTGENERICIMAGE: number;
        /**
         * Firmware file open failed. Since: 1.22.
         */
        static FWFILEOPENFAILED: number;
        /**
         * Firmware update discontinuous frame. Since: 1.22.
         */
        static FWUPDATEDISCONTINUOUSFRAME: number;
        /**
         * Firmware update failed. Since: 1.22.
         */
        static FWUPDATEFAILED: number;
        /**
         * Event registration failed.
         */
        static CATEVENTREGISTRATIONFAILED: number;
        /**
         * Invalid terminal response.
         */
        static CATINVALIDTERMINALRESPONSE: number;
        /**
         * Invalid envelope command.
         */
        static CATINVALIDENVELOPECOMMAND: number;
        /**
         * Envelope command busy.
         */
        static CATENVELOPECOMMANDBUSY: number;
        /**
         * Envelope command failed.
         */
        static CATENVELOPECOMMANDFAILED: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        /**
         * Gets the nickname string for the #QmiProtocolError specified at `val`.
         * @param val a QmiProtocolError.
         */
        static get_string(val: ProtocolError): string;
        static quark(): GLib.Quark;
    }

    /**
     * QoS event.
     */

    /**
     * QoS event.
     */
    export namespace QosEvent {
        export const $gtype: GObject.GType<QosEvent>;
    }

    enum QosEvent {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * Activated.
         */
        ACTIVATED,
        /**
         * Suspended.
         */
        SUSPENDED,
        /**
         * Gone.
         */
        GONE,
        /**
         * Modify accepted.
         */
        MODIFY_ACCEPTED,
        /**
         * Modify rejected.
         */
        MODIFY_REJECTED,
        /**
         * Information code updated.
         */
        INFO_CODE_UPDATED,
    }
    /**
     * QoS flow status.
     */

    /**
     * QoS flow status.
     */
    export namespace QosStatus {
        export const $gtype: GObject.GType<QosStatus>;
    }

    enum QosStatus {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * Activated.
         */
        ACTIVATED,
        /**
         * Suspended.
         */
        SUSPENDED,
        /**
         * Gone.
         */
        GONE,
    }
    /**
     * SAR RF state. Each RF state corresponds to a TX power, and the mapping between TX power and RF state is dictated by NV items.
     */
    /**
     * SAR RF state. Each RF state corresponds to a TX power, and the mapping between TX power and RF state is dictated by NV items.
     */
    class SarRfState {
        static $gtype: GObject.GType<SarRfState>;

        // Static fields

        /**
         * RF State 0
         */
        static '0': number;
        /**
         * RF State 1
         */
        static '1': number;
        /**
         * RF State 2
         */
        static '2': number;
        /**
         * RF State 3
         */
        static '3': number;
        /**
         * RF State 4
         */
        static '4': number;
        /**
         * RF State 5
         */
        static '5': number;
        /**
         * RF State 6
         */
        static '6': number;
        /**
         * RF State 7
         */
        static '7': number;
        /**
         * RF State 8
         */
        static '8': number;
        /**
         * RF State 9
         */
        static '9': number;
        /**
         * RF State 10
         */
        static '10': number;
        /**
         * RF State 11
         */
        static '11': number;
        /**
         * RF State 12
         */
        static '12': number;
        /**
         * RF State 13
         */
        static '13': number;
        /**
         * RF State 14
         */
        static '14': number;
        /**
         * RF State 15
         */
        static '15': number;
        /**
         * RF State 16
         */
        static '16': number;
        /**
         * RF State 17
         */
        static '17': number;
        /**
         * RF State 18
         */
        static '18': number;
        /**
         * RF State 19
         */
        static '19': number;
        /**
         * RF State 20
         */
        static '20': number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * QMI services.
     */

    /**
     * QMI services.
     */
    export namespace Service {
        export const $gtype: GObject.GType<Service>;
    }

    enum Service {
        /**
         * Unknown service.
         */
        UNKNOWN,
        /**
         * Control service.
         */
        CTL,
        /**
         * Wireless Data Service.
         */
        WDS,
        /**
         * Device Management Service.
         */
        DMS,
        /**
         * Network Access Service.
         */
        NAS,
        /**
         * Quality Of Service service.
         */
        QOS,
        /**
         * Wireless Messaging Service.
         */
        WMS,
        /**
         * Position Determination Service.
         */
        PDS,
        /**
         * Authentication service.
         */
        AUTH,
        /**
         * AT service.
         */
        AT,
        /**
         * Voice service.
         */
        VOICE,
        /**
         * Card Application Toolkit service (v2).
         */
        CAT2,
        /**
         * User Identity Module service.
         */
        UIM,
        /**
         * Phonebook Management service.
         */
        PBM,
        /**
         * QCHAT service. Since: 1.8.
         */
        QCHAT,
        /**
         * Remote file system service.
         */
        RMTFS,
        /**
         * Test service. Since: 1.8.
         */
        TEST,
        /**
         * Location service (~ PDS v2).
         */
        LOC,
        /**
         * Specific absorption rate service.
         */
        SAR,
        /**
         * IMS settings service. Since: 1.8.
         */
        IMS,
        /**
         * Analog to digital converter driver service. Since: 1.8.
         */
        ADC,
        /**
         * Core sound driver service. Since: 1.8.
         */
        CSD,
        /**
         * Modem embedded file system service. Since: 1.8.
         */
        MFS,
        /**
         * Time service. Since: 1.8.
         */
        TIME,
        /**
         * Thermal sensors service. Since: 1.8.
         */
        TS,
        /**
         * Thermal mitigation device service. Since: 1.8.
         */
        TMD,
        /**
         * Service access proxy service. Since: 1.8.
         */
        SAP,
        /**
         * Wireless data administrative service. Since: 1.8.
         */
        WDA,
        /**
         * TSYNC control service. Since: 1.8.
         */
        TSYNC,
        /**
         * Remote file system access service. Since: 1.8.
         */
        RFSA,
        /**
         * Circuit switched videotelephony service. Since: 1.8.
         */
        CSVT,
        /**
         * Qualcomm mobile access point service. Since: 1.8.
         */
        QCMAP,
        /**
         * IMS presence service. Since: 1.8.
         */
        IMSP,
        /**
         * IMS videotelephony service. Since: 1.8.
         */
        IMSVT,
        /**
         * IMS application service. Since: 1.8.
         */
        IMSA,
        /**
         * Coexistence service. Since: 1.8.
         */
        COEX,
        /**
         * Persistent device configuration service. Since: 1.8.
         */
        PDC,
        /**
         * Simultaneous transmit service. Since: 1.8.
         */
        STX,
        /**
         * Bearer independent transport service. Since: 1.8.
         */
        BIT,
        /**
         * IMS RTP service. Since: 1.8.
         */
        IMSRTP,
        /**
         * RF radiated performance enhancement service. Since: 1.8.
         */
        RFRPE,
        /**
         * Data system determination service. Since: 1.8.
         */
        DSD,
        /**
         * Subsystem control service. Since: 1.8.
         */
        SSCTL,
        /**
         * Data Port Mapper service. Since: 1.30.
         */
        DPM,
        /**
         * Card Application Toolkit service (v1).
         */
        CAT,
        /**
         * Remote Management Service.
         */
        RMS,
        /**
         * Open Mobile Alliance device management service.
         */
        OMA,
        /**
         * Foxconn General Modem Service. Since: 1.32.
         */
        FOX,
        /**
         * Firmware Over The Air service. Since: 1.24.
         */
        FOTA,
        /**
         * Telit General Modem Service. Since: 1.24.
         */
        GMS,
        /**
         * Telit General Application Service. Since: 1.24.
         */
        GAS,
        /**
         * Telit AT Relay Service. Since: 1.34.
         */
        ATR,
        /**
         * Snapdragon Sensore Core Service. Since: 1.34.
         */
        SSC,
    }
    /**
     * SIO (serial I/O) port numbers. All ports available in the modem have a SIO
     * port number. This enum is incomplete, only few port numbers are publicly
     * known.
     */

    /**
     * SIO (serial I/O) port numbers. All ports available in the modem have a SIO
     * port number. This enum is incomplete, only few port numbers are publicly
     * known.
     */
    export namespace SioPort {
        export const $gtype: GObject.GType<SioPort>;
    }

    enum SioPort {
        /**
         * Invalid port number.
         */
        NONE,
        /**
         * A2 MUX (BAM-DMUX) port for rmnet0.
         */
        A2_MUX_RMNET0,
        /**
         * A2 MUX (BAM-DMUX) port for rmnet1.
         */
        A2_MUX_RMNET1,
        /**
         * A2 MUX (BAM-DMUX) port for rmnet2.
         */
        A2_MUX_RMNET2,
        /**
         * A2 MUX (BAM-DMUX) port for rmnet3.
         */
        A2_MUX_RMNET3,
        /**
         * A2 MUX (BAM-DMUX) port for rmnet4.
         */
        A2_MUX_RMNET4,
        /**
         * A2 MUX (BAM-DMUX) port for rmnet5.
         */
        A2_MUX_RMNET5,
        /**
         * A2 MUX (BAM-DMUX) port for rmnet6.
         */
        A2_MUX_RMNET6,
        /**
         * A2 MUX (BAM-DMUX) port for rmnet7.
         */
        A2_MUX_RMNET7,
    }
    /**
     * SSC service report types.
     */

    /**
     * SSC service report types.
     */
    export namespace SscReportType {
        export const $gtype: GObject.GType<SscReportType>;
    }

    enum SscReportType {
        /**
         * Small size report.
         */
        SMALL,
        /**
         * Large size report.
         */
        LARGE,
    }
    /**
     * Card application personalization feature, when a code is required.
     */

    /**
     * Card application personalization feature, when a code is required.
     */
    export namespace UimCardApplicationPersonalizationFeature {
        export const $gtype: GObject.GType<UimCardApplicationPersonalizationFeature>;
    }

    enum UimCardApplicationPersonalizationFeature {
        /**
         * GW network.
         */
        GW_NETWORK,
        /**
         * GW network subset.
         */
        GW_NETWORK_SUBSET,
        /**
         * GW service provider.
         */
        GW_SERVICE_PROVIDER,
        /**
         * GW corporate.
         */
        GW_CORPORATE,
        /**
         * UIM.
         */
        GW_UIM,
        /**
         * 1X network type 1.
         */
        '1X_NETWORK_TYPE_1',
        /**
         * 1X network type 2.
         */
        '1X_NETWORK_TYPE_2',
        /**
         * 1X HRPD.
         */
        '1X_HRPD',
        /**
         * 1X service provider.
         */
        '1X_SERVICE_PROVIDER',
        /**
         * 1X corporate.
         */
        '1X_CORPORATE',
        /**
         * 1X R-UIM.
         */
        '1X_RUIM',
        /**
         * GW SPN. Since 1.34.
         */
        GW_SERVICE_PROVIDER_NAME,
        /**
         * GW SP + EHPLMN. Since 1.34.
         */
        GW_SP_EHPLMN,
        /**
         * GW ICCID. Since 1.34.
         */
        GW_ICCID,
        /**
         * GW IMPI. Since 1.34.
         */
        GW_IMPI,
        /**
         * GW network subset and service provider. Since 1.34.
         */
        GW_NETWORK_SUBSET_SERVICE_PROVIDER,
        /**
         * GW carrier. Since 1.34.
         */
        GW_CARRIER,
    }
    /**
     * Card application personalization feature status.
     */

    /**
     * Card application personalization feature status.
     */
    export namespace UimCardApplicationPersonalizationFeatureStatus {
        export const $gtype: GObject.GType<UimCardApplicationPersonalizationFeatureStatus>;
    }

    enum UimCardApplicationPersonalizationFeatureStatus {
        /**
         * GW network.
         */
        GW_NETWORK,
        /**
         * GW network subset.
         */
        GW_NETWORK_SUBSET,
        /**
         * GW service provider.
         */
        GW_SERVICE_PROVIDER,
        /**
         * GW corporate.
         */
        GW_CORPORATE,
        /**
         * UIM.
         */
        GW_UIM,
        /**
         * 1X network type 1.
         */
        '1X_NETWORK_TYPE_1',
        /**
         * 1X network type 2.
         */
        '1X_NETWORK_TYPE_2',
        /**
         * 1X HRPD.
         */
        '1X_HRPD',
        /**
         * 1X service provider.
         */
        '1X_SERVICE_PROVIDER',
        /**
         * 1X corporate.
         */
        '1X_CORPORATE',
        /**
         * 1X R-UIM.
         */
        '1X_RUIM',
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * GW service provider name.
         */
        GW_SERVICE_PROVIDER_NAME,
        /**
         * GW SP + EHPLMN.
         */
        GW_SP_EHPLMN,
        /**
         * GW ICCID.
         */
        GW_ICCID,
        /**
         * GW IMPI.
         */
        GW_IMPI,
        /**
         * GW network subset and service provider.
         */
        GW_NETWORK_SUBSET_SERVICE_PROVIDER,
        /**
         * GW carrier.
         */
        GW_CARRIER,
    }
    /**
     * Card application personalization state.
     */

    /**
     * Card application personalization state.
     */
    export namespace UimCardApplicationPersonalizationState {
        export const $gtype: GObject.GType<UimCardApplicationPersonalizationState>;
    }

    enum UimCardApplicationPersonalizationState {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * Operation in progress.
         */
        IN_PROGRESS,
        /**
         * Ready.
         */
        READY,
        /**
         * Code required.
         */
        CODE_REQUIRED,
        /**
         * PUK code required.
         */
        PUK_CODE_REQUIRED,
        /**
         * Permanently blocked-
         */
        PERMANENTLY_BLOCKED,
    }
    /**
     * Card application state.
     */

    /**
     * Card application state.
     */
    export namespace UimCardApplicationState {
        export const $gtype: GObject.GType<UimCardApplicationState>;
    }

    enum UimCardApplicationState {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * Detected.
         */
        DETECTED,
        /**
         * PIN1 or UPIN PIN required.
         */
        PIN1_OR_UPIN_PIN_REQUIRED,
        /**
         * PUK1 or UPIN PUK required.
         */
        PUK1_OR_UPIN_PUK_REQUIRED,
        /**
         * Personalization state must be checked.
         */
        CHECK_PERSONALIZATION_STATE,
        /**
         * PIN1 blocked.
         */
        PIN1_BLOCKED,
        /**
         * Illegal.
         */
        ILLEGAL,
        /**
         * Ready
         */
        READY,
    }
    /**
     * Card application type.
     */

    /**
     * Card application type.
     */
    export namespace UimCardApplicationType {
        export const $gtype: GObject.GType<UimCardApplicationType>;
    }

    enum UimCardApplicationType {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * SIM.
         */
        SIM,
        /**
         * USIM.
         */
        USIM,
        /**
         * RUIM.
         */
        RUIM,
        /**
         * CSIM.
         */
        CSIM,
        /**
         * ISIM.
         */
        ISIM,
    }
    /**
     * Card error.
     */

    /**
     * Card error.
     */
    export namespace UimCardError {
        export const $gtype: GObject.GType<UimCardError>;
    }

    enum UimCardError {
        /**
         * Unknown error.
         */
        UNKNOWN,
        /**
         * Power down.
         */
        POWER_DOWN,
        /**
         * Poll error.
         */
        POLL,
        /**
         * No ATR received.
         */
        NO_ATR_RECEIVED,
        /**
         * Voltage mismatch.
         */
        VOLTAGE_MISMATCH,
        /**
         * Parity error.
         */
        PARITY,
        /**
         * Unknown error, possibly removed.
         */
        POSSIBLY_REMOVED,
        /**
         * Technical problem.
         */
        TECHNICAL,
    }
    /**
     * Protocol for the card.
     */

    /**
     * Protocol for the card.
     */
    export namespace UimCardProtocol {
        export const $gtype: GObject.GType<UimCardProtocol>;
    }

    enum UimCardProtocol {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * ICC protocol.
         */
        ICC,
        /**
         * UICC protocol.
         */
        UICC,
    }
    /**
     * State of the card.
     */

    /**
     * State of the card.
     */
    export namespace UimCardState {
        export const $gtype: GObject.GType<UimCardState>;
    }

    enum UimCardState {
        /**
         * Absent.
         */
        ABSENT,
        /**
         * Present.
         */
        PRESENT,
        /**
         * Error.
         */
        ERROR,
    }
    /**
     * Depersonalization operation to perform.
     */

    /**
     * Depersonalization operation to perform.
     */
    export namespace UimDepersonalizationOperation {
        export const $gtype: GObject.GType<UimDepersonalizationOperation>;
    }

    enum UimDepersonalizationOperation {
        /**
         * Deactivate personalization
         */
        DEACTIVATE,
        /**
         * Unblock personalization
         */
        UNBLOCK,
    }
    /**
     * Type of UIM file.
     */

    /**
     * Type of UIM file.
     */
    export namespace UimFileType {
        export const $gtype: GObject.GType<UimFileType>;
    }

    enum UimFileType {
        /**
         * Transparent.
         */
        TRANSPARENT,
        /**
         * Cyclic.
         */
        CYCLIC,
        /**
         * Linear fixed.
         */
        LINEAR_FIXED,
        /**
         * Dedicated file.
         */
        DEDICATED_FILE,
        /**
         * Master file.
         */
        MASTER_FILE,
    }
    /**
     * State of the physical card.
     */

    /**
     * State of the physical card.
     */
    export namespace UimPhysicalCardState {
        export const $gtype: GObject.GType<UimPhysicalCardState>;
    }

    enum UimPhysicalCardState {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * Absent.
         */
        ABSENT,
        /**
         * Present.
         */
        PRESENT,
    }
    /**
     * PIN ID.
     */

    /**
     * PIN ID.
     */
    export namespace UimPinId {
        export const $gtype: GObject.GType<UimPinId>;
    }

    enum UimPinId {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * PIN1.
         */
        PIN1,
        /**
         * PIN2.
         */
        PIN2,
        /**
         * UPIN.
         */
        UPIN,
        /**
         * Hidden key.
         */
        HIDDEN_KEY,
    }
    /**
     * The PIN state.
     */

    /**
     * The PIN state.
     */
    export namespace UimPinState {
        export const $gtype: GObject.GType<UimPinState>;
    }

    enum UimPinState {
        /**
         * Not initialized.
         */
        NOT_INITIALIZED,
        /**
         * Enabled, not verified.
         */
        ENABLED_NOT_VERIFIED,
        /**
         * Enabled, verified.
         */
        ENABLED_VERIFIED,
        /**
         * Disabled.
         */
        DISABLED,
        /**
         * Blocked.
         */
        BLOCKED,
        /**
         * Permanently Blocked.
         */
        PERMANENTLY_BLOCKED,
    }
    /**
     * Refresh mode
     */

    /**
     * Refresh mode
     */
    export namespace UimRefreshMode {
        export const $gtype: GObject.GType<UimRefreshMode>;
    }

    enum UimRefreshMode {
        /**
         * Reset.
         */
        RESET,
        /**
         * Init.
         */
        INIT,
        /**
         * Init & FCN.
         */
        INIT_FCN,
        /**
         * FCN.
         */
        FCN,
        /**
         * Init & full FCN.
         */
        INIT_FULL_FCN,
        /**
         * Application reset.
         */
        APP_RESET,
        /**
         * 3G session reset.
         */
        '3G_RESET',
    }
    /**
     * Current stage of the refresh procedure.
     */

    /**
     * Current stage of the refresh procedure.
     */
    export namespace UimRefreshStage {
        export const $gtype: GObject.GType<UimRefreshStage>;
    }

    enum UimRefreshStage {
        /**
         * Waiting for REFRESH OK message.
         */
        WAIT_FOR_OK,
        /**
         * Refresh started.
         */
        START,
        /**
         * Refresh completed successfully.
         */
        END_WITH_SUCCESS,
        /**
         * Refresh has failed.
         */
        END_WITH_FAILURE,
    }
    /**
     * Logic applicable to security attributes.
     */

    /**
     * Logic applicable to security attributes.
     */
    export namespace UimSecurityAttributeLogic {
        export const $gtype: GObject.GType<UimSecurityAttributeLogic>;
    }

    enum UimSecurityAttributeLogic {
        /**
         * Always.
         */
        ALWAYS,
        /**
         * Never.
         */
        NEVER,
        /**
         * And.
         */
        AND,
        /**
         * Or.
         */
        OR,
        /**
         * Single.
         */
        SINGLE,
    }
    /**
     * Type of UIM session.
     */

    /**
     * Type of UIM session.
     */
    export namespace UimSessionType {
        export const $gtype: GObject.GType<UimSessionType>;
    }

    enum UimSessionType {
        /**
         * Primary GSM/WCDMA provisioning.
         */
        PRIMARY_GW_PROVISIONING,
        /**
         * Primary CDMA1x provisioning.
         */
        PRIMARY_1X_PROVISIONING,
        /**
         * Secondary GSM/WCDMA provisioning.
         */
        SECONDARY_GW_PROVISIONING,
        /**
         * Secondary CDMA1x provisioning.
         */
        SECONDARY_1X_PROVISIONING,
        /**
         * Nonprovisioning on slot 1.
         */
        NONPROVISIONING_SLOT_1,
        /**
         * Nonprovisioning on slot 2.
         */
        NONPROVISIONING_SLOT_2,
        /**
         * Card on slot 1.
         */
        CARD_SLOT_1,
        /**
         * Card on slot 2.
         */
        CARD_SLOT_2,
        /**
         * Logical channel on slot 1.
         */
        LOGICAL_CHANNEL_SLOT_1,
        /**
         * Logical channel on slot 2.
         */
        LOGICAL_CHANNEL_SLOT_2,
        /**
         * Tertiary GSM/WCDMA provisioning. Since 1.28.
         */
        TERTIARY_GW_PROVISIONING,
        /**
         * Tertiary CDMA1x provisioning. Since 1.28.
         */
        TERTIARY_1X_PROVISIONING,
        /**
         * Quaternary GSM/WCDMA provisioning. Since 1.28.
         */
        QUATERNARY_GW_PROVISIONING,
        /**
         * Quaternary CDMA1x provisioning. Since 1.28.
         */
        QUATERNARY_1X_PROVISIONING,
        /**
         * Quinary GSM/WCDMA provisioning. Since 1.28.
         */
        QUINARY_GW_PROVISIONING,
        /**
         * Quinary CDMA1x provisioning. Since 1.28.
         */
        QUINARY_1X_PROVISIONING,
        /**
         * Nonprovisioning on slot 3. Since 1.28.
         */
        NONPROVISIONING_SLOT_3,
        /**
         * Nonprovisioning on slot 4. Since 1.28.
         */
        NONPROVISIONING_SLOT_4,
        /**
         * Nonprovisioning on slot 5. Since 1.28.
         */
        NONPROVISIONING_SLOT_5,
        /**
         * Card on slot 3. Since 1.28.
         */
        CARD_SLOT_3,
        /**
         * Card on slot 4. Since 1.28.
         */
        CARD_SLOT_4,
        /**
         * Card on slot 5. Since 1.28.
         */
        CARD_SLOT_5,
        /**
         * Logical channel on slot 3. Since 1.28.
         */
        LOGICAL_CHANNEL_SLOT_3,
        /**
         * Logical channel on slot 4. Since 1.28.
         */
        LOGICAL_CHANNEL_SLOT_4,
        /**
         * Logical channel on slot 5. Since 1.28.
         */
        LOGICAL_CHANNEL_SLOT_5,
    }
    /**
     * State of the slot.
     */

    /**
     * State of the slot.
     */
    export namespace UimSlotState {
        export const $gtype: GObject.GType<UimSlotState>;
    }

    enum UimSlotState {
        /**
         * Inactive.
         */
        INACTIVE,
        /**
         * Active.
         */
        ACTIVE,
    }
    /**
     * Alpha Coding Scheme.
     */

    /**
     * Alpha Coding Scheme.
     */
    export namespace VoiceAlphaDataCodingScheme {
        export const $gtype: GObject.GType<VoiceAlphaDataCodingScheme>;
    }

    enum VoiceAlphaDataCodingScheme {
        /**
         * SMS default 7-bit coded alphabet.
         */
        GSM,
        /**
         * UCS2.
         */
        UCS2,
    }
    /**
     * ALS line indicator.
     */
    /**
     * ALS line indicator.
     */
    class VoiceAls {
        static $gtype: GObject.GType<VoiceAls>;

        // Static fields

        /**
         * Line 1, default.
         */
        static '1': number;
        /**
         * Line 2.
         */
        static '2': number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Call control result type.
     */

    /**
     * Call control result type.
     */
    export namespace VoiceCallControlResultType {
        export const $gtype: GObject.GType<VoiceCallControlResultType>;
    }

    enum VoiceCallControlResultType {
        /**
         * Voice.
         */
        VOICE,
        /**
         * Supplementary service.
         */
        SUPS,
        /**
         * Unstructured supplementary service.
         */
        USSD,
    }
    /**
     * Call control supplementary service type.
     */

    /**
     * Call control supplementary service type.
     */
    export namespace VoiceCallControlSupplementaryServiceType {
        export const $gtype: GObject.GType<VoiceCallControlSupplementaryServiceType>;
    }

    enum VoiceCallControlSupplementaryServiceType {
        /**
         * Activate.
         */
        ACTIVATE,
        /**
         * Deactivate.
         */
        DEACTIVATE,
        /**
         * Register.
         */
        REGISTER,
        /**
         * Erase.
         */
        ERASE,
        /**
         * Interrogate.
         */
        INTERROGATE,
        /**
         * Register password.
         */
        REGISTER_PASSWORD,
        /**
         * USSD.
         */
        USSD,
    }
    /**
     * Call direction.
     */

    /**
     * Call direction.
     */
    export namespace VoiceCallDirection {
        export const $gtype: GObject.GType<VoiceCallDirection>;
    }

    enum VoiceCallDirection {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * Mobile-originated.
         */
        MO,
        /**
         * Mobile-terminated.
         */
        MT,
    }
    /**
     * Possible call end reasons resulting from a voice call or supplementary
     * service connection being terminated.
     */

    /**
     * Possible call end reasons resulting from a voice call or supplementary
     * service connection being terminated.
     */
    export namespace VoiceCallEndReason {
        export const $gtype: GObject.GType<VoiceCallEndReason>;
    }

    enum VoiceCallEndReason {
        /**
         * Device is offline.
         */
        OFFLINE,
        /**
         * CDMA specific. Phone is CDMA locked.
         */
        CDMA_LOCK,
        /**
         * Device has no service.
         */
        NO_SERVICE,
        /**
         * Fade.
         */
        FADE,
        /**
         * CDMA specific. Received intercept from the BS.
         */
        INTERCEPT,
        /**
         * CDMA specific. Received reorder from the BS.
         */
        REORDER,
        /**
         * Received release from the BS.
         */
        RELEASE_NORMAL,
        /**
         * CDMA specific. Received release from the BS.
         */
        RELEASE_SO_REJECT,
        /**
         * CDMA specific. Received incoming call from the BS.
         */
        INCOMING_CALL,
        /**
         * CDMA specific. Received alert stop from the BS.
         */
        ALERT_STOP,
        /**
         * Client ended the call.
         */
        CLIENT_END,
        /**
         * CDMA specific. Received end activation.
         */
        ACTIVATION,
        /**
         * CDMA specific. MC aborted the origination/conversation.
         */
        MC_ABORT,
        /**
         * CDMA specific. Maximum access probes transmitted.
         */
        MAX_ACCESS_PROBE,
        /**
         * CDMA specific. Persistence test failure.
         */
        PSIST_N,
        /**
         * R-UIM not present.
         */
        UIM_NOT_PRESENT,
        /**
         * Access attempt in progress.
         */
        ACCESS_ATTEMPT_IN_PROGRESS,
        /**
         * Access failure.
         */
        ACCESS_FAILURE,
        /**
         * CDMA specific. Retry order.
         */
        ACCESS_RETRY_ORDER,
        /**
         * CDMA specific. Concurrent service not supported by the BS.
         */
        CCS_NOT_SUPPORTED_BY_BS,
        /**
         * CDMA specific. No response received from the BS.
         */
        NO_RESPONSE_FROM_BS,
        /**
         * CDMA specific. Rejected by the BS.
         */
        REJECTED_BY_BS,
        /**
         * CDMA specific. Concurrent services requested are incompatible.
         */
        INCOMPATIBLE,
        /**
         * CDMA specific. Access blocked by the BS.
         */
        ACCESS_BLOCK,
        /**
         * Already in TC.
         */
        ALREADY_IN_TC,
        /**
         * CDMA specific. Emergency call is flashed over this call.
         */
        EMERGENCY_FLASHED,
        /**
         * Call originated during GPS.
         */
        USER_CALL_ORIGINATED_DURING_GPS,
        /**
         * Call originated during SMS.
         */
        USER_CALL_ORIGINATED_DURING_SMS,
        /**
         * Call originated during data.
         */
        USER_CALL_ORIGINATED_DURING_DATA,
        /**
         * Redirection or handoff.
         */
        REDIRECTION_OR_HANDOFF,
        /**
         * Access blocked by BS for all.
         */
        ACCESS_BLOCK_ALL,
        /**
         * OTASP SPC error indication.
         */
        OTASP_SPC_ERR,
        /**
         * Maximum access probes for IS-707B call.
         */
        IS707B_MAX_ACCESS_PROBES,
        /**
         * Base station reject order.
         */
        ACCESS_FAILURE_REJECT_ORDER,
        /**
         * Base station retry order.
         */
        ACCESS_FAILURE_RETRY_ORDER,
        /**
         * Timer T42 expired.
         */
        TIMEOUT_T42,
        /**
         * Timer T40 expired.
         */
        TIMEOUT_T40,
        /**
         * Service initialization failure.
         */
        SERVICE_INIT_FAILURE,
        /**
         * Timer T50 expired.
         */
        TIMEOUT_T50,
        /**
         * Timer T51 expired.
         */
        TIMEOUT_T51,
        /**
         * Acknowledgement timeout due to 12 retransmissions.
         */
        RL_ACK_TIMEOUT,
        /**
         * Bad forward link or timer T5M expired.
         */
        BAD_FORWARD_LINK,
        /**
         * Transceiver Resource Manager request failed.
         */
        TRM_REQUEST_FAILED,
        /**
         * Timer T41 expired.
         */
        TIMEOUT_T41,
        /**
         * GSM/WCDMA specific. Client rejected incoming call.
         */
        INCOMING_REJECTED,
        /**
         * GSM/WCDMA specific. Client rejected a setup indication.
         */
        SETUP_REJECTED,
        /**
         * GSM/WCDMA specific. Network ended the call.
         */
        NETWORK_END,
        /**
         * GSM/WCDMA specific. No funds.
         */
        NO_FUNDS,
        /**
         * GSM/WCDMA specific. Device has no service.
         */
        NO_GW_SERVICE,
        /**
         * CDMA specific. Device has no service.
         */
        NO_CDMA_SERVICE,
        /**
         * Full service is unavailable.
         */
        NO_FULL_SERVICE,
        /**
         * No resources available to handle a new MO/MT PS call.
         */
        MAX_PS_CALLS,
        /**
         * Unknown subscriber.
         */
        UNKNOWN_SUBSCRIBER,
        /**
         * Illegal subscriber.
         */
        ILLEGAL_SUBSCRIBER,
        /**
         * Bearer service not provisioned.
         */
        BEARER_SERVICE_NOT_PROVISIONED,
        /**
         * Tele service not provisioned.
         */
        TELE_SERVICE_NOT_PROVISIONED,
        /**
         * Illegal equipment.
         */
        ILLEGAL_EQUIPMENT,
        /**
         * Call barred.
         */
        CALL_BARRED,
        /**
         * Illegal SS operation.
         */
        ILLEGAL_SS_OPERATION,
        /**
         * Supplementary service error status.
         */
        SS_ERROR_STATUS,
        /**
         * Supplementary service not available.
         */
        SS_NOT_AVAILABLE,
        /**
         * Supplementary service subscription violation.
         */
        SS_SUBSCRIPTION_VIOLATION,
        /**
         * Supplementary service incompatibility.
         */
        SS_INCOMPATIBILITY,
        /**
         * Facility not supported.
         */
        FACILITY_NOT_SUPPORTED,
        /**
         * Absent subscriber.
         */
        ABSENT_SUBSCRIBER,
        /**
         * Short term denial.
         */
        SHORT_TERM_DENIAL,
        /**
         * Long term denial.
         */
        LONG_TERM_DENIAL,
        /**
         * System failure.
         */
        SYSTEM_FAILURE,
        /**
         * Data missing.
         */
        DATA_MISSING,
        /**
         * Unexpected data value.
         */
        UNEXPECTED_DATA_VALUE,
        /**
         * Password registration failure.
         */
        PASSWORD_REGISTRATION_FAILURE,
        /**
         * Negative password check.
         */
        NEGATIVE_PASSWORD_CHECK,
        /**
         * Number of password attempts violation.
         */
        NUM_OF_PASSWORD_ATTEMPTS_VIOLATION,
        /**
         * Position method failure.
         */
        POSITION_METHOD_FAILURE,
        /**
         * Unknown alphabet.
         */
        UNKNOWN_ALPHABET,
        /**
         * USSD busy.
         */
        USSD_BUSY,
        /**
         * Rejected by user.
         */
        REJECTED_BY_USER,
        /**
         * Rejected by network.
         */
        REJECTED_BY_NETWORK,
        /**
         * Deflection to served subscriber.
         */
        DEFLECTION_TO_SERVED_SUBSCRIBER,
        /**
         * Special service codde.
         */
        SPECIAL_SERVICE_CODE,
        /**
         * Invalid deflected to number.
         */
        INVALID_DEFLECTED_TO_NUMBER,
        /**
         * Multiparty participants exceeded.
         */
        MULTIPARTY_PARTICIPANTS_EXCEEDED,
        /**
         * Resources not available.
         */
        RESOURCES_NOT_AVAILABLE,
        /**
         * Unassigned number.
         */
        UNASSIGNED_NUMBER,
        /**
         * No route to destination.
         */
        NO_ROUTE_TO_DESTINATION,
        /**
         * Channel unacceptable.
         */
        CHANNEL_UNACCEPTABLE,
        /**
         * Operator determined barring.
         */
        OPERATOR_DETERMINED_BARRING,
        /**
         * Normal call clearing.
         */
        NORMAL_CALL_CLEARING,
        /**
         * User busy.
         */
        USER_BUSY,
        /**
         * No user responding.
         */
        NO_USER_RESPONDING,
        /**
         * User alerting no answer.
         */
        USER_ALERTING_NO_ANSWER,
        /**
         * Call rejected.
         */
        CALL_REJECTED,
        /**
         * Number changed.
         */
        NUMBER_CHANGED,
        /**
         * Preemption.
         */
        PREEMPTION,
        /**
         * Destination out of order.
         */
        DESTINATION_OUT_OF_ORDER,
        /**
         * Invalid number format.
         */
        INVALID_NUMBER_FORMAT,
        /**
         * Facility rejected.
         */
        FACILITY_REJECTED,
        /**
         * Response to status enquiry.
         */
        RESPONSE_TO_STATUS_ENQUIRY,
        /**
         * Normal unspecified.
         */
        NORMAL_UNSPECIFIED,
        /**
         * No circuit or channel available.
         */
        NO_CIRCUIT_OR_CHANNEL_AVAILABLE,
        /**
         * Network out of order.
         */
        NETWORK_OUT_OF_ORDER,
        /**
         * Temporary failure.
         */
        TEMPORARY_FAILURE,
        /**
         * Switching equipment congestion.
         */
        SWITCHING_EQUIPMENT_CONGESTION,
        /**
         * Access information discarded.
         */
        ACCESS_INFORMATION_DISCARDED,
        /**
         * Requested circuit or channel not available.
         */
        REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE,
        /**
         * Resources unavailable or unspecified.
         */
        RESOURCES_UNAVAILABLE_OR_UNSPECIFIED,
        /**
         * QoS unavailable.
         */
        QOS_UNAVAILABLE,
        /**
         * Requested facility not subscribed.
         */
        REQUESTED_FACILITY_NOT_SUBSCRIBED,
        /**
         * Incoming calls barred withing closed user group.
         */
        INCOMING_CALLS_BARRED_WITHIN_CUG,
        /**
         * Bearer capability not auth.
         */
        BEARER_CAPABILITY_NOT_AUTH,
        /**
         * Bearer capability unavailable.
         */
        BEARER_CAPABILITY_UNAVAILABLE,
        /**
         * Service option not available.
         */
        SERVICE_OPTION_NOT_AVAILABLE,
        /**
         * ACM limit exceeded.
         */
        ACM_LIMIT_EXCEEDED,
        /**
         * Bearer service not implemented.
         */
        BEARER_SERVICE_NOT_IMPLEMENTED,
        /**
         * Requested facility not implemented.
         */
        REQUESTED_FACILITY_NOT_IMPLEMENTED,
        /**
         * Only digital information bearer available.
         */
        ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE,
        /**
         * Service or option not implemented.
         */
        SERVICE_OR_OPTION_NOT_IMPLEMENTED,
        /**
         * Invalid transaction identifier.
         */
        INVALID_TRANSACTION_IDENTIFIER,
        /**
         * User not member of closed user group.
         */
        USER_NOT_MEMBER_OF_CUG,
        /**
         * Incompatible destination.
         */
        INCOMPATIBLE_DESTINATION,
        /**
         * Invalid transit network selection.
         */
        INVALID_TRANSIT_NETWORK_SELECTION,
        /**
         * Semantically incorrect message.
         */
        SEMANTICALLY_INCORRECT_MESSAGE,
        /**
         * Invalid mandatory information.
         */
        INVALID_MANDATORY_INFORMATION,
        /**
         * Message type not implemented.
         */
        MESSAGE_TYPE_NOT_IMPLEMENTED,
        /**
         * Message type not compatible with protocol state.
         */
        MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE,
        /**
         * Information element non existent.
         */
        INFORMATION_ELEMENT_NON_EXISTENT,
        /**
         * IE error.
         */
        CONDITIONAL_IE_ERROR,
        /**
         * Message not compatible with protocol state.
         */
        MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE,
        /**
         * Recovery on timer expired.
         */
        RECOVERY_ON_TIMER_EXPIRED,
        /**
         * Protocol error unspecified.
         */
        PROTOCOL_ERROR_UNSPECIFIED,
        /**
         * Interworking unspecified.
         */
        INTERWORKING_UNSPECIFIED,
        /**
         * Outgoing calls barred within closed user group.
         */
        OUTGOING_CALLS_BARRED_WITHIN_CUG,
        /**
         * No closed user group selection.
         */
        NO_CUG_SELECTION,
        /**
         * Unknown closed user group index.
         */
        UNKNOWN_CUG_INDEX,
        /**
         * Closed user group index incompatible.
         */
        CUG_INDEX_INCOMPATIBLE,
        /**
         * Closed user group call failure unspecified.
         */
        CUG_CALL_FAILURE_UNSPECIFIED,
        /**
         * Calling line identification restriction not subscribed.
         */
        CLIR_NOT_SUBSCRIBED,
        /**
         * Completion of communications to busy subscriber possible.
         */
        CCBS_POSSIBLE,
        /**
         * Completion of communications to busy subscriber not possible.
         */
        CCBS_NOT_POSSIBLE,
        /**
         * IMSI unknown in HLR.
         */
        IMSI_UNKNOWN_IN_HLR,
        /**
         * Illegal MS.
         */
        ILLEGAL_MS,
        /**
         * IMSI unknown in VLR.
         */
        IMSI_UNKNOWN_IN_VLR,
        /**
         * IMEI not accepted.
         */
        IMEI_NOT_ACCEPTED,
        /**
         * Illegal ME.
         */
        ILLEGAL_ME,
        /**
         * PLMN not allowed.
         */
        PLMN_NOT_ALLOWED,
        /**
         * Location area not allowed.
         */
        LOCATION_AREA_NOT_ALLOWED,
        /**
         * Roaming not allowed in this location area.
         */
        ROAMING_NOT_ALLOWED_IN_THIS_LOCATION_AREA,
        /**
         * No suitable cells in location area.
         */
        NO_SUITABLE_CELLS_IN_LOCATION_AREA,
        /**
         * Network failure.
         */
        NETWORK_FAILURE,
        /**
         * MAC failure.
         */
        MAC_FAILURE,
        /**
         * Synch failure.
         */
        SYNCH_FAILURE,
        /**
         * Network contestion.
         */
        NETWORK_CONGESTION,
        /**
         * GSM authentication unacceptable.
         */
        GSM_AUTHENTICATION_UNACCEPTABLE,
        /**
         * Service not subscribed.
         */
        SERVICE_NOT_SUBSCRIBED,
        /**
         * Service temporarily out of order.
         */
        SERVICE_TEMPORARILY_OUT_OF_ORDER,
        /**
         * Call cannot be identified.
         */
        CALL_CANNOT_BE_IDENTIFIED,
        /**
         * Incorrect semantics in message.
         */
        INCORRECT_SEMANTICS_IN_MESSAGE,
        /**
         * Mandatory information invalid.
         */
        MANDATORY_INFORMATION_INVALID,
        /**
         * Access stratum failure.
         */
        ACCESS_STRATUM_FAILURE,
        /**
         * Invalid SIM.
         */
        INVALID_SIM,
        /**
         * Wrong state.
         */
        WRONG_STATE,
        /**
         * Access class blocked.
         */
        ACCESS_CLASS_BLOCKED,
        /**
         * No resources.
         */
        NO_RESOURCES,
        /**
         * Invalid user data.
         */
        INVALID_USER_DATA,
        /**
         * Timer T3230 expired.
         */
        TIMER_T3230_EXPIRED,
        /**
         * No cell available.
         */
        NO_CELL_AVAILABLE,
        /**
         * Abort message received.
         */
        ABORT_MESSAGE_RECEIVED,
        /**
         * Radio link lost.
         */
        RADIO_LINK_LOST,
        /**
         * Timer T303 expired.
         */
        TIMER_T303_EXPIRED,
        /**
         * CNM MM release pending.
         */
        CNM_MM_RELEASE_PENDING,
        /**
         * Access stratum reject, RR release indication.
         */
        ACCESS_STRATUM_REJECT_RR_RELEASE_INDICATION,
        /**
         * Access stratum reject, RR random access failure.
         */
        ACCESS_STRATUM_REJECT_RR_RANDOM_ACCESS_FAILURE,
        /**
         * Access stratum reject, RRC release indication.
         */
        ACCESS_STRATUM_REJECT_RRC_RELEASE_INDICATION,
        /**
         * Access stratum reject, RRC close session indication.
         */
        ACCESS_STRATUM_REJECT_RRC_CLOSE_SESSION_INDICATION,
        /**
         * Access stratum reject, RRC open session failure.
         */
        ACCESS_STRATUM_REJECT_RRC_OPEN_SESSION_FAILURE,
        /**
         * Access stratum reject, low level failure.
         */
        ACCESS_STRATUM_REJECT_LOW_LEVEL_FAILURE,
        /**
         * Access stratum reject, low level failure redial not allowed.
         */
        ACCESS_STRATUM_REJECT_LOW_LEVEL_FAILURE_REDIAL_NOT_ALLOWED,
        /**
         * Access stratum reject, low level immediate retry.
         */
        ACCESS_STRATUM_REJECT_LOW_LEVEL_IMMEDIATE_RETRY,
        /**
         * Access stratum reject, abort radio unavailable.
         */
        ACCESS_STRATUM_REJECT_ABORT_RADIO_UNAVAILABLE,
        /**
         * Service option not supported.
         */
        SERVICE_OPTION_NOT_SUPPORTED,
        /**
         * Bad request wait invite.
         */
        BAD_REQUEST_WAIT_INVITE,
        /**
         * Bad request wait reinvite.
         */
        BAD_REQUEST_WAIT_REINVITE,
        /**
         * Invalid remote URI.
         */
        INVALID_REMOTE_URI,
        /**
         * Remote unsupported media type.
         */
        REMOTE_UNSUPPORTED_MEDIA_TYPE,
        /**
         * Peer not reachable.
         */
        PEER_NOT_REACHABLE,
        /**
         * Network no response, timeout.
         */
        NETWORK_NO_RESPONSE_TIMEOUT,
        /**
         * Network no response, hold failure.
         */
        NETWORK_NO_RESPONSE_HOLD_FAILURE,
        /**
         * Data connection lost.
         */
        DATA_CONNECTION_LOST,
        /**
         * Upgrade/downgrade rejected.
         */
        UPGRADE_DOWNGRADE_REJECTED,
        /**
         * SIP 403 forbidden.
         */
        SIP_403_FORBIDDEN,
        /**
         * No network response.
         */
        NO_NETWORK_RESPONSE,
        /**
         * Upgrade/downgrade failed.
         */
        UPGRADE_DOWNGRADE_FAILED,
        /**
         * Upgrade/downgrade cancelled.
         */
        UPGRADE_DOWNGRADE_CANCELLED,
        /**
         * Service specific access control reject.
         */
        SSAC_REJECT,
        /**
         * Thermal emergency.
         */
        THERMAL_EMERGENCY,
        /**
         * 1xCSFG soft failure.
         */
        '1XCSFB_SOFT_FAILURE',
        /**
         * 1xCSFG hard failure.
         */
        '1XCSFB_HARD_FAILURE',
    }
    /**
     * Call mode.
     */

    /**
     * Call mode.
     */
    export namespace VoiceCallMode {
        export const $gtype: GObject.GType<VoiceCallMode>;
    }

    enum VoiceCallMode {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * CDMA.
         */
        CDMA,
        /**
         * GSM.
         */
        GSM,
        /**
         * UMTS.
         */
        UMTS,
        /**
         * LTE.
         */
        LTE,
    }
    /**
     * State of a call.
     */

    /**
     * State of a call.
     */
    export namespace VoiceCallState {
        export const $gtype: GObject.GType<VoiceCallState>;
    }

    enum VoiceCallState {
        /**
         * Unknown state.
         */
        UNKNOWN,
        /**
         * Call is being originated.
         */
        ORIGINATION,
        /**
         * Incoming call.
         */
        INCOMING,
        /**
         * Call is in progress.
         */
        CONVERSATION,
        /**
         * Call is originating but waiting for call control to complete.
         */
        CC_IN_PROGRESS,
        /**
         * Alerting.
         */
        ALERTING,
        /**
         * On hold.
         */
        HOLD,
        /**
         * Waiting.
         */
        WAITING,
        /**
         * Disconnecting.
         */
        DISCONNECTING,
        /**
         * Call is finished.
         */
        END,
        /**
         * 3GPP specific. MT call is in setup state.
         */
        SETUP,
    }
    /**
     * Type of a voice call.
     */

    /**
     * Type of a voice call.
     */
    export namespace VoiceCallType {
        export const $gtype: GObject.GType<VoiceCallType>;
    }

    enum VoiceCallType {
        /**
         * Voice call.
         */
        VOICE,
        /**
         * VoIP call.
         */
        VOICE_IP,
        /**
         * OTAPA.
         */
        OTAPA,
        /**
         * Non-standard OTASP.
         */
        NON_STD_OTASP,
        /**
         * Emergency call.
         */
        EMERGENCY,
        /**
         * Supplementary service.
         */
        SUPS,
    }
    /**
     * Voice domain preference.
     */

    /**
     * Voice domain preference.
     */
    export namespace VoiceDomain {
        export const $gtype: GObject.GType<VoiceDomain>;
    }

    enum VoiceDomain {
        /**
         * CS-only.
         */
        CS_ONLY,
        /**
         * PS-only.
         */
        PS_ONLY,
        /**
         * CS preferred, PS secondary.
         */
        CS_PREFERRED,
        /**
         * PS preferred, CS secondary.
         */
        PS_PREFERRED,
    }
    /**
     * Remote party number presentation indicator.
     */

    /**
     * Remote party number presentation indicator.
     */
    export namespace VoicePresentation {
        export const $gtype: GObject.GType<VoicePresentation>;
    }

    enum VoicePresentation {
        /**
         * Allowed presentation.
         */
        ALLOWED,
        /**
         * Restricted presentation.
         */
        RESTRICTED,
        /**
         * Unavailable presentation.
         */
        UNAVAILABLE,
        /**
         * 3GPP specific. Payphone presentation.
         */
        PAYPHONE,
    }
    /**
     * Voice privacy.
     */

    /**
     * Voice privacy.
     */
    export namespace VoicePrivacy {
        export const $gtype: GObject.GType<VoicePrivacy>;
    }

    enum VoicePrivacy {
        /**
         * Standard.
         */
        STANDARD,
        /**
         * Enhanced.
         */
        ENHANCED,
    }
    /**
     * Service option.
     */

    /**
     * Service option.
     */
    export namespace VoiceServiceOption {
        export const $gtype: GObject.GType<VoiceServiceOption>;
    }

    enum VoiceServiceOption {
        /**
         * Any service option.
         */
        WILD,
        /**
         * IS-96A.
         */
        IS_96A,
        /**
         * EVRC.
         */
        EVRC,
        /**
         * IS733.
         */
        '13K_IS733',
        /**
         * Selectable mode vocoder.
         */
        SELECTABLE_MODE_VOCODER,
        /**
         * 4GV narrowband.
         */
        '4GV_NARROW_BAND',
        /**
         * 4GV wideband.
         */
        '4GV_WIDE_BAND',
        /**
         * 13K.
         */
        '13K',
        /**
         * IS-96.
         */
        IS_96,
        /**
         * WVRC.
         */
        WVRC,
    }
    /**
     * Supplementary service action.
     */

    /**
     * Supplementary service action.
     */
    export namespace VoiceSupplementaryServiceAction {
        export const $gtype: GObject.GType<VoiceSupplementaryServiceAction>;
    }

    enum VoiceSupplementaryServiceAction {
        /**
         * Activate supplementary service.
         */
        ACTIVATE,
        /**
         * De-activate supplementary service.
         */
        DEACTIVATE,
        /**
         * Register supplementary service.
         */
        REGISTER,
        /**
         * Erase/Un-register supplementary service.
         */
        ERASE,
    }
    /**
     * Supplementary service notification type.
     */

    /**
     * Supplementary service notification type.
     */
    export namespace VoiceSupplementaryServiceNotificationType {
        export const $gtype: GObject.GType<VoiceSupplementaryServiceNotificationType>;
    }

    enum VoiceSupplementaryServiceNotificationType {
        /**
         * Outgoing call is forward.
         */
        OUTGOING_CALL_IS_FORWARDED,
        /**
         * Outgoing call is waiting.
         */
        OUTGOING_CALL_IS_WAITING,
        /**
         * Outgoing CUG call.
         */
        OUTGOING_CUG_CALL,
        /**
         * All outgoing calls are barred.
         */
        OUTGOING_CALLS_BARRED,
        /**
         * Outgoing call is deflected.
         */
        OUTGOING_CALL_IS_DEFLECTED,
        /**
         * Incoming CUG call.
         */
        INCOMING_CUG_CALL,
        /**
         * All incoming calls are barred.
         */
        INCOMING_CALLS_BARRED,
        /**
         * Incoming forwarded call.
         */
        INCOMING_FORWARDED_CALL,
        /**
         * Incoming deflected call.
         */
        INCOMING_DEFLECTED_CALL,
        /**
         * Incoming call is forwarded.
         */
        INCOMING_CALL_IS_FORWARDED,
        /**
         * Unconditional call forward is active.
         */
        UNCONDITIONAL_CALL_FORWARD_ACTIVE,
        /**
         * Conditional call forward is active.
         */
        CONDITIONAL_CALL_FORWARD_ACTIVE,
        /**
         * CLIR suppression is rejected.
         */
        CLIR_SUPPRESSION_REJECTED,
        /**
         * Call is on hold.
         */
        CALL_IS_ON_HOLD,
        /**
         * Call is retrieved.
         */
        CALL_IS_RETRIEVED,
        /**
         * Call is in multiparty.
         */
        CALL_IS_IN_MULTIPARTY,
        /**
         * Incoming call is ECT.
         */
        INCOMING_CALL_IS_ECT,
    }
    /**
     * Supplementary service reason.
     */

    /**
     * Supplementary service reason.
     */
    export namespace VoiceSupplementaryServiceReason {
        export const $gtype: GObject.GType<VoiceSupplementaryServiceReason>;
    }

    enum VoiceSupplementaryServiceReason {
        /**
         * Unconditional call forward.
         */
        FORWARD_UNCONDITIONAL,
        /**
         * Forward when mobile is busy.
         */
        FORWARD_MOBILE_BUSY,
        /**
         * Forward when no reply.
         */
        FORWARD_NO_REPLY,
        /**
         * Forward when call is unreachable.
         */
        FORWARD_UNREACHABLE,
        /**
         * Forward all calls.
         */
        FORWARD_ALL,
        /**
         * Forward all calls conditionally.
         */
        FORWARD_ALL_CONDITIONAL,
        /**
         * All outgoing.
         */
        ALL_OUTGOING,
        /**
         * Outgoing Internal.
         */
        OUTGOING_INTERNAL,
        /**
         * Outgoing internal/external to home.
         */
        OUTGOING_INTERNAL_EXTERNAL_TO_HOME,
        /**
         * All incoming.
         */
        ALL_INCOMING,
        /**
         * Roaming incoming.
         */
        INCOMING_ROAMING,
        /**
         * All calls are barred.
         */
        BAR_ALL,
        /**
         * All outgoing calls are barred.
         */
        BAR_ALL_OUTGOING,
        /**
         * All incoming calls are barred.
         */
        BAR_ALL_INCOMING,
        /**
         * Call waiting.
         */
        CALL_WAITING,
    }
    /**
     * Supplementary service type during call.
     */

    /**
     * Supplementary service type during call.
     */
    export namespace VoiceSupplementaryServiceType {
        export const $gtype: GObject.GType<VoiceSupplementaryServiceType>;
    }

    enum VoiceSupplementaryServiceType {
        /**
         * Release held or waiting call.
         */
        RELEASE_HELD_OR_WAITING,
        /**
         * Release active call and accept held or waiting call.
         */
        RELEASE_ACTIVE_ACCEPT_HELD_OR_WAITING,
        /**
         * Hold active call and accept held or waiting call.
         */
        HOLD_ACTIVE_ACCEPT_WAITING_OR_HELD,
        /**
         * Hold all calls except specified call.
         */
        HOLD_ALL_EXCEPT_SPECIFIED_CALL,
        /**
         * Create conference call.
         */
        MAKE_CONFERENCE_CALL,
        /**
         * Explicit call transfer.
         */
        EXPLICIT_CALL_TRANSFER,
        /**
         * Activate completion of calls to busy subscriber.
         */
        CCBS_ACTIVATION,
        /**
         * End all calls.
         */
        END_ALL_CALLS,
        /**
         * Release a specified call.
         */
        RELEASE_SPECIFIED_CALL,
        /**
         * Put all active calls to hold.
         */
        LOCAL_HOLD,
        /**
         * Unhold all held calls.
         */
        LOCAL_UNHOLD,
    }
    /**
     * TTY mode.
     */

    /**
     * TTY mode.
     */
    export namespace VoiceTtyMode {
        export const $gtype: GObject.GType<VoiceTtyMode>;
    }

    enum VoiceTtyMode {
        /**
         * Full.
         */
        FULL,
        /**
         * Voice carry over.
         */
        VCO,
        /**
         * Hearing carry over.
         */
        HCO,
        /**
         * Off.
         */
        OFF,
    }
    /**
     * User action type.
     */

    /**
     * User action type.
     */
    export namespace VoiceUserAction {
        export const $gtype: GObject.GType<VoiceUserAction>;
    }

    enum VoiceUserAction {
        /**
         * Unknown user action.
         */
        UNKNOWN,
        /**
         * User is not required to respond to the USSD code.
         */
        NOT_REQUIRED,
        /**
         * User is required to respond to the USSD code.
         */
        REQUIRED,
    }
    /**
     * Data Coding Scheme used in USSD operations.
     */

    /**
     * Data Coding Scheme used in USSD operations.
     */
    export namespace VoiceUssDataCodingScheme {
        export const $gtype: GObject.GType<VoiceUssDataCodingScheme>;
    }

    enum VoiceUssDataCodingScheme {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * ASCII coding scheme.
         */
        ASCII,
        /**
         * 8-bit coding scheme.
         */
        '8BIT',
        /**
         * UCS2.
         */
        UCS2,
    }
    /**
     * Data aggregation protocol in uplink or downlink.
     */

    /**
     * Data aggregation protocol in uplink or downlink.
     */
    export namespace WdaDataAggregationProtocol {
        export const $gtype: GObject.GType<WdaDataAggregationProtocol>;
    }

    enum WdaDataAggregationProtocol {
        /**
         * Disabled.
         */
        DISABLED,
        /**
         * TLP enabled.
         */
        TLP,
        /**
         * QC NCM enabled.
         */
        QC_NCM,
        /**
         * MBIM enabled.
         */
        MBIM,
        /**
         * RNDIS enabled.
         */
        RNDIS,
        /**
         * QMAP enabled.
         */
        QMAP,
        /**
         * QMAPV2 enabled. Since: 1.30.
         */
        QMAPV2,
        /**
         * QMAPV3 enabled. Since: 1.30.
         */
        QMAPV3,
        /**
         * QMAPV4 enabled. Since: 1.30.
         */
        QMAPV4,
        /**
         * QMAPV5 enabled. Since: 1.28.
         */
        QMAPV5,
    }
    /**
     * Link layer protocol.
     */

    /**
     * Link layer protocol.
     */
    export namespace WdaLinkLayerProtocol {
        export const $gtype: GObject.GType<WdaLinkLayerProtocol>;
    }

    enum WdaLinkLayerProtocol {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * 802.3 ethernet mode.
         */
        '802_3',
        /**
         * Raw IP mode.
         */
        RAW_IP,
    }
    /**
     * Action when setting the attach PDN list.
     */

    /**
     * Action when setting the attach PDN list.
     */
    export namespace WdsAttachPdnListAction {
        export const $gtype: GObject.GType<WdsAttachPdnListAction>;
    }

    enum WdsAttachPdnListAction {
        /**
         * No action (default)
         */
        NONE,
        /**
         * PS detach or PDN disconnect based on the modem configuration
         */
        DETACH_OR_PDN_DISCONNECT,
    }
    /**
     * Status of the autoconnect setting.
     */

    /**
     * Status of the autoconnect setting.
     */
    export namespace WdsAutoconnectSetting {
        export const $gtype: GObject.GType<WdsAutoconnectSetting>;
    }

    enum WdsAutoconnectSetting {
        /**
         * Disabled.
         */
        DISABLED,
        /**
         * Enabled.
         */
        ENABLED,
        /**
         * Paused, resume on power cycle.
         */
        PAUSED,
    }
    /**
     * Status of the autoconnect setting while roaming.
     */

    /**
     * Status of the autoconnect setting while roaming.
     */
    export namespace WdsAutoconnectSettingRoaming {
        export const $gtype: GObject.GType<WdsAutoconnectSettingRoaming>;
    }

    enum WdsAutoconnectSettingRoaming {
        /**
         * Autoconnect always allowed, even when roaming.
         */
        ALLOWED,
        /**
         * Autoconnect allowed only in home network.
         */
        HOME_ONLY,
    }
    /**
     * Reason for ending the call.
     */

    /**
     * Reason for ending the call.
     */
    export namespace WdsCallEndReason {
        export const $gtype: GObject.GType<WdsCallEndReason>;
    }

    enum WdsCallEndReason {
        /**
         * Unspecified reason.
         */
        GENERIC_UNSPECIFIED,
        /**
         * Client end.
         */
        GENERIC_CLIENT_END,
        /**
         * No service.
         */
        GENERIC_NO_SERVICE,
        /**
         * Fade.
         */
        GENERIC_FADE,
        /**
         * Release normal.
         */
        GENERIC_RELEASE_NORMAL,
        /**
         * Access attempt in progress.
         */
        GENERIC_ACCESS_ATTEMPT_IN_PROGRESS,
        /**
         * Access Failure.
         */
        GENERIC_ACCESS_FAILURE,
        /**
         * Redirection or handoff.
         */
        GENERIC_REDIRECTION_OR_HANDOFF,
        /**
         * Close in progress.
         */
        GENERIC_CLOSE_IN_PROGRESS,
        /**
         * Authentication failed.
         */
        GENERIC_AUTHENTICATION_FAILED,
        /**
         * Internal error.
         */
        GENERIC_INTERNAL_ERROR,
        /**
         * CDMA specific. Phone is CDMA-locked.
         */
        CDMA_LOCK,
        /**
         * CDMA specific. Received intercept from the BS.
         */
        CDMA_INTERCEPT,
        /**
         * CDMA specific. Received reorder from the BS.
         */
        CDMA_REORDER,
        /**
         * CDMA specific. Received release from the BS, SO reject.
         */
        CDMA_RELEASE_SO_REJECT,
        /**
         * CDMA specific. Received incoming call from the BS.
         */
        CDMA_INCOMING_CALL,
        /**
         * CDMA specific. Received alert stop from the BS.
         */
        CDMA_ALERT_STOP,
        /**
         * CDMA specific. Received end activation.
         */
        CDMA_ACTIVATION,
        /**
         * CDMA specific. Maximum access probes transmitted.
         */
        CDMA_MAX_ACCESS_PROBES,
        /**
         * CDMA specific. Concurrent service not supported by the BS.
         */
        CDMA_CCS_NOT_SUPPORTED_BY_BS,
        /**
         * CDMA specific. No response received from the BS.
         */
        CDMA_NO_RESPONSE_FROM_BS,
        /**
         * CDMA specific. Rejected by the BS.
         */
        CDMA_REJECTED_BY_BS,
        /**
         * CDMA specific. Concurrent services requested are incompatible.
         */
        CDMA_INCOMPATIBLE,
        /**
         * CDMA specific. Already in TC.
         */
        CDMA_ALREADY_IN_TC,
        /**
         * CDMA specific. Call originated during GPS.
         */
        CDMA_USER_CALL_ORIGINATED_DURING_GPS,
        /**
         * CDMA specific. Call originated during SMS.
         */
        CDMA_USER_CALL_ORIGINATED_DURING_SMS,
        /**
         * CDMA specific. No service.
         */
        CDMA_NO_SERVICE,
        /**
         * GSM/WCDMA specific. Call origination request failed.
         */
        GSM_WCDMA_CONFERENCE_FAILED,
        /**
         * GSM/WCDMA specific. Client rejected incoming call.
         */
        GSM_WCDMA_INCOMING_REJECTED,
        /**
         * GSM/WCDMA specific. No service.
         */
        GSM_WCDMA_NO_SERVICE,
        /**
         * GSM/WCDMA specific. Network ended the call.
         */
        GSM_WCDMA_NETWORK_END,
        /**
         * GSM/WCDMA specific. LLC or SNDCP failure.
         */
        GSM_WCDMA_LLC_SNDCP_FAILURE,
        /**
         * GSM/WCDMA specific. Insufficient resources.
         */
        GSM_WCDMA_INSUFFICIENT_RESOURCES,
        /**
         * GSM/WCDMA specific. Service option temporarily out of order.
         */
        GSM_WCDMA_OPTION_TEMPORARILY_OUT_OF_ORDER,
        /**
         * GSM/WCDMA specific. NSAPI already used.
         */
        GSM_WCDMA_NSAPI_ALREADY_USED,
        /**
         * GSM/WCDMA specific. Regular PDP context deactivation.
         */
        GSM_WCDMA_REGULAR_DEACTIVATION,
        /**
         * GSM/WCDMA specific. Network failure.
         */
        GSM_WCDMA_NETWORK_FAILURE,
        /**
         * GSM/WCDMA specific. Reattach required.
         */
        GSM_WCDMA_REATTACH_REQUIRED,
        /**
         * GSM/WCDMA specific. Protocol error.
         */
        GSM_WCDMA_PROTOCOL_ERROR,
        /**
         * GSM/WCDMA specific. Operator-determined barring.
         */
        GSM_WCDMA_OPERATOR_DETERMINED_BARRING,
        /**
         * GSM/WCDMA specific. Unknown or missing APN.
         */
        GSM_WCDMA_UNKNOWN_APN,
        /**
         * GSM/WCDMA specific. Unknown PDP address or type.
         */
        GSM_WCDMA_UNKNOWN_PDP,
        /**
         * GSM/WCDMA specific. Activation rejected by GGSN.
         */
        GSM_WCDMA_GGSN_REJECT,
        /**
         * GSM/WCDMA specific. Activation rejected.
         */
        GSM_WCDMA_ACTIVATION_REJECT,
        /**
         * GSM/WCDMA specific. Service option not supported.
         */
        GSM_WCDMA_OPTION_NOT_SUPPORTED,
        /**
         * GSM/WCDMA specific. Service option not subscribed.
         */
        GSM_WCDMA_OPTION_UNSUBSCRIBED,
        /**
         * GSM/WCDMA specific. QoS not accepted.
         */
        GSM_WCDMA_QOS_NOT_ACCEPTED,
        /**
         * GSM/WCDMA specific. Semantic error in TFT operation.
         */
        GSM_WCDMA_TFT_SEMANTIC_ERROR,
        /**
         * GSM/WCDMA specific. Syntax error in TFT operation.
         */
        GSM_WCDMA_TFT_SYNTAX_ERROR,
        /**
         * GSM/WCDMA specific. Unknown PDP context.
         */
        GSM_WCDMA_UNKNOWN_PDP_CONTEXT,
        /**
         * GSM/WCDMA specific. Semantic error in packet filters.
         */
        GSM_WCDMA_FILTER_SEMANTIC_ERROR,
        /**
         * GSM/WCDMA specific. Syntax error in packet filters.
         */
        GSM_WCDMA_FILTER_SYNTAX_ERROR,
        /**
         * GSM/WCDMA specific. PDP context without TFT activated.
         */
        GSM_WCDMA_PDP_WITHOUT_ACTIVE_TFT,
        /**
         * GSM/WCDMA specific. Invalid transaction ID.
         */
        GSM_WCDMA_INVALID_TRANSACTION_ID,
        /**
         * GSM/WCDMA specific. Message incorrect semantically.
         */
        GSM_WCDMA_MESSAGE_INCORRECT_SEMANTIC,
        /**
         * GSM/WCDMA specific. Invalid mandatory information.
         */
        GSM_WCDMA_INVALID_MANDATORY_INFO,
        /**
         * GSM/WCDMA specific. Message type not implemented.
         */
        GSM_WCDMA_MESSAGE_TYPE_UNSUPPORTED,
        /**
         * GSM/WCDMA specific. Message not compatible with state.
         */
        GSM_WCDMA_MESSAGE_TYPE_NONCOMPATIBLE_STATE,
        /**
         * GSM/WCDMA specific. Information element unknown.
         */
        GSM_WCDMA_UNKNOWN_INFO_ELEMENT,
        /**
         * GSM/WCDMA specific. Conditional IE error.
         */
        GSM_WCDMA_CONDITIONAL_IE_ERROR,
        /**
         * GSM/WCDMA specific. Message and protocol state uncompatible.
         */
        GSM_WCDMA_MESSAGE_AND_PROTOCOL_STATE_UNCOMPATIBLE,
        /**
         * GSM/WCDMA specific. APN type conflict.
         */
        GSM_WCDMA_APN_TYPE_CONFLICT,
        /**
         * GSM/WCDMA specific. No GPRS context.
         */
        GSM_WCDMA_NO_GPRS_CONTEXT,
        /**
         * GSM/WCDMA specific. Feature not supported.
         */
        GSM_WCDMA_FEATURE_NOT_SUPPORTED,
        /**
         * CDMA/EVDO specific. Received Connection Deny: General or Network busy.
         */
        EVDO_CONNECTION_DENY_GENERAL_OR_BUSY,
        /**
         * CDMA/EVDO specific. Received Connection Deny: Billing or Authentication failure.
         */
        EVDO_CONNECTION_DENY_BILLING_OR_AUTHENTICATION_FAILURE,
        /**
         * CDMA/EVDO specific. Change HDR.
         */
        EVDO_HDR_CHANGE,
        /**
         * CDMA/EVDO specific. Exit HDR.
         */
        EVDO_HDR_EXIT,
        /**
         * CDMA/EVDO specific. No HDR session.
         */
        EVDO_HDR_NO_SESSION,
        /**
         * CDMA/EVDO specific. HDR call ended in favor of a GPS fix.
         */
        EVDO_HDR_ORIGINATION_DURING_GPS_FIX,
        /**
         * CDMA/EVDO specific. Connection setup timeout.
         */
        EVDO_HDR_CONNECTION_SETUP_TIMEOUT,
        /**
         * CDMA/EVDO specific. Released HDR call by call manager.
         */
        EVDO_HDR_RELEASED_BY_CM,
    }
    /**
     * Type of call to originate.
     */

    /**
     * Type of call to originate.
     */
    export namespace WdsCallType {
        export const $gtype: GObject.GType<WdsCallType>;
    }

    enum WdsCallType {
        /**
         * Laptop call.
         */
        LAPTOP,
        /**
         * Embedded call.
         */
        EMBEDDED,
    }
    /**
     * Client Type
     */

    /**
     * Client Type
     */
    export namespace WdsClientType {
        export const $gtype: GObject.GType<WdsClientType>;
    }

    enum WdsClientType {
        /**
         * client type tethered
         */
        TETHERED,
        /**
         * no client type defined
         */
        UNDEFINED,
    }
    /**
     * Status of the network connection.
     */

    /**
     * Status of the network connection.
     */
    export namespace WdsConnectionStatus {
        export const $gtype: GObject.GType<WdsConnectionStatus>;
    }

    enum WdsConnectionStatus {
        /**
         * Unknown status.
         */
        UNKNOWN,
        /**
         * Network is disconnected
         */
        DISCONNECTED,
        /**
         * Network is connected.
         */
        CONNECTED,
        /**
         * Network connection is suspended.
         */
        SUSPENDED,
        /**
         * Network authentication is ongoing.
         */
        AUTHENTICATING,
    }
    /**
     * Data bearer technology.
     */

    /**
     * Data bearer technology.
     */
    export namespace WdsDataBearerTechnology {
        export const $gtype: GObject.GType<WdsDataBearerTechnology>;
    }

    enum WdsDataBearerTechnology {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * CDMA2000 1x.
         */
        CDMA20001X,
        /**
         * CDMA2000 HRPD 1xEVDO.
         */
        '1XEVDO',
        /**
         * GSM.
         */
        GSM,
        /**
         * UMTS.
         */
        UMTS,
        /**
         * CDMA2000 HRPD 1xEVDO RevA.
         */
        '1XEVDO_REVA',
        /**
         * EDGE.
         */
        EDGE,
        /**
         * HSDPA and WCDMA.
         */
        HSDPA,
        /**
         * WCDMA and HSUPA.
         */
        HSUPA,
        /**
         * HSDPA and HSUPA.
         */
        HSDPA_HSUPDA,
        /**
         * LTE.
         */
        LTE,
        /**
         * CDMA2000 eHRPD.
         */
        EHRPD,
        /**
         * HSDPA+ and WCDMA.
         */
        HSDPAPLUS,
        /**
         * HSDPA+ and HSUPA.
         */
        HSDPAPLUS_HSUPA,
        /**
         * DC-HSDPA+ and WCDMA.
         */
        DCHSDPAPLUS,
        /**
         * DC-HSDPA+ and HSUPA.
         */
        DCHSDPAPLUS_HSUPA,
        /**
         * HSDPA+ with 64QAM. Since: 1.18.
         */
        HSDPAPLUS_PLUS_64QAM,
        /**
         * HSDPA+ with 64QAM and HSUPA. Since: 1.18.
         */
        HSDPAPLUS_PLUS_64QAM_HSUPA,
        /**
         * TD-SCDMA. Since: 1.18.
         */
        TDSCDMA,
        /**
         * TD-SCDMA and HSDPA. Since: 1.18.
         */
        TDSCDMA_HSDPA,
        /**
         * TD-SCDMA and HSUPA. Since: 1.18.
         */
        TDSCDMA_HSUPA,
    }
    /**
     * Data call status.
     */

    /**
     * Data call status.
     */
    export namespace WdsDataCallStatus {
        export const $gtype: GObject.GType<WdsDataCallStatus>;
    }

    enum WdsDataCallStatus {
        /**
         * data call status unknown.
         */
        UNKNOWN,
        /**
         * data call status activated.
         */
        ACTIVATED,
        /**
         * data call status terminated.
         */
        TERMINATED,
    }
    /**
     * Data call type.
     */

    /**
     * Data call type.
     */
    export namespace WdsDataCallType {
        export const $gtype: GObject.GType<WdsDataCallType>;
    }

    enum WdsDataCallType {
        /**
         * data call type unknown.
         */
        UNKNOWN,
        /**
         * embedded data call.
         */
        EMBEDDED,
        /**
         * tethered data call.
         */
        TETHERED,
        /**
         * modem embedded data call.
         */
        MODEM_EMBEDDED,
    }
    /**
     * Data system type.
     */

    /**
     * Data system type.
     */
    export namespace WdsDataSystem {
        export const $gtype: GObject.GType<WdsDataSystem>;
    }

    enum WdsDataSystem {
        /**
         * unknown
         */
        UNKNOWN,
        /**
         * CDMA 1x
         */
        CDMA1X,
        /**
         * CDMA 1x EVDO
         */
        CDMA1X_EVDO,
        /**
         * GPRS
         */
        GPRS,
        /**
         * WCDMA
         */
        WCDMA,
        /**
         * LTE
         */
        LTE,
        /**
         * TD-SCDMA.
         */
        TDSCDMA,
    }
    /**
     * Network type of the data system.
     */

    /**
     * Network type of the data system.
     */
    export namespace WdsDataSystemNetworkType {
        export const $gtype: GObject.GType<WdsDataSystemNetworkType>;
    }

    enum WdsDataSystemNetworkType {
        /**
         * 3GPP network type.
         */
        '3GPP',
        /**
         * 3GPP2 network type.
         */
        '3GPP2',
    }
    /**
     * QoS delivery order.
     */

    /**
     * QoS delivery order.
     */
    export namespace WdsDeliveryOrder {
        export const $gtype: GObject.GType<WdsDeliveryOrder>;
    }

    enum WdsDeliveryOrder {
        /**
         * Subscribe.
         */
        SUBSCRIBE,
        /**
         * On.
         */
        ON,
        /**
         * Off.
         */
        OFF,
    }
    /**
     * Dormancy status.
     */

    /**
     * Dormancy status.
     */
    export namespace WdsDormancyStatus {
        export const $gtype: GObject.GType<WdsDormancyStatus>;
    }

    enum WdsDormancyStatus {
        /**
         * dormancy status unknown.
         */
        UNKNOWN,
        /**
         * traffic channel is dormant.
         */
        TRAFFIC_CHANNEL_DORMANT,
        /**
         * traffic channel is active.
         */
        TRAFFIC_CHANNEL_ACTIVE,
    }
    /**
     * Extended DS profile errors.
     */

    /**
     * Extended DS profile errors.
     */
    export namespace WdsDsProfileError {
        export const $gtype: GObject.GType<WdsDsProfileError>;
    }

    enum WdsDsProfileError {
        /**
         * Unknown DS profile error.
         */
        UNKNOWN,
        /**
         * General failure.
         */
        FAIL,
        /**
         * Invalid handle.
         */
        INVALID_HANDLE,
        /**
         * Invalid operation.
         */
        INVALID_OPERATION,
        /**
         * Invalid profile type.
         */
        INVALID_PROFILE_TYPE,
        /**
         * Invalid profile number.
         */
        INVALID_PROFILE_NUMBER,
        /**
         * Invalid profile identifier.
         */
        INVALID_PROFILE_ID,
        /**
         * Invalid argument.
         */
        INVALID_ARGUMENT,
        /**
         * Registry not initialized.
         */
        REGISTRY_NOT_INITIALIZED,
        /**
         * Invalid parameter length.
         */
        INVALID_PARAMETER_LENGTH,
        /**
         * List end, profile not found.
         */
        LIST_END,
        /**
         * Invalid subscription identifier.
         */
        INVALID_SUBSCRIPTION_ID,
        /**
         * Invalid profile family.
         */
        INVALID_PROFILE_FAMILY,
        /**
         * Invalid 3GPP profile family.
         */
        '3GPP_INVALID_PROFILE_FAMILY',
        /**
         * Error accessing 3GPP profiles.
         */
        '3GPP_ACCESS_ERROR',
        /**
         * 3GPP profile doesn't have a valid context.
         */
        '3GPP_CONTEXT_NOT_DEFINED',
        /**
         * 3GPP profile doesn't have valid flag set.
         */
        '3GPP_VALID_FLAG_NOT_SET',
        /**
         * 3GPP profile has read-only flag set.
         */
        '3GPP_READ_ONLY_FLAG_SET',
        /**
         * Out of 3GPP profiles.
         */
        '3GPP_OUT_OF_PROFILES',
        /**
         * Invalid 3GPP2 profile identifier.
         */
        '3GPP2_INVALID_PROFILE_ID',
    }
    /**
     * Type of network allowed when trying to connect.
     */

    /**
     * Type of network allowed when trying to connect.
     */
    export namespace WdsExtendedTechnologyPreference {
        export const $gtype: GObject.GType<WdsExtendedTechnologyPreference>;
    }

    enum WdsExtendedTechnologyPreference {
        /**
         * Use CDMA.
         */
        CDMA,
        /**
         * Use UMTS.
         */
        UMTS,
        /**
         * Use EPC, LTE.
         */
        EPC,
        /**
         * Use eMBMS.
         */
        EMBMS,
        /**
         * Use modem link-local.
         */
        MODEM_LINK_LOCAL,
    }
    /**
     * Type of IP family.
     */

    /**
     * Type of IP family.
     */
    export namespace WdsIpFamily {
        export const $gtype: GObject.GType<WdsIpFamily>;
    }

    enum WdsIpFamily {
        /**
         * unknown. Since: 1.18.
         */
        UNKNOWN,
        /**
         * IPv4.
         */
        IPV4,
        /**
         * IPv6.
         */
        IPV6,
        /**
         * None specified.
         */
        UNSPECIFIED,
    }
    /**
     * IP support type.
     */

    /**
     * IP support type.
     */
    export namespace WdsIpSupportType {
        export const $gtype: GObject.GType<WdsIpSupportType>;
    }

    enum WdsIpSupportType {
        /**
         * IPv4 type.
         */
        IPV4,
        /**
         * IPv6 type.
         */
        IPV6,
        /**
         * IPv4v6 type.
         */
        IPV4V6,
    }
    /**
     * Network type of the data bearer.
     */

    /**
     * Network type of the data bearer.
     */
    export namespace WdsNetworkType {
        export const $gtype: GObject.GType<WdsNetworkType>;
    }

    enum WdsNetworkType {
        /**
         * Unknown.
         */
        UNKNOWN,
        /**
         * 3GPP2 network type.
         */
        '3GPP2',
        /**
         * 3GPP network type.
         */
        '3GPP',
    }
    /**
     * PDP data compression types.
     */

    /**
     * PDP data compression types.
     */
    export namespace WdsPdpDataCompressionType {
        export const $gtype: GObject.GType<WdsPdpDataCompressionType>;
    }

    enum WdsPdpDataCompressionType {
        /**
         * no data compression
         */
        OFF,
        /**
         * manufacturer preferred
         */
        MANUFACTURER_PREFERRED,
        /**
         * V42bis
         */
        V42BIS,
        /**
         * V44
         */
        V44,
    }
    /**
     * PDP header compression types.
     */

    /**
     * PDP header compression types.
     */
    export namespace WdsPdpHeaderCompressionType {
        export const $gtype: GObject.GType<WdsPdpHeaderCompressionType>;
    }

    enum WdsPdpHeaderCompressionType {
        /**
         * no header compression
         */
        OFF,
        /**
         * manufacturer preferred
         */
        MANUFACTURER_PREFERRED,
        /**
         * RFC1144
         */
        RFC1144,
        /**
         * RFC2507
         */
        RFC2507,
        /**
         * RFC3095
         */
        RFC3095,
    }
    /**
     * PDP context type.
     */

    /**
     * PDP context type.
     */
    export namespace WdsPdpType {
        export const $gtype: GObject.GType<WdsPdpType>;
    }

    enum WdsPdpType {
        /**
         * IPv4
         */
        IPV4,
        /**
         * PPP
         */
        PPP,
        /**
         * IPv6
         */
        IPV6,
        /**
         * IPv4 and IPv6 combined context
         */
        IPV4_OR_IPV6,
    }
    /**
     * Profile change event.
     */

    /**
     * Profile change event.
     */
    export namespace WdsProfileChangeEvent {
        export const $gtype: GObject.GType<WdsProfileChangeEvent>;
    }

    enum WdsProfileChangeEvent {
        /**
         * create profile event.
         */
        CREATE_EVENT,
        /**
         * delete profile event.
         */
        DELETE_EVENT,
        /**
         * modify profile event.
         */
        MODIFY_EVENT,
        /**
         * subscription changed event.
         */
        SUBSCRIPTION_CHANGE_EVENT,
    }
    /**
     * Profile family.
     */

    /**
     * Profile family.
     */
    export namespace WdsProfileFamily {
        export const $gtype: GObject.GType<WdsProfileFamily>;
    }

    enum WdsProfileFamily {
        /**
         * Embedded profile family.
         */
        EMBEDDED,
        /**
         * Tethered profile family.
         */
        TETHERED,
    }
    /**
     * Profile network type family.
     */

    /**
     * Profile network type family.
     */
    export namespace WdsProfileType {
        export const $gtype: GObject.GType<WdsProfileType>;
    }

    enum WdsProfileType {
        /**
         * 3GPP profile type.
         */
        '3GPP',
        /**
         * 3GPP2 profile type.
         */
        '3GPP2',
        /**
         * EPC profile type. Since 1.34.
         */
        EPC,
        /**
         * All technologies profile type. Since 1.34.
         */
        ALL,
    }
    /**
     * QoS Class Identifier.
     */

    /**
     * QoS Class Identifier.
     */
    export namespace WdsQosClassIdentifier {
        export const $gtype: GObject.GType<WdsQosClassIdentifier>;
    }

    enum WdsQosClassIdentifier {
        /**
         * network assigned
         */
        NETWORK_ASSIGN,
        /**
         * guaranteed bitrate 1
         */
        GUARANTEED_BITRATE1,
        /**
         * guaranteed bitrate 2
         */
        GUARANTEED_BITRATE2,
        /**
         * guaranteed bitrate 3
         */
        GUARANTEED_BITRATE3,
        /**
         * guaranteed bitrate 4
         */
        GUARANTEED_BITRATE4,
        /**
         * non-guaranteed bitrate 5
         */
        NON_GUARANTEED_BITRATE5,
        /**
         * non-guaranteed bitrate 6
         */
        NON_GUARANTEED_BITRATE6,
        /**
         * non-guaranteed bitrate 7
         */
        NON_GUARANTEED_BITRATE7,
        /**
         * non-guaranteed bitrate 8
         */
        NON_GUARANTEED_BITRATE8,
    }
    /**
     * Radio access technology.
     */

    /**
     * Radio access technology.
     */
    export namespace WdsRadioAccessTechnology {
        export const $gtype: GObject.GType<WdsRadioAccessTechnology>;
    }

    enum WdsRadioAccessTechnology {
        /**
         * null bearer
         */
        NULL_BEARER,
        /**
         * WCDMA.
         */
        '3GPP_WCDMA',
        /**
         * GERAN.
         */
        '3GPP_GERAN',
        /**
         * LTE.
         */
        '3GPP_LTE',
        /**
         * TD-SDCMA.
         */
        '3GPP_TDSCDMA',
        /**
         * 3GPP WLAN.
         */
        '3GPP_WLAN',
        /**
         * 3GPP maximum.
         */
        '3GPP_MAXIMUM',
        /**
         * CDMA 1x.
         */
        '3GPP2_1X',
        /**
         * CDMA EVDO, HRPD.
         */
        '3GPP2_HRPD',
        /**
         * CDMA EVDO with eHRPD.
         */
        '3GPP2_EHRPD',
        /**
         * 3GPP2 WLAN.
         */
        '3GPP2_WLAN',
        /**
         * 3GPP2 maximum.
         */
        '3GPP2_MAXIMUM',
    }
    /**
     * Whether SDUs detected as erroneous are delivered or not.
     */

    /**
     * Whether SDUs detected as erroneous are delivered or not.
     */
    export namespace WdsSduErroneousDelivery {
        export const $gtype: GObject.GType<WdsSduErroneousDelivery>;
    }

    enum WdsSduErroneousDelivery {
        /**
         * Subscribe.
         */
        SUBSCRIBE,
        /**
         * No detection.
         */
        NO_DETECTION,
        /**
         * Erroneous SDUs are delivered.
         */
        ENABLED,
        /**
         * Erroneous SDUs are delivered.
         */
        DISABLED,
    }
    /**
     * Target value for the fraction of SDUs lost or detected as erroneous.
     */

    /**
     * Target value for the fraction of SDUs lost or detected as erroneous.
     */
    export namespace WdsSduErrorRatio {
        export const $gtype: GObject.GType<WdsSduErrorRatio>;
    }

    enum WdsSduErrorRatio {
        /**
         * Subscribe.
         */
        SUBSCRIBE,
        /**
         * 1x10^2.
         */
        '1E2',
        /**
         * 7x10^3.
         */
        '7E3',
        /**
         * 1x10^3.
         */
        '1E3',
        /**
         * 1x10^4.
         */
        '1E4',
        /**
         * 1x10^5.
         */
        '1E5',
        /**
         * 1x10^6.
         */
        '1E6',
        /**
         * 1x10^7.
         */
        '1E1',
    }
    /**
     * Target value for the undetected bit error ratio in the delivered SDUs.
     */

    /**
     * Target value for the undetected bit error ratio in the delivered SDUs.
     */
    export namespace WdsSduResidualBitErrorRatio {
        export const $gtype: GObject.GType<WdsSduResidualBitErrorRatio>;
    }

    enum WdsSduResidualBitErrorRatio {
        /**
         * Subscribe.
         */
        SUBSCRIBE,
        /**
         * 5x10^2.
         */
        '5E2',
        /**
         * 1x10^2.
         */
        '1E2',
        /**
         * 5x10^3.
         */
        '5E3',
        /**
         * 4x10^3.
         */
        '4E3',
        /**
         * 1x10^3.
         */
        '1E3',
        /**
         * 1x10^4.
         */
        '1E4',
        /**
         * 1x10^5.
         */
        '1E5',
        /**
         * 1x10^6.
         */
        '1E6',
        /**
         * 6x10^8.
         */
        '6E8',
    }
    /**
     * Tethered call type.
     */

    /**
     * Tethered call type.
     */
    export namespace WdsTetheredCallType {
        export const $gtype: GObject.GType<WdsTetheredCallType>;
    }

    enum WdsTetheredCallType {
        /**
         * non-tethered.
         */
        NON_TETHERED,
        /**
         * RmNet.
         */
        RMNET,
        /**
         * DUN.
         */
        DUN,
    }
    /**
     * QoS Traffic Classes.
     */

    /**
     * QoS Traffic Classes.
     */
    export namespace WdsTrafficClass {
        export const $gtype: GObject.GType<WdsTrafficClass>;
    }

    enum WdsTrafficClass {
        /**
         * default class, best-effort
         */
        SUBSCRIBED,
        /**
         * two-way video/voice, most delay sensitive
         */
        CONVERSATIONAL,
        /**
         * one-way video/audio, delay sensitive
         */
        STREAMING,
        /**
         * delay-sensitive, e.g. browsing, SSH.
         */
        INTERACTIVE,
        /**
         * delay-insensitive, e.g. downloads, email.
         */
        BACKGROUND,
    }
    /**
     * 3GPP-specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_3GPP.
     */

    /**
     * 3GPP-specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_3GPP.
     */
    export namespace WdsVerboseCallEndReason3gpp {
        export const $gtype: GObject.GType<WdsVerboseCallEndReason3gpp>;
    }

    enum WdsVerboseCallEndReason3gpp {
        /**
         * Operator-determined barring.
         */
        OPERATOR_DETERMINED_BARRING,
        /**
         * LLC or SNDCP failure.
         */
        LLC_SNDCP_FAILURE,
        /**
         * Insufficient resources.
         */
        INSUFFICIENT_RESOURCES,
        /**
         * Unknown or missing APN.
         */
        UNKNOWN_APN,
        /**
         * Unknown PDP address or type.
         */
        UNKNOWN_PDP,
        /**
         * Authentication failed.
         */
        AUTHENTICATION_FAILED,
        /**
         * Activation rejected by GGSN.
         */
        GGSN_REJECT,
        /**
         * Activation rejected.
         */
        ACTIVATION_REJECT,
        /**
         * Service option not supported.
         */
        OPTION_NOT_SUPPORTED,
        /**
         * Service option not subscribed.
         */
        OPTION_UNSUBSCRIBED,
        /**
         * Service option temporarily out of order.
         */
        OPTION_TEMPORARILY_OUT_OF_ORDER,
        /**
         * NSAPI already used.
         */
        NSAPI_ALREADY_USED,
        /**
         * Regular PDP context deactivation.
         */
        REGULAR_DEACTIVATION,
        /**
         * QoS not accepted.
         */
        QOS_NOT_ACCEPTED,
        /**
         * Network failure.
         */
        NETWORK_FAILURE,
        /**
         * Reattach required.
         */
        REATTACH_REQUIRED,
        /**
         * Feature not supported.
         */
        FEATURE_NOT_SUPPORTED,
        /**
         * Semantic error in TFT operation.
         */
        TFT_SEMANTIC_ERROR,
        /**
         * Syntax error in TFT operation.
         */
        TFT_SYNTAX_ERROR,
        /**
         * Unknown PDP context.
         */
        UNKNOWN_PDP_CONTEXT,
        /**
         * Semantic error in packet filters.
         */
        FILTER_SEMANTIC_ERROR,
        /**
         * Syntax error in packet filters.
         */
        FILTER_SYNTAX_ERROR,
        /**
         * PDP context without TFT activated.
         */
        PDP_WITHOUT_ACTIVE_TFT,
        /**
         * IPv4 only allowed.
         */
        IPV4_ONLY_ALLOWED,
        /**
         * IPv6 only allowed.
         */
        IPV6_ONLY_ALLOWED,
        /**
         * Single address bearer only.
         */
        SINGLE_ADDRESS_BEARER_ONLY,
        /**
         * ESM information not received.
         */
        ESM_INFO_NOT_RECEIVED,
        /**
         * PDN connection does not exist.
         */
        PDN_CONNECTION_DOES_NOT_EXIST,
        /**
         * Multiple connection to same PDN not allowed.
         */
        MULTIPLE_CONNECTION_TO_SAME_PDN_NOT_ALLOWED,
        /**
         * Invalid transaction ID.
         */
        INVALID_TRANSACTION_ID,
        /**
         * Message incorrect semantically.
         */
        MESSAGE_INCORRECT_SEMANTIC,
        /**
         * Invalid mandatory information.
         */
        INVALID_MANDATORY_INFO,
        /**
         * Message type not implemented.
         */
        MESSAGE_TYPE_UNSUPPORTED,
        /**
         * Message not compatible with state.
         */
        MESSAGE_TYPE_NONCOMPATIBLE_STATE,
        /**
         * Information element unknown.
         */
        UNKNOWN_INFO_ELEMENT,
        /**
         * Conditional IE error.
         */
        CONDITIONAL_IE_ERROR,
        /**
         * Message and protocol state uncompatible.
         */
        MESSAGE_AND_PROTOCOL_STATE_UNCOMPATIBLE,
        /**
         * Protocol error.
         */
        PROTOCOL_ERROR,
        /**
         * APN type conflict.
         */
        APN_TYPE_CONFLICT,
        /**
         * Invalid proxy call session control function address. Since 1.24.10.
         */
        INVALID_PROXY_CALL_SESSION_CONTROL_FUNCTION_ADDRESS,
    }
    /**
     * Call manager specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_CM.
     */

    /**
     * Call manager specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_CM.
     */
    export namespace WdsVerboseCallEndReasonCm {
        export const $gtype: GObject.GType<WdsVerboseCallEndReasonCm>;
    }

    enum WdsVerboseCallEndReasonCm {
        /**
         * CDMA specific. Phone is CDMA-locked.
         */
        CDMA_LOCK,
        /**
         * CDMA specific. Received intercept from the BS.
         */
        INTERCEPT,
        /**
         * CDMA specific. Received reorder from the BS.
         */
        REORDER,
        /**
         * CDMA specific. Received release from the BS, SO reject.
         */
        RELEASE_SO_REJECT,
        /**
         * CDMA specific. Received incoming call from the BS.
         */
        INCOMING_CALL,
        /**
         * CDMA specific. Received alert stop from the BS.
         */
        ALERT_STOP,
        /**
         * CDMA specific. Received end activation.
         */
        ACTIVATION,
        /**
         * CDMA specific. Maximum access probes transmitted.
         */
        MAX_ACCESS_PROBES,
        /**
         * CDMA specific. Concurrent service not supported by the BS.
         */
        CCS_NOT_SUPPORTED_BY_BS,
        /**
         * CDMA specific. No response received from the BS.
         */
        NO_RESPONSE_FROM_BS,
        /**
         * CDMA specific. Rejected by the BS.
         */
        REJECTED_BY_BS,
        /**
         * CDMA specific. Concurrent services requested are incompatible.
         */
        INCOMPATIBLE,
        /**
         * CDMA specific. Already in TC.
         */
        ALREADY_IN_TC,
        /**
         * CDMA specific. Call originated during GPS.
         */
        USER_CALL_ORIGINATED_DURING_GPS,
        /**
         * CDMA specific. Call originated during SMS.
         */
        USER_CALL_ORIGINATED_DURING_SMS,
        /**
         * CDMA specific. No service.
         */
        NO_CDMA_SERVICE,
        /**
         * MC abort. Since 1.24.10.
         */
        MC_ABORT,
        /**
         * Persistence test failure. Since 1.24.10.
         */
        PSIST_NG,
        /**
         * UIM not present. Since 1.24.10.
         */
        UIM_NOT_PRESENT,
        /**
         * Retry order.
         */
        RETRY_ORDER,
        /**
         * Access blocked. Since 1.24.10.
         */
        ACCESS_BLOCK,
        /**
         * Access blocked for all. Since 1.24.10.
         */
        ACCESS_BLOCK_ALL,
        /**
         * Maximum access probes for IS-707B call. Since 1.24.10.
         */
        IS707B_MAX_ACCESS_PROBES,
        /**
         * Thermal emergency. Since 1.24.10.
         */
        THERMAL_EMERGENCY,
        /**
         * Call origination throttled. Since 1.24.10.
         */
        CALL_ORIGINATION_THROTTLED,
        /**
         * Voice call originated and concurrent voice/data not supported. Since 1.24.10.
         */
        USER_CALL_ORIGINATED,
        /**
         * Conference failed. Since 1.24.10.
         */
        CONFERENCE_FAILED,
        /**
         * Incoming rejected.
         */
        INCOMING_REJECTED,
        /**
         * No gateway service.
         */
        NO_GATEWAY_SERVICE,
        /**
         * No GPRS context.
         */
        NO_GPRS_CONTEXT,
        /**
         * Illegal MS.
         */
        ILLEGAL_MS,
        /**
         * Illegal ME.
         */
        ILLEGAL_ME,
        /**
         * GPRS and non GPRS services not allowed.
         */
        GPRS_AND_NON_GPRS_SERVICES_NOT_ALLOWED,
        /**
         * GPRS services not allowed.
         */
        GPRS_SERVICES_NOT_ALLOWED,
        /**
         * MS identity not derived by the network.
         */
        MS_IDENTITY_NOT_DERIVED_BY_THE_NETWORK,
        /**
         * Implicitly detached.
         */
        IMPLICITLY_DETACHED,
        /**
         * PLMN not allowed.
         */
        PLMN_NOT_ALLOWED,
        /**
         * LA not allowed.
         */
        LA_NOT_ALLOWED,
        /**
         * GPRS services not allowed in PLMN.
         */
        GPRS_SERVICES_NOT_ALLOWED_IN_PLMN,
        /**
         * PDP duplicate.
         */
        PDP_DUPLICATE,
        /**
         * UE radio access technology change.
         */
        UE_RAT_CHANGE,
        /**
         * Congestion.
         */
        CONGESTION,
        /**
         * No PDP context activated.
         */
        NO_PDP_CONTEXT_ACTIVATED,
        /**
         * Access class DSAC rejection.
         */
        ACCESS_CLASS_DSAC_REJECTION,
        /**
         * Maximum retries failed to activate PDP context. Since 1.24.10.
         */
        PDP_ACTIVATE_MAX_RETRY_FAILED,
        /**
         * RAB failure. Since 1.24.10.
         */
        RAB_FAILURE,
        /**
         * EPS service not allowed. Since 1.24.10.
         */
        EPS_SERVICE_NOT_ALLOWED,
        /**
         * Tracking area not allowed. Since 1.24.10.
         */
        TRACKING_AREA_NOT_ALLOWED,
        /**
         * Roaming not allowed in tracking area. Since 1.24.10.
         */
        ROAMING_NOT_ALLOWED_IN_TRACKING_AREA,
        /**
         * No suitable cells in tracking area. Since 1.24.10.
         */
        NO_SUITABLE_CELLS_IN_TRACKING_AREA,
        /**
         * Not authorized in closed subscriber group. Since 1.24.10.
         */
        NOT_AUTHORIZED_CLOSED_SUBSCRIBER_GROUP,
        /**
         * EPS Session Management, unknown EPS bearer context. Since 1.24.10.
         */
        ESM_UNKNOWN_EPS_BEARER_CONTEXT,
        /**
         * DRB released at RRC. Since 1.24.10.
         */
        DRB_RELEASED_AT_RRC,
        /**
         * NAS signal connection released. Since 1.24.10.
         */
        NAS_SIGNAL_CONNECTION_RELEASED,
        /**
         * EPS Mobility Management, detached. Since 1.24.10.
         */
        EMM_DETACHED,
        /**
         * EPS Mobility Management, attach failed. Since 1.24.10.
         */
        EMM_ATTACH_FAILED,
        /**
         * EPS Mobility Management, attach started. Since 1.24.10.
         */
        EMM_ATTACH_STARTED,
        /**
         * LTE NAS service request failed. Since 1.24.10.
         */
        LTE_NAS_SERVICE_REQUEST_FAILED,
        /**
         * EPS Session Management, active dedicated bearer reactivated by network. Since 1.24.10.
         */
        ESM_ACTIVE_DEDICATED_BEARER_REACTIVATED_BY_NW,
        /**
         * EPS Session Management, lower layer failure. Since 1.24.10.
         */
        ESM_LOWER_LAYER_FAILURE,
        /**
         * EPS Session Management, sync up with network. Since 1.24.10.
         */
        ESM_SYNC_UP_WITH_NW,
        /**
         * EPS Session Management, network activated dedicated bearer with id of default bearer. Since 1.24.10.
         */
        ESM_NW_ACTIVATED_DEDICATED_BEARER_WITH_ID_OF_DEFAULT_BEARER,
        /**
         * EPS Session Management, bad OTA message. Since 1.24.10.
         */
        ESM_BAD_OTA_MESSAGE,
        /**
         * EPS Session Management, DS rejected call. Since 1.24.10.
         */
        ESM_DS_REJECTED_CALL,
        /**
         * EPS Session Management, context transferred due to IRAT. Since 1.24.10.
         */
        ESM_CONTEXT_TRANSFERRED_DUE_TO_IRAT,
        /**
         * DS explicit deactivation. Since 1.24.10.
         */
        DS_EXPLICIT_DEACT,
        /**
         * EPS Session Management, local cause none. Since 1.24.10.
         */
        ESM_LOCAL_CAUSE_NONE,
        /**
         * LTE NAS service request failed, no throttle. Since 1.24.10.
         */
        LTE_NAS_SERVICE_REQUEST_FAILED_NO_THROTTLE,
        /**
         * ACL failure. Since 1.24.10.
         */
        ACL_FAILURE,
        /**
         * LTE NAS service request failed, DS disallow. Since 1.24.10.
         */
        LTE_NAS_SERVICE_REQUEST_FAILED_DS_DISALLOW,
        /**
         * EPS Mobility Management, T3417 expired. Since 1.24.10.
         */
        EMM_T3417_EXPIRED,
        /**
         * EPS Mobility Management, T3417 ext expired. Since 1.24.10.
         */
        EMM_T3417_EXT_EXPIRED,
        /**
         * LTE Radio Resource Control, UL data confirmation failure, txn. Since 1.24.10.
         */
        LRRC_UL_DATA_CONFIRMATION_FAILURE_TXN,
        /**
         * LTE Radio Resource Control, UL data confirmation failure, handover. Since 1.24.10.
         */
        LRRC_UL_DATA_CONFIRMATION_FAILURE_HANDOVER,
        /**
         * LTE Radio Resource Control, UL data confirmation failure, connection release. Since 1.24.10.
         */
        LRRC_UL_DATA_CONFIRMATION_FAILURE_CONN_REL,
        /**
         * LTE Radio Resource Control, UL data confirmation failure, radio link failure. Since 1.24.10.
         */
        LRRC_UL_DATA_CONFIRMATION_FAILURE_RLF,
        /**
         * LTE Radio Resource Control, UL data confirmation failure, ctrl not conn. Since 1.24.10.
         */
        LRRC_UL_DATA_CONFIRMATION_FAILURE_CTRL_NOT_CONN,
        /**
         * LTE Radio Resource Control, connection establishment failure. Since 1.24.10.
         */
        LRRC_CONNECTION_ESTABLISHMENT_FAILURE,
        /**
         * LTE Radio Resource Control, connection establishment failure, aborted. Since 1.24.10.
         */
        LRRC_CONNECTION_ESTABLISHMENT_FAILURE_ABORTED,
        /**
         * LTE Radio Resource Control, connection establishment failure, access barred. Since 1.24.10.
         */
        LRRC_CONNECTION_ESTABLISHMENT_FAILURE_ACCESS_BARRED,
        /**
         * LTE Radio Resource Control, connection establishment failure, cell reselection. Since 1.24.10.
         */
        LRRC_CONNECTION_ESTABLISHMENT_FAILURE_CELL_RESELECTION,
        /**
         * LTE Radio Resource Control, connection establishment failure, config failure. Since 1.24.10.
         */
        LRRC_CONNECTION_ESTABLISHMENT_FAILURE_CONFIG_FAILURE,
        /**
         * LTE Radio Resource Control, connection establishment failure, timer expired. Since 1.24.10.
         */
        LRRC_CONNECTION_ESTABLISHMENT_FAILURE_TIMER_EXPIRED,
        /**
         * LTE Radio Resource Control, connection establishment failure, link failure. Since 1.24.10.
         */
        LRRC_CONNECTION_ESTABLISHMENT_FAILURE_LINK_FAILURE,
        /**
         * LTE Radio Resource Control, connection establishment failure, not camped. Since 1.24.10.
         */
        LRRC_CONNECTION_ESTABLISHMENT_FAILURE_NOT_CAMPED,
        /**
         * LTE Radio Resource Control, connection establishment failure, SI failure. Since 1.24.10.
         */
        LRRC_CONNECTION_ESTABLISHMENT_FAILURE_SI_FAILURE,
        /**
         * LTE Radio Resource Control, connection establishment failure, rejected. Since 1.24.10.
         */
        LRRC_CONNECTION_ESTABLISHMENT_FAILURE_REJECTED,
        /**
         * LTE Radio Resource Control, connection release, normal. Since 1.24.10.
         */
        LRRC_CONNECTION_RELEASE_NORMAL,
        /**
         * LTE Radio Resource Control, connection release, radio link failure. Since 1.24.10.
         */
        LRRC_CONNECTION_RELEASE_RLF,
        /**
         * LTE Radio Resource Control, connection release, cre failure. Since 1.24.10.
         */
        LRRC_CONNECTION_RELEASE_CRE_FAILURE,
        /**
         * LTE Radio Resource Control, connection release, oos during cre. Since 1.24.10.
         */
        LRRC_CONNECTION_RELEASE_OOS_DURING_CRE,
        /**
         * LTE Radio Resource Control, connection release, aborted. Since 1.24.10.
         */
        LRRC_CONNECTION_RELEASE_ABORTED,
        /**
         * LTE Radio Resource Control, connection release, SIB read error. Since 1.24.10.
         */
        LRRC_CONNECTION_RELEASE_SIB_READ_ERROR,
        /**
         * Detach with reattach LTE network detach. Since 1.24.10.
         */
        DETACH_WITH_REATTACH_LTE_NW_DETACH,
        /**
         * Detach without reattach LTE network detach. Since 1.24.10.
         */
        DETACH_WITHOUT_REATTACH_LTE_NW_DETACH,
        /**
         * EPS Session Management, proc timeout. Since 1.24.10.
         */
        ESM_PROC_TIMEOUT,
        /**
         * Message exceed max L2 limit. Since 1.24.10.
         */
        MESSAGE_EXCEED_MAX_L2_LIMIT,
        /**
         * CDMA/EVDO specific. Received Connection Deny. General or Network busy.
         */
        CONNECTION_DENY_GENERAL_OR_BUSY,
        /**
         * CDMA/EVDO specific. Received Connection Deny. Billing or Authentication failure.
         */
        CONNECTION_DENY_BILLING_OR_AUTHENTICATION_FAILURE,
        /**
         * CDMA/EVDO specific. Change HDR.
         */
        HDR_CHANGE,
        /**
         * CDMA/EVDO specific. Exit HDR.
         */
        HDR_EXIT,
        /**
         * CDMA/EVDO specific. No HDR session.
         */
        HDR_NO_SESSION,
        /**
         * CDMA/EVDO specific. HDR call ended in favor of a GPS fix.
         */
        HDR_ORIGINATION_DURING_GPS_FIX,
        /**
         * CDMA/EVDO specific. Connection setup timeout.
         */
        HDR_CONNECTION_SETUP_TIMEOUT,
        /**
         * CDMA/EVDO specific. Released HDR call by call manager.
         */
        HDR_RELEASED_BY_CM,
        /**
         * Failed to acquire co-located HDR for origination. Since 1.24.10.
         */
        HDR_COLLOCATED_ACQUISITION_FAILED,
        /**
         * CDMA/EVDO specific. OTASP commit in progress. Since 1.24.10.
         */
        OTASP_COMMIT_IN_PROGRESS,
        /**
         * CDMA/EVDO specific. No hybrid HDR service.
         */
        HDR_NO_HYBRID_SERVICE,
        /**
         * CDMA/EVDO specific. No lock granted. Since 1.24.10.
         */
        HDR_NO_LOCK_GRANTED,
        /**
         * CDMA/EVDO specific. hold other in progress. Since 1.24.10.
         */
        HOLD_OTHER_IN_PROGRESS,
        /**
         * CDMA/EVDO specific. Fade. Since 1.24.10.
         */
        HDR_FADE,
        /**
         * CDMA/EVDO specific. Access failure. Since 1.24.10.
         */
        HDR_ACCESS_FAILURE,
        /**
         * Client end.
         */
        CLIENT_END,
        /**
         * No service.
         */
        NO_SERVICE,
        /**
         * Fade.
         */
        FADE,
        /**
         * Release normal.
         */
        RELEASE_NORMAL,
        /**
         * Access attempt in progress.
         */
        ACCESS_ATTEMPT_IN_PROGRESS,
        /**
         * Access Failure.
         */
        ACCESS_FAILURE,
        /**
         * Redirection or handoff.
         */
        REDIRECTION_OR_HANDOFF,
        /**
         * Offline. Since 1.24.10.
         */
        OFFLINE,
        /**
         * Emergency mode. Since 1.24.10.
         */
        EMERGENCY_MODE,
        /**
         * Phone in use. Since 1.24.10.
         */
        PHONE_IN_USE,
        /**
         * Invalid mode. Since 1.24.10.
         */
        INVALID_MODE,
        /**
         * Invalid SIM state. Since 1.24.10.
         */
        INVALID_SIM_STATE,
        /**
         * No collocated HDR. Since 1.24.10.
         */
        NO_COLLOCATED_HDR,
        /**
         * Call control rejected. Since 1.24.10.
         */
        CALL_CONTROL_REJECTED,
    }
    /**
     * eHRPD-specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_EHRPD.
     */

    /**
     * eHRPD-specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_EHRPD.
     */
    export namespace WdsVerboseCallEndReasonEhrpd {
        export const $gtype: GObject.GType<WdsVerboseCallEndReasonEhrpd>;
    }

    enum WdsVerboseCallEndReasonEhrpd {
        /**
         * Subscription limited to IPv4.
         */
        SUBSCRIPTION_LIMITED_TO_IPV4,
        /**
         * Subscription limited to IPv6.
         */
        SUBSCRIPTION_LIMITED_TO_IPV6,
        /**
         * VSNCP specific. timeout.
         */
        VSNCP_TIMEOUT,
        /**
         * VSNCP specific. failure.
         */
        VSNCP_FAILURE,
        /**
         * VSNCP specific. 3GPP2 general error.
         */
        VSNCP_3GPP2_GENERAL_ERROR,
        /**
         * VSNCP specific. 3GPP2 unauthenticated APN.
         */
        VSNCP_3GPP2_UNAUTHENTICATED_APN,
        /**
         * VSNCP specific. 3GPP2 PDN limit exceeded.
         */
        VSNCP_3GPP2_PDN_LIMIT_EXCEEDED,
        /**
         * VSNCP specific. 3GPP2 no PDN gateway.
         */
        VSNCP_3GPP2_NO_PDN_GATEWAY,
        /**
         * VSNCP specific. 3GPP2 PDN gateway unreachable.
         */
        VSNCP_3GPP2_PDN_GATEWAY_UNREACHABLE,
        /**
         * VSNCP specific. 3GPP2 PDN gateway rejected.
         */
        VSNCP_3GPP2_PDN_GATEWAY_REJECTED,
        /**
         * VSNCP specific. 3GPP2 insufficient parameters.
         */
        VSNCP_3GPP2_INSUFFICIENT_PARAMETERS,
        /**
         * VSNCP specific. 3GPP2 resource unavailable.
         */
        VSNCP_3GPP2_RESOURCE_UNAVAILABLE,
        /**
         * VSNCP specific. 3GPP2 administratively prohibited.
         */
        VSNCP_3GPP2_ADMINISTRATIVELY_PROHIBITED,
        /**
         * VSNCP specific. 3GPP2 PDN ID in use.
         */
        VSNCP_3GPP2_PDN_ID_IN_USE,
        /**
         * VSNCP specific. 3GPP2 subscription limitation.
         */
        VSNCP_3GPP2_SUBSCRIPTION_LIMITATION,
        /**
         * VSNCP specific. 3GPP2 PDN exists for this APN.
         */
        VSNCP_3GPP2_PDN_EXISTS_FOR_THIS_APN,
    }
    /**
     * Internal call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_INTERNAL.
     */

    /**
     * Internal call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_INTERNAL.
     */
    export namespace WdsVerboseCallEndReasonInternal {
        export const $gtype: GObject.GType<WdsVerboseCallEndReasonInternal>;
    }

    enum WdsVerboseCallEndReasonInternal {
        /**
         * Internal error.
         */
        ERROR,
        /**
         * Call ended.
         */
        CALL_ENDED,
        /**
         * Unknown internal cause.
         */
        UNKNOWN_INTERNAL_CAUSE,
        /**
         * Unknown cause.
         */
        UNKNOWN_CAUSE,
        /**
         * Close in progress.
         */
        CLOSE_IN_PROGRESS,
        /**
         * Network initiated termination.
         */
        NETWORK_INITIATED_TERMINATION,
        /**
         * App preempted.
         */
        APP_PREEMPTED,
        /**
         * PDN IPv4 call disallowed. Since: 1.14.
         */
        PDN_IPV4_CALL_DISALLOWED,
        /**
         * PDN IPv4 call throttled. Since: 1.14.
         */
        PDN_IPV4_CALL_THROTTLED,
        /**
         * PDN IPv6 call disallowed. Since: 1.14.
         */
        PDN_IPV6_CALL_DISALLOWED,
        /**
         * PDN IPv6 call throttled. Since: 1.14.
         */
        PDN_IPV6_CALL_THROTTLED,
        /**
         * Modem restart. Since: 1.14.
         */
        MODEM_RESTART,
        /**
         * PDP PPP not supported. Since: 1.14.
         */
        PDP_PPP_NOT_SUPPORTED,
        /**
         * Unpreferred RAT. Since: 1.14.
         */
        UNPREFERRED_RAT,
        /**
         * Physical link close in progress. Since: 1.14.
         */
        PHYSICAL_LINK_CLOSE_IN_PROGRESS,
        /**
         * APN pending handover. Since: 1.14.
         */
        APN_PENDING_HANDOVER,
        /**
         * Profile bearer incompatible. Since: 1.14.
         */
        PROFILE_BEARER_INCOMPATIBLE,
        /**
         * MMGDSI Card event. Since: 1.14.
         */
        MMGDSI_CARD_EVENT,
        /**
         * LPM or power down. Since: 1.14.
         */
        LPM_OR_POWER_DOWN,
        /**
         * APN disabled. Since: 1.14.
         */
        APN_DISABLED,
        /**
         * MPIT expired. Since: 1.14.
         */
        MPIT_EXPIRED,
        /**
         * IPv6 address transfer failed. Since: 1.14.
         */
        IPV6_ADDRESS_TRANSFER_FAILED,
        /**
         * TRAT swap failed. Since: 1.14.
         */
        TRAT_SWAP_FAILED,
        /**
         * eHRPD to HRPD fallback. Since 1.24.10.
         */
        EHRPD_TO_HRPD_FALLBACK,
        /**
         * Mandatory APN disabled. Since 1.24.10.
         */
        MANDATORY_APN_DISABLED,
        /**
         * MIP config failure. Since 1.24.10.
         */
        MIP_CONFIG_FAILURE,
        /**
         * PDN inactivity timeout expired. Since 1.24.10.
         */
        PDN_INACTIVITY_TIMER_EXPIRED,
        /**
         * Max IPv4 connections. Since 1.24.10.
         */
        MAX_V4_CONNECTIONS,
        /**
         * Max IPv6 connections. Since 1.24.10.
         */
        MAX_V6_CONNECTIONS,
        /**
         * APN mismatch. Since 1.24.10.
         */
        APN_MISMATCH,
        /**
         * IP version mismatch. Since 1.24.10.
         */
        IP_VERSION_MISMATCH,
        /**
         * DUN call disallowed. Since 1.24.10.
         */
        DUN_CALL_DISALLOWED,
        /**
         * Invalid profile. Since 1.24.10.
         */
        INVALID_PROFILE,
        /**
         * EPC to non-EPC transition. Since 1.24.10.
         */
        EPC_NONEPC_TRANSITION,
        /**
         * Invalid profile ID. Since 1.24.10.
         */
        INVALID_PROFILE_ID,
        /**
         * Call already present. Since 1.24.10.
         */
        CALL_ALREADY_PRESENT,
        /**
         * Interface in use. Since 1.24.10.
         */
        INTERFACE_IN_USE,
        /**
         * IP PDP mismatch. Since 1.24.10.
         */
        IP_PDP_MISMATCH,
        /**
         * APN disallowed on roaming. Since 1.24.10.
         */
        APN_DISALLOWED_ON_ROAMING,
        /**
         * APN parameter change. Since 1.24.10.
         */
        APN_PARAMETER_CHANGE,
        /**
         * Interface in use config match. Since 1.24.10.
         */
        INTERFACE_IN_USE_CONFIG_MATCH,
        /**
         * NULL APN disallowed. Since 1.24.10.
         */
        NULL_APN_DISALLOWED,
        /**
         * Thermal mitigation. Since 1.24.10.
         */
        THERMAL_MITIGATION,
        /**
         * Subs ID mismatch Since 1.24.10.
         */
        SUBS_ID_MISMATCH,
        /**
         * Data settings disabled. Since 1.24.10.
         */
        DATA_SETTINGS_DISABLED,
        /**
         * Data roaming settings disabled. Since 1.24.10.
         */
        DATA_ROAMING_SETTINGS_DISABLED,
        /**
         * APN format invalid. Since 1.24.10.
         */
        APN_FORMAT_INVALID,
        /**
         * DDS call abort. Since 1.24.10.
         */
        DDS_CALL_ABORT,
        /**
         * Validation failure. Since 1.24.10.
         */
        VALIDATION_FAILURE,
    }
    /**
     * IPv6-specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_IPV6.
     */

    /**
     * IPv6-specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_IPV6.
     */
    export namespace WdsVerboseCallEndReasonIpv6 {
        export const $gtype: GObject.GType<WdsVerboseCallEndReasonIpv6>;
    }

    enum WdsVerboseCallEndReasonIpv6 {
        /**
         * Prefix unavailable.
         */
        PREFIX_UNAVAILABLE,
        /**
         * HRDP IPv6 disabled.
         */
        HRPD_IPV6_DISABLED,
        /**
         * IPv6 disabled. Since 1.24.10.
         */
        DISABLED,
    }
    /**
     * Mobile IP specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_MIP.
     */

    /**
     * Mobile IP specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_MIP.
     */
    export namespace WdsVerboseCallEndReasonMip {
        export const $gtype: GObject.GType<WdsVerboseCallEndReasonMip>;
    }

    enum WdsVerboseCallEndReasonMip {
        /**
         * Unknown reason.
         */
        ERROR_REASON_UNKNOWN,
        /**
         * FA error. Reason unspecified.
         */
        FA_ERROR_REASON_UNSPECIFIED,
        /**
         * FA error. Administratively prohibited.
         */
        FA_ERROR_ADMINISTRATIVELY_PROHIBITED,
        /**
         * FA error. Insufficient resources.
         */
        FA_ERROR_INSUFFICIENT_RESOURCES,
        /**
         * FA error. Mobile node authenticatin failure.
         */
        FA_ERROR_MOBILE_NODE_AUTHENTICATION_FAILURE,
        /**
         * FA error. HA authentication failure.
         */
        FA_ERROR_HA_AUTHENTICATION_FAILURE,
        /**
         * FA error. Requested lifetime too long.
         */
        FA_ERROR_REQUESTED_LIFETIME_TOO_LONG,
        /**
         * FA error. Malformed request.
         */
        FA_ERROR_MALFORMED_REQUEST,
        /**
         * FA error. Malformed reply.
         */
        FA_ERROR_MALFORMED_REPLY,
        /**
         * FA error. Encapsulation unavailable.
         */
        FA_ERROR_ENCAPSULATION_UNAVAILABLE,
        /**
         * FA error. VJHC unavailable.
         */
        FA_ERROR_VJHC_UNAVAILABLE,
        /**
         * FA error. Reverse tunnel unavailable.
         */
        FA_ERROR_REVERSE_TUNNEL_UNAVAILABLE,
        /**
         * FA error. Reverse tunnel mandatory and T bit not set.
         */
        FA_ERROR_REVERSE_TUNNEL_MANDATORY_AND_T_BIT_NOT_SET,
        /**
         * FA error. Delivery style not supported.
         */
        FA_ERROR_DELIVERY_STYLE_NOT_SUPPORTED,
        /**
         * FA error. Missing NAI.
         */
        FA_ERROR_MISSING_NAI,
        /**
         * FA error. Missing HA.
         */
        FA_ERROR_MISSING_HA,
        /**
         * FA error. Missing home address.
         */
        FA_ERROR_MISSING_HOME_ADDRESS,
        /**
         * FA error. Unknown challenge.
         */
        FA_ERROR_UNKNOWN_CHALLENGE,
        /**
         * FA error. Missing challenge.
         */
        FA_ERROR_MISSING_CHALLENGE,
        /**
         * FA error. Stale challenge.
         */
        FA_ERROR_STALE_CHALLENGE,
        /**
         * HA error. Reason unspecified.
         */
        HA_ERROR_REASON_UNSPECIFIED,
        /**
         * HA error. Administratively prohibited.
         */
        HA_ERROR_ADMINISTRATIVELY_PROHIBITED,
        /**
         * HA error. Insufficient resources.
         */
        HA_ERROR_INSUFFICIENT_RESOURCES,
        /**
         * HA error. Mobile node authentication failure.
         */
        HA_ERROR_MOBILE_NODE_AUTHENTICATION_FAILURE,
        /**
         * HA error. FA authentication failure.
         */
        HA_ERROR_FA_AUTHENTICATION_FAILURE,
        /**
         * HA error. Registration ID mismatch.
         */
        HA_ERROR_REGISTRATION_ID_MISMATCH,
        /**
         * HA error. Malformed request.
         */
        HA_ERROR_MALFORMED_REQUEST,
        /**
         * HA error. Unknown HA address.
         */
        HA_ERROR_UNKNOWN_HA_ADDRESS,
        /**
         * HA error. Reverse tunnel unavailable.
         */
        HA_ERROR_REVERSE_TUNNEL_UNAVAILABLE,
        /**
         * HA error. Reverse tunnel mandatory and T bit not set.
         */
        HA_ERROR_REVERSE_TUNNEL_MANDATORY_AND_T_BIT_NOT_SET,
        /**
         * HA error. Encapsulation unavailable.
         */
        HA_ERROR_ENCAPSULATION_UNAVAILABLE,
    }
    /**
     * PPP-specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_PPP.
     */

    /**
     * PPP-specific call end reasons, given when the `QmiWdsVerboseCallEndReasonType` is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_PPP.
     */
    export namespace WdsVerboseCallEndReasonPpp {
        export const $gtype: GObject.GType<WdsVerboseCallEndReasonPpp>;
    }

    enum WdsVerboseCallEndReasonPpp {
        /**
         * Unknown error.
         */
        UNKNOWN,
        /**
         * Timeout.
         */
        TIMEOUT,
        /**
         * Authentication failure.
         */
        AUTHENTICATION_FAILURE,
        /**
         * Option mismatch.
         */
        OPTION_MISMATCH,
        /**
         * PAP failure.
         */
        PAP_FAILURE,
        /**
         * CHAP failure.
         */
        CHAP_FAILURE,
        /**
         * Close in progress. Since 1.24.10.
         */
        CLOSE_IN_PROGRESS,
    }
    /**
     * Type of verbose call end reason.
     */

    /**
     * Type of verbose call end reason.
     */
    export namespace WdsVerboseCallEndReasonType {
        export const $gtype: GObject.GType<WdsVerboseCallEndReasonType>;
    }

    enum WdsVerboseCallEndReasonType {
        /**
         * Mobile IP.
         */
        MIP,
        /**
         * Internal.
         */
        INTERNAL,
        /**
         * Call manager.
         */
        CM,
        /**
         * 3GPP.
         */
        '3GPP',
        /**
         * PPP.
         */
        PPP,
        /**
         * eHRPD.
         */
        EHRPD,
        /**
         * IPv6.
         */
        IPV6,
    }
    /**
     * Ack failure cause.
     */

    /**
     * Ack failure cause.
     */
    export namespace WmsAckFailureCause {
        export const $gtype: GObject.GType<WmsAckFailureCause>;
    }

    enum WmsAckFailureCause {
        /**
         * No network response.
         */
        NO_NETWORK_RESPONSE,
        /**
         * Network released link.
         */
        NETWORK_RELEASED_LINK,
        /**
         * Not sent.
         */
        NOT_SENT,
    }
    /**
     * Indication of whether ACK needs to be sent or not.
     */

    /**
     * Indication of whether ACK needs to be sent or not.
     */
    export namespace WmsAckIndicator {
        export const $gtype: GObject.GType<WmsAckIndicator>;
    }

    enum WmsAckIndicator {
        /**
         * ACK needs to be sent.
         */
        SEND,
        /**
         * ACK doesn't need to be sent.
         */
        DO_NOT_SEND,
    }
    /**
     * Cause codes when failed to send an SMS in CDMA.
     */

    /**
     * Cause codes when failed to send an SMS in CDMA.
     */
    export namespace WmsCdmaCauseCode {
        export const $gtype: GObject.GType<WmsCdmaCauseCode>;
    }

    enum WmsCdmaCauseCode {
        /**
         * Address is valid but not yet allocated. Since 1.18.
         */
        NETWORK_ADDRESS_VACANT,
        /**
         * Address is invalid. Since 1.18.
         */
        NETWORK_ADDRESS_TRANSLATION_FAILURE,
        /**
         * Network resource shortage. Since 1.18.
         */
        NETWORK_RESOURCE_SHORTAGE,
        /**
         * Network failed. Since 1.18.
         */
        NETWORK_FAILURE,
        /**
         * SMS teleservice ID is invalid. Since 1.18.
         */
        NETWORK_INVALID_TELESERVICE_ID,
        /**
         * Other network error. Since 1.18.
         */
        NETWORK_OTHER,
        /**
         * No page response from destination. Since 1.18.
         */
        DESTINATION_NO_PAGE_RESPONSE,
        /**
         * Destination is busy. Since 1.18.
         */
        DESTINATION_BUSY,
        /**
         * No acknowledge from destination. Since 1.18.
         */
        DESTINATION_NO_ACK,
        /**
         * Destination resource shortage. Since 1.18.
         */
        DESTINATION_RESOURCE_SHORTAGE,
        /**
         * SMS delivery postponed. Since 1.18.
         */
        DESTINATION_SMS_DELIVERY_POSTPONED,
        /**
         * Destination out of service. Since 1.18.
         */
        DESTINATION_OUT_OF_SERVICE,
        /**
         * Destination not at address. Since 1.18.
         */
        DESTINATION_NOT_AT_ADDRESS,
        /**
         * Other destination error. Since 1.18.
         */
        DESTINATION_OTHER,
        /**
         * Radio interface resource shortage. Since 1.18.
         */
        RADIO_INTERFACE_RESOURCE_SHORTAGE,
        /**
         * Radio interface incompatibility. Since 1.18.
         */
        RADIO_INTERFACE_INCOMPATIBILITY,
        /**
         * Other radio interface error. Since 1.18.
         */
        RADIO_INTERFACE_OTHER,
        /**
         * Encoding error. Since 1.18.
         */
        GENERAL_ENCODING,
        /**
         * SMS origin denied. Since 1.18.
         */
        GENERAL_SMS_ORIGIN_DENIED,
        /**
         * SMS destination denied. Since 1.18.
         */
        GENERAL_SMS_DESTINATION_DENIED,
        /**
         * Supplementary service not supported. Since 1.18.
         */
        GENERAL_SUPPLEMENTARY_SERVICE_NOT_SUPPORTED,
        /**
         * SMS not supported. Since 1.18.
         */
        GENERAL_SMS_NOT_SUPPORTED,
        /**
         * Missing optional expected parameter. Since 1.18.
         */
        GENERAL_MISSING_EXPECTED_PARAMETER,
        /**
         * Missing mandatory parameter. Since 1.18.
         */
        GENERAL_MISSING_MANDATORY_PARAMETER,
        /**
         * Unrecognized parameter value. Since 1.18.
         */
        GENERAL_UNRECOGNIZED_PARAMETER_VALUE,
        /**
         * Unexpected parameter value. Since 1.18.
         */
        GENERAL_UNEXPECTED_PARAMETER_VALUE,
        /**
         * User data size error. Since 1.18.
         */
        GENERAL_USER_DATA_SIZE_ERROR,
        /**
         * Other general error. Since 1.18.
         */
        GENERAL_OTHER,
    }
    /**
     * Error class reported from the network when failed to send an SMS in CDMA,
     * or reported by the device when failed to process a transfer-only CDMA message.
     */

    /**
     * Error class reported from the network when failed to send an SMS in CDMA,
     * or reported by the device when failed to process a transfer-only CDMA message.
     */
    export namespace WmsCdmaErrorClass {
        export const $gtype: GObject.GType<WmsCdmaErrorClass>;
    }

    enum WmsCdmaErrorClass {
        /**
         * Temporary error reported by network.
         */
        TEMPORARY,
        /**
         * Permanent error reported by network.
         */
        PERMANENT,
        /**
         * Temporary error reported by device. Since 1.28.
         */
        TEMPORARY_DEVICE,
        /**
         * Permanent error reported by device. Since 1.28.
         */
        PERMANENT_DEVICE,
    }
    /**
     * CDMA service option selection.
     */
    /**
     * CDMA service option selection.
     */
    class WmsCdmaServiceOption {
        static $gtype: GObject.GType<WmsCdmaServiceOption>;

        // Static fields

        /**
         * Automatic selection of service option.
         */
        static AUTO: number;
        /**
         * Use service option 6.
         */
        static '6': number;
        /**
         * Use service option 14.
         */
        static '14': number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * RP cause codes when failed to send an SMS in GSM/WCDMA.
     */

    /**
     * RP cause codes when failed to send an SMS in GSM/WCDMA.
     */
    export namespace WmsGsmUmtsRpCause {
        export const $gtype: GObject.GType<WmsGsmUmtsRpCause>;
    }

    enum WmsGsmUmtsRpCause {
        /**
         * Unassigned number.
         */
        UNASSIGNED_NUMBER,
        /**
         * Operator determined barring.
         */
        OPERATOR_DETERMINED_BARRING,
        /**
         * Call barred.
         */
        CALL_BARRED,
        /**
         * Reserved.
         */
        RESERVED,
        /**
         * SMS transfer rejected.
         */
        SMS_TRANSFER_REJECTED,
        /**
         * Memory capacity exceeded.
         */
        MEMORY_CAPACITY_EXCEEDED,
        /**
         * Destination out of order.
         */
        DESTINATION_OUT_OF_ORDER,
        /**
         * Unidentified subscriber.
         */
        UNIDENTIFIED_SUBSCRIBER,
        /**
         * Facility rejected.
         */
        FACILITY_REJECTED,
        /**
         * Unknown subscriber.
         */
        UNKNOWN_SUBSCRIBER,
        /**
         * Network out of order.
         */
        NETWORK_OUF_OF_ORDER,
        /**
         * Temporary failure.
         */
        TEMPORARY_FAILURE,
        /**
         * Congestion.
         */
        CONGESTION,
        /**
         * Resources unavailable.
         */
        RESOURCES_UNAVAILABLE,
        /**
         * Facility not subscribed.
         */
        FACILITY_NOT_SUBSCRIBED,
        /**
         * Facility not implemented.
         */
        FACILITY_NOT_IMPLEMENTED,
        /**
         * Invalid SMS transfer reference value.
         */
        INVALID_SMS_TRANSFER_REFERENCE_VALUE,
        /**
         * Semantically incorrect message.
         */
        SEMANTICALLY_INCORRECT_MESSAGE,
        /**
         * Invalid mandatory info.
         */
        INVALID_MANDATORY_INFO,
        /**
         * Message type not implemented.
         */
        MESSAGE_TYPE_NOT_IMPLEMENTED,
        /**
         * Message not compatible with SMS.
         */
        MESSAGE_NOT_COMPATIBLE_WITH_SMS,
        /**
         * Information element not implemented.
         */
        INFORMATION_ELEMENT_NOT_IMPLEMENTED,
        /**
         * Protocol error.
         */
        PROTOCOL_ERROR,
        /**
         * Interworking error.
         */
        INTERWORKING,
    }
    /**
     * RT cause codes when failed to send an SMS in GSM/WCDMA.
     */

    /**
     * RT cause codes when failed to send an SMS in GSM/WCDMA.
     */
    export namespace WmsGsmUmtsTpCause {
        export const $gtype: GObject.GType<WmsGsmUmtsTpCause>;
    }

    enum WmsGsmUmtsTpCause {
        /**
         * Tele interworking not supported.
         */
        TELE_INTERWORKING_NOT_SUPPORTED,
        /**
         * Short message type 0 not supported.
         */
        SHORT_MESSAGE_TYPE_0_NOT_SUPPORTED,
        /**
         * Short message cannot be replaced.
         */
        SHORT_MESSAGE_CANNOT_BE_REPLACED,
        /**
         * Unspecified TP-PID error.
         */
        UNSPECIFIED_PID_ERROR,
        /**
         * Data coding scheme not supported.
         */
        DCS_NOT_SUPPORTED,
        /**
         * Message class not supported.
         */
        MESSAGE_CLASS_NOT_SUPPORTED,
        /**
         * Unspecified data coding scheme error.
         */
        UNSPECIFIED_DCS_ERROR,
        /**
         * Command cannot be actioned.
         */
        COMMAND_CANNOT_BE_ACTIONED,
        /**
         * Command unsupported.
         */
        COMMAND_UNSUPPORTED,
        /**
         * Unspecified command error.
         */
        UNSPECIFIED_COMMAND_ERROR,
        /**
         * TPDU not supported.
         */
        TPDU_NOT_SUPPORTED,
        /**
         * SC busy.
         */
        SC_BUSY,
        /**
         * No SC subscription.
         */
        NO_SC_SUBSCRIPTION,
        /**
         * SC system failure.
         */
        SC_SYSTEM_FAILURE,
        /**
         * Invalid SME address.
         */
        INVALID_SME_ADDRESS,
        /**
         * Destination SME barred.
         */
        DESTINATION_SME_BARRED,
        /**
         * SM rejected or duplicate.
         */
        SM_REJECTED_OR_DUPLICATE,
        /**
         * TP-VPF not supported.
         */
        VPF_NOT_SUPPORTED,
        /**
         * TP-VP not supported.
         */
        VP_NOT_SUPPORTED,
        /**
         * SIM SMS storage full.
         */
        SIM_SMS_STORAGE_FULL,
        /**
         * No SMS storage capability in SIM.
         */
        NO_SMS_STORAGE_CAPABILITY_IN_SIM,
        /**
         * MS error.
         */
        MS_ERROR,
        /**
         * Memory capacity exceeded.
         */
        MEMORY_CAPACITY_EXCEEDED,
        /**
         * SIM application toolkit busy.
         */
        SIM_APPLICATION_TOOLKIT_BUSY,
        /**
         * SIM data download error.
         */
        SIM_DATA_DOWNLOAD_ERROR,
        /**
         * Unspecified error.
         */
        UNSPECIFIED_ERROR,
    }
    /**
     * Message class.
     */
    /**
     * Message class.
     */
    class WmsMessageClass {
        static $gtype: GObject.GType<WmsMessageClass>;

        // Static fields

        /**
         * Class 0.
         */
        static '0': number;
        /**
         * Class 1.
         */
        static '1': number;
        /**
         * Class 2.
         */
        static '2': number;
        /**
         * Class 3.
         */
        static '3': number;
        /**
         * Class none.
         */
        static NONE: number;
        /**
         * Class CDMA.
         */
        static CDMA: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Type of message delivery failure.
     */

    /**
     * Type of message delivery failure.
     */
    export namespace WmsMessageDeliveryFailureType {
        export const $gtype: GObject.GType<WmsMessageDeliveryFailureType>;
    }

    enum WmsMessageDeliveryFailureType {
        /**
         * Temporary failure.
         */
        TEMPORARY,
        /**
         * Permanent failure.
         */
        PERMANENT,
    }
    /**
     * Type of message.
     */

    /**
     * Type of message.
     */
    export namespace WmsMessageFormat {
        export const $gtype: GObject.GType<WmsMessageFormat>;
    }

    enum WmsMessageFormat {
        /**
         * CDMA message.
         */
        CDMA,
        /**
         * Point-to-point 3GPP message.
         */
        GSM_WCDMA_POINT_TO_POINT,
        /**
         * Broadcast 3GPP message.
         */
        GSM_WCDMA_BROADCAST,
        /**
         * Message Waiting Indicator.
         */
        MWI,
    }
    /**
     * Message mode.
     */

    /**
     * Message mode.
     */
    export namespace WmsMessageMode {
        export const $gtype: GObject.GType<WmsMessageMode>;
    }

    enum WmsMessageMode {
        /**
         * Message sent using 3GPP2 technologies.
         */
        CDMA,
        /**
         * Message sent using 3GPP technologies.
         */
        GSM_WCDMA,
    }
    /**
     * Type of message protocol.
     */

    /**
     * Type of message protocol.
     */
    export namespace WmsMessageProtocol {
        export const $gtype: GObject.GType<WmsMessageProtocol>;
    }

    enum WmsMessageProtocol {
        /**
         * CDMA.
         */
        CDMA,
        /**
         * WCDMA.
         */
        WCDMA,
    }
    /**
     * Type of message tag.
     */

    /**
     * Type of message tag.
     */
    export namespace WmsMessageTagType {
        export const $gtype: GObject.GType<WmsMessageTagType>;
    }

    enum WmsMessageTagType {
        /**
         * Received SMS, already read.
         */
        MT_READ,
        /**
         * Received SMS, not read.
         */
        MT_NOT_READ,
        /**
         * Sent SMS.
         */
        MO_SENT,
        /**
         * Not yet sent SMS.
         */
        MO_NOT_SENT,
    }
    /**
     * Type of message.
     */

    /**
     * Type of message.
     */
    export namespace WmsMessageType {
        export const $gtype: GObject.GType<WmsMessageType>;
    }

    enum WmsMessageType {
        /**
         * Point to point message.
         */
        POINT,
    }
    /**
     * Type of notification.
     */

    /**
     * Type of notification.
     */
    export namespace WmsNotificationType {
        export const $gtype: GObject.GType<WmsNotificationType>;
    }

    enum WmsNotificationType {
        /**
         * Primary.
         */
        PRIMARY,
        /**
         * Secondary GSM.
         */
        SECONDARY_GSM,
        /**
         * Secondary UMTS.
         */
        SECONDARY_UMTS,
    }
    /**
     * Action to perform when a message is received.
     */

    /**
     * Action to perform when a message is received.
     */
    export namespace WmsReceiptAction {
        export const $gtype: GObject.GType<WmsReceiptAction>;
    }

    enum WmsReceiptAction {
        /**
         * Discard message.
         */
        DISCARD,
        /**
         * Store and notify to client.
         */
        STORE_AND_NOTIFY,
        /**
         * Notify to client, which should send back ACK.
         */
        TRANSFER_ONLY,
        /**
         * Notify to client and send back ACK.
         */
        TRANSFER_AND_ACK,
        /**
         * Unknown action.
         */
        UNKNOWN,
    }
    /**
     * Type of messaging storage.
     */

    /**
     * Type of messaging storage.
     */
    export namespace WmsStorageType {
        export const $gtype: GObject.GType<WmsStorageType>;
    }

    enum WmsStorageType {
        /**
         * Message stored in UIM.
         */
        UIM,
        /**
         * Message stored in non-volatile memory.
         */
        NV,
        /**
         * None.
         */
        NONE,
    }
    /**
     * Transfer indication actions.
     */

    /**
     * Transfer indication actions.
     */
    export namespace WmsTransferIndication {
        export const $gtype: GObject.GType<WmsTransferIndication>;
    }

    enum WmsTransferIndication {
        /**
         * Status reports transferred to the client.
         */
        CLIENT,
    }
    /**
     * A symbol specifying the broadcast CID.
     */
    const CID_BROADCAST: number;
    /**
     * A symbol specifying a special CID value that references no CID.
     */
    const CID_NONE: number;
    /**
     * Symbol defining the #QmiClient:client-cid property.
     */
    const CLIENT_CID: string;
    /**
     * Symbol defining the #QmiClient:client-device property.
     */
    const CLIENT_DEVICE: string;
    /**
     * Symbol defining the #QmiClient:client-service property.
     */
    const CLIENT_SERVICE: string;
    /**
     * Symbol defining the #QmiClient:client-valid property.
     */
    const CLIENT_VALID: string;
    /**
     * Symbol defining the #QmiClient:client-version-major property.
     */
    const CLIENT_VERSION_MAJOR: string;
    /**
     * Symbol defining the #QmiClient:client-version-minor property.
     */
    const CLIENT_VERSION_MINOR: string;
    /**
     * Symbol defining the common string prefix used for all libqmi errors in DBus.
     */
    const DBUS_ERROR_PREFIX: string;
    /**
     * Symbol defining the #QmiDevice:device-consecutive-timeouts property.
     */
    const DEVICE_CONSECUTIVE_TIMEOUTS: string;
    /**
     * Symbol defining the #QmiDevice:device-file property.
     */
    const DEVICE_FILE: string;
    /**
     * Symbol defining the maximum supported mux id.
     */
    const DEVICE_MUX_ID_MAX: number;
    /**
     * Symbol defining the minimum supported mux id.
     */
    const DEVICE_MUX_ID_MIN: number;
    /**
     * Symbol defining the mux id for an unbound interface. This value is also used
     * to indicate an invalid mux id.
     */
    const DEVICE_MUX_ID_UNBOUND: number;
    /**
     * Symbol defining the #QmiDevice:device-node property.
     *
     * <note><para>
     * This property is only available when the library is built with QRTR support.
     * </para></note>
     */
    const DEVICE_NODE: string;
    /**
     * Symbol defining the #QmiDevice:device-no-file-check property.
     */
    const DEVICE_NO_FILE_CHECK: string;
    /**
     * Symbol defining the #QmiDevice:device-proxy-path property.
     */
    const DEVICE_PROXY_PATH: string;
    /**
     * Symbol defining the #QmiDevice::indication signal.
     */
    const DEVICE_SIGNAL_INDICATION: string;
    /**
     * Symbol defining the #QmiDevice::device-removed signal.
     */
    const DEVICE_SIGNAL_REMOVED: string;
    /**
     * Symbol defining the #QmiDevice:device-wwan-iface property.
     */
    const DEVICE_WWAN_IFACE: string;
    /**
     * First byte of every QMI QMUX message.
     */
    const MESSAGE_QMUX_MARKER: number;
    /**
     * Fake header added by libqmi to re-use existing QMUX message parsers for QRTR messages.
     * QRTR QMI services with a service ID > 0xFF use this fake header where the service ID
     * is set to 16 bits instead of 8 bits. This header has no purpose outside of libqmi
     * and is never send to the actual device implementing these QMI services.
     */
    const MESSAGE_QRTR_MARKER: number;
    /**
     * Generic vendor id (0x0000).
     */
    const MESSAGE_VENDOR_GENERIC: number;
    /**
     * Symbol defining the #QmiProxy:qmi-proxy-n-clients property.
     */
    const PROXY_N_CLIENTS: string;
    /**
     * Symbol defining the default abstract socket name where the #QmiProxy will listen.
     */
    const PROXY_SOCKET_PATH: string;
    /**
     * The TX/RX rate information is unavailable or cannot be measured.
     */
    const WDS_RATE_UNAVAILABLE: number;
    /**
     * Gets the nickname string for the #QmiCoreError specified at `val`.
     * @param val a QmiCoreError.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function core_error_get_string(val: CoreError): string;
    function core_error_quark(): GLib.Quark;
    /**
     * Gets the nickname string for the #QmiDataEndpointType specified at `val`.
     * @param val a QmiDataEndpointType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function data_endpoint_type_get_string(val: DataEndpointType): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiDeviceAddLinkFlags in `mask`.
     * @param mask bitmask of QmiDeviceAddLinkFlags values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function device_add_link_flags_build_string_from_mask(mask: DeviceAddLinkFlags): string;
    /**
     * Gets the nickname string for the #QmiDeviceExpectedDataFormat specified at `val`.
     * @param val a QmiDeviceExpectedDataFormat.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function device_expected_data_format_get_string(val: DeviceExpectedDataFormat): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiDeviceOpenFlags in `mask`.
     * @param mask bitmask of QmiDeviceOpenFlags values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function device_open_flags_build_string_from_mask(mask: DeviceOpenFlags): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiDeviceReleaseClientFlags in `mask`.
     * @param mask bitmask of QmiDeviceReleaseClientFlags values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function device_release_client_flags_build_string_from_mask(mask: DeviceReleaseClientFlags): string;
    /**
     * Gets the nickname string for the #QmiDmsActivationState specified at `val`.
     * @param val a QmiDmsActivationState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_activation_state_get_string(val: DmsActivationState): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiDmsBandCapability in `mask`.
     * @param mask bitmask of QmiDmsBandCapability values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function dms_band_capability_build_string_from_mask(mask: DmsBandCapability): string;
    /**
     * Gets the nickname string for the #QmiDmsBootImageDownloadMode specified at `val`.
     * @param val a QmiDmsBootImageDownloadMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_boot_image_download_mode_get_string(val: DmsBootImageDownloadMode): string;
    /**
     * Gets the nickname string for the #QmiDmsDataServiceCapability specified at `val`.
     * @param val a QmiDmsDataServiceCapability.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_data_service_capability_get_string(val: DmsDataServiceCapability): string;
    /**
     * Gets the nickname string for the #QmiDmsFirmwareImageType specified at `val`.
     * @param val a QmiDmsFirmwareImageType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_firmware_image_type_get_string(val: DmsFirmwareImageType): string;
    /**
     * Gets the nickname string for the #QmiDmsFoxconnDeviceMode specified at `val`.
     * @param val a QmiDmsFoxconnDeviceMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_foxconn_device_mode_get_string(val: DmsFoxconnDeviceMode): string;
    /**
     * Gets the nickname string for the #QmiDmsFoxconnFirmwareVersionType specified at `val`.
     * @param val a QmiDmsFoxconnFirmwareVersionType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_foxconn_firmware_version_type_get_string(val: DmsFoxconnFirmwareVersionType): string;
    /**
     * Gets the nickname string for the #QmiDmsHpDeviceMode specified at `val`.
     * @param val a QmiDmsHpDeviceMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_hp_device_mode_get_string(val: DmsHpDeviceMode): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiDmsLteBandCapability in `mask`.
     * @param mask bitmask of QmiDmsLteBandCapability values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function dms_lte_band_capability_build_string_from_mask(mask: DmsLteBandCapability): string;
    /**
     * Gets the nickname string for the #QmiDmsMacType specified at `val`.
     * @param val a QmiDmsMacType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_mac_type_get_string(val: DmsMacType): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiDmsOfflineReason in `mask`.
     * @param mask bitmask of QmiDmsOfflineReason values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function dms_offline_reason_build_string_from_mask(mask: DmsOfflineReason): string;
    /**
     * Gets the nickname string for the #QmiDmsOperatingMode specified at `val`.
     * @param val a QmiDmsOperatingMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_operating_mode_get_string(val: DmsOperatingMode): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiDmsPowerState in `mask`.
     * @param mask bitmask of QmiDmsPowerState values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function dms_power_state_build_string_from_mask(mask: DmsPowerState): string;
    /**
     * Gets the nickname string for the #QmiDmsRadioInterface specified at `val`.
     * @param val a QmiDmsRadioInterface.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_radio_interface_get_string(val: DmsRadioInterface): string;
    /**
     * Gets the nickname string for the #QmiDmsSimCapability specified at `val`.
     * @param val a QmiDmsSimCapability.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_sim_capability_get_string(val: DmsSimCapability): string;
    /**
     * Gets a text description of the Sierra Wireless USB composition.
     * @param value a #QmiDmsSwiUsbComposition.
     * @returns a string.
     */
    function dms_swi_usb_composition_get_description(value: DmsSwiUsbComposition): string;
    /**
     * Gets the nickname string for the #QmiDmsSwiUsbComposition specified at `val`.
     * @param val a QmiDmsSwiUsbComposition.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_swi_usb_composition_get_string(val: DmsSwiUsbComposition): string;
    /**
     * Gets the nickname string for the #QmiDmsTimeReferenceType specified at `val`.
     * @param val a QmiDmsTimeReferenceType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_time_reference_type_get_string(val: DmsTimeReferenceType): string;
    /**
     * Gets the nickname string for the #QmiDmsTimeSource specified at `val`.
     * @param val a QmiDmsTimeSource.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_time_source_get_string(val: DmsTimeSource): string;
    /**
     * Gets the nickname string for the #QmiDmsUimFacility specified at `val`.
     * @param val a QmiDmsUimFacility.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_uim_facility_get_string(val: DmsUimFacility): string;
    /**
     * Gets the nickname string for the #QmiDmsUimFacilityState specified at `val`.
     * @param val a QmiDmsUimFacilityState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_uim_facility_state_get_string(val: DmsUimFacilityState): string;
    /**
     * Gets the nickname string for the #QmiDmsUimPinId specified at `val`.
     * @param val a QmiDmsUimPinId.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_uim_pin_id_get_string(val: DmsUimPinId): string;
    /**
     * Gets the nickname string for the #QmiDmsUimPinStatus specified at `val`.
     * @param val a QmiDmsUimPinStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_uim_pin_status_get_string(val: DmsUimPinStatus): string;
    /**
     * Gets the nickname string for the #QmiDmsUimState specified at `val`.
     * @param val a QmiDmsUimState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dms_uim_state_get_string(val: DmsUimState): string;
    /**
     * Gets the nickname string for the #QmiDsdApnType specified at `val`.
     * @param val a QmiDsdApnType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dsd_apn_type_get_string(val: DsdApnType): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiDsdApnTypePreference in `mask`.
     * @param mask bitmask of QmiDsdApnTypePreference values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function dsd_apn_type_preference_build_string_from_mask(mask: DsdApnTypePreference): string;
    /**
     * Gets the nickname string for the #QmiDsdDataSystemNetworkType specified at `val`.
     * @param val a QmiDsdDataSystemNetworkType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dsd_data_system_network_type_get_string(val: DsdDataSystemNetworkType): string;
    /**
     * Gets the nickname string for the #QmiDsdRadioAccessTechnology specified at `val`.
     * @param val a QmiDsdRadioAccessTechnology.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function dsd_radio_access_technology_get_string(val: DsdRadioAccessTechnology): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiDsdSoMask in `mask`.
     * @param mask bitmask of QmiDsdSoMask values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function dsd_so_mask_build_string_from_mask(mask: DsdSoMask): string;
    /**
     * Gets the nickname string for the #QmiEndian specified at `val`.
     * @param val a QmiEndian.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function endian_get_string(val: Endian): string;
    /**
     * Gets the nickname string for the #QmiFoxFirmwareVersionType specified at `val`.
     * @param val a QmiFoxFirmwareVersionType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function fox_firmware_version_type_get_string(val: FoxFirmwareVersionType): string;
    /**
     * Gets the nickname string for the #QmiGasFirmwareListingMode specified at `val`.
     * @param val a QmiGasFirmwareListingMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function gas_firmware_listing_mode_get_string(val: GasFirmwareListingMode): string;
    /**
     * Gets the nickname string for the #QmiGasUsbCompositionEndpointType specified at `val`.
     * @param val a QmiGasUsbCompositionEndpointType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function gas_usb_composition_endpoint_type_get_string(val: GasUsbCompositionEndpointType): string;
    /**
     * Gets the nickname string for the #QmiImsaImsRegistrationStatus specified at `val`.
     * @param val a QmiImsaImsRegistrationStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function imsa_ims_registration_status_get_string(val: ImsaImsRegistrationStatus): string;
    /**
     * Gets the nickname string for the #QmiImsaRegistrationTechnology specified at `val`.
     * @param val a QmiImsaRegistrationTechnology.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function imsa_registration_technology_get_string(val: ImsaRegistrationTechnology): string;
    /**
     * Gets the nickname string for the #QmiImsaServiceStatus specified at `val`.
     * @param val a QmiImsaServiceStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function imsa_service_status_get_string(val: ImsaServiceStatus): string;
    /**
     * Gets the nickname string for the #QmiImspEnablerState specified at `val`.
     * @param val a QmiImspEnablerState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function imsp_enabler_state_get_string(val: ImspEnablerState): string;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationAtrReceivedOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationAtrReceivedOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_atr_received_output_unref().
     */
    function indication_atr_received_indication_parse(message: Message): IndicationAtrReceivedOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationDmsEventReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationDmsEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_dms_event_report_output_unref().
     */
    function indication_dms_event_report_indication_parse(message: Message): IndicationDmsEventReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationDsdSystemStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationDsdSystemStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_dsd_system_status_output_unref().
     */
    function indication_dsd_system_status_indication_parse(message: Message): IndicationDsdSystemStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocDeleteAssistanceDataOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocDeleteAssistanceDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_delete_assistance_data_output_unref().
     */
    function indication_loc_delete_assistance_data_indication_parse(
        message: Message,
    ): IndicationLocDeleteAssistanceDataOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocEngineStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocEngineStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_engine_state_output_unref().
     */
    function indication_loc_engine_state_indication_parse(message: Message): IndicationLocEngineStateOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocFixRecurrenceTypeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocFixRecurrenceTypeOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_fix_recurrence_type_output_unref().
     */
    function indication_loc_fix_recurrence_type_indication_parse(
        message: Message,
    ): IndicationLocFixRecurrenceTypeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocGetEngineLockOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocGetEngineLockOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_get_engine_lock_output_unref().
     */
    function indication_loc_get_engine_lock_indication_parse(message: Message): IndicationLocGetEngineLockOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocGetNmeaTypesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocGetNmeaTypesOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_get_nmea_types_output_unref().
     */
    function indication_loc_get_nmea_types_indication_parse(message: Message): IndicationLocGetNmeaTypesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocGetOperationModeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocGetOperationModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_get_operation_mode_output_unref().
     */
    function indication_loc_get_operation_mode_indication_parse(message: Message): IndicationLocGetOperationModeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocGetPredictedOrbitsDataSourceOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocGetPredictedOrbitsDataSourceOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_get_predicted_orbits_data_source_output_unref().
     */
    function indication_loc_get_predicted_orbits_data_source_indication_parse(
        message: Message,
    ): IndicationLocGetPredictedOrbitsDataSourceOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocGetServerOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocGetServerOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_get_server_output_unref().
     */
    function indication_loc_get_server_indication_parse(message: Message): IndicationLocGetServerOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocGnssSvInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocGnssSvInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_gnss_sv_info_output_unref().
     */
    function indication_loc_gnss_sv_info_indication_parse(message: Message): IndicationLocGnssSvInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocInjectPredictedOrbitsDataOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocInjectPredictedOrbitsDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_inject_predicted_orbits_data_output_unref().
     */
    function indication_loc_inject_predicted_orbits_data_indication_parse(
        message: Message,
    ): IndicationLocInjectPredictedOrbitsDataOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocInjectXtraDataOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocInjectXtraDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_inject_xtra_data_output_unref().
     */
    function indication_loc_inject_xtra_data_indication_parse(message: Message): IndicationLocInjectXtraDataOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocNmeaOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocNmeaOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_nmea_output_unref().
     */
    function indication_loc_nmea_indication_parse(message: Message): IndicationLocNmeaOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocPositionReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocPositionReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_position_report_output_unref().
     */
    function indication_loc_position_report_indication_parse(message: Message): IndicationLocPositionReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocSetEngineLockOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocSetEngineLockOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_set_engine_lock_output_unref().
     */
    function indication_loc_set_engine_lock_indication_parse(message: Message): IndicationLocSetEngineLockOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocSetNmeaTypesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocSetNmeaTypesOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_set_nmea_types_output_unref().
     */
    function indication_loc_set_nmea_types_indication_parse(message: Message): IndicationLocSetNmeaTypesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocSetOperationModeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocSetOperationModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_set_operation_mode_output_unref().
     */
    function indication_loc_set_operation_mode_indication_parse(message: Message): IndicationLocSetOperationModeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationLocSetServerOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationLocSetServerOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_loc_set_server_output_unref().
     */
    function indication_loc_set_server_indication_parse(message: Message): IndicationLocSetServerOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationNasEventReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationNasEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_nas_event_report_output_unref().
     */
    function indication_nas_event_report_indication_parse(message: Message): IndicationNasEventReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationNasNetworkRejectOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationNasNetworkRejectOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_nas_network_reject_output_unref().
     */
    function indication_nas_network_reject_indication_parse(message: Message): IndicationNasNetworkRejectOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationNasNetworkTimeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationNasNetworkTimeOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_nas_network_time_output_unref().
     */
    function indication_nas_network_time_indication_parse(message: Message): IndicationNasNetworkTimeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationNasOperatorNameOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationNasOperatorNameOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_nas_operator_name_output_unref().
     */
    function indication_nas_operator_name_indication_parse(message: Message): IndicationNasOperatorNameOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationNasServingSystemOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationNasServingSystemOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_nas_serving_system_output_unref().
     */
    function indication_nas_serving_system_indication_parse(message: Message): IndicationNasServingSystemOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationNasSignalInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationNasSignalInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_nas_signal_info_output_unref().
     */
    function indication_nas_signal_info_indication_parse(message: Message): IndicationNasSignalInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationNasSystemInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationNasSystemInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_nas_system_info_output_unref().
     */
    function indication_nas_system_info_indication_parse(message: Message): IndicationNasSystemInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationOmaEventReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationOmaEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_oma_event_report_output_unref().
     */
    function indication_oma_event_report_indication_parse(message: Message): IndicationOmaEventReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationPdcActivateConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationPdcActivateConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_pdc_activate_config_output_unref().
     */
    function indication_pdc_activate_config_indication_parse(message: Message): IndicationPdcActivateConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationPdcDeactivateConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationPdcDeactivateConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_pdc_deactivate_config_output_unref().
     */
    function indication_pdc_deactivate_config_indication_parse(message: Message): IndicationPdcDeactivateConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationPdcGetConfigInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationPdcGetConfigInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_pdc_get_config_info_output_unref().
     */
    function indication_pdc_get_config_info_indication_parse(message: Message): IndicationPdcGetConfigInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationPdcGetSelectedConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationPdcGetSelectedConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_pdc_get_selected_config_output_unref().
     */
    function indication_pdc_get_selected_config_indication_parse(
        message: Message,
    ): IndicationPdcGetSelectedConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationPdcListConfigsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationPdcListConfigsOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_pdc_list_configs_output_unref().
     */
    function indication_pdc_list_configs_indication_parse(message: Message): IndicationPdcListConfigsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationPdcLoadConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationPdcLoadConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_pdc_load_config_output_unref().
     */
    function indication_pdc_load_config_indication_parse(message: Message): IndicationPdcLoadConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationPdcRefreshOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationPdcRefreshOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_pdc_refresh_output_unref().
     */
    function indication_pdc_refresh_indication_parse(message: Message): IndicationPdcRefreshOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationPdcSetSelectedConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationPdcSetSelectedConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_pdc_set_selected_config_output_unref().
     */
    function indication_pdc_set_selected_config_indication_parse(
        message: Message,
    ): IndicationPdcSetSelectedConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationPdsEventReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationPdsEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_pds_event_report_output_unref().
     */
    function indication_pds_event_report_indication_parse(message: Message): IndicationPdsEventReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationQosFlowStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationQosFlowStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_qos_flow_status_output_unref().
     */
    function indication_qos_flow_status_indication_parse(message: Message): IndicationQosFlowStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationQosNetworkStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationQosNetworkStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_qos_network_status_output_unref().
     */
    function indication_qos_network_status_indication_parse(message: Message): IndicationQosNetworkStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationSscReportLargeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationSscReportLargeOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_ssc_report_large_output_unref().
     */
    function indication_ssc_report_large_indication_parse(message: Message): IndicationSscReportLargeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationSscReportSmallOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationSscReportSmallOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_ssc_report_small_output_unref().
     */
    function indication_ssc_report_small_indication_parse(message: Message): IndicationSscReportSmallOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationUimCardStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationUimCardStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_uim_card_status_output_unref().
     */
    function indication_uim_card_status_indication_parse(message: Message): IndicationUimCardStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationUimRefreshOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationUimRefreshOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_uim_refresh_output_unref().
     */
    function indication_uim_refresh_indication_parse(message: Message): IndicationUimRefreshOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationUimSlotStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationUimSlotStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_uim_slot_status_output_unref().
     */
    function indication_uim_slot_status_indication_parse(message: Message): IndicationUimSlotStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationVoiceAllCallStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationVoiceAllCallStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_voice_all_call_status_output_unref().
     */
    function indication_voice_all_call_status_indication_parse(message: Message): IndicationVoiceAllCallStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationVoiceOriginateUssdNoWaitOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationVoiceOriginateUssdNoWaitOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_voice_originate_ussd_no_wait_output_unref().
     */
    function indication_voice_originate_ussd_no_wait_indication_parse(
        message: Message,
    ): IndicationVoiceOriginateUssdNoWaitOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationVoiceSupplementaryServiceOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationVoiceSupplementaryServiceOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_voice_supplementary_service_output_unref().
     */
    function indication_voice_supplementary_service_indication_parse(
        message: Message,
    ): IndicationVoiceSupplementaryServiceOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationVoiceUssdOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationVoiceUssdOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_voice_ussd_output_unref().
     */
    function indication_voice_ussd_indication_parse(message: Message): IndicationVoiceUssdOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationWdsEventReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationWdsEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_wds_event_report_output_unref().
     */
    function indication_wds_event_report_indication_parse(message: Message): IndicationWdsEventReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationWdsExtendedIpConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationWdsExtendedIpConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_wds_extended_ip_config_output_unref().
     */
    function indication_wds_extended_ip_config_indication_parse(message: Message): IndicationWdsExtendedIpConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationWdsPacketServiceStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationWdsPacketServiceStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_wds_packet_service_status_output_unref().
     */
    function indication_wds_packet_service_status_indication_parse(
        message: Message,
    ): IndicationWdsPacketServiceStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationWdsProfileChangedOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationWdsProfileChangedOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_wds_profile_changed_output_unref().
     */
    function indication_wds_profile_changed_indication_parse(message: Message): IndicationWdsProfileChangedOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationWdsSetLteAttachPdnListOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationWdsSetLteAttachPdnListOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_wds_set_lte_attach_pdn_list_output_unref().
     */
    function indication_wds_set_lte_attach_pdn_list_indication_parse(
        message: Message,
    ): IndicationWdsSetLteAttachPdnListOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationWmsEventReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationWmsEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_wms_event_report_output_unref().
     */
    function indication_wms_event_report_indication_parse(message: Message): IndicationWmsEventReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiIndicationWmsSmscAddressOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiIndicationWmsSmscAddressOutput, or %NULL if @error is set. The returned value should be freed with qmi_indication_wms_smsc_address_output_unref().
     */
    function indication_wms_smsc_address_indication_parse(message: Message): IndicationWmsSmscAddressOutput;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiLocDeleteCellDatabase in `mask`.
     * @param mask bitmask of QmiLocDeleteCellDatabase values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function loc_delete_cell_database_build_string_from_mask(mask: LocDeleteCellDatabase): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiLocDeleteClockInfo in `mask`.
     * @param mask bitmask of QmiLocDeleteClockInfo values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function loc_delete_clock_info_build_string_from_mask(mask: LocDeleteClockInfo): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiLocDeleteGnssData in `mask`.
     * @param mask bitmask of QmiLocDeleteGnssData values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function loc_delete_gnss_data_build_string_from_mask(mask: LocDeleteGnssData): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiLocDeleteSvInfo in `mask`.
     * @param mask bitmask of QmiLocDeleteSvInfo values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function loc_delete_sv_info_build_string_from_mask(mask: LocDeleteSvInfo): string;
    /**
     * Gets the nickname string for the #QmiLocEngineState specified at `val`.
     * @param val a QmiLocEngineState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_engine_state_get_string(val: LocEngineState): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiLocEventRegistrationFlag in `mask`.
     * @param mask bitmask of QmiLocEventRegistrationFlag values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function loc_event_registration_flag_build_string_from_mask(mask: LocEventRegistrationFlag): string;
    /**
     * Gets the nickname string for the #QmiLocFixRecurrenceType specified at `val`.
     * @param val a QmiLocFixRecurrenceType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_fix_recurrence_type_get_string(val: LocFixRecurrenceType): string;
    /**
     * Gets the nickname string for the #QmiLocHealthStatus specified at `val`.
     * @param val a QmiLocHealthStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_health_status_get_string(val: LocHealthStatus): string;
    /**
     * Gets the nickname string for the #QmiLocIndicationStatus specified at `val`.
     * @param val a QmiLocIndicationStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_indication_status_get_string(val: LocIndicationStatus): string;
    /**
     * Gets the nickname string for the #QmiLocIntermediateReportState specified at `val`.
     * @param val a QmiLocIntermediateReportState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_intermediate_report_state_get_string(val: LocIntermediateReportState): string;
    /**
     * Gets the nickname string for the #QmiLocLockType specified at `val`.
     * @param val a QmiLocLockType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_lock_type_get_string(val: LocLockType): string;
    /**
     * Gets the nickname string for the #QmiLocNavigationData specified at `val`.
     * @param val a QmiLocNavigationData.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_navigation_data_get_string(val: LocNavigationData): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiLocNmeaType in `mask`.
     * @param mask bitmask of QmiLocNmeaType values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function loc_nmea_type_build_string_from_mask(mask: LocNmeaType): string;
    /**
     * Gets the nickname string for the #QmiLocOperationMode specified at `val`.
     * @param val a QmiLocOperationMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_operation_mode_get_string(val: LocOperationMode): string;
    /**
     * Gets the nickname string for the #QmiLocPredictedOrbitsDataFormat specified at `val`.
     * @param val a QmiLocPredictedOrbitsDataFormat.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_predicted_orbits_data_format_get_string(val: LocPredictedOrbitsDataFormat): string;
    /**
     * Gets the nickname string for the #QmiLocReliability specified at `val`.
     * @param val a QmiLocReliability.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_reliability_get_string(val: LocReliability): string;
    /**
     * Gets the nickname string for the #QmiLocSatelliteStatus specified at `val`.
     * @param val a QmiLocSatelliteStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_satellite_status_get_string(val: LocSatelliteStatus): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiLocSatelliteValidInformation in `mask`.
     * @param mask bitmask of QmiLocSatelliteValidInformation values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function loc_satellite_valid_information_build_string_from_mask(mask: LocSatelliteValidInformation): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiLocSensorDataUsage in `mask`.
     * @param mask bitmask of QmiLocSensorDataUsage values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function loc_sensor_data_usage_build_string_from_mask(mask: LocSensorDataUsage): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiLocServerAddressType in `mask`.
     * @param mask bitmask of QmiLocServerAddressType values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function loc_server_address_type_build_string_from_mask(mask: LocServerAddressType): string;
    /**
     * Gets the nickname string for the #QmiLocServerType specified at `val`.
     * @param val a QmiLocServerType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_server_type_get_string(val: LocServerType): string;
    /**
     * Gets the nickname string for the #QmiLocSessionStatus specified at `val`.
     * @param val a QmiLocSessionStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_session_status_get_string(val: LocSessionStatus): string;
    /**
     * Gets the nickname string for the #QmiLocSystem specified at `val`.
     * @param val a QmiLocSystem.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_system_get_string(val: LocSystem): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiLocTechnologyUsed in `mask`.
     * @param mask bitmask of QmiLocTechnologyUsed values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function loc_technology_used_build_string_from_mask(mask: LocTechnologyUsed): string;
    /**
     * Gets the nickname string for the #QmiLocTimeSource specified at `val`.
     * @param val a QmiLocTimeSource.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function loc_time_source_get_string(val: LocTimeSource): string;
    /**
     * Creates a new `type` TLV with the value given in `raw,` and adds it to the #QmiMessage.
     * @param self a #QmiMessage.
     * @param type specific ID of the TLV to add.
     * @param raw raw data buffer with the value of the TLV.
     * @param length length of the raw data buffer.
     * @returns %TRUE if the TLV is successfully added, otherwise %FALSE is returned and @error is set.
     */
    function message_add_raw_tlv(self: Message, type: number, raw: number, length: number): boolean;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageAtrSendOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageAtrSendOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_atr_send_output_unref().
     */
    function message_atr_send_response_parse(message: Message): MessageAtrSendOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsActivateAutomaticOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsActivateAutomaticOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_activate_automatic_output_unref().
     */
    function message_dms_activate_automatic_response_parse(message: Message): MessageDmsActivateAutomaticOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsActivateManualOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsActivateManualOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_activate_manual_output_unref().
     */
    function message_dms_activate_manual_response_parse(message: Message): MessageDmsActivateManualOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsDeleteStoredImageOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsDeleteStoredImageOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_delete_stored_image_output_unref().
     */
    function message_dms_delete_stored_image_response_parse(message: Message): MessageDmsDeleteStoredImageOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsFoxconnChangeDeviceModeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsFoxconnChangeDeviceModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_foxconn_change_device_mode_output_unref().
     */
    function message_dms_foxconn_change_device_mode_response_parse(
        message: Message,
    ): MessageDmsFoxconnChangeDeviceModeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsFoxconnGetFirmwareVersionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsFoxconnGetFirmwareVersionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_foxconn_get_firmware_version_output_unref().
     */
    function message_dms_foxconn_get_firmware_version_response_parse(
        message: Message,
    ): MessageDmsFoxconnGetFirmwareVersionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsFoxconnSetFccAuthenticationOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsFoxconnSetFccAuthenticationOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_foxconn_set_fcc_authentication_output_unref().
     */
    function message_dms_foxconn_set_fcc_authentication_response_parse(
        message: Message,
    ): MessageDmsFoxconnSetFccAuthenticationOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsFoxconnSetFccAuthenticationV2Output out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsFoxconnSetFccAuthenticationV2Output, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_foxconn_set_fcc_authentication_v2_output_unref().
     */
    function message_dms_foxconn_set_fcc_authentication_v2_response_parse(
        message: Message,
    ): MessageDmsFoxconnSetFccAuthenticationV2Output;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetActivationStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetActivationStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_activation_state_output_unref().
     */
    function message_dms_get_activation_state_response_parse(message: Message): MessageDmsGetActivationStateOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetAltNetConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetAltNetConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_alt_net_config_output_unref().
     */
    function message_dms_get_alt_net_config_response_parse(message: Message): MessageDmsGetAltNetConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetBandCapabilitiesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetBandCapabilitiesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_band_capabilities_output_unref().
     */
    function message_dms_get_band_capabilities_response_parse(message: Message): MessageDmsGetBandCapabilitiesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetBootImageDownloadModeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetBootImageDownloadModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_boot_image_download_mode_output_unref().
     */
    function message_dms_get_boot_image_download_mode_response_parse(
        message: Message,
    ): MessageDmsGetBootImageDownloadModeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetCapabilitiesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetCapabilitiesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_capabilities_output_unref().
     */
    function message_dms_get_capabilities_response_parse(message: Message): MessageDmsGetCapabilitiesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetFactorySkuOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetFactorySkuOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_factory_sku_output_unref().
     */
    function message_dms_get_factory_sku_response_parse(message: Message): MessageDmsGetFactorySkuOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetFirmwarePreferenceOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetFirmwarePreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_firmware_preference_output_unref().
     */
    function message_dms_get_firmware_preference_response_parse(
        message: Message,
    ): MessageDmsGetFirmwarePreferenceOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetHardwareRevisionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetHardwareRevisionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_hardware_revision_output_unref().
     */
    function message_dms_get_hardware_revision_response_parse(message: Message): MessageDmsGetHardwareRevisionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetIdsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetIdsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_ids_output_unref().
     */
    function message_dms_get_ids_response_parse(message: Message): MessageDmsGetIdsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetMacAddressOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetMacAddressOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_mac_address_output_unref().
     */
    function message_dms_get_mac_address_response_parse(message: Message): MessageDmsGetMacAddressOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetManufacturerOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetManufacturerOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_manufacturer_output_unref().
     */
    function message_dms_get_manufacturer_response_parse(message: Message): MessageDmsGetManufacturerOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetModelOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetModelOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_model_output_unref().
     */
    function message_dms_get_model_response_parse(message: Message): MessageDmsGetModelOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetMsisdnOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetMsisdnOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_msisdn_output_unref().
     */
    function message_dms_get_msisdn_response_parse(message: Message): MessageDmsGetMsisdnOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetOperatingModeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetOperatingModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_operating_mode_output_unref().
     */
    function message_dms_get_operating_mode_response_parse(message: Message): MessageDmsGetOperatingModeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetPowerStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetPowerStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_power_state_output_unref().
     */
    function message_dms_get_power_state_response_parse(message: Message): MessageDmsGetPowerStateOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetPrlVersionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetPrlVersionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_prl_version_output_unref().
     */
    function message_dms_get_prl_version_response_parse(message: Message): MessageDmsGetPrlVersionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetRevisionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetRevisionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_revision_output_unref().
     */
    function message_dms_get_revision_response_parse(message: Message): MessageDmsGetRevisionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetSoftwareVersionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetSoftwareVersionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_software_version_output_unref().
     */
    function message_dms_get_software_version_response_parse(message: Message): MessageDmsGetSoftwareVersionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetStoredImageInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetStoredImageInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_stored_image_info_output_unref().
     */
    function message_dms_get_stored_image_info_response_parse(message: Message): MessageDmsGetStoredImageInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetSupportedMessagesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_supported_messages_output_unref().
     */
    function message_dms_get_supported_messages_response_parse(message: Message): MessageDmsGetSupportedMessagesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetTimeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetTimeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_time_output_unref().
     */
    function message_dms_get_time_response_parse(message: Message): MessageDmsGetTimeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsGetUserLockStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsGetUserLockStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_user_lock_state_output_unref().
     */
    function message_dms_get_user_lock_state_response_parse(message: Message): MessageDmsGetUserLockStateOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsHpChangeDeviceModeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsHpChangeDeviceModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_hp_change_device_mode_output_unref().
     */
    function message_dms_hp_change_device_mode_response_parse(message: Message): MessageDmsHpChangeDeviceModeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsListStoredImagesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsListStoredImagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_list_stored_images_output_unref().
     */
    function message_dms_list_stored_images_response_parse(message: Message): MessageDmsListStoredImagesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsReadEriFileOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsReadEriFileOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_read_eri_file_output_unref().
     */
    function message_dms_read_eri_file_response_parse(message: Message): MessageDmsReadEriFileOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsReadUserDataOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsReadUserDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_read_user_data_output_unref().
     */
    function message_dms_read_user_data_response_parse(message: Message): MessageDmsReadUserDataOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsResetOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_reset_output_unref().
     */
    function message_dms_reset_response_parse(message: Message): MessageDmsResetOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsRestoreFactoryDefaultsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsRestoreFactoryDefaultsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_restore_factory_defaults_output_unref().
     */
    function message_dms_restore_factory_defaults_response_parse(
        message: Message,
    ): MessageDmsRestoreFactoryDefaultsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSetAltNetConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSetAltNetConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_alt_net_config_output_unref().
     */
    function message_dms_set_alt_net_config_response_parse(message: Message): MessageDmsSetAltNetConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSetBootImageDownloadModeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSetBootImageDownloadModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_boot_image_download_mode_output_unref().
     */
    function message_dms_set_boot_image_download_mode_response_parse(
        message: Message,
    ): MessageDmsSetBootImageDownloadModeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSetEventReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_event_report_output_unref().
     */
    function message_dms_set_event_report_response_parse(message: Message): MessageDmsSetEventReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSetFccAuthenticationOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSetFccAuthenticationOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_fcc_authentication_output_unref().
     */
    function message_dms_set_fcc_authentication_response_parse(message: Message): MessageDmsSetFccAuthenticationOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSetFirmwareIdOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSetFirmwareIdOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_firmware_id_output_unref().
     */
    function message_dms_set_firmware_id_response_parse(message: Message): MessageDmsSetFirmwareIdOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSetFirmwarePreferenceOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSetFirmwarePreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_firmware_preference_output_unref().
     */
    function message_dms_set_firmware_preference_response_parse(
        message: Message,
    ): MessageDmsSetFirmwarePreferenceOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSetOperatingModeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSetOperatingModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_operating_mode_output_unref().
     */
    function message_dms_set_operating_mode_response_parse(message: Message): MessageDmsSetOperatingModeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSetServiceProgrammingCodeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSetServiceProgrammingCodeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_service_programming_code_output_unref().
     */
    function message_dms_set_service_programming_code_response_parse(
        message: Message,
    ): MessageDmsSetServiceProgrammingCodeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSetTimeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSetTimeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_time_output_unref().
     */
    function message_dms_set_time_response_parse(message: Message): MessageDmsSetTimeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSetUserLockCodeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSetUserLockCodeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_user_lock_code_output_unref().
     */
    function message_dms_set_user_lock_code_response_parse(message: Message): MessageDmsSetUserLockCodeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSetUserLockStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSetUserLockStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_user_lock_state_output_unref().
     */
    function message_dms_set_user_lock_state_response_parse(message: Message): MessageDmsSetUserLockStateOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSwiGetCurrentFirmwareOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSwiGetCurrentFirmwareOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_swi_get_current_firmware_output_unref().
     */
    function message_dms_swi_get_current_firmware_response_parse(
        message: Message,
    ): MessageDmsSwiGetCurrentFirmwareOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSwiGetUsbCompositionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSwiGetUsbCompositionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_swi_get_usb_composition_output_unref().
     */
    function message_dms_swi_get_usb_composition_response_parse(message: Message): MessageDmsSwiGetUsbCompositionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsSwiSetUsbCompositionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsSwiSetUsbCompositionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_swi_set_usb_composition_output_unref().
     */
    function message_dms_swi_set_usb_composition_response_parse(message: Message): MessageDmsSwiSetUsbCompositionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsUimChangePinOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsUimChangePinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_change_pin_output_unref().
     */
    function message_dms_uim_change_pin_response_parse(message: Message): MessageDmsUimChangePinOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsUimGetCkStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsUimGetCkStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_ck_status_output_unref().
     */
    function message_dms_uim_get_ck_status_response_parse(message: Message): MessageDmsUimGetCkStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsUimGetIccidOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsUimGetIccidOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_iccid_output_unref().
     */
    function message_dms_uim_get_iccid_response_parse(message: Message): MessageDmsUimGetIccidOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsUimGetImsiOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsUimGetImsiOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_imsi_output_unref().
     */
    function message_dms_uim_get_imsi_response_parse(message: Message): MessageDmsUimGetImsiOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsUimGetPinStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsUimGetPinStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_pin_status_output_unref().
     */
    function message_dms_uim_get_pin_status_response_parse(message: Message): MessageDmsUimGetPinStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsUimGetStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsUimGetStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_state_output_unref().
     */
    function message_dms_uim_get_state_response_parse(message: Message): MessageDmsUimGetStateOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsUimSetCkProtectionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsUimSetCkProtectionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_set_ck_protection_output_unref().
     */
    function message_dms_uim_set_ck_protection_response_parse(message: Message): MessageDmsUimSetCkProtectionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsUimSetPinProtectionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsUimSetPinProtectionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_set_pin_protection_output_unref().
     */
    function message_dms_uim_set_pin_protection_response_parse(message: Message): MessageDmsUimSetPinProtectionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsUimUnblockCkOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsUimUnblockCkOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_unblock_ck_output_unref().
     */
    function message_dms_uim_unblock_ck_response_parse(message: Message): MessageDmsUimUnblockCkOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsUimUnblockPinOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsUimUnblockPinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_unblock_pin_output_unref().
     */
    function message_dms_uim_unblock_pin_response_parse(message: Message): MessageDmsUimUnblockPinOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsUimVerifyPinOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsUimVerifyPinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_verify_pin_output_unref().
     */
    function message_dms_uim_verify_pin_response_parse(message: Message): MessageDmsUimVerifyPinOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsValidateServiceProgrammingCodeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsValidateServiceProgrammingCodeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_validate_service_programming_code_output_unref().
     */
    function message_dms_validate_service_programming_code_response_parse(
        message: Message,
    ): MessageDmsValidateServiceProgrammingCodeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDmsWriteUserDataOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDmsWriteUserDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_write_user_data_output_unref().
     */
    function message_dms_write_user_data_response_parse(message: Message): MessageDmsWriteUserDataOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDpmClosePortOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDpmClosePortOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dpm_close_port_output_unref().
     */
    function message_dpm_close_port_response_parse(message: Message): MessageDpmClosePortOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDpmOpenPortOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDpmOpenPortOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dpm_open_port_output_unref().
     */
    function message_dpm_open_port_response_parse(message: Message): MessageDpmOpenPortOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDsdGetApnInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDsdGetApnInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dsd_get_apn_info_output_unref().
     */
    function message_dsd_get_apn_info_response_parse(message: Message): MessageDsdGetApnInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDsdGetSystemStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDsdGetSystemStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dsd_get_system_status_output_unref().
     */
    function message_dsd_get_system_status_response_parse(message: Message): MessageDsdGetSystemStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDsdSetApnTypeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDsdSetApnTypeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dsd_set_apn_type_output_unref().
     */
    function message_dsd_set_apn_type_response_parse(message: Message): MessageDsdSetApnTypeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageDsdSystemStatusChangeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageDsdSystemStatusChangeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dsd_system_status_change_output_unref().
     */
    function message_dsd_system_status_change_response_parse(message: Message): MessageDsdSystemStatusChangeOutput;
    /**
     * Calls the given function for each TLV found within the #QmiMessage.
     * @param self a #QmiMessage.
     */
    function message_foreach_raw_tlv(self: Message): void;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageFoxGetFirmwareVersionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageFoxGetFirmwareVersionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_fox_get_firmware_version_output_unref().
     */
    function message_fox_get_firmware_version_response_parse(message: Message): MessageFoxGetFirmwareVersionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageGasDmsGetFirmwareListOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageGasDmsGetFirmwareListOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_gas_dms_get_firmware_list_output_unref().
     */
    function message_gas_dms_get_firmware_list_response_parse(message: Message): MessageGasDmsGetFirmwareListOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageGasDmsGetUsbCompositionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageGasDmsGetUsbCompositionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_gas_dms_get_usb_composition_output_unref().
     */
    function message_gas_dms_get_usb_composition_response_parse(message: Message): MessageGasDmsGetUsbCompositionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageGasDmsSetActiveFirmwareOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageGasDmsSetActiveFirmwareOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_gas_dms_set_active_firmware_output_unref().
     */
    function message_gas_dms_set_active_firmware_response_parse(message: Message): MessageGasDmsSetActiveFirmwareOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageGasDmsSetUsbCompositionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageGasDmsSetUsbCompositionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_gas_dms_set_usb_composition_output_unref().
     */
    function message_gas_dms_set_usb_composition_response_parse(message: Message): MessageGasDmsSetUsbCompositionOutput;
    /**
     * Gets the client ID of the message.
     * @param self a #QmiMessage.
     * @returns the client ID.
     */
    function message_get_client_id(self: Message): number;
    /**
     * Gets the data buffer of the #QmiMessage without the QMUX header.
     * @param self a #QmiMessage.
     * @returns The raw QMI buffer, or %NULL if @error is set.
     */
    function message_get_data(self: Message): [number, number];
    /**
     * Gets the length of the raw data corresponding to the given #QmiMessage.
     * @param self a #QmiMessage.
     * @returns the length of the raw data.
     */
    function message_get_length(self: Message): number;
    /**
     * Gets the marker of the #QmiMessage.
     * @param self a #QmiMessage.
     * @returns The message marker.
     */
    function message_get_marker(self: Message): number;
    /**
     * Gets the ID of the message.
     * @param self a #QmiMessage.
     * @returns the ID.
     */
    function message_get_message_id(self: Message): number;
    /**
     * Gets a printable string with the contents of the whole QMI message.
     *
     * If known, the printable string will contain translated TLV values as well as
     * the raw data buffer contents.
     *
     * The translation of the contents may be specific to the `context` provided,
     * e.g. for vendor-specific messages.
     *
     * If no `context` given, the behavior is the same as qmi_message_get_printable().
     * @param self a #QmiMessage.
     * @param context a #QmiMessageContext.
     * @param line_prefix prefix string to use in each new generated line.
     * @returns a newly allocated string, which should be freed with g_free().
     */
    function message_get_printable_full(self: Message, context: MessageContext, line_prefix: string): string;
    /**
     * Gets the raw data buffer of the #QmiMessage.
     * @param self a #QmiMessage.
     * @returns The raw data buffer, or %NULL if @error is set.
     */
    function message_get_raw(self: Message): [number, number];
    /**
     * Get the raw data buffer of a specific TLV within the #QmiMessage.
     * @param self a #QmiMessage.
     * @param type specific ID of the TLV to get.
     * @returns The raw data buffer of the TLV, or %NULL if not found.
     */
    function message_get_raw_tlv(self: Message, type: number): [number, number];
    /**
     * Gets the service corresponding to the given #QmiMessage.
     * @param self a #QmiMessage.
     * @returns a #QmiService.
     */
    function message_get_service(self: Message): Service;
    /**
     * Gets a printable string with the contents of the TLV.
     *
     * This method is the most generic one and doesn't try to translate the TLV contents.
     * @param self a #QmiMessage.
     * @param line_prefix prefix string to use in each new generated line.
     * @param type type of the TLV.
     * @param raw raw data buffer with the value of the TLV.
     * @param raw_length length of the raw data buffer.
     * @returns a newly allocated string, which should be freed with g_free().
     */
    function message_get_tlv_printable(
        self: Message,
        line_prefix: string,
        type: number,
        raw: number,
        raw_length: number,
    ): string;
    /**
     * Gets the transaction ID of the message.
     * @param self a #QmiMessage.
     * @returns the transaction ID.
     */
    function message_get_transaction_id(self: Message): number;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageGmsTestGetValueOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageGmsTestGetValueOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_gms_test_get_value_output_unref().
     */
    function message_gms_test_get_value_response_parse(message: Message): MessageGmsTestGetValueOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageGmsTestSetValueOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageGmsTestSetValueOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_gms_test_set_value_output_unref().
     */
    function message_gms_test_set_value_response_parse(message: Message): MessageGmsTestSetValueOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageImsGetImsServicesEnabledSettingOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageImsGetImsServicesEnabledSettingOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_ims_get_ims_services_enabled_setting_output_unref().
     */
    function message_ims_get_ims_services_enabled_setting_response_parse(
        message: Message,
    ): MessageImsGetImsServicesEnabledSettingOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageImsaGetImsRegistrationStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageImsaGetImsRegistrationStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_imsa_get_ims_registration_status_output_unref().
     */
    function message_imsa_get_ims_registration_status_response_parse(
        message: Message,
    ): MessageImsaGetImsRegistrationStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageImsaGetImsServicesStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageImsaGetImsServicesStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_imsa_get_ims_services_status_output_unref().
     */
    function message_imsa_get_ims_services_status_response_parse(
        message: Message,
    ): MessageImsaGetImsServicesStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageImspGetEnablerStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageImspGetEnablerStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_imsp_get_enabler_state_output_unref().
     */
    function message_imsp_get_enabler_state_response_parse(message: Message): MessageImspGetEnablerStateOutput;
    /**
     * Checks whether the given #QmiMessage is an indication.
     * @param self a #QmiMessage.
     * @returns %TRUE if @self is an indication message, %FALSE otherwise.
     */
    function message_is_indication(self: Message): boolean;
    /**
     * Checks whether the given #QmiMessage is a request.
     * @param self a #QmiMessage.
     * @returns %TRUE if @self is a request message, %FALSE otherwise.
     */
    function message_is_request(self: Message): boolean;
    /**
     * Checks whether the given #QmiMessage is a response.
     * @param self a #QmiMessage.
     * @returns %TRUE if @self is a response message, %FALSE otherwise.
     */
    function message_is_response(self: Message): boolean;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocDeleteAssistanceDataOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocDeleteAssistanceDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_delete_assistance_data_output_unref().
     */
    function message_loc_delete_assistance_data_response_parse(message: Message): MessageLocDeleteAssistanceDataOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocGetEngineLockOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocGetEngineLockOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_get_engine_lock_output_unref().
     */
    function message_loc_get_engine_lock_response_parse(message: Message): MessageLocGetEngineLockOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocGetNmeaTypesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocGetNmeaTypesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_get_nmea_types_output_unref().
     */
    function message_loc_get_nmea_types_response_parse(message: Message): MessageLocGetNmeaTypesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocGetOperationModeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocGetOperationModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_get_operation_mode_output_unref().
     */
    function message_loc_get_operation_mode_response_parse(message: Message): MessageLocGetOperationModeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocGetPredictedOrbitsDataSourceOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocGetPredictedOrbitsDataSourceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_get_predicted_orbits_data_source_output_unref().
     */
    function message_loc_get_predicted_orbits_data_source_response_parse(
        message: Message,
    ): MessageLocGetPredictedOrbitsDataSourceOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocGetServerOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocGetServerOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_get_server_output_unref().
     */
    function message_loc_get_server_response_parse(message: Message): MessageLocGetServerOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocInjectPredictedOrbitsDataOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocInjectPredictedOrbitsDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_inject_predicted_orbits_data_output_unref().
     */
    function message_loc_inject_predicted_orbits_data_response_parse(
        message: Message,
    ): MessageLocInjectPredictedOrbitsDataOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocInjectXtraDataOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocInjectXtraDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_inject_xtra_data_output_unref().
     */
    function message_loc_inject_xtra_data_response_parse(message: Message): MessageLocInjectXtraDataOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocRegisterEventsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocRegisterEventsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_register_events_output_unref().
     */
    function message_loc_register_events_response_parse(message: Message): MessageLocRegisterEventsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocSetEngineLockOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocSetEngineLockOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_set_engine_lock_output_unref().
     */
    function message_loc_set_engine_lock_response_parse(message: Message): MessageLocSetEngineLockOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocSetNmeaTypesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocSetNmeaTypesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_set_nmea_types_output_unref().
     */
    function message_loc_set_nmea_types_response_parse(message: Message): MessageLocSetNmeaTypesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocSetOperationModeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocSetOperationModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_set_operation_mode_output_unref().
     */
    function message_loc_set_operation_mode_response_parse(message: Message): MessageLocSetOperationModeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocSetServerOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocSetServerOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_set_server_output_unref().
     */
    function message_loc_set_server_response_parse(message: Message): MessageLocSetServerOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocStartOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocStartOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_start_output_unref().
     */
    function message_loc_start_response_parse(message: Message): MessageLocStartOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageLocStopOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageLocStopOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_stop_output_unref().
     */
    function message_loc_stop_response_parse(message: Message): MessageLocStopOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasAttachDetachOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasAttachDetachOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_attach_detach_output_unref().
     */
    function message_nas_attach_detach_response_parse(message: Message): MessageNasAttachDetachOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasConfigSignalInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasConfigSignalInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_config_signal_info_output_unref().
     */
    function message_nas_config_signal_info_response_parse(message: Message): MessageNasConfigSignalInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasConfigSignalInfoV2Output out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasConfigSignalInfoV2Output, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_config_signal_info_v2_output_unref().
     */
    function message_nas_config_signal_info_v2_response_parse(message: Message): MessageNasConfigSignalInfoV2Output;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasForceNetworkSearchOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasForceNetworkSearchOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_force_network_search_output_unref().
     */
    function message_nas_force_network_search_response_parse(message: Message): MessageNasForceNetworkSearchOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetCdmaPositionInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetCdmaPositionInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_cdma_position_info_output_unref().
     */
    function message_nas_get_cdma_position_info_response_parse(message: Message): MessageNasGetCdmaPositionInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetCellLocationInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetCellLocationInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_cell_location_info_output_unref().
     */
    function message_nas_get_cell_location_info_response_parse(message: Message): MessageNasGetCellLocationInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetDrxOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetDrxOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_drx_output_unref().
     */
    function message_nas_get_drx_response_parse(message: Message): MessageNasGetDrxOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetHomeNetworkOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetHomeNetworkOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_home_network_output_unref().
     */
    function message_nas_get_home_network_response_parse(message: Message): MessageNasGetHomeNetworkOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetLteCphyCaInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetLteCphyCaInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_lte_cphy_ca_info_output_unref().
     */
    function message_nas_get_lte_cphy_ca_info_response_parse(message: Message): MessageNasGetLteCphyCaInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetOperatorNameOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetOperatorNameOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_operator_name_output_unref().
     */
    function message_nas_get_operator_name_response_parse(message: Message): MessageNasGetOperatorNameOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetPlmnNameOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetPlmnNameOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_plmn_name_output_unref().
     */
    function message_nas_get_plmn_name_response_parse(message: Message): MessageNasGetPlmnNameOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetPreferredNetworksOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetPreferredNetworksOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_preferred_networks_output_unref().
     */
    function message_nas_get_preferred_networks_response_parse(message: Message): MessageNasGetPreferredNetworksOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetRfBandInformationOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetRfBandInformationOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_rf_band_information_output_unref().
     */
    function message_nas_get_rf_band_information_response_parse(message: Message): MessageNasGetRfBandInformationOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetServingSystemOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetServingSystemOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_serving_system_output_unref().
     */
    function message_nas_get_serving_system_response_parse(message: Message): MessageNasGetServingSystemOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetSignalInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetSignalInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_signal_info_output_unref().
     */
    function message_nas_get_signal_info_response_parse(message: Message): MessageNasGetSignalInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetSignalStrengthOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetSignalStrengthOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_signal_strength_output_unref().
     */
    function message_nas_get_signal_strength_response_parse(message: Message): MessageNasGetSignalStrengthOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetSupportedMessagesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_supported_messages_output_unref().
     */
    function message_nas_get_supported_messages_response_parse(message: Message): MessageNasGetSupportedMessagesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetSystemInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetSystemInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_system_info_output_unref().
     */
    function message_nas_get_system_info_response_parse(message: Message): MessageNasGetSystemInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetSystemSelectionPreferenceOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetSystemSelectionPreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_system_selection_preference_output_unref().
     */
    function message_nas_get_system_selection_preference_response_parse(
        message: Message,
    ): MessageNasGetSystemSelectionPreferenceOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetTechnologyPreferenceOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetTechnologyPreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_technology_preference_output_unref().
     */
    function message_nas_get_technology_preference_response_parse(
        message: Message,
    ): MessageNasGetTechnologyPreferenceOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasGetTxRxInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasGetTxRxInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_tx_rx_info_output_unref().
     */
    function message_nas_get_tx_rx_info_response_parse(message: Message): MessageNasGetTxRxInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasInitiateNetworkRegisterOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasInitiateNetworkRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_initiate_network_register_output_unref().
     */
    function message_nas_initiate_network_register_response_parse(
        message: Message,
    ): MessageNasInitiateNetworkRegisterOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasNetworkScanOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasNetworkScanOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_network_scan_output_unref().
     */
    function message_nas_network_scan_response_parse(message: Message): MessageNasNetworkScanOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasRegisterIndicationsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasRegisterIndicationsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_register_indications_output_unref().
     */
    function message_nas_register_indications_response_parse(message: Message): MessageNasRegisterIndicationsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasResetOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_reset_output_unref().
     */
    function message_nas_reset_response_parse(message: Message): MessageNasResetOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasSetEventReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_set_event_report_output_unref().
     */
    function message_nas_set_event_report_response_parse(message: Message): MessageNasSetEventReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasSetPreferredNetworksOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasSetPreferredNetworksOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_set_preferred_networks_output_unref().
     */
    function message_nas_set_preferred_networks_response_parse(message: Message): MessageNasSetPreferredNetworksOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasSetSystemSelectionPreferenceOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasSetSystemSelectionPreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_set_system_selection_preference_output_unref().
     */
    function message_nas_set_system_selection_preference_response_parse(
        message: Message,
    ): MessageNasSetSystemSelectionPreferenceOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasSetTechnologyPreferenceOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasSetTechnologyPreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_set_technology_preference_output_unref().
     */
    function message_nas_set_technology_preference_response_parse(
        message: Message,
    ): MessageNasSetTechnologyPreferenceOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageNasSwiGetStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageNasSwiGetStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_swi_get_status_output_unref().
     */
    function message_nas_swi_get_status_response_parse(message: Message): MessageNasSwiGetStatusOutput;
    /**
     * Create a new #QmiMessage with the specified parameters.
     *
     * Note that `transaction_id` must be less than #G_MAXUINT8 if `service` is
     * #QMI_SERVICE_CTL.
     * @param service a #QmiService
     * @param client_id client ID of the originating control point.
     * @param transaction_id transaction ID.
     * @param message_id message ID.
     * @returns a newly created #QmiMessage. The returned value should be freed with qmi_message_unref().
     */
    function message_new(service: Service, client_id: number, transaction_id: number, message_id: number): Message;
    /**
     * Create a new #QmiMessage for the given `service` and `client_id` and including the given QMI data buffer.
     *
     * Whenever a complete QMI message is read, its data gets removed from the `qmi_data` buffer.
     *
     * This method should be used instead of qmi_message_new_from_raw() if the input data doesn't have QMUX headers.
     * @param service a #QmiService
     * @param client_id client ID of the originating control point.
     * @param qmi_data data buffer containing only the QMI part of the message.
     * @returns a newly created #QmiMessage, which should be freed with qmi_message_unref(). If @qmi_data doesn't contain a complete QMI data payload %NULL is returned. If there is a complete QMI data payload but it appears not to be valid, %NULL is returned and @error is set.
     */
    function message_new_from_data(
        service: Service,
        client_id: number,
        qmi_data: Uint8Array | string,
    ): [Message, Uint8Array];
    /**
     * Create a new #QmiMessage from the given raw data buffer.
     *
     * Whenever a complete QMI message is read, its raw data gets removed from the `raw` buffer.
     * @param raw raw data buffer.
     * @returns a newly created #QmiMessage, which should be freed with qmi_message_unref(). If @raw doesn't contain a complete QMI message %NULL is returned. If there is a complete QMI message but it appears not to be valid, %NULL is returned and @error is set.
     */
    function message_new_from_raw(raw: Uint8Array | string): [Message, Uint8Array];
    /**
     * Parses a #QmiMessage and builds a #QmiMessageOmaCancelSessionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageOmaCancelSessionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_cancel_session_output_unref().
     */
    function message_oma_cancel_session_response_parse(message: Message): MessageOmaCancelSessionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageOmaGetFeatureSettingOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageOmaGetFeatureSettingOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_get_feature_setting_output_unref().
     */
    function message_oma_get_feature_setting_response_parse(message: Message): MessageOmaGetFeatureSettingOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageOmaGetSessionInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageOmaGetSessionInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_get_session_info_output_unref().
     */
    function message_oma_get_session_info_response_parse(message: Message): MessageOmaGetSessionInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageOmaResetOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageOmaResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_reset_output_unref().
     */
    function message_oma_reset_response_parse(message: Message): MessageOmaResetOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageOmaSendSelectionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageOmaSendSelectionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_send_selection_output_unref().
     */
    function message_oma_send_selection_response_parse(message: Message): MessageOmaSendSelectionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageOmaSetEventReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageOmaSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_set_event_report_output_unref().
     */
    function message_oma_set_event_report_response_parse(message: Message): MessageOmaSetEventReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageOmaSetFeatureSettingOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageOmaSetFeatureSettingOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_set_feature_setting_output_unref().
     */
    function message_oma_set_feature_setting_response_parse(message: Message): MessageOmaSetFeatureSettingOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageOmaStartSessionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageOmaStartSessionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_start_session_output_unref().
     */
    function message_oma_start_session_response_parse(message: Message): MessageOmaStartSessionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePbmGetAllCapabilitiesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePbmGetAllCapabilitiesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pbm_get_all_capabilities_output_unref().
     */
    function message_pbm_get_all_capabilities_response_parse(message: Message): MessagePbmGetAllCapabilitiesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePbmGetCapabilitiesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePbmGetCapabilitiesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pbm_get_capabilities_output_unref().
     */
    function message_pbm_get_capabilities_response_parse(message: Message): MessagePbmGetCapabilitiesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePbmIndicationRegisterOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePbmIndicationRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pbm_indication_register_output_unref().
     */
    function message_pbm_indication_register_response_parse(message: Message): MessagePbmIndicationRegisterOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcActivateConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcActivateConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_activate_config_output_unref().
     */
    function message_pdc_activate_config_response_parse(message: Message): MessagePdcActivateConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcConfigChangeOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcConfigChangeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_config_change_output_unref().
     */
    function message_pdc_config_change_response_parse(message: Message): MessagePdcConfigChangeOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcDeactivateConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcDeactivateConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_deactivate_config_output_unref().
     */
    function message_pdc_deactivate_config_response_parse(message: Message): MessagePdcDeactivateConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcDeleteConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcDeleteConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_delete_config_output_unref().
     */
    function message_pdc_delete_config_response_parse(message: Message): MessagePdcDeleteConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcGetConfigInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcGetConfigInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_get_config_info_output_unref().
     */
    function message_pdc_get_config_info_response_parse(message: Message): MessagePdcGetConfigInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcGetConfigLimitsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcGetConfigLimitsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_get_config_limits_output_unref().
     */
    function message_pdc_get_config_limits_response_parse(message: Message): MessagePdcGetConfigLimitsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcGetDefaultConfigInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcGetDefaultConfigInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_get_default_config_info_output_unref().
     */
    function message_pdc_get_default_config_info_response_parse(message: Message): MessagePdcGetDefaultConfigInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcGetSelectedConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcGetSelectedConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_get_selected_config_output_unref().
     */
    function message_pdc_get_selected_config_response_parse(message: Message): MessagePdcGetSelectedConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcListConfigsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcListConfigsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_list_configs_output_unref().
     */
    function message_pdc_list_configs_response_parse(message: Message): MessagePdcListConfigsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcLoadConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcLoadConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_load_config_output_unref().
     */
    function message_pdc_load_config_response_parse(message: Message): MessagePdcLoadConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcRegisterOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_register_output_unref().
     */
    function message_pdc_register_response_parse(message: Message): MessagePdcRegisterOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcResetOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_reset_output_unref().
     */
    function message_pdc_reset_response_parse(message: Message): MessagePdcResetOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdcSetSelectedConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdcSetSelectedConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_set_selected_config_output_unref().
     */
    function message_pdc_set_selected_config_response_parse(message: Message): MessagePdcSetSelectedConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdsGetAgpsConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdsGetAgpsConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_get_agps_config_output_unref().
     */
    function message_pds_get_agps_config_response_parse(message: Message): MessagePdsGetAgpsConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdsGetAutoTrackingStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdsGetAutoTrackingStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_get_auto_tracking_state_output_unref().
     */
    function message_pds_get_auto_tracking_state_response_parse(message: Message): MessagePdsGetAutoTrackingStateOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdsGetDefaultTrackingSessionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdsGetDefaultTrackingSessionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_get_default_tracking_session_output_unref().
     */
    function message_pds_get_default_tracking_session_response_parse(
        message: Message,
    ): MessagePdsGetDefaultTrackingSessionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdsGetGpsServiceStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdsGetGpsServiceStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_get_gps_service_state_output_unref().
     */
    function message_pds_get_gps_service_state_response_parse(message: Message): MessagePdsGetGpsServiceStateOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdsResetOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdsResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_reset_output_unref().
     */
    function message_pds_reset_response_parse(message: Message): MessagePdsResetOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdsSetAgpsConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdsSetAgpsConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_set_agps_config_output_unref().
     */
    function message_pds_set_agps_config_response_parse(message: Message): MessagePdsSetAgpsConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdsSetAutoTrackingStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdsSetAutoTrackingStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_set_auto_tracking_state_output_unref().
     */
    function message_pds_set_auto_tracking_state_response_parse(message: Message): MessagePdsSetAutoTrackingStateOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdsSetDefaultTrackingSessionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdsSetDefaultTrackingSessionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_set_default_tracking_session_output_unref().
     */
    function message_pds_set_default_tracking_session_response_parse(
        message: Message,
    ): MessagePdsSetDefaultTrackingSessionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdsSetEventReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdsSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_set_event_report_output_unref().
     */
    function message_pds_set_event_report_response_parse(message: Message): MessagePdsSetEventReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessagePdsSetGpsServiceStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessagePdsSetGpsServiceStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_set_gps_service_state_output_unref().
     */
    function message_pds_set_gps_service_state_response_parse(message: Message): MessagePdsSetGpsServiceStateOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageQosGetFlowStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageQosGetFlowStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_qos_get_flow_status_output_unref().
     */
    function message_qos_get_flow_status_response_parse(message: Message): MessageQosGetFlowStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageQosGetNetworkStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageQosGetNetworkStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_qos_get_network_status_output_unref().
     */
    function message_qos_get_network_status_response_parse(message: Message): MessageQosGetNetworkStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageQosResetOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageQosResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_qos_reset_output_unref().
     */
    function message_qos_reset_response_parse(message: Message): MessageQosResetOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageQosSwiReadDataStatsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageQosSwiReadDataStatsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_qos_swi_read_data_stats_output_unref().
     */
    function message_qos_swi_read_data_stats_response_parse(message: Message): MessageQosSwiReadDataStatsOutput;
    /**
     * Atomically increments the reference count of `self` by one.
     * @param self a #QmiMessage.
     * @returns the new reference to @self.
     */
    function message_ref(self: Message): Message;
    /**
     * Create a new response #QmiMessage for the specified `request`.
     * @param request a request #QmiMessage.
     * @param error a #QmiProtocolError to set in the result TLV.
     * @returns a newly created #QmiMessage. The returned value should be freed with qmi_message_unref().
     */
    function message_response_new(request: Message, error: ProtocolError): Message;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageSarRfGetStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageSarRfGetStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_sar_rf_get_state_output_unref().
     */
    function message_sar_rf_get_state_response_parse(message: Message): MessageSarRfGetStateOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageSarRfSetStateOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageSarRfSetStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_sar_rf_set_state_output_unref().
     */
    function message_sar_rf_set_state_response_parse(message: Message): MessageSarRfSetStateOutput;
    /**
     * Overwrites the transaction ID of the message.
     * @param self a #QmiMessage.
     * @param transaction_id transaction id.
     */
    function message_set_transaction_id(self: Message, transaction_id: number): void;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageSscControlOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageSscControlOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_ssc_control_output_unref().
     */
    function message_ssc_control_response_parse(message: Message): MessageSscControlOutput;
    /**
     * Reads a string from the TLV.
     *
     * The string written in `out` will need to be NUL-terminated by the caller.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     *
     * Since 1.24.6 the read string is guaranteed to be valid UTF-8.
     *
     * The fixed sized field may be suffixed with e.g. 0xFF if the contents are
     * shorter than `string_length`. Since 1.26, this method will return the valid
     * UTF-8 characters in the start of the string, instead of returning an error
     * when doing the full UTF-8 string validation.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of a the offset within the TLV value.
     * @param string_length amount of bytes to read.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_fixed_size_string(
        self: Message,
        tlv_offset: number,
        offset: number,
        string_length: number,
    ): [boolean, number, string];
    /**
     * Reads a 64-bit floating-point number from the TLV.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of a the offset within the TLV value.
     * @param endian source endianness, which will be swapped to host byte order if necessary.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_gdouble(
        self: Message,
        tlv_offset: number,
        offset: number,
        endian: Endian,
    ): [boolean, number, number];
    /**
     * Reads a 32-bit floating-point number from the TLV.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of a the offset within the TLV value.
     * @param endian source endianness, which will be swapped to host byte order if necessary.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_gfloat_endian(
        self: Message,
        tlv_offset: number,
        offset: number,
        endian: Endian,
    ): [boolean, number, number];
    /**
     * Reads a signed 16-bit integer from the TLV, in host byte order.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of a the offset within the TLV value.
     * @param endian source endianness, which will be swapped to host byte order if necessary.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_gint16(
        self: Message,
        tlv_offset: number,
        offset: number,
        endian: Endian,
    ): [boolean, number, number];
    /**
     * Reads a signed 32-bit integer from the TLV, in host byte order.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of a the offset within the TLV value.
     * @param endian source endianness, which will be swapped to host byte order if necessary.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_gint32(
        self: Message,
        tlv_offset: number,
        offset: number,
        endian: Endian,
    ): [boolean, number, number];
    /**
     * Reads a signed 64-bit integer from the TLV, in host byte order.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of a the offset within the TLV value.
     * @param endian source endianness, which will be swapped to host byte order if necessary.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_gint64(
        self: Message,
        tlv_offset: number,
        offset: number,
        endian: Endian,
    ): [boolean, number, number];
    /**
     * Reads a signed byte from the TLV.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of a the offset within the TLV value.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_gint8(self: Message, tlv_offset: number, offset: number): [boolean, number, number];
    /**
     * Reads an unsigned 16-bit integer from the TLV, in host byte order.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of a the offset within the TLV value.
     * @param endian source endianness, which will be swapped to host byte order if necessary.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_guint16(
        self: Message,
        tlv_offset: number,
        offset: number,
        endian: Endian,
    ): [boolean, number, number];
    /**
     * Reads an unsigned 32-bit integer from the TLV, in host byte order.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of a the offset within the TLV value.
     * @param endian source endianness, which will be swapped to host byte order if necessary.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_guint32(
        self: Message,
        tlv_offset: number,
        offset: number,
        endian: Endian,
    ): [boolean, number, number];
    /**
     * Reads an unsigned 64-bit integer from the TLV, in host byte order.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of a the offset within the TLV value.
     * @param endian source endianness, which will be swapped to host byte order if necessary.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_guint64(
        self: Message,
        tlv_offset: number,
        offset: number,
        endian: Endian,
    ): [boolean, number, number];
    /**
     * Reads an unsigned byte from the TLV.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of the offset within the TLV value.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_guint8(self: Message, tlv_offset: number, offset: number): [boolean, number, number];
    /**
     * Starts reading a given TLV from the #QmiMessage.
     * @param self a #QmiMessage.
     * @param type specific ID of the TLV to read.
     * @returns the offset where the TLV starts, or 0 if an error happens.
     */
    function message_tlv_read_init(self: Message, type: number): [number, number];
    function message_tlv_read_remaining_size(self: Message, tlv_offset: number, offset: number): number;
    /**
     * Reads a `b_bytes-sized` integer from the TLV, in host byte order.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of a the offset within the TLV value.
     * @param n_bytes number of bytes to read.
     * @param endian source endianness, which will be swapped to host byte order if necessary.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_sized_guint(
        self: Message,
        tlv_offset: number,
        offset: number,
        n_bytes: number,
        endian: Endian,
    ): [boolean, number, number];
    /**
     * Reads a string from the TLV.
     *
     * `offset` needs to point to a valid `gsize` specifying the index to start
     * reading from within the TLV value (0 for the first item). If the variable
     * is successfully read, `offset` will be updated to point past the read item.
     *
     * Since 1.24.6 the read string is guaranteed to be valid UTF-8. Also, in order to
     * overcome known firmware errors on string fields, this method will also
     * attempt to parse the string as GSM-7 or UCS-2 if the initial UTF-8 validation
     * fails.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_read_init().
     * @param offset address of a the offset within the TLV value.
     * @param n_size_prefix_bytes number of bytes used in the size prefix.
     * @param max_size maximum number of bytes to read, or 0 to read all available bytes.
     * @returns %TRUE if the variable is successfully read, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_read_string(
        self: Message,
        tlv_offset: number,
        offset: number,
        n_size_prefix_bytes: number,
        max_size: number,
    ): [boolean, number, string];
    /**
     * Completes building a TLV in the #QmiMessage.
     *
     * In case of error the TLV will be reseted; i.e. there is no need to explicitly
     * call qmi_message_tlv_write_reset().
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_write_init().
     * @returns %TRUE if the TLV is successfully completed, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_write_complete(self: Message, tlv_offset: number): boolean;
    /**
     * Appends a signed 16-bit integer to the TLV being built. The number to be
     * written is expected to be given in host endianness, and this method takes
     * care of converting the value written to the byte order specified by `endian`.
     * @param self a #QmiMessage.
     * @param endian target endianness, swapped from host byte order if necessary.
     * @param _in a #gint16 in host byte order.
     * @returns %TRUE if the variable is successfully added, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_write_gint16(self: Message, endian: Endian, _in: number): boolean;
    /**
     * Appends a signed 32-bit integer to the TLV being built. The number to be
     * written is expected to be given in host endianness, and this method takes
     * care of converting the value written to the byte order specified by `endian`.
     * @param self a #QmiMessage.
     * @param endian target endianness, swapped from host byte order if necessary.
     * @param _in a #gint32 in host byte order.
     * @returns %TRUE if the variable is successfully added, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_write_gint32(self: Message, endian: Endian, _in: number): boolean;
    /**
     * Appends a signed 32-bit integer to the TLV being built. The number to be
     * written is expected to be given in host endianness, and this method takes
     * care of converting the value written to the byte order specified by `endian`.
     * @param self a #QmiMessage.
     * @param endian target endianness, swapped from host byte order if necessary.
     * @param _in a #gint64 in host byte order.
     * @returns %TRUE if the variable is successfully added, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_write_gint64(self: Message, endian: Endian, _in: number): boolean;
    /**
     * Appends a signed byte variable to the TLV being built.
     * @param self a #QmiMessage.
     * @param _in a #gint8.
     * @returns %TRUE if the variable is successfully added, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_write_gint8(self: Message, _in: number): boolean;
    /**
     * Appends an unsigned 16-bit integer to the TLV being built. The number to be
     * written is expected to be given in host endianness, and this method takes
     * care of converting the value written to the byte order specified by `endian`.
     * @param self a #QmiMessage.
     * @param endian target endianness, swapped from host byte order if necessary.
     * @param _in a #guint16 in host byte order.
     * @returns %TRUE if the variable is successfully added, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_write_guint16(self: Message, endian: Endian, _in: number): boolean;
    /**
     * Appends an unsigned 32-bit integer to the TLV being built. The number to be
     * written is expected to be given in host endianness, and this method takes
     * care of converting the value written to the byte order specified by `endian`.
     * @param self a #QmiMessage.
     * @param endian target endianness, swapped from host byte order if necessary.
     * @param _in a #guint32 in host byte order.
     * @returns %TRUE if the variable is successfully added, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_write_guint32(self: Message, endian: Endian, _in: number): boolean;
    /**
     * Appends an unsigned 64-bit integer to the TLV being built. The number to be
     * written is expected to be given in host endianness, and this method takes
     * care of converting the value written to the byte order specified by `endian`.
     * @param self a #QmiMessage.
     * @param endian target endianness, swapped from host byte order if necessary.
     * @param _in a #guint64 in host byte order.
     * @returns %TRUE if the variable is successfully added, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_write_guint64(self: Message, endian: Endian, _in: number): boolean;
    /**
     * Appends an unsigned byte to the TLV being built.
     * @param self a #QmiMessage.
     * @param _in a #guint8.
     * @returns %TRUE if the variable is successfully added, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_write_guint8(self: Message, _in: number): boolean;
    /**
     * Starts building a new TLV in the #QmiMessage.
     *
     * In order to finish adding the TLV, qmi_message_tlv_write_complete() needs to be
     * called.
     *
     * If any error happens adding fields on the TLV, the previous state can be
     * recovered using qmi_message_tlv_write_reset().
     * @param self a #QmiMessage.
     * @param type specific ID of the TLV to add.
     * @returns the offset where the TLV was started to be added, or 0 if an error happens.
     */
    function message_tlv_write_init(self: Message, type: number): number;
    /**
     * Removes the TLV being currently added.
     * @param self a #QmiMessage.
     * @param tlv_offset offset that was returned by qmi_message_tlv_write_init().
     */
    function message_tlv_write_reset(self: Message, tlv_offset: number): void;
    /**
     * Appends a `n_bytes-sized` unsigned integer to the TLV being built. The number
     * to be written is expected to be given in host endianness, and this method
     * takes care of converting the value written to the byte order specified by
     * `endian`.
     *
     * The value of `n_bytes` can be any between 1 and 8.
     * @param self a #QmiMessage.
     * @param n_bytes number of bytes to write.
     * @param endian target endianness, swapped from host byte order if necessary.
     * @param _in a #guint64 in host byte order.
     * @returns %TRUE if the variable is successfully added, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_write_sized_guint(self: Message, n_bytes: number, endian: Endian, _in: number): boolean;
    /**
     * Appends a string to the TLV being built.
     *
     * Fixed-sized strings should give `n_size_prefix_bytes` equal to 0.
     * @param self a #QmiMessage.
     * @param n_size_prefix_bytes number of bytes to use in the size prefix.
     * @param _in string to write.
     * @param in_length length of @in, or -1 if @in is NUL-terminated.
     * @returns %TRUE if the string is successfully added, otherwise %FALSE is returned and @error is set.
     */
    function message_tlv_write_string(
        self: Message,
        n_size_prefix_bytes: number,
        _in: string,
        in_length: number,
    ): boolean;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimChangePinOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimChangePinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_change_pin_output_unref().
     */
    function message_uim_change_pin_response_parse(message: Message): MessageUimChangePinOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimChangeProvisioningSessionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimChangeProvisioningSessionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_change_provisioning_session_output_unref().
     */
    function message_uim_change_provisioning_session_response_parse(
        message: Message,
    ): MessageUimChangeProvisioningSessionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimDepersonalizationOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimDepersonalizationOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_depersonalization_output_unref().
     */
    function message_uim_depersonalization_response_parse(message: Message): MessageUimDepersonalizationOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimGetCardStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimGetCardStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_get_card_status_output_unref().
     */
    function message_uim_get_card_status_response_parse(message: Message): MessageUimGetCardStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimGetConfigurationOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimGetConfigurationOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_get_configuration_output_unref().
     */
    function message_uim_get_configuration_response_parse(message: Message): MessageUimGetConfigurationOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimGetFileAttributesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimGetFileAttributesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_get_file_attributes_output_unref().
     */
    function message_uim_get_file_attributes_response_parse(message: Message): MessageUimGetFileAttributesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimGetSlotStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimGetSlotStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_get_slot_status_output_unref().
     */
    function message_uim_get_slot_status_response_parse(message: Message): MessageUimGetSlotStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimGetSupportedMessagesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_get_supported_messages_output_unref().
     */
    function message_uim_get_supported_messages_response_parse(message: Message): MessageUimGetSupportedMessagesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimPowerOffSimOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimPowerOffSimOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_power_off_sim_output_unref().
     */
    function message_uim_power_off_sim_response_parse(message: Message): MessageUimPowerOffSimOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimPowerOnSimOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimPowerOnSimOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_power_on_sim_output_unref().
     */
    function message_uim_power_on_sim_response_parse(message: Message): MessageUimPowerOnSimOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimReadRecordOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimReadRecordOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_read_record_output_unref().
     */
    function message_uim_read_record_response_parse(message: Message): MessageUimReadRecordOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimReadTransparentOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimReadTransparentOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_read_transparent_output_unref().
     */
    function message_uim_read_transparent_response_parse(message: Message): MessageUimReadTransparentOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimRefreshCompleteOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimRefreshCompleteOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_refresh_complete_output_unref().
     */
    function message_uim_refresh_complete_response_parse(message: Message): MessageUimRefreshCompleteOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimRefreshRegisterAllOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimRefreshRegisterAllOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_refresh_register_all_output_unref().
     */
    function message_uim_refresh_register_all_response_parse(message: Message): MessageUimRefreshRegisterAllOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimRefreshRegisterOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimRefreshRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_refresh_register_output_unref().
     */
    function message_uim_refresh_register_response_parse(message: Message): MessageUimRefreshRegisterOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimRegisterEventsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimRegisterEventsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_register_events_output_unref().
     */
    function message_uim_register_events_response_parse(message: Message): MessageUimRegisterEventsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimRemoteUnlockOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimRemoteUnlockOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_remote_unlock_output_unref().
     */
    function message_uim_remote_unlock_response_parse(message: Message): MessageUimRemoteUnlockOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimResetOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_reset_output_unref().
     */
    function message_uim_reset_response_parse(message: Message): MessageUimResetOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimSetPinProtectionOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimSetPinProtectionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_set_pin_protection_output_unref().
     */
    function message_uim_set_pin_protection_response_parse(message: Message): MessageUimSetPinProtectionOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimSwitchSlotOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimSwitchSlotOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_switch_slot_output_unref().
     */
    function message_uim_switch_slot_response_parse(message: Message): MessageUimSwitchSlotOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimUnblockPinOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimUnblockPinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_unblock_pin_output_unref().
     */
    function message_uim_unblock_pin_response_parse(message: Message): MessageUimUnblockPinOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageUimVerifyPinOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageUimVerifyPinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_verify_pin_output_unref().
     */
    function message_uim_verify_pin_response_parse(message: Message): MessageUimVerifyPinOutput;
    /**
     * Atomically decrements the reference count of `self` by one.
     * If the reference count drops to 0, `self` is completely disposed.
     * @param self a #QmiMessage.
     */
    function message_unref(self: Message): void;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceAnswerCallOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceAnswerCallOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_answer_call_output_unref().
     */
    function message_voice_answer_call_response_parse(message: Message): MessageVoiceAnswerCallOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceAnswerUssdOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceAnswerUssdOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_answer_ussd_output_unref().
     */
    function message_voice_answer_ussd_response_parse(message: Message): MessageVoiceAnswerUssdOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceBurstDtmfOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceBurstDtmfOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_burst_dtmf_output_unref().
     */
    function message_voice_burst_dtmf_response_parse(message: Message): MessageVoiceBurstDtmfOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceCancelUssdOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceCancelUssdOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_cancel_ussd_output_unref().
     */
    function message_voice_cancel_ussd_response_parse(message: Message): MessageVoiceCancelUssdOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceDialCallOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceDialCallOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_dial_call_output_unref().
     */
    function message_voice_dial_call_response_parse(message: Message): MessageVoiceDialCallOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceEndCallOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceEndCallOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_end_call_output_unref().
     */
    function message_voice_end_call_response_parse(message: Message): MessageVoiceEndCallOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceGetAllCallInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceGetAllCallInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_get_all_call_info_output_unref().
     */
    function message_voice_get_all_call_info_response_parse(message: Message): MessageVoiceGetAllCallInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceGetCallWaitingOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceGetCallWaitingOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_get_call_waiting_output_unref().
     */
    function message_voice_get_call_waiting_response_parse(message: Message): MessageVoiceGetCallWaitingOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceGetConfigOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceGetConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_get_config_output_unref().
     */
    function message_voice_get_config_response_parse(message: Message): MessageVoiceGetConfigOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceGetSupportedMessagesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_get_supported_messages_output_unref().
     */
    function message_voice_get_supported_messages_response_parse(
        message: Message,
    ): MessageVoiceGetSupportedMessagesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceIndicationRegisterOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceIndicationRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_indication_register_output_unref().
     */
    function message_voice_indication_register_response_parse(message: Message): MessageVoiceIndicationRegisterOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceManageCallsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceManageCallsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_manage_calls_output_unref().
     */
    function message_voice_manage_calls_response_parse(message: Message): MessageVoiceManageCallsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceOriginateUssdNoWaitOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceOriginateUssdNoWaitOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_originate_ussd_no_wait_output_unref().
     */
    function message_voice_originate_ussd_no_wait_response_parse(
        message: Message,
    ): MessageVoiceOriginateUssdNoWaitOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceOriginateUssdOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceOriginateUssdOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_originate_ussd_output_unref().
     */
    function message_voice_originate_ussd_response_parse(message: Message): MessageVoiceOriginateUssdOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceSetSupplementaryServiceOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceSetSupplementaryServiceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_set_supplementary_service_output_unref().
     */
    function message_voice_set_supplementary_service_response_parse(
        message: Message,
    ): MessageVoiceSetSupplementaryServiceOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceStartContinuousDtmfOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceStartContinuousDtmfOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_start_continuous_dtmf_output_unref().
     */
    function message_voice_start_continuous_dtmf_response_parse(
        message: Message,
    ): MessageVoiceStartContinuousDtmfOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageVoiceStopContinuousDtmfOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageVoiceStopContinuousDtmfOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_stop_continuous_dtmf_output_unref().
     */
    function message_voice_stop_continuous_dtmf_response_parse(message: Message): MessageVoiceStopContinuousDtmfOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdaGetDataFormatOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdaGetDataFormatOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wda_get_data_format_output_unref().
     */
    function message_wda_get_data_format_response_parse(message: Message): MessageWdaGetDataFormatOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdaGetSupportedMessagesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdaGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wda_get_supported_messages_output_unref().
     */
    function message_wda_get_supported_messages_response_parse(message: Message): MessageWdaGetSupportedMessagesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdaSetDataFormatOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdaSetDataFormatOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wda_set_data_format_output_unref().
     */
    function message_wda_set_data_format_response_parse(message: Message): MessageWdaSetDataFormatOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsBindDataPortOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsBindDataPortOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_bind_data_port_output_unref().
     */
    function message_wds_bind_data_port_response_parse(message: Message): MessageWdsBindDataPortOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsBindMuxDataPortOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsBindMuxDataPortOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_bind_mux_data_port_output_unref().
     */
    function message_wds_bind_mux_data_port_response_parse(message: Message): MessageWdsBindMuxDataPortOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsConfigureProfileEventListOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsConfigureProfileEventListOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_configure_profile_event_list_output_unref().
     */
    function message_wds_configure_profile_event_list_response_parse(
        message: Message,
    ): MessageWdsConfigureProfileEventListOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsCreateProfileOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsCreateProfileOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_create_profile_output_unref().
     */
    function message_wds_create_profile_response_parse(message: Message): MessageWdsCreateProfileOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsDeleteProfileOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsDeleteProfileOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_delete_profile_output_unref().
     */
    function message_wds_delete_profile_response_parse(message: Message): MessageWdsDeleteProfileOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetAutoconnectSettingsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetAutoconnectSettingsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_autoconnect_settings_output_unref().
     */
    function message_wds_get_autoconnect_settings_response_parse(
        message: Message,
    ): MessageWdsGetAutoconnectSettingsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetChannelRatesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetChannelRatesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_channel_rates_output_unref().
     */
    function message_wds_get_channel_rates_response_parse(message: Message): MessageWdsGetChannelRatesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetCurrentDataBearerTechnologyOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetCurrentDataBearerTechnologyOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_current_data_bearer_technology_output_unref().
     */
    function message_wds_get_current_data_bearer_technology_response_parse(
        message: Message,
    ): MessageWdsGetCurrentDataBearerTechnologyOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetCurrentSettingsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetCurrentSettingsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_current_settings_output_unref().
     */
    function message_wds_get_current_settings_response_parse(message: Message): MessageWdsGetCurrentSettingsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetDataBearerTechnologyOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetDataBearerTechnologyOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_data_bearer_technology_output_unref().
     */
    function message_wds_get_data_bearer_technology_response_parse(
        message: Message,
    ): MessageWdsGetDataBearerTechnologyOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetDefaultProfileNumberOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetDefaultProfileNumberOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_default_profile_number_output_unref().
     */
    function message_wds_get_default_profile_number_response_parse(
        message: Message,
    ): MessageWdsGetDefaultProfileNumberOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetDefaultSettingsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetDefaultSettingsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_default_settings_output_unref().
     */
    function message_wds_get_default_settings_response_parse(message: Message): MessageWdsGetDefaultSettingsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetDormancyStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetDormancyStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_dormancy_status_output_unref().
     */
    function message_wds_get_dormancy_status_response_parse(message: Message): MessageWdsGetDormancyStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetLteAttachParametersOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetLteAttachParametersOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_lte_attach_parameters_output_unref().
     */
    function message_wds_get_lte_attach_parameters_response_parse(
        message: Message,
    ): MessageWdsGetLteAttachParametersOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetLteAttachPdnListOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetLteAttachPdnListOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_lte_attach_pdn_list_output_unref().
     */
    function message_wds_get_lte_attach_pdn_list_response_parse(message: Message): MessageWdsGetLteAttachPdnListOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetMaxLteAttachPdnNumberOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetMaxLteAttachPdnNumberOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_max_lte_attach_pdn_number_output_unref().
     */
    function message_wds_get_max_lte_attach_pdn_number_response_parse(
        message: Message,
    ): MessageWdsGetMaxLteAttachPdnNumberOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetPacketServiceStatusOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetPacketServiceStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_packet_service_status_output_unref().
     */
    function message_wds_get_packet_service_status_response_parse(
        message: Message,
    ): MessageWdsGetPacketServiceStatusOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetPacketStatisticsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetPacketStatisticsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_packet_statistics_output_unref().
     */
    function message_wds_get_packet_statistics_response_parse(message: Message): MessageWdsGetPacketStatisticsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetPdnThrottleInfoOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetPdnThrottleInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_pdn_throttle_info_output_unref().
     */
    function message_wds_get_pdn_throttle_info_response_parse(message: Message): MessageWdsGetPdnThrottleInfoOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetProfileListOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetProfileListOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_profile_list_output_unref().
     */
    function message_wds_get_profile_list_response_parse(message: Message): MessageWdsGetProfileListOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetProfileSettingsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetProfileSettingsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_profile_settings_output_unref().
     */
    function message_wds_get_profile_settings_response_parse(message: Message): MessageWdsGetProfileSettingsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGetSupportedMessagesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_supported_messages_output_unref().
     */
    function message_wds_get_supported_messages_response_parse(message: Message): MessageWdsGetSupportedMessagesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGoActiveOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGoActiveOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_go_active_output_unref().
     */
    function message_wds_go_active_response_parse(message: Message): MessageWdsGoActiveOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsGoDormantOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsGoDormantOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_go_dormant_output_unref().
     */
    function message_wds_go_dormant_response_parse(message: Message): MessageWdsGoDormantOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsIndicationRegisterOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsIndicationRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_indication_register_output_unref().
     */
    function message_wds_indication_register_response_parse(message: Message): MessageWdsIndicationRegisterOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsModifyProfileOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsModifyProfileOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_modify_profile_output_unref().
     */
    function message_wds_modify_profile_response_parse(message: Message): MessageWdsModifyProfileOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsResetOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_reset_output_unref().
     */
    function message_wds_reset_response_parse(message: Message): MessageWdsResetOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsSetAutoconnectSettingsOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsSetAutoconnectSettingsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_set_autoconnect_settings_output_unref().
     */
    function message_wds_set_autoconnect_settings_response_parse(
        message: Message,
    ): MessageWdsSetAutoconnectSettingsOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsSetDefaultProfileNumberOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsSetDefaultProfileNumberOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_set_default_profile_number_output_unref().
     */
    function message_wds_set_default_profile_number_response_parse(
        message: Message,
    ): MessageWdsSetDefaultProfileNumberOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsSetEventReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_set_event_report_output_unref().
     */
    function message_wds_set_event_report_response_parse(message: Message): MessageWdsSetEventReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsSetIpFamilyOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsSetIpFamilyOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_set_ip_family_output_unref().
     */
    function message_wds_set_ip_family_response_parse(message: Message): MessageWdsSetIpFamilyOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsSetLteAttachPdnListOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsSetLteAttachPdnListOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_set_lte_attach_pdn_list_output_unref().
     */
    function message_wds_set_lte_attach_pdn_list_response_parse(message: Message): MessageWdsSetLteAttachPdnListOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsStartNetworkOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsStartNetworkOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_start_network_output_unref().
     */
    function message_wds_start_network_response_parse(message: Message): MessageWdsStartNetworkOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsStopNetworkOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsStopNetworkOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_stop_network_output_unref().
     */
    function message_wds_stop_network_response_parse(message: Message): MessageWdsStopNetworkOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWdsSwiCreateProfileIndexedOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWdsSwiCreateProfileIndexedOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_swi_create_profile_indexed_output_unref().
     */
    function message_wds_swi_create_profile_indexed_response_parse(
        message: Message,
    ): MessageWdsSwiCreateProfileIndexedOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsDeleteOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsDeleteOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_delete_output_unref().
     */
    function message_wms_delete_response_parse(message: Message): MessageWmsDeleteOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsGetMessageProtocolOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsGetMessageProtocolOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_get_message_protocol_output_unref().
     */
    function message_wms_get_message_protocol_response_parse(message: Message): MessageWmsGetMessageProtocolOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsGetRoutesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsGetRoutesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_get_routes_output_unref().
     */
    function message_wms_get_routes_response_parse(message: Message): MessageWmsGetRoutesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsGetSupportedMessagesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_get_supported_messages_output_unref().
     */
    function message_wms_get_supported_messages_response_parse(message: Message): MessageWmsGetSupportedMessagesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsListMessagesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsListMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_list_messages_output_unref().
     */
    function message_wms_list_messages_response_parse(message: Message): MessageWmsListMessagesOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsModifyTagOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsModifyTagOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_modify_tag_output_unref().
     */
    function message_wms_modify_tag_response_parse(message: Message): MessageWmsModifyTagOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsRawReadOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsRawReadOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_raw_read_output_unref().
     */
    function message_wms_raw_read_response_parse(message: Message): MessageWmsRawReadOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsRawSendOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsRawSendOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_raw_send_output_unref().
     */
    function message_wms_raw_send_response_parse(message: Message): MessageWmsRawSendOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsRawWriteOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsRawWriteOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_raw_write_output_unref().
     */
    function message_wms_raw_write_response_parse(message: Message): MessageWmsRawWriteOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsResetOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_reset_output_unref().
     */
    function message_wms_reset_response_parse(message: Message): MessageWmsResetOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsSendAckOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsSendAckOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_send_ack_output_unref().
     */
    function message_wms_send_ack_response_parse(message: Message): MessageWmsSendAckOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsSendFromMemoryStorageOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsSendFromMemoryStorageOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_send_from_memory_storage_output_unref().
     */
    function message_wms_send_from_memory_storage_response_parse(
        message: Message,
    ): MessageWmsSendFromMemoryStorageOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsSetEventReportOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_set_event_report_output_unref().
     */
    function message_wms_set_event_report_response_parse(message: Message): MessageWmsSetEventReportOutput;
    /**
     * Parses a #QmiMessage and builds a #QmiMessageWmsSetRoutesOutput out of it.
     * The operation fails if the message is of the wrong type.
     * @param message a #QmiMessage.
     * @returns a #QmiMessageWmsSetRoutesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_set_routes_output_unref().
     */
    function message_wms_set_routes_response_parse(message: Message): MessageWmsSetRoutesOutput;
    /**
     * Gets the nickname string for the #QmiNasActiveBand specified at `val`.
     * @param val a QmiNasActiveBand.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_active_band_get_string(val: NasActiveBand): string;
    /**
     * Gets the nickname string for the #QmiNasAttachState specified at `val`.
     * @param val a QmiNasAttachState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_attach_state_get_string(val: NasAttachState): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiNasBandPreference in `mask`.
     * @param mask bitmask of QmiNasBandPreference values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function nas_band_preference_build_string_from_mask(mask: NasBandPreference): string;
    /**
     * Gets the nickname string for the #QmiNasBoolean specified at `val`.
     * @param val a QmiNasBoolean.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_boolean_get_string(val: NasBoolean): string;
    /**
     * Gets the nickname string for the #QmiNasCallBarringStatus specified at `val`.
     * @param val a QmiNasCallBarringStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_call_barring_status_get_string(val: NasCallBarringStatus): string;
    /**
     * Gets the nickname string for the #QmiNasCdmaPilotType specified at `val`.
     * @param val a QmiNasCdmaPilotType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_cdma_pilot_type_get_string(val: NasCdmaPilotType): string;
    /**
     * Gets the nickname string for the #QmiNasCdmaPrlPreference specified at `val`.
     * @param val a QmiNasCdmaPrlPreference.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_cdma_prl_preference_get_string(val: NasCdmaPrlPreference): string;
    /**
     * Gets the nickname string for the #QmiNasCellBroadcastCapability specified at `val`.
     * @param val a QmiNasCellBroadcastCapability.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_cell_broadcast_capability_get_string(val: NasCellBroadcastCapability): string;
    /**
     * Gets the nickname string for the #QmiNasChangeDuration specified at `val`.
     * @param val a QmiNasChangeDuration.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_change_duration_get_string(val: NasChangeDuration): string;
    /**
     * Gets the nickname string for the #QmiNasDataCapability specified at `val`.
     * @param val a QmiNasDataCapability.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_data_capability_get_string(val: NasDataCapability): string;
    /**
     * Gets the nickname string for the #QmiNasDayOfWeek specified at `val`.
     * @param val a QmiNasDayOfWeek.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_day_of_week_get_string(val: NasDayOfWeek): string;
    /**
     * Gets the nickname string for the #QmiNasDaylightSavingsAdjustment specified at `val`.
     * @param val a QmiNasDaylightSavingsAdjustment.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_daylight_savings_adjustment_get_string(val: NasDaylightSavingsAdjustment): string;
    /**
     * Gets the nickname string for the #QmiNasDLBandwidth specified at `val`.
     * @param val a QmiNasDLBandwidth.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_dl_bandwidth_get_string(val: NasDLBandwidth): string;
    /**
     * Gets the nickname string for the #QmiNasDrx specified at `val`.
     * @param val a QmiNasDrx.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_drx_get_string(val: NasDrx): string;
    /**
     * Gets the nickname string for the #QmiNasEvdoSinrLevel specified at `val`.
     * @param val a QmiNasEvdoSinrLevel.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_evdo_sinr_level_get_string(val: NasEvdoSinrLevel): string;
    /**
     * Gets the nickname string for the #QmiNasGsmWcdmaAcquisitionOrderPreference specified at `val`.
     * @param val a QmiNasGsmWcdmaAcquisitionOrderPreference.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_gsm_wcdma_acquisition_order_preference_get_string(val: NasGsmWcdmaAcquisitionOrderPreference): string;
    /**
     * Gets the nickname string for the #QmiNasHdrPersonality specified at `val`.
     * @param val a QmiNasHdrPersonality.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_hdr_personality_get_string(val: NasHdrPersonality): string;
    /**
     * Gets the nickname string for the #QmiNasHdrProtocolRevision specified at `val`.
     * @param val a QmiNasHdrProtocolRevision.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_hdr_protocol_revision_get_string(val: NasHdrProtocolRevision): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiNasLteBandPreference in `mask`.
     * @param mask bitmask of QmiNasLteBandPreference values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function nas_lte_band_preference_build_string_from_mask(mask: NasLteBandPreference): string;
    /**
     * Gets the nickname string for the #QmiNasLteCellAccessStatus specified at `val`.
     * @param val a QmiNasLteCellAccessStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_lte_cell_access_status_get_string(val: NasLteCellAccessStatus): string;
    /**
     * Gets the nickname string for the #QmiNasLteRegistrationDomain specified at `val`.
     * @param val a QmiNasLteRegistrationDomain.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_lte_registration_domain_get_string(val: NasLteRegistrationDomain): string;
    /**
     * Gets the nickname string for the #QmiNasLteVoiceDomain specified at `val`.
     * @param val a QmiNasLteVoiceDomain.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_lte_voice_domain_get_string(val: NasLteVoiceDomain): string;
    /**
     * Gets the nickname string for the #QmiNasNetworkDescriptionDisplay specified at `val`.
     * @param val a QmiNasNetworkDescriptionDisplay.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_network_description_display_get_string(val: NasNetworkDescriptionDisplay): string;
    /**
     * Gets the nickname string for the #QmiNasNetworkDescriptionEncoding specified at `val`.
     * @param val a QmiNasNetworkDescriptionEncoding.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_network_description_encoding_get_string(val: NasNetworkDescriptionEncoding): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiNasNetworkNameDisplayCondition in `mask`.
     * @param mask bitmask of QmiNasNetworkNameDisplayCondition values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function nas_network_name_display_condition_build_string_from_mask(mask: NasNetworkNameDisplayCondition): string;
    /**
     * Gets the nickname string for the #QmiNasNetworkNameSource specified at `val`.
     * @param val a QmiNasNetworkNameSource.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_network_name_source_get_string(val: NasNetworkNameSource): string;
    /**
     * Gets the nickname string for the #QmiNasNetworkRegisterType specified at `val`.
     * @param val a QmiNasNetworkRegisterType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_network_register_type_get_string(val: NasNetworkRegisterType): string;
    /**
     * Gets the nickname string for the #QmiNasNetworkScanResult specified at `val`.
     * @param val a QmiNasNetworkScanResult.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_network_scan_result_get_string(val: NasNetworkScanResult): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiNasNetworkScanType in `mask`.
     * @param mask bitmask of QmiNasNetworkScanType values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function nas_network_scan_type_build_string_from_mask(mask: NasNetworkScanType): string;
    /**
     * Gets the nickname string for the #QmiNasNetworkSelectionPreference specified at `val`.
     * @param val a QmiNasNetworkSelectionPreference.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_network_selection_preference_get_string(val: NasNetworkSelectionPreference): string;
    /**
     * Gets the nickname string for the #QmiNasNetworkSelectionRegistrationRestriction specified at `val`.
     * @param val a QmiNasNetworkSelectionRegistrationRestriction.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_network_selection_registration_restriction_get_string(
        val: NasNetworkSelectionRegistrationRestriction,
    ): string;
    /**
     * Gets the nickname string for the #QmiNasNetworkServiceDomain specified at `val`.
     * @param val a QmiNasNetworkServiceDomain.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_network_service_domain_get_string(val: NasNetworkServiceDomain): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiNasNetworkStatus in `mask`.
     * @param mask bitmask of QmiNasNetworkStatus values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function nas_network_status_build_string_from_mask(mask: NasNetworkStatus): string;
    /**
     * Gets the nickname string for the #QmiNasNetworkType specified at `val`.
     * @param val a QmiNasNetworkType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_network_type_get_string(val: NasNetworkType): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiNasPlmnAccessTechnologyIdentifier in `mask`.
     * @param mask bitmask of QmiNasPlmnAccessTechnologyIdentifier values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function nas_plmn_access_technology_identifier_build_string_from_mask(
        mask: NasPlmnAccessTechnologyIdentifier,
    ): string;
    /**
     * Gets the nickname string for the #QmiNasPlmnEncodingScheme specified at `val`.
     * @param val a QmiNasPlmnEncodingScheme.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_plmn_encoding_scheme_get_string(val: NasPlmnEncodingScheme): string;
    /**
     * Gets the nickname string for the #QmiNasPlmnLanguageId specified at `val`.
     * @param val a QmiNasPlmnLanguageId.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_plmn_language_id_get_string(val: NasPlmnLanguageId): string;
    /**
     * Gets the nickname string for the #QmiNasPlmnNameCountryInitials specified at `val`.
     * @param val a QmiNasPlmnNameCountryInitials.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_plmn_name_country_initials_get_string(val: NasPlmnNameCountryInitials): string;
    /**
     * Gets the nickname string for the #QmiNasPlmnNameSpareBits specified at `val`.
     * @param val a QmiNasPlmnNameSpareBits.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_plmn_name_spare_bits_get_string(val: NasPlmnNameSpareBits): string;
    /**
     * Gets the nickname string for the #QmiNasPreferenceDuration specified at `val`.
     * @param val a QmiNasPreferenceDuration.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_preference_duration_get_string(val: NasPreferenceDuration): string;
    /**
     * Gets the nickname string for the #QmiNasPsAttachAction specified at `val`.
     * @param val a QmiNasPsAttachAction.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_ps_attach_action_get_string(val: NasPsAttachAction): string;
    /**
     * Gets the nickname string for the #QmiNasRadioInterface specified at `val`.
     * @param val a QmiNasRadioInterface.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_radio_interface_get_string(val: NasRadioInterface): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiNasRadioTechnologyPreference in `mask`.
     * @param mask bitmask of QmiNasRadioTechnologyPreference values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function nas_radio_technology_preference_build_string_from_mask(mask: NasRadioTechnologyPreference): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiNasRatModePreference in `mask`.
     * @param mask bitmask of QmiNasRatModePreference values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function nas_rat_mode_preference_build_string_from_mask(mask: NasRatModePreference): string;
    /**
     * Converts the encoded data in `array` to UTF-8 and returns a newly allocated
     * NUL-terminated string.
     * @param encoding a #QmiNasNetworkDescriptionEncoding.
     * @param array a #GArray with the encoded data.
     * @returns the UTF-8 encoded string, or %NULL if an error happened during the conversion. The returned value should be freed with g_free().
     */
    function nas_read_string_from_network_description_encoded_array(
        encoding: NasNetworkDescriptionEncoding,
        array: Uint8Array | string,
    ): string;
    /**
     * Converts the encoded data in `array` to UTF-8 and returns a newly allocated
     * NUL-terminated string.
     * @param encoding a #QmiNasPlmnEncodingScheme.
     * @param array a #GArray with the encoded data.
     * @returns the UTF-8 encoded string, or %NULL if an error happened during the conversion. The returned value should be freed with g_free().
     */
    function nas_read_string_from_plmn_encoded_array(
        encoding: NasPlmnEncodingScheme,
        array: Uint8Array | string,
    ): string;
    /**
     * Gets the nickname string for the #QmiNasRegistrationState specified at `val`.
     * @param val a QmiNasRegistrationState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_registration_state_get_string(val: NasRegistrationState): string;
    /**
     * Gets the nickname string for the #QmiNasRejectCause specified at `val`.
     * @param val a QmiNasRejectCause.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_reject_cause_get_string(val: NasRejectCause): string;
    /**
     * Gets the nickname string for the #QmiNasRoamingIndicatorStatus specified at `val`.
     * @param val a QmiNasRoamingIndicatorStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_roaming_indicator_status_get_string(val: NasRoamingIndicatorStatus): string;
    /**
     * Gets the nickname string for the #QmiNasRoamingPreference specified at `val`.
     * @param val a QmiNasRoamingPreference.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_roaming_preference_get_string(val: NasRoamingPreference): string;
    /**
     * Gets the nickname string for the #QmiNasRoamingStatus specified at `val`.
     * @param val a QmiNasRoamingStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_roaming_status_get_string(val: NasRoamingStatus): string;
    /**
     * Gets the nickname string for the #QmiNasScellState specified at `val`.
     * @param val a QmiNasScellState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_scell_state_get_string(val: NasScellState): string;
    /**
     * Gets the nickname string for the #QmiNasServiceDomainPreference specified at `val`.
     * @param val a QmiNasServiceDomainPreference.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_service_domain_preference_get_string(val: NasServiceDomainPreference): string;
    /**
     * Gets the nickname string for the #QmiNasServiceStatus specified at `val`.
     * @param val a QmiNasServiceStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_service_status_get_string(val: NasServiceStatus): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiNasSignalStrengthRequest in `mask`.
     * @param mask bitmask of QmiNasSignalStrengthRequest values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function nas_signal_strength_request_build_string_from_mask(mask: NasSignalStrengthRequest): string;
    /**
     * Gets the nickname string for the #QmiNasSimRejectState specified at `val`.
     * @param val a QmiNasSimRejectState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_sim_reject_state_get_string(val: NasSimRejectState): string;
    /**
     * Gets the nickname string for the #QmiNasSwiEmmConnectionState specified at `val`.
     * @param val a QmiNasSwiEmmConnectionState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_swi_emm_connection_state_get_string(val: NasSwiEmmConnectionState): string;
    /**
     * Gets the nickname string for the #QmiNasSwiEmmState specified at `val`.
     * @param val a QmiNasSwiEmmState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_swi_emm_state_get_string(val: NasSwiEmmState): string;
    /**
     * Gets the nickname string for the #QmiNasSwiImsRegState specified at `val`.
     * @param val a QmiNasSwiImsRegState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_swi_ims_reg_state_get_string(val: NasSwiImsRegState): string;
    /**
     * Gets the nickname string for the #QmiNasSwiModemMode specified at `val`.
     * @param val a QmiNasSwiModemMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_swi_modem_mode_get_string(val: NasSwiModemMode): string;
    /**
     * Gets the nickname string for the #QmiNasSwiPsState specified at `val`.
     * @param val a QmiNasSwiPsState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_swi_ps_state_get_string(val: NasSwiPsState): string;
    /**
     * Gets the nickname string for the #QmiNasSwiSystemMode specified at `val`.
     * @param val a QmiNasSwiSystemMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_swi_system_mode_get_string(val: NasSwiSystemMode): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiNasTdScdmaBandPreference in `mask`.
     * @param mask bitmask of QmiNasTdScdmaBandPreference values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function nas_td_scdma_band_preference_build_string_from_mask(mask: NasTdScdmaBandPreference): string;
    /**
     * Gets the nickname string for the #QmiNasUsagePreference specified at `val`.
     * @param val a QmiNasUsagePreference.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_usage_preference_get_string(val: NasUsagePreference): string;
    /**
     * Gets the nickname string for the #QmiNasVoiceDomainPreference specified at `val`.
     * @param val a QmiNasVoiceDomainPreference.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_voice_domain_preference_get_string(val: NasVoiceDomainPreference): string;
    /**
     * Gets the nickname string for the #QmiNasWcdmaHsService specified at `val`.
     * @param val a QmiNasWcdmaHsService.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_wcdma_hs_service_get_string(val: NasWcdmaHsService): string;
    /**
     * Gets the nickname string for the #QmiNasWcdmaRrcState specified at `val`.
     * @param val a QmiNasWcdmaRrcState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function nas_wcdma_rrc_state_get_string(val: NasWcdmaRrcState): string;
    /**
     * Gets the nickname string for the #QmiOmaHfaFeatureDoneState specified at `val`.
     * @param val a QmiOmaHfaFeatureDoneState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function oma_hfa_feature_done_state_get_string(val: OmaHfaFeatureDoneState): string;
    /**
     * Gets the nickname string for the #QmiOmaSessionFailedReason specified at `val`.
     * @param val a QmiOmaSessionFailedReason.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function oma_session_failed_reason_get_string(val: OmaSessionFailedReason): string;
    /**
     * Gets the nickname string for the #QmiOmaSessionState specified at `val`.
     * @param val a QmiOmaSessionState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function oma_session_state_get_string(val: OmaSessionState): string;
    /**
     * Gets the nickname string for the #QmiOmaSessionType specified at `val`.
     * @param val a QmiOmaSessionType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function oma_session_type_get_string(val: OmaSessionType): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiPbmEventRegistrationFlag in `mask`.
     * @param mask bitmask of QmiPbmEventRegistrationFlag values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function pbm_event_registration_flag_build_string_from_mask(mask: PbmEventRegistrationFlag): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiPbmPhonebookType in `mask`.
     * @param mask bitmask of QmiPbmPhonebookType values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function pbm_phonebook_type_build_string_from_mask(mask: PbmPhonebookType): string;
    /**
     * Gets the nickname string for the #QmiPbmSessionType specified at `val`.
     * @param val a QmiPbmSessionType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function pbm_session_type_get_string(val: PbmSessionType): string;
    /**
     * Gets the nickname string for the #QmiPdcConfigurationType specified at `val`.
     * @param val a QmiPdcConfigurationType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function pdc_configuration_type_get_string(val: PdcConfigurationType): string;
    /**
     * Gets the nickname string for the #QmiPdcRefreshEventType specified at `val`.
     * @param val a QmiPdcRefreshEventType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function pdc_refresh_event_type_get_string(val: PdcRefreshEventType): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiPdsDataValid in `mask`.
     * @param mask bitmask of QmiPdsDataValid values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function pds_data_valid_build_string_from_mask(mask: PdsDataValid): string;
    /**
     * Gets the nickname string for the #QmiPdsNetworkMode specified at `val`.
     * @param val a QmiPdsNetworkMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function pds_network_mode_get_string(val: PdsNetworkMode): string;
    /**
     * Gets the nickname string for the #QmiPdsOperatingMode specified at `val`.
     * @param val a QmiPdsOperatingMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function pds_operating_mode_get_string(val: PdsOperatingMode): string;
    /**
     * Gets the nickname string for the #QmiPdsOperationMode specified at `val`.
     * @param val a QmiPdsOperationMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function pds_operation_mode_get_string(val: PdsOperationMode): string;
    /**
     * Gets the nickname string for the #QmiPdsPositionSessionStatus specified at `val`.
     * @param val a QmiPdsPositionSessionStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function pds_position_session_status_get_string(val: PdsPositionSessionStatus): string;
    /**
     * Gets the nickname string for the #QmiPdsTrackingSessionState specified at `val`.
     * @param val a QmiPdsTrackingSessionState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function pds_tracking_session_state_get_string(val: PdsTrackingSessionState): string;
    /**
     * Gets the nickname string for the #QmiProtocolError specified at `val`.
     * @param val a QmiProtocolError.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function protocol_error_get_string(val: ProtocolError): string;
    function protocol_error_quark(): GLib.Quark;
    /**
     * Gets the nickname string for the #QmiQosEvent specified at `val`.
     * @param val a QmiQosEvent.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function qos_event_get_string(val: QosEvent): string;
    /**
     * Gets the nickname string for the #QmiQosStatus specified at `val`.
     * @param val a QmiQosStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function qos_status_get_string(val: QosStatus): string;
    /**
     * Gets the nickname string for the #QmiSarRfState specified at `val`.
     * @param val a QmiSarRfState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function sar_rf_state_get_string(val: SarRfState): string;
    /**
     * Gets the nickname string for the #QmiService specified at `val`.
     * @param val a QmiService.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function service_get_string(val: Service): string;
    /**
     * Gets the nickname string for the #QmiSioPort specified at `val`.
     * @param val a QmiSioPort.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function sio_port_get_string(val: SioPort): string;
    /**
     * Gets the nickname string for the #QmiSscReportType specified at `val`.
     * @param val a QmiSscReportType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function ssc_report_type_get_string(val: SscReportType): string;
    /**
     * Gets the nickname string for the #QmiUimCardApplicationPersonalizationFeature specified at `val`.
     * @param val a QmiUimCardApplicationPersonalizationFeature.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_card_application_personalization_feature_get_string(
        val: UimCardApplicationPersonalizationFeature,
    ): string;
    /**
     * Gets the nickname string for the #QmiUimCardApplicationPersonalizationFeatureStatus specified at `val`.
     * @param val a QmiUimCardApplicationPersonalizationFeatureStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_card_application_personalization_feature_status_get_string(
        val: UimCardApplicationPersonalizationFeatureStatus,
    ): string;
    /**
     * Gets the nickname string for the #QmiUimCardApplicationPersonalizationState specified at `val`.
     * @param val a QmiUimCardApplicationPersonalizationState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_card_application_personalization_state_get_string(val: UimCardApplicationPersonalizationState): string;
    /**
     * Gets the nickname string for the #QmiUimCardApplicationState specified at `val`.
     * @param val a QmiUimCardApplicationState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_card_application_state_get_string(val: UimCardApplicationState): string;
    /**
     * Gets the nickname string for the #QmiUimCardApplicationType specified at `val`.
     * @param val a QmiUimCardApplicationType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_card_application_type_get_string(val: UimCardApplicationType): string;
    /**
     * Gets the nickname string for the #QmiUimCardError specified at `val`.
     * @param val a QmiUimCardError.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_card_error_get_string(val: UimCardError): string;
    /**
     * Gets the nickname string for the #QmiUimCardProtocol specified at `val`.
     * @param val a QmiUimCardProtocol.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_card_protocol_get_string(val: UimCardProtocol): string;
    /**
     * Gets the nickname string for the #QmiUimCardState specified at `val`.
     * @param val a QmiUimCardState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_card_state_get_string(val: UimCardState): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiUimConfiguration in `mask`.
     * @param mask bitmask of QmiUimConfiguration values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function uim_configuration_build_string_from_mask(mask: UimConfiguration): string;
    /**
     * Gets the nickname string for the #QmiUimDepersonalizationOperation specified at `val`.
     * @param val a QmiUimDepersonalizationOperation.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_depersonalization_operation_get_string(val: UimDepersonalizationOperation): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiUimEventRegistrationFlag in `mask`.
     * @param mask bitmask of QmiUimEventRegistrationFlag values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function uim_event_registration_flag_build_string_from_mask(mask: UimEventRegistrationFlag): string;
    /**
     * Gets the nickname string for the #QmiUimFileType specified at `val`.
     * @param val a QmiUimFileType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_file_type_get_string(val: UimFileType): string;
    /**
     * Gets the nickname string for the #QmiUimPhysicalCardState specified at `val`.
     * @param val a QmiUimPhysicalCardState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_physical_card_state_get_string(val: UimPhysicalCardState): string;
    /**
     * Gets the nickname string for the #QmiUimPinId specified at `val`.
     * @param val a QmiUimPinId.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_pin_id_get_string(val: UimPinId): string;
    /**
     * Gets the nickname string for the #QmiUimPinState specified at `val`.
     * @param val a QmiUimPinState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_pin_state_get_string(val: UimPinState): string;
    /**
     * Gets the nickname string for the #QmiUimRefreshMode specified at `val`.
     * @param val a QmiUimRefreshMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_refresh_mode_get_string(val: UimRefreshMode): string;
    /**
     * Gets the nickname string for the #QmiUimRefreshStage specified at `val`.
     * @param val a QmiUimRefreshStage.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_refresh_stage_get_string(val: UimRefreshStage): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiUimSecurityAttribute in `mask`.
     * @param mask bitmask of QmiUimSecurityAttribute values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function uim_security_attribute_build_string_from_mask(mask: UimSecurityAttribute): string;
    /**
     * Gets the nickname string for the #QmiUimSecurityAttributeLogic specified at `val`.
     * @param val a QmiUimSecurityAttributeLogic.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_security_attribute_logic_get_string(val: UimSecurityAttributeLogic): string;
    /**
     * Gets the nickname string for the #QmiUimSessionType specified at `val`.
     * @param val a QmiUimSessionType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_session_type_get_string(val: UimSessionType): string;
    /**
     * Gets the nickname string for the #QmiUimSlotState specified at `val`.
     * @param val a QmiUimSlotState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function uim_slot_state_get_string(val: UimSlotState): string;
    /**
     * Checks whether personal info should be hidden when traces are enabled.
     * @returns %TRUE to show personal info in trace, %FALSE otherwise.
     */
    function utils_get_show_personal_info(): boolean;
    /**
     * Checks whether QMI message traces are currently enabled.
     * @returns %TRUE if traces are enabled, %FALSE otherwise.
     */
    function utils_get_traces_enabled(): boolean;
    /**
     * Sets whether personal info is printed when traces are enabled.
     * @param show_personal_info %TRUE to show personal info in traces, %FALSE otherwise.
     */
    function utils_set_show_personal_info(show_personal_info: boolean): void;
    /**
     * Sets whether QMI message traces are enabled or disabled.
     * @param enabled %TRUE to enable traces, %FALSE to disable them.
     */
    function utils_set_traces_enabled(enabled: boolean): void;
    /**
     * Gets the nickname string for the #QmiVoiceAlphaDataCodingScheme specified at `val`.
     * @param val a QmiVoiceAlphaDataCodingScheme.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_alpha_data_coding_scheme_get_string(val: VoiceAlphaDataCodingScheme): string;
    /**
     * Gets the nickname string for the #QmiVoiceAls specified at `val`.
     * @param val a QmiVoiceAls.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_als_get_string(val: VoiceAls): string;
    /**
     * Gets the nickname string for the #QmiVoiceCallControlResultType specified at `val`.
     * @param val a QmiVoiceCallControlResultType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_call_control_result_type_get_string(val: VoiceCallControlResultType): string;
    /**
     * Gets the nickname string for the #QmiVoiceCallControlSupplementaryServiceType specified at `val`.
     * @param val a QmiVoiceCallControlSupplementaryServiceType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_call_control_supplementary_service_type_get_string(
        val: VoiceCallControlSupplementaryServiceType,
    ): string;
    /**
     * Gets the nickname string for the #QmiVoiceCallDirection specified at `val`.
     * @param val a QmiVoiceCallDirection.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_call_direction_get_string(val: VoiceCallDirection): string;
    /**
     * Gets the nickname string for the #QmiVoiceCallEndReason specified at `val`.
     * @param val a QmiVoiceCallEndReason.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_call_end_reason_get_string(val: VoiceCallEndReason): string;
    /**
     * Gets the nickname string for the #QmiVoiceCallMode specified at `val`.
     * @param val a QmiVoiceCallMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_call_mode_get_string(val: VoiceCallMode): string;
    /**
     * Gets the nickname string for the #QmiVoiceCallState specified at `val`.
     * @param val a QmiVoiceCallState.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_call_state_get_string(val: VoiceCallState): string;
    /**
     * Gets the nickname string for the #QmiVoiceCallType specified at `val`.
     * @param val a QmiVoiceCallType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_call_type_get_string(val: VoiceCallType): string;
    /**
     * Gets the nickname string for the #QmiVoiceDomain specified at `val`.
     * @param val a QmiVoiceDomain.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_domain_get_string(val: VoiceDomain): string;
    /**
     * Gets the nickname string for the #QmiVoicePresentation specified at `val`.
     * @param val a QmiVoicePresentation.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_presentation_get_string(val: VoicePresentation): string;
    /**
     * Gets the nickname string for the #QmiVoicePrivacy specified at `val`.
     * @param val a QmiVoicePrivacy.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_privacy_get_string(val: VoicePrivacy): string;
    /**
     * Gets the nickname string for the #QmiVoiceServiceOption specified at `val`.
     * @param val a QmiVoiceServiceOption.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_service_option_get_string(val: VoiceServiceOption): string;
    /**
     * Gets the nickname string for the #QmiVoiceSupplementaryServiceAction specified at `val`.
     * @param val a QmiVoiceSupplementaryServiceAction.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_supplementary_service_action_get_string(val: VoiceSupplementaryServiceAction): string;
    /**
     * Gets the nickname string for the #QmiVoiceSupplementaryServiceNotificationType specified at `val`.
     * @param val a QmiVoiceSupplementaryServiceNotificationType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_supplementary_service_notification_type_get_string(
        val: VoiceSupplementaryServiceNotificationType,
    ): string;
    /**
     * Gets the nickname string for the #QmiVoiceSupplementaryServiceReason specified at `val`.
     * @param val a QmiVoiceSupplementaryServiceReason.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_supplementary_service_reason_get_string(val: VoiceSupplementaryServiceReason): string;
    /**
     * Gets the nickname string for the #QmiVoiceSupplementaryServiceType specified at `val`.
     * @param val a QmiVoiceSupplementaryServiceType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_supplementary_service_type_get_string(val: VoiceSupplementaryServiceType): string;
    /**
     * Gets the nickname string for the #QmiVoiceTtyMode specified at `val`.
     * @param val a QmiVoiceTtyMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_tty_mode_get_string(val: VoiceTtyMode): string;
    /**
     * Gets the nickname string for the #QmiVoiceUserAction specified at `val`.
     * @param val a QmiVoiceUserAction.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_user_action_get_string(val: VoiceUserAction): string;
    /**
     * Gets the nickname string for the #QmiVoiceUssDataCodingScheme specified at `val`.
     * @param val a QmiVoiceUssDataCodingScheme.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function voice_uss_data_coding_scheme_get_string(val: VoiceUssDataCodingScheme): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiVoiceWcdmaAmrStatus in `mask`.
     * @param mask bitmask of QmiVoiceWcdmaAmrStatus values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function voice_wcdma_amr_status_build_string_from_mask(mask: VoiceWcdmaAmrStatus): string;
    /**
     * Gets the nickname string for the #QmiWdaDataAggregationProtocol specified at `val`.
     * @param val a QmiWdaDataAggregationProtocol.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wda_data_aggregation_protocol_get_string(val: WdaDataAggregationProtocol): string;
    /**
     * Gets the nickname string for the #QmiWdaLinkLayerProtocol specified at `val`.
     * @param val a QmiWdaLinkLayerProtocol.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wda_link_layer_protocol_get_string(val: WdaLinkLayerProtocol): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsApnTypeMask in `mask`.
     * @param mask bitmask of QmiWdsApnTypeMask values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_apn_type_mask_build_string_from_mask(mask: WdsApnTypeMask): string;
    /**
     * Gets the nickname string for the #QmiWdsAttachPdnListAction specified at `val`.
     * @param val a QmiWdsAttachPdnListAction.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_attach_pdn_list_action_get_string(val: WdsAttachPdnListAction): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsAuthentication in `mask`.
     * @param mask bitmask of QmiWdsAuthentication values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_authentication_build_string_from_mask(mask: WdsAuthentication): string;
    /**
     * Gets the nickname string for the #QmiWdsAutoconnectSetting specified at `val`.
     * @param val a QmiWdsAutoconnectSetting.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_autoconnect_setting_get_string(val: WdsAutoconnectSetting): string;
    /**
     * Gets the nickname string for the #QmiWdsAutoconnectSettingRoaming specified at `val`.
     * @param val a QmiWdsAutoconnectSettingRoaming.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_autoconnect_setting_roaming_get_string(val: WdsAutoconnectSettingRoaming): string;
    /**
     * Gets the nickname string for the #QmiWdsCallEndReason specified at `val`.
     * @param val a QmiWdsCallEndReason.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_call_end_reason_get_string(val: WdsCallEndReason): string;
    /**
     * Gets the nickname string for the #QmiWdsCallType specified at `val`.
     * @param val a QmiWdsCallType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_call_type_get_string(val: WdsCallType): string;
    /**
     * Gets the nickname string for the #QmiWdsClientType specified at `val`.
     * @param val a QmiWdsClientType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_client_type_get_string(val: WdsClientType): string;
    /**
     * Gets the nickname string for the #QmiWdsConnectionStatus specified at `val`.
     * @param val a QmiWdsConnectionStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_connection_status_get_string(val: WdsConnectionStatus): string;
    /**
     * Gets the nickname string for the #QmiWdsDataBearerTechnology specified at `val`.
     * @param val a QmiWdsDataBearerTechnology.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_data_bearer_technology_get_string(val: WdsDataBearerTechnology): string;
    /**
     * Gets the nickname string for the #QmiWdsDataCallStatus specified at `val`.
     * @param val a QmiWdsDataCallStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_data_call_status_get_string(val: WdsDataCallStatus): string;
    /**
     * Gets the nickname string for the #QmiWdsDataCallType specified at `val`.
     * @param val a QmiWdsDataCallType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_data_call_type_get_string(val: WdsDataCallType): string;
    /**
     * Gets the nickname string for the #QmiWdsDataSystem specified at `val`.
     * @param val a QmiWdsDataSystem.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_data_system_get_string(val: WdsDataSystem): string;
    /**
     * Gets the nickname string for the #QmiWdsDataSystemNetworkType specified at `val`.
     * @param val a QmiWdsDataSystemNetworkType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_data_system_network_type_get_string(val: WdsDataSystemNetworkType): string;
    /**
     * Gets the nickname string for the #QmiWdsDeliveryOrder specified at `val`.
     * @param val a QmiWdsDeliveryOrder.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_delivery_order_get_string(val: WdsDeliveryOrder): string;
    /**
     * Gets the nickname string for the #QmiWdsDormancyStatus specified at `val`.
     * @param val a QmiWdsDormancyStatus.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_dormancy_status_get_string(val: WdsDormancyStatus): string;
    /**
     * Gets the nickname string for the #QmiWdsDsProfileError specified at `val`.
     * @param val a QmiWdsDsProfileError.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_ds_profile_error_get_string(val: WdsDsProfileError): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsExtendedDataBearerTechnology3gpp2 in `mask`.
     * @param mask bitmask of QmiWdsExtendedDataBearerTechnology3gpp2 values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_extended_data_bearer_technology_3gpp2_build_string_from_mask(
        mask: WdsExtendedDataBearerTechnology3gpp2,
    ): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsExtendedDataBearerTechnology3gpp in `mask`.
     * @param mask bitmask of QmiWdsExtendedDataBearerTechnology3gpp values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_extended_data_bearer_technology_3gpp_build_string_from_mask(
        mask: WdsExtendedDataBearerTechnology3gpp,
    ): string;
    /**
     * Gets the nickname string for the #QmiWdsExtendedTechnologyPreference specified at `val`.
     * @param val a QmiWdsExtendedTechnologyPreference.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_extended_technology_preference_get_string(val: WdsExtendedTechnologyPreference): string;
    /**
     * Gets the nickname string for the #QmiWdsIpFamily specified at `val`.
     * @param val a QmiWdsIpFamily.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_ip_family_get_string(val: WdsIpFamily): string;
    /**
     * Gets the nickname string for the #QmiWdsIpSupportType specified at `val`.
     * @param val a QmiWdsIpSupportType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_ip_support_type_get_string(val: WdsIpSupportType): string;
    /**
     * Gets the nickname string for the #QmiWdsNetworkType specified at `val`.
     * @param val a QmiWdsNetworkType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_network_type_get_string(val: WdsNetworkType): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsPacketStatisticsMaskFlag in `mask`.
     * @param mask bitmask of QmiWdsPacketStatisticsMaskFlag values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_packet_statistics_mask_flag_build_string_from_mask(mask: WdsPacketStatisticsMaskFlag): string;
    /**
     * Gets the nickname string for the #QmiWdsPdpDataCompressionType specified at `val`.
     * @param val a QmiWdsPdpDataCompressionType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_pdp_data_compression_type_get_string(val: WdsPdpDataCompressionType): string;
    /**
     * Gets the nickname string for the #QmiWdsPdpHeaderCompressionType specified at `val`.
     * @param val a QmiWdsPdpHeaderCompressionType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_pdp_header_compression_type_get_string(val: WdsPdpHeaderCompressionType): string;
    /**
     * Gets the nickname string for the #QmiWdsPdpType specified at `val`.
     * @param val a QmiWdsPdpType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_pdp_type_get_string(val: WdsPdpType): string;
    /**
     * Gets the nickname string for the #QmiWdsProfileChangeEvent specified at `val`.
     * @param val a QmiWdsProfileChangeEvent.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_profile_change_event_get_string(val: WdsProfileChangeEvent): string;
    /**
     * Gets the nickname string for the #QmiWdsProfileFamily specified at `val`.
     * @param val a QmiWdsProfileFamily.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_profile_family_get_string(val: WdsProfileFamily): string;
    /**
     * Gets the nickname string for the #QmiWdsProfileType specified at `val`.
     * @param val a QmiWdsProfileType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_profile_type_get_string(val: WdsProfileType): string;
    /**
     * Gets the nickname string for the #QmiWdsQosClassIdentifier specified at `val`.
     * @param val a QmiWdsQosClassIdentifier.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_qos_class_identifier_get_string(val: WdsQosClassIdentifier): string;
    /**
     * Gets the nickname string for the #QmiWdsRadioAccessTechnology specified at `val`.
     * @param val a QmiWdsRadioAccessTechnology.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_radio_access_technology_get_string(val: WdsRadioAccessTechnology): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsRat3gpp2 in `mask`.
     * @param mask bitmask of QmiWdsRat3gpp2 values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_rat_3gpp2_build_string_from_mask(mask: WdsRat3gpp2): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsRat3gpp in `mask`.
     * @param mask bitmask of QmiWdsRat3gpp values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_rat_3gpp_build_string_from_mask(mask: WdsRat3gpp): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsRequestedSettings in `mask`.
     * @param mask bitmask of QmiWdsRequestedSettings values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_requested_settings_build_string_from_mask(mask: WdsRequestedSettings): string;
    /**
     * Gets the nickname string for the #QmiWdsSduErroneousDelivery specified at `val`.
     * @param val a QmiWdsSduErroneousDelivery.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_sdu_erroneous_delivery_get_string(val: WdsSduErroneousDelivery): string;
    /**
     * Gets the nickname string for the #QmiWdsSduErrorRatio specified at `val`.
     * @param val a QmiWdsSduErrorRatio.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_sdu_error_ratio_get_string(val: WdsSduErrorRatio): string;
    /**
     * Gets the nickname string for the #QmiWdsSduResidualBitErrorRatio specified at `val`.
     * @param val a QmiWdsSduResidualBitErrorRatio.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_sdu_residual_bit_error_ratio_get_string(val: WdsSduResidualBitErrorRatio): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsSetEventReportTransferStatistics in `mask`.
     * @param mask bitmask of QmiWdsSetEventReportTransferStatistics values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_set_event_report_transfer_statistics_build_string_from_mask(
        mask: WdsSetEventReportTransferStatistics,
    ): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsSoCdma1x in `mask`.
     * @param mask bitmask of QmiWdsSoCdma1x values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_so_cdma1x_build_string_from_mask(mask: WdsSoCdma1x): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsSoEvdoRev0 in `mask`.
     * @param mask bitmask of QmiWdsSoEvdoRev0 values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_so_evdo_rev0_build_string_from_mask(mask: WdsSoEvdoRev0): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsSoEvdoRevA in `mask`.
     * @param mask bitmask of QmiWdsSoEvdoRevA values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_so_evdo_reva_build_string_from_mask(mask: WdsSoEvdoRevA): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsSoEvdoRevB in `mask`.
     * @param mask bitmask of QmiWdsSoEvdoRevB values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_so_evdo_revb_build_string_from_mask(mask: WdsSoEvdoRevB): string;
    /**
     * Builds a string containing a comma-separated list of nicknames for
     * each #QmiWdsTechnologyPreference in `mask`.
     * @param mask bitmask of QmiWdsTechnologyPreference values.
     * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
     */
    function wds_technology_preference_build_string_from_mask(mask: WdsTechnologyPreference): string;
    /**
     * Gets the nickname string for the #QmiWdsTetheredCallType specified at `val`.
     * @param val a QmiWdsTetheredCallType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_tethered_call_type_get_string(val: WdsTetheredCallType): string;
    /**
     * Gets the nickname string for the #QmiWdsTrafficClass specified at `val`.
     * @param val a QmiWdsTrafficClass.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_traffic_class_get_string(val: WdsTrafficClass): string;
    /**
     * Gets the nickname string for the #QmiWdsVerboseCallEndReason3gpp specified at `val`.
     * @param val a QmiWdsVerboseCallEndReason3gpp.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_verbose_call_end_reason_3gpp_get_string(val: WdsVerboseCallEndReason3gpp): string;
    /**
     * Gets the nickname string for the #QmiWdsVerboseCallEndReasonCm specified at `val`.
     * @param val a QmiWdsVerboseCallEndReasonCm.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_verbose_call_end_reason_cm_get_string(val: WdsVerboseCallEndReasonCm): string;
    /**
     * Gets the nickname string for the #QmiWdsVerboseCallEndReasonEhrpd specified at `val`.
     * @param val a QmiWdsVerboseCallEndReasonEhrpd.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_verbose_call_end_reason_ehrpd_get_string(val: WdsVerboseCallEndReasonEhrpd): string;
    /**
     * Get verbose call end reason based on the reason type.
     * @param type a #QmiWdsVerboseCallEndReasonType.
     * @param reason the reason id.
     * @returns a string with the reason, or %NULL if not found. Do not free the returned value.
     */
    function wds_verbose_call_end_reason_get_string(type: WdsVerboseCallEndReasonType, reason: number): string;
    /**
     * Gets the nickname string for the #QmiWdsVerboseCallEndReasonInternal specified at `val`.
     * @param val a QmiWdsVerboseCallEndReasonInternal.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_verbose_call_end_reason_internal_get_string(val: WdsVerboseCallEndReasonInternal): string;
    /**
     * Gets the nickname string for the #QmiWdsVerboseCallEndReasonIpv6 specified at `val`.
     * @param val a QmiWdsVerboseCallEndReasonIpv6.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_verbose_call_end_reason_ipv6_get_string(val: WdsVerboseCallEndReasonIpv6): string;
    /**
     * Gets the nickname string for the #QmiWdsVerboseCallEndReasonMip specified at `val`.
     * @param val a QmiWdsVerboseCallEndReasonMip.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_verbose_call_end_reason_mip_get_string(val: WdsVerboseCallEndReasonMip): string;
    /**
     * Gets the nickname string for the #QmiWdsVerboseCallEndReasonPpp specified at `val`.
     * @param val a QmiWdsVerboseCallEndReasonPpp.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_verbose_call_end_reason_ppp_get_string(val: WdsVerboseCallEndReasonPpp): string;
    /**
     * Gets the nickname string for the #QmiWdsVerboseCallEndReasonType specified at `val`.
     * @param val a QmiWdsVerboseCallEndReasonType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wds_verbose_call_end_reason_type_get_string(val: WdsVerboseCallEndReasonType): string;
    /**
     * Gets the nickname string for the #QmiWmsAckFailureCause specified at `val`.
     * @param val a QmiWmsAckFailureCause.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_ack_failure_cause_get_string(val: WmsAckFailureCause): string;
    /**
     * Gets the nickname string for the #QmiWmsAckIndicator specified at `val`.
     * @param val a QmiWmsAckIndicator.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_ack_indicator_get_string(val: WmsAckIndicator): string;
    /**
     * Gets the nickname string for the #QmiWmsCdmaCauseCode specified at `val`.
     * @param val a QmiWmsCdmaCauseCode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_cdma_cause_code_get_string(val: WmsCdmaCauseCode): string;
    /**
     * Gets the nickname string for the #QmiWmsCdmaErrorClass specified at `val`.
     * @param val a QmiWmsCdmaErrorClass.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_cdma_error_class_get_string(val: WmsCdmaErrorClass): string;
    /**
     * Gets the nickname string for the #QmiWmsCdmaServiceOption specified at `val`.
     * @param val a QmiWmsCdmaServiceOption.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_cdma_service_option_get_string(val: WmsCdmaServiceOption): string;
    /**
     * Gets the nickname string for the #QmiWmsGsmUmtsRpCause specified at `val`.
     * @param val a QmiWmsGsmUmtsRpCause.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_gsm_umts_rp_cause_get_string(val: WmsGsmUmtsRpCause): string;
    /**
     * Gets the nickname string for the #QmiWmsGsmUmtsTpCause specified at `val`.
     * @param val a QmiWmsGsmUmtsTpCause.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_gsm_umts_tp_cause_get_string(val: WmsGsmUmtsTpCause): string;
    /**
     * Gets the nickname string for the #QmiWmsMessageClass specified at `val`.
     * @param val a QmiWmsMessageClass.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_message_class_get_string(val: WmsMessageClass): string;
    /**
     * Gets the nickname string for the #QmiWmsMessageDeliveryFailureType specified at `val`.
     * @param val a QmiWmsMessageDeliveryFailureType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_message_delivery_failure_type_get_string(val: WmsMessageDeliveryFailureType): string;
    /**
     * Gets the nickname string for the #QmiWmsMessageFormat specified at `val`.
     * @param val a QmiWmsMessageFormat.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_message_format_get_string(val: WmsMessageFormat): string;
    /**
     * Gets the nickname string for the #QmiWmsMessageMode specified at `val`.
     * @param val a QmiWmsMessageMode.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_message_mode_get_string(val: WmsMessageMode): string;
    /**
     * Gets the nickname string for the #QmiWmsMessageProtocol specified at `val`.
     * @param val a QmiWmsMessageProtocol.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_message_protocol_get_string(val: WmsMessageProtocol): string;
    /**
     * Gets the nickname string for the #QmiWmsMessageTagType specified at `val`.
     * @param val a QmiWmsMessageTagType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_message_tag_type_get_string(val: WmsMessageTagType): string;
    /**
     * Gets the nickname string for the #QmiWmsMessageType specified at `val`.
     * @param val a QmiWmsMessageType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_message_type_get_string(val: WmsMessageType): string;
    /**
     * Gets the nickname string for the #QmiWmsNotificationType specified at `val`.
     * @param val a QmiWmsNotificationType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_notification_type_get_string(val: WmsNotificationType): string;
    /**
     * Gets the nickname string for the #QmiWmsReceiptAction specified at `val`.
     * @param val a QmiWmsReceiptAction.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_receipt_action_get_string(val: WmsReceiptAction): string;
    /**
     * Gets the nickname string for the #QmiWmsStorageType specified at `val`.
     * @param val a QmiWmsStorageType.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_storage_type_get_string(val: WmsStorageType): string;
    /**
     * Gets the nickname string for the #QmiWmsTransferIndication specified at `val`.
     * @param val a QmiWmsTransferIndication.
     * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
     */
    function wms_transfer_indication_get_string(val: WmsTransferIndication): string;
    interface DeviceCommandAbortableParseResponseFn {
        (self: Device, abort_response: Message): boolean;
    }
    interface MessageForeachRawTlvFn {
        (type: number, value: number, length: number): void;
    }
    /**
     * QMI flags in messages of the %QMI_SERVICE_CTL service.
     */

    /**
     * QMI flags in messages of the %QMI_SERVICE_CTL service.
     */
    export namespace CtlFlag {
        export const $gtype: GObject.GType<CtlFlag>;
    }

    enum CtlFlag {
        /**
         * None.
         */
        NONE,
        /**
         * Message is a response.
         */
        RESPONSE,
        /**
         * Message is an indication.
         */
        INDICATION,
    }
    /**
     * Flags specifying the behavior of the new link.
     */

    /**
     * Flags specifying the behavior of the new link.
     */
    export namespace DeviceAddLinkFlags {
        export const $gtype: GObject.GType<DeviceAddLinkFlags>;
    }

    enum DeviceAddLinkFlags {
        /**
         * none.
         */
        NONE,
        /**
         * checksum offload (v4) is enabled in ingress path.
         */
        INGRESS_MAP_CKSUMV4,
        /**
         * checksum offload (v4) is enabled in egress path.
         */
        EGRESS_MAP_CKSUMV4,
        /**
         * checksum offload (v5) is enabled in ingress path. Since 1.32.
         */
        INGRESS_MAP_CKSUMV5,
        /**
         * checksum offload (v5) is enabled in egress path. Since 1.32.
         */
        EGRESS_MAP_CKSUMV5,
    }
    /**
     * Flags to specify which actions to be performed when the device is open.
     */

    /**
     * Flags to specify which actions to be performed when the device is open.
     */
    export namespace DeviceOpenFlags {
        export const $gtype: GObject.GType<DeviceOpenFlags>;
    }

    enum DeviceOpenFlags {
        /**
         * No flags.
         */
        NONE,
        /**
         * Run version info check when opening. Since 1.24.4 this flag no longer prevents requests from being sent to the modem if they're assumed not supported based on the version info of each message.
         */
        VERSION_INFO,
        /**
         * Synchronize with endpoint once the device is open. Will release any previously allocated client ID.
         */
        SYNC,
        /**
         * set network port to "802.3" mode; mutually exclusive with `QMI_DEVICE_OPEN_FLAGS_NET_RAW_IP`
         */
        NET_802_3,
        /**
         * set network port to "raw IP" mode; mutally exclusive with `QMI_DEVICE_OPEN_FLAGS_NET_8`02_3
         */
        NET_RAW_IP,
        /**
         * set network port to transmit/receive QoS headers; mutually exclusive with `QMI_DEVICE_OPEN_FLAGS_NET_NO_QOS_HEADER`
         */
        NET_QOS_HEADER,
        /**
         * set network port to not transmit/receive QoS headers; mutually exclusive with `QMI_DEVICE_OPEN_FLAGS_NET_QOS_HEADER`
         */
        NET_NO_QOS_HEADER,
        /**
         * Try to open the port through the 'qmi-proxy'. Since: 1.8.
         */
        PROXY,
        /**
         * open an MBIM port with QMUX tunneling service. Since: 1.16.
         */
        MBIM,
        /**
         * open a port either in QMI or MBIM mode, depending on device driver. Since: 1.18.
         */
        AUTO,
        /**
         * Explicitly state that indications are wanted (implicit in QMI mode, optional when in MBIM mode).
         */
        EXPECT_INDICATIONS,
    }
    /**
     * Flags to specify which actions to be performed when releasing the client.
     */

    /**
     * Flags to specify which actions to be performed when releasing the client.
     */
    export namespace DeviceReleaseClientFlags {
        export const $gtype: GObject.GType<DeviceReleaseClientFlags>;
    }

    enum DeviceReleaseClientFlags {
        /**
         * No flags.
         */
        NONE,
        /**
         * Release the CID when releasing the client.
         */
        RELEASE_CID,
    }
    /**
     * Frequency band capabilities.
     *
     * This type is bit to bit compatible with #QmiNasBandPreference.
     */

    /**
     * Frequency band capabilities.
     *
     * This type is bit to bit compatible with #QmiNasBandPreference.
     */
    export namespace DmsBandCapability {
        export const $gtype: GObject.GType<DmsBandCapability>;
    }

    enum DmsBandCapability {
        /**
         * Band class 0, A-system.
         */
        BC_0_A_SYSTEM,
        /**
         * Band class 0, B-system.
         */
        BC_0_B_SYSTEM,
        /**
         * Band class 1, all blocks.
         */
        BC_1_ALL_BLOCKS,
        /**
         * Band class 2.
         */
        BC_2,
        /**
         * Band class 3, A-system.
         */
        BC_3_A_SYSTEM,
        /**
         * Band class 4, all blocks.
         */
        BC_4_ALL_BLOCKS,
        /**
         * Band class 5, all blocks.
         */
        BC_5_ALL_BLOCKS,
        /**
         * GSM DCS band.
         */
        GSM_DCS_1800,
        /**
         * GSM Extended GSM band (900).
         */
        GSM_900_EXTENDED,
        /**
         * GSM Primary GSM band (900).
         */
        GSM_900_PRIMARY,
        /**
         * Band class 6.
         */
        BC_6,
        /**
         * Band class 7.
         */
        BC_7,
        /**
         * Band class 8.
         */
        BC_8,
        /**
         * Band class 9.
         */
        BC_9,
        /**
         * Band class 10.
         */
        BC_10,
        /**
         * Band class 11.
         */
        BC_11,
        /**
         * GSM 450 band.
         */
        GSM_450,
        /**
         * GSM 480 band.
         */
        GSM_480,
        /**
         * GSM 750 band.
         */
        GSM_750,
        /**
         * GSM 850 band.
         */
        GSM_850,
        /**
         * GSM railways band (900).
         */
        GSM_900_RAILWAYS,
        /**
         * GSM PCS band (1900).
         */
        GSM_PCS_1900,
        /**
         * WCDMA 2100 band (Europe, Japan, China).
         */
        WCDMA_2100,
        /**
         * WCDMA PCS 1900 band (US).
         */
        WCDMA_PCS_1900,
        /**
         * WCDMA DCS 1800 band (Europe, China).
         */
        WCDMA_DCS_1800,
        /**
         * WCDMA 1700 band (US).
         */
        WCDMA_1700_US,
        /**
         * WCDMA 850 band (US).
         */
        WCDMA_850_US,
        /**
         * QWCDMA 850 band (Japan).
         */
        WCDMA_800,
        /**
         * Band class 12.
         */
        BC_12,
        /**
         * Band class 14.
         */
        BC_14,
        /**
         * Band class 15.
         */
        BC_15,
        /**
         * WCDMA 2600 band (Europe).
         */
        WCDMA_2600,
        /**
         * WCDMA 900 band (Europe, Japan).
         */
        WCDMA_900,
        /**
         * WCDMA 1700 band (Japan).
         */
        WCDMA_1700_JAPAN,
        /**
         * Band class 16.
         */
        BC_16,
        /**
         * Band class 17.
         */
        BC_17,
        /**
         * Band class 18.
         */
        BC_18,
        /**
         * Band class 19.
         */
        BC_19,
        /**
         * WCDMA 850 band (Japan)
         */
        WCDMA_850_JAPAN,
        /**
         * WCDMA 1500 band.
         */
        WCDMA_1500,
    }
    /**
     * LTE-specific Frequency bands.
     */
    /**
     * LTE-specific Frequency bands.
     */
    class DmsLteBandCapability {
        static $gtype: GObject.GType<DmsLteBandCapability>;

        // Static fields

        /**
         * LTE EUTRAN Band 1
         */
        static '1': number;
        /**
         * LTE EUTRAN Band 2.
         */
        static '2': number;
        /**
         * LTE EUTRAN Band 3.
         */
        static '3': number;
        /**
         * LTE EUTRAN Band 4.
         */
        static '4': number;
        /**
         * LTE EUTRAN Band 5.
         */
        static '5': number;
        /**
         * LTE EUTRAN Band 6.
         */
        static '6': number;
        /**
         * LTE EUTRAN Band 7.
         */
        static '7': number;
        /**
         * LTE EUTRAN Band 8.
         */
        static '8': number;
        /**
         * LTE EUTRAN Band 9.
         */
        static '9': number;
        /**
         * LTE EUTRAN Band 10.
         */
        static '10': number;
        /**
         * LTE EUTRAN Band 11.
         */
        static '11': number;
        /**
         * LTE EUTRAN Band 12.
         */
        static '12': number;
        /**
         * LTE EUTRAN Band 13.
         */
        static '13': number;
        /**
         * LTE EUTRAN Band 14.
         */
        static '14': number;
        /**
         * LTE EUTRAN Band 17.
         */
        static '17': number;
        /**
         * LTE EUTRAN Band 18.
         */
        static '18': number;
        /**
         * LTE EUTRAN Band 19.
         */
        static '19': number;
        /**
         * LTE EUTRAN Band 20.
         */
        static '20': number;
        /**
         * LTE EUTRAN Band 21.
         */
        static '21': number;
        /**
         * LTE EUTRAN Band 24.
         */
        static '24': number;
        /**
         * LTE EUTRAN Band 25.
         */
        static '25': number;
        /**
         * LTE EUTRAN Band 26.
         */
        static '26': number;
        /**
         * LTE EUTRAN Band 27.
         */
        static '27': number;
        /**
         * LTE EUTRAN Band 28.
         */
        static '28': number;
        /**
         * LTE EUTRAN Band 29.
         */
        static '29': number;
        /**
         * LTE EUTRAN Band 30.
         */
        static '30': number;
        /**
         * LTE EUTRAN Band 31.
         */
        static '31': number;
        /**
         * LTE EUTRAN Band 32.
         */
        static '32': number;
        /**
         * LTE EUTRAN Band 33.
         */
        static '33': number;
        /**
         * LTE EUTRAN Band 34.
         */
        static '34': number;
        /**
         * LTE EUTRAN Band 35.
         */
        static '35': number;
        /**
         * LTE EUTRAN Band 36.
         */
        static '36': number;
        /**
         * LTE EUTRAN Band 37.
         */
        static '37': number;
        /**
         * LTE EUTRAN Band 38.
         */
        static '38': number;
        /**
         * LTE EUTRAN Band 39.
         */
        static '39': number;
        /**
         * LTE EUTRAN Band 40.
         */
        static '40': number;
        /**
         * LTE EUTRAN Band 41.
         */
        static '41': number;
        /**
         * LTE EUTRAN Band 42.
         */
        static '42': number;
        /**
         * LTE EUTRAN Band 43.
         */
        static '43': number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Reasons for being in Offline (`QMI_DMS_OPERATING_MODE_OFFLINE)` state.
     */

    /**
     * Reasons for being in Offline (`QMI_DMS_OPERATING_MODE_OFFLINE)` state.
     */
    export namespace DmsOfflineReason {
        export const $gtype: GObject.GType<DmsOfflineReason>;
    }

    enum DmsOfflineReason {
        /**
         * Host image misconfiguration.
         */
        HOST_IMAGE_MISCONFIGURATION,
        /**
         * PRI image misconfiguration.
         */
        PRI_IMAGE_MISCONFIGURATION,
        /**
         * PRI version incompatible.
         */
        PRI_VERSION_INCOMPATIBLE,
        /**
         * Memory full, cannot copy PRI information.
         */
        DEVICE_MEMORY_FULL,
    }
    /**
     * Flags specifying the current power state.
     *
     * If `QMI_DMS_POWER_STATE_EXTERNAL_SOURCE` is set, the device is powerered by an
     * external source; otherwise it is powered by a battery.
     *
     * If `QMI_DMS_POWER_STATE_BATTERY_CONNECTED` is set, the battery is connected;
     * otherwise the battery is not connected.
     *
     * If `QMI_DMS_POWER_STATE_BATTERY_CHARGING` is set, the battery is being charged;
     * otherwise the battery is not being charged.
     *
     * If `QMI_DMS_POWER_STATE_FAULT` is set, a power fault has been detected.
     */

    /**
     * Flags specifying the current power state.
     *
     * If `QMI_DMS_POWER_STATE_EXTERNAL_SOURCE` is set, the device is powerered by an
     * external source; otherwise it is powered by a battery.
     *
     * If `QMI_DMS_POWER_STATE_BATTERY_CONNECTED` is set, the battery is connected;
     * otherwise the battery is not connected.
     *
     * If `QMI_DMS_POWER_STATE_BATTERY_CHARGING` is set, the battery is being charged;
     * otherwise the battery is not being charged.
     *
     * If `QMI_DMS_POWER_STATE_FAULT` is set, a power fault has been detected.
     */
    export namespace DmsPowerState {
        export const $gtype: GObject.GType<DmsPowerState>;
    }

    enum DmsPowerState {
        /**
         * Powered by an external source.
         */
        EXTERNAL_SOURCE,
        /**
         * Battery is connected.
         */
        BATTERY_CONNECTED,
        /**
         * Battery is currently being charged.
         */
        BATTERY_CHARGING,
        /**
         * Recognized power fault.
         */
        FAULT,
    }
    /**
     * APN type preference as a bitmask.
     */

    /**
     * APN type preference as a bitmask.
     */
    export namespace DsdApnTypePreference {
        export const $gtype: GObject.GType<DsdApnTypePreference>;
    }

    enum DsdApnTypePreference {
        /**
         * Default/Internet traffic.
         */
        DEFAULT,
        /**
         * IMS.
         */
        IMS,
        /**
         * Multimedia Messaging Service.
         */
        MMS,
        /**
         * Dial Up Network.
         */
        DUN,
        /**
         * Secure User Plane Location.
         */
        SUPL,
        /**
         * High Priority Mobile Data.
         */
        HIPRI,
        /**
         * over the air administration.
         */
        FOTA,
        /**
         * Carrier Branded Services.
         */
        CBS,
        /**
         * Initial Attach.
         */
        IA,
        /**
         * Emergency.
         */
        EMERGENCY,
    }
    /**
     * Service Option (SO) mask.
     */

    /**
     * Service Option (SO) mask.
     */
    export namespace DsdSoMask {
        export const $gtype: GObject.GType<DsdSoMask>;
    }

    enum DsdSoMask {
        /**
         * WCDMA.
         */
        '3GPP_SO_MASK_WCDMA',
        /**
         * HSDPA.
         */
        '3GPP_SO_MASK_HSDPA',
        /**
         * HSUPA.
         */
        '3GPP_SO_MASK_HSUPA',
        /**
         * HSDPAPLUS.
         */
        '3GPP_SO_MASK_HSDPAPLUS',
        /**
         * DC HSDPAPLUS.
         */
        '3GPP_SO_MASK_DC_HSDPAPLUS',
        /**
         * 64 QAM.
         */
        '3GPP_SO_MASK_64_QAM',
        /**
         * HSPA.
         */
        '3GPP_SO_MASK_HSPA',
        /**
         * GPRS.
         */
        '3GPP_SO_MASK_GPRS',
        /**
         * EDGE.
         */
        '3GPP_SO_MASK_EDGE',
        /**
         * GSM.
         */
        '3GPP_SO_MASK_GSM',
        /**
         * S2B.
         */
        '3GPP_SO_MASK_S2B',
        /**
         * LTE Limited Service.
         */
        '3GPP_SO_MASK_LTE_LIMITED_SRVC',
        /**
         * LTE FDD.
         */
        '3GPP_SO_MASK_LTE_FDD',
        /**
         * LTE TDD.
         */
        '3GPP_SO_MASK_LTE_TDD',
        /**
         * TDSCDMA.
         */
        '3GPP_SO_MASK_TDSCDMA',
        /**
         * DC_HSUPA.
         */
        '3GPP_SO_MASK_DC_HSUPA',
        /**
         * LTE CA DL.
         */
        '3GPP_SO_MASK_LTE_CA_DL',
        /**
         * LTE CA UL.
         */
        '3GPP_SO_MASK_LTE_CA_UL',
        /**
         * S2B Limited Service.
         */
        '3GPP_SO_MASK_S2B_LIMITED_SRVC',
        /**
         * 4.5G.
         */
        '3GPP_SO_MASK_FOUR_POINT_FIVE_G',
        /**
         * 4.5G+.
         */
        '3GPP_SO_MASK_FOUR_POINT_FIVE_G_PLUS',
        /**
         * 1X IS95.
         */
        '3GPP2_SO_MASK_1X_IS95',
        /**
         * 1X IS2000.
         */
        '3GPP2_SO_MASK_1X_IS2000',
        /**
         * 1X IS2000 REL A.
         */
        '3GPP2_SO_MASK_1X_IS2000_REL_A',
        /**
         * HDR REV0 DPA.
         */
        '3GPP2_SO_MASK_HDR_REV0_DPA',
        /**
         * HDR REVB DPA.
         */
        '3GPP2_SO_MASK_HDR_REVA_DPA',
        /**
         * HDR REVB DPA.
         */
        '3GPP2_SO_MASK_HDR_REVB_DPA',
        /**
         * HDR REVA MPA.
         */
        '3GPP2_SO_MASK_HDR_REVA_MPA',
        /**
         * HDR REVB MPA.
         */
        '3GPP2_SO_MASK_HDR_REVB_MPA',
        /**
         * HDR REVA EMPA.
         */
        '3GPP2_SO_MASK_HDR_REVA_EMPA',
        /**
         * HDR REVB EMPA.
         */
        '3GPP2_SO_MASK_HDR_REVB_EMPA',
        /**
         * HDR REVB MMPA.
         */
        '3GPP2_SO_MASK_HDR_REVB_MMPA',
        /**
         * HDR EVDO FMC.
         */
        '3GPP2_SO_MASK_HDR_EVDO_FMC',
        /**
         * 1X Circuit Switched.
         */
        '3GPP2_SO_MASK_1X_CS',
        /**
         * 5G TDD.
         */
        '3GPP_SO_MASK_5G_TDD',
        /**
         * 5G SUB6.
         */
        '3GPP_SO_MASK_5G_SUB6',
        /**
         * 5G MMWAVE.
         */
        '3GPP_SO_MASK_5G_MMWAVE',
        /**
         * 5G NSA.
         */
        '3GPP_SO_MASK_5G_NSA',
        /**
         * 5G SA.
         */
        '3GPP_SO_MASK_5G_SA',
    }
    /**
     * Type of data to delete from the cell database.
     */

    /**
     * Type of data to delete from the cell database.
     */
    export namespace LocDeleteCellDatabase {
        export const $gtype: GObject.GType<LocDeleteCellDatabase>;
    }

    enum LocDeleteCellDatabase {
        /**
         * Position.
         */
        POS,
        /**
         * Latest GPS position.
         */
        LATEST_GPS_POS,
        /**
         * OTA position.
         */
        OTA_POS,
        /**
         * External reference position.
         */
        EXT_REF_POS,
        /**
         * Timetag.
         */
        TIMETAG,
        /**
         * Cell ID.
         */
        CELLID,
        /**
         * Cached cell ID.
         */
        CACHED_CELLID,
        /**
         * Last serving cell.
         */
        LAST_SRV_CELL,
        /**
         * Current servince cell.
         */
        CUR_SRV_CELL,
        /**
         * Neighboring cell info.
         */
        NEIGHBOR_INFO,
    }
    /**
     * Type of data to delete from the clock information.
     */

    /**
     * Type of data to delete from the clock information.
     */
    export namespace LocDeleteClockInfo {
        export const $gtype: GObject.GType<LocDeleteClockInfo>;
    }

    enum LocDeleteClockInfo {
        /**
         * Time estimation.
         */
        TIME_EST,
        /**
         * Frequency estimation.
         */
        FREQ_EST,
        /**
         * Week number.
         */
        WEEK_NUMBER,
        /**
         * RTC time.
         */
        RTC_TIME,
        /**
         * Time transfer.
         */
        TIME_TRANSFER,
        /**
         * GPS time estimation.
         */
        GPS_TIME_EST,
        /**
         * GLONASS time estimation.
         */
        GLO_TIME_EST,
        /**
         * GLONASS day number.
         */
        GLO_DAY_NUMBER,
        /**
         * GLONASS year number.
         */
        GLO_YEAR_NUMBER,
        /**
         * GLONASS RF group delay.
         */
        GLO_RF_GRP_DELAY,
        /**
         * Disable TT.
         */
        DISABLE_TT,
    }
    /**
     * Flags to use when deleting GNSS assistance data.
     *
     * Since 1.22
     */

    /**
     * Flags to use when deleting GNSS assistance data.
     *
     * Since 1.22
     */
    export namespace LocDeleteGnssData {
        export const $gtype: GObject.GType<LocDeleteGnssData>;
    }

    enum LocDeleteGnssData {
        /**
         * GPS SV dir.
         */
        GPS_SVDIR,
        /**
         * GPS SV steer.
         */
        GPS_SVSTEER,
        /**
         * GPS time.
         */
        GPS_TIME,
        /**
         * GPS alm corr.
         */
        GPS_ALM_CORR,
        /**
         * GLONASS SV dir.
         */
        GLO_SVDIR,
        /**
         * GLONASS SV steer.
         */
        GLO_SVSTEER,
        /**
         * GLONASS time.
         */
        GLO_TIME,
        /**
         * GLONASS alm corr.
         */
        GLO_ALM_CORR,
        /**
         * SBAS SV dir.
         */
        SBAS_SVDIR,
        /**
         * SBAS SV steer.
         */
        SBAS_SVSTEER,
        /**
         * Position.
         */
        POSITION,
        /**
         * Time.
         */
        TIME,
        /**
         * Ionospheric data.
         */
        IONO,
        /**
         * UTC time.
         */
        UTC,
        /**
         * Health information.
         */
        HEALTH,
        /**
         * SA data.
         */
        SADATA,
        /**
         * RTI.
         */
        RTI,
        /**
         * SV no exist.
         */
        SV_NO_EXIST,
        /**
         * Frequency bias estimation.
         */
        FREQ_BIAS_EST,
    }
    /**
     * Type of data to delete for a given satellite.
     */

    /**
     * Type of data to delete for a given satellite.
     */
    export namespace LocDeleteSvInfo {
        export const $gtype: GObject.GType<LocDeleteSvInfo>;
    }

    enum LocDeleteSvInfo {
        /**
         * Ephemeris.
         */
        EPHEMERIS,
        /**
         * Almanac.
         */
        ALMANAC,
    }
    /**
     * For which events to register the subscription.
     *
     * Since 1.22
     */

    /**
     * For which events to register the subscription.
     *
     * Since 1.22
     */
    export namespace LocEventRegistrationFlag {
        export const $gtype: GObject.GType<LocEventRegistrationFlag>;
    }

    enum LocEventRegistrationFlag {
        /**
         * Position report.
         */
        POSITION_REPORT,
        /**
         * GNSS satellite info.
         */
        GNSS_SATELLITE_INFO,
        /**
         * NMEA.
         */
        NMEA,
        /**
         * NI Notify verify request.
         */
        NI_NOTIFY_VERIFY_REQUEST,
        /**
         * Inject time request.
         */
        INJECT_TIME_REQUEST,
        /**
         * Inject predicted orbits request.
         */
        INJECT_PREDICTED_ORBITS_REQUEST,
        /**
         * Inject position request.
         */
        INJECT_POSITION_REQUEST,
        /**
         * Engine state.
         */
        ENGINE_STATE,
        /**
         * Fix session state.
         */
        FIX_SESSION_STATE,
        /**
         * WIFI request.
         */
        WIFI_REQUEST,
        /**
         * Sensor streaming ready status.
         */
        SENSOR_STREAMING_READY_STATUS,
        /**
         * Time sync request.
         */
        TIME_SYNC_REQUEST,
        /**
         * Set SPI streaming report.
         */
        SET_SPI_STREAMING_REPORT,
        /**
         * Location server connection request.
         */
        LOCATION_SERVER_CONNECTION_REQUEST,
        /**
         * NI geofence notification.
         */
        NI_GEOFENCE_NOTIFICATION,
        /**
         * Geofence general alert.
         */
        GEOFENCE_GENERAL_ALERT,
        /**
         * Geofence breach notification.
         */
        GEOFENCE_BREACH_NOTIFICATION,
        /**
         * Pedometer control.
         */
        PEDOMETER_CONTROL,
        /**
         * Motion data control.
         */
        MOTION_DATA_CONTROL,
    }
    /**
     * NMEA trace types that may be enabled in the GNSS engine.
     */

    /**
     * NMEA trace types that may be enabled in the GNSS engine.
     */
    export namespace LocNmeaType {
        export const $gtype: GObject.GType<LocNmeaType>;
    }

    enum LocNmeaType {
        /**
         * Enable GGA traces.
         */
        GGA,
        /**
         * Enable RMC traces.
         */
        RMC,
        /**
         * Enable GSV traces.
         */
        GSV,
        /**
         * Enable GSA traces.
         */
        GSA,
        /**
         * Enable VTG traces.
         */
        VTG,
        /**
         * Enable PQXFI traces.
         */
        PQXFI,
        /**
         * Enable PSTIS traces.
         */
        PSTIS,
        /**
         * Enable all supported trace types.
         */
        ALL,
    }
    /**
     * Which information about the satellite is valid.
     *
     * Since 1.22
     */

    /**
     * Which information about the satellite is valid.
     *
     * Since 1.22
     */
    export namespace LocSatelliteValidInformation {
        export const $gtype: GObject.GType<LocSatelliteValidInformation>;
    }

    enum LocSatelliteValidInformation {
        /**
         * System,
         */
        SYSTEM,
        /**
         * GNSS Satellite ID.
         */
        GNSS_SATELLITE_ID,
        /**
         * Health status.
         */
        HEALTH_STATUS,
        /**
         * Process status.
         */
        PROCESS_STATUS,
        /**
         * Satellite info mask.
         */
        SATELLITE_INFO_MASK,
        /**
         * Elevation.
         */
        ELEVATION,
        /**
         * Azimuth.
         */
        AZIMUTH,
        /**
         * Signal to noise ratio.
         */
        SIGNAL_TO_NOISE_RATIO,
    }
    /**
     * Which sensors where used and for which measurements.
     *
     * Since 1.22
     */

    /**
     * Which sensors where used and for which measurements.
     *
     * Since 1.22
     */
    export namespace LocSensorDataUsage {
        export const $gtype: GObject.GType<LocSensorDataUsage>;
    }

    enum LocSensorDataUsage {
        /**
         * Accelerometer used.
         */
        ACCELEROMETER_USED,
        /**
         * Gyro used.
         */
        GYRO_USED,
        /**
         * Aided heading.
         */
        AIDED_HEADING,
        /**
         * Aided speed.
         */
        AIDED_SPEED,
        /**
         * Aided position.
         */
        AIDED_POSITION,
        /**
         * Aided velocity.
         */
        AIDED_VELOCITY,
    }
    /**
     * Type of server address for Assisted-GPS.
     */

    /**
     * Type of server address for Assisted-GPS.
     */
    export namespace LocServerAddressType {
        export const $gtype: GObject.GType<LocServerAddressType>;
    }

    enum LocServerAddressType {
        /**
         * None.
         */
        NONE,
        /**
         * IPv4 server address.
         */
        IPV4,
        /**
         * IPv6 server address.
         */
        IPV6,
        /**
         * URL server address.
         */
        URL,
    }
    /**
     * Which technology has been used.
     *
     * Since 1.22
     */

    /**
     * Which technology has been used.
     *
     * Since 1.22
     */
    export namespace LocTechnologyUsed {
        export const $gtype: GObject.GType<LocTechnologyUsed>;
    }

    enum LocTechnologyUsed {
        /**
         * Satellite.
         */
        SATELLITE,
        /**
         * Cellular.
         */
        CELLULAR,
        /**
         * Wifi.
         */
        WIFI,
        /**
         * Sensors.
         */
        SENSORS,
        /**
         * Reference Location.
         */
        REFERENCE_LOCATION,
        /**
         * Injected Position.
         */
        INJECTED_POSITION,
        /**
         * AFLT (Advanced Forward Link Trilateration).
         */
        AFLT,
        /**
         * Hybrid.
         */
        HYBRID,
    }
    /**
     * Flags to specify frequency band preferences.
     *
     * This type is bit to bit compatible with #QmiDmsBandCapability.
     */

    /**
     * Flags to specify frequency band preferences.
     *
     * This type is bit to bit compatible with #QmiDmsBandCapability.
     */
    export namespace NasBandPreference {
        export const $gtype: GObject.GType<NasBandPreference>;
    }

    enum NasBandPreference {
        /**
         * Band class 0, A system.
         */
        BC_0_A_SYSTEM,
        /**
         * Band class 0, B system.
         */
        BC_0_B_SYSTEM,
        /**
         * Band class 1.
         */
        BC_1_ALL_BLOCKS,
        /**
         * Band class 2.
         */
        BC_2,
        /**
         * Band class 3, A system.
         */
        BC_3_A_SYSTEM,
        /**
         * Band class 4, all blocks.
         */
        BC_4_ALL_BLOCKS,
        /**
         * Band class 5, all blocks.
         */
        BC_5_ALL_BLOCKS,
        /**
         * GSM DCS 1800 band.
         */
        GSM_DCS_1800,
        /**
         * Extended GSM 900 band.
         */
        GSM_900_EXTENDED,
        /**
         * Primary GSM 900 band.
         */
        GSM_900_PRIMARY,
        /**
         * Band class 6.
         */
        BC_6,
        /**
         * Band class 7.
         */
        BC_7,
        /**
         * Band class 8.
         */
        BC_8,
        /**
         * Band class 9.
         */
        BC_9,
        /**
         * Band class 10.
         */
        BC_10,
        /**
         * Band class 11.
         */
        BC_11,
        /**
         * GSM 450.
         */
        GSM_450,
        /**
         * GSM 480.
         */
        GSM_480,
        /**
         * GSM 750.
         */
        GSM_750,
        /**
         * GSM 850.
         */
        GSM_850,
        /**
         * GSM 900 (Railways).
         */
        GSM_900_RAILWAYS,
        /**
         * GSM 1900.
         */
        GSM_PCS_1900,
        /**
         * WCDMA 2100.
         */
        WCDMA_2100,
        /**
         * WCDMA PCS 1900.
         */
        WCDMA_PCS_1900,
        /**
         * WCDMA DCS 1800.
         */
        WCDMA_DCS_1800,
        /**
         * WCDMA 1700 (U.S.).
         */
        WCDMA_1700_US,
        /**
         * WCDMA 850.
         */
        WCDMA_850_US,
        /**
         * WCDMA 800.
         */
        WCDMA_800,
        /**
         * Band class 12.
         */
        BC_12,
        /**
         * Band class 14.
         */
        BC_14,
        /**
         * Band class 15.
         */
        BC_15,
        /**
         * WCDMA 2600.
         */
        WCDMA_2600,
        /**
         * WCDMA 900.
         */
        WCDMA_900,
        /**
         * WCDMA 1700 (Japan).
         */
        WCDMA_1700_JAPAN,
        /**
         * Band class 16.
         */
        BC_16,
        /**
         * Band class 17.
         */
        BC_17,
        /**
         * Band class 18.
         */
        BC_18,
        /**
         * Band class 19.
         */
        BC_19,
        /**
         * WCDMA 850 (Japan). Since: 1.22.
         */
        WCDMA_850_JAPAN,
        /**
         * WCDMA 1500. Since: 1.22.
         */
        WCDMA_1500,
    }
    /**
     * Flags to specify LTE-specific frequency band preferences.
     */
    /**
     * Flags to specify LTE-specific frequency band preferences.
     */
    class NasLteBandPreference {
        static $gtype: GObject.GType<NasLteBandPreference>;

        // Static fields

        /**
         * LTE EUTRAN Band 1
         */
        static '1': number;
        /**
         * LTE EUTRAN Band 2.
         */
        static '2': number;
        /**
         * LTE EUTRAN Band 3.
         */
        static '3': number;
        /**
         * LTE EUTRAN Band 4.
         */
        static '4': number;
        /**
         * LTE EUTRAN Band 5.
         */
        static '5': number;
        /**
         * LTE EUTRAN Band 6.
         */
        static '6': number;
        /**
         * LTE EUTRAN Band 7.
         */
        static '7': number;
        /**
         * LTE EUTRAN Band 8.
         */
        static '8': number;
        /**
         * LTE EUTRAN Band 9.
         */
        static '9': number;
        /**
         * LTE EUTRAN Band 10.
         */
        static '10': number;
        /**
         * LTE EUTRAN Band 11.
         */
        static '11': number;
        /**
         * LTE EUTRAN Band 12.
         */
        static '12': number;
        /**
         * LTE EUTRAN Band 13.
         */
        static '13': number;
        /**
         * LTE EUTRAN Band 14.
         */
        static '14': number;
        /**
         * LTE EUTRAN Band 17.
         */
        static '17': number;
        /**
         * LTE EUTRAN Band 18.
         */
        static '18': number;
        /**
         * LTE EUTRAN Band 19.
         */
        static '19': number;
        /**
         * LTE EUTRAN Band 20.
         */
        static '20': number;
        /**
         * LTE EUTRAN Band 21.
         */
        static '21': number;
        /**
         * LTE EUTRAN Band 24.
         */
        static '24': number;
        /**
         * LTE EUTRAN Band 25.
         */
        static '25': number;
        /**
         * LTE EUTRAN Band 26.
         */
        static '26': number;
        /**
         * LTE EUTRAN Band 27.
         */
        static '27': number;
        /**
         * LTE EUTRAN Band 28.
         */
        static '28': number;
        /**
         * LTE EUTRAN Band 29.
         */
        static '29': number;
        /**
         * LTE EUTRAN Band 30.
         */
        static '30': number;
        /**
         * LTE EUTRAN Band 31.
         */
        static '31': number;
        /**
         * LTE EUTRAN Band 32.
         */
        static '32': number;
        /**
         * LTE EUTRAN Band 33.
         */
        static '33': number;
        /**
         * LTE EUTRAN Band 34.
         */
        static '34': number;
        /**
         * LTE EUTRAN Band 35.
         */
        static '35': number;
        /**
         * LTE EUTRAN Band 36.
         */
        static '36': number;
        /**
         * LTE EUTRAN Band 37.
         */
        static '37': number;
        /**
         * LTE EUTRAN Band 38.
         */
        static '38': number;
        /**
         * LTE EUTRAN Band 39.
         */
        static '39': number;
        /**
         * LTE EUTRAN Band 40.
         */
        static '40': number;
        /**
         * LTE EUTRAN Band 41.
         */
        static '41': number;
        /**
         * LTE EUTRAN Band 42.
         */
        static '42': number;
        /**
         * LTE EUTRAN Band 43.
         */
        static '43': number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Flags used to control display of the PLMN name and Service Provider Name. See
     * 3GPP TS 51.011 descripton of the EFspn SIM file for more details.
     */

    /**
     * Flags used to control display of the PLMN name and Service Provider Name. See
     * 3GPP TS 51.011 descripton of the EFspn SIM file for more details.
     */
    export namespace NasNetworkNameDisplayCondition {
        export const $gtype: GObject.GType<NasNetworkNameDisplayCondition>;
    }

    enum NasNetworkNameDisplayCondition {
        /**
         * if
         * set, display of the registered PLMN is required when the registered PLMN is either
         * the HPLMN or a PLMN in the Service Provider PLMN List (see EFspdi). Otherwise
         * display of the registered PLMN is not required in this case.
         */
        REGISTERED_PLMN_IF_KNOWN_NETWORK,
        /**
         * if
         * set, display of the Service Provider Name is not required when registered PLMN is
         * neither HPLMN nor a PLMN in the service provider PLMN list (see EFspdi). If not set,
         * SPN display is required in this case.
         */
        SPN_NOT_REQUIRED_IF_UNKNOWN_NETWORK,
    }
    /**
     * Flags to use when specifying which networks to scan.
     */

    /**
     * Flags to use when specifying which networks to scan.
     */
    export namespace NasNetworkScanType {
        export const $gtype: GObject.GType<NasNetworkScanType>;
    }

    enum NasNetworkScanType {
        /**
         * GSM network.
         */
        GSM,
        /**
         * UMTS network.
         */
        UMTS,
        /**
         * LTE network.
         */
        LTE,
        /**
         * TD-SCDMA network.
         */
        TD_SCDMA,
    }
    /**
     * Flags to specify the status of a given network.
     */

    /**
     * Flags to specify the status of a given network.
     */
    export namespace NasNetworkStatus {
        export const $gtype: GObject.GType<NasNetworkStatus>;
    }

    enum NasNetworkStatus {
        /**
         * Network is in use, current serving.
         */
        CURRENT_SERVING,
        /**
         * Network is vailable.
         */
        AVAILABLE,
        /**
         * Network is home network.
         */
        HOME,
        /**
         * Network is a roaming network.
         */
        ROAMING,
        /**
         * Network is forbidden.
         */
        FORBIDDEN,
        /**
         * Network is not forbidden.
         */
        NOT_FORBIDDEN,
        /**
         * Network is preferred.
         */
        PREFERRED,
        /**
         * Network is not preferred.
         */
        NOT_PREFERRED,
    }
    /**
     * Preferred networks access technology identifier as specified in
     * ETSI TS 131 102, chapter 4.2.5.
     */

    /**
     * Preferred networks access technology identifier as specified in
     * ETSI TS 131 102, chapter 4.2.5.
     */
    export namespace NasPlmnAccessTechnologyIdentifier {
        export const $gtype: GObject.GType<NasPlmnAccessTechnologyIdentifier>;
    }

    enum NasPlmnAccessTechnologyIdentifier {
        /**
         * Unspecified.
         */
        UNSPECIFIED,
        /**
         * GSM Compact.
         */
        GSM_COMPACT,
        /**
         * GSM.
         */
        GSM,
        /**
         * NG-RAN.
         */
        NGRAN,
        /**
         * E-UTRAN.
         */
        EUTRAN,
        /**
         * UTRAN.
         */
        UTRAN,
        /**
         * All technologies.
         */
        ALL,
    }
    /**
     * Flags to specify the radio technology preference.
     */

    /**
     * Flags to specify the radio technology preference.
     */
    export namespace NasRadioTechnologyPreference {
        export const $gtype: GObject.GType<NasRadioTechnologyPreference>;
    }

    enum NasRadioTechnologyPreference {
        /**
         * Automatic selection.
         */
        AUTO,
        /**
         * 3GPP2 technology.
         */
        '3GPP2',
        /**
         * 3GPP technology.
         */
        '3GPP',
        /**
         * AMPS if 3GPP2, GSM if 3GPP.
         */
        AMPS_OR_GSM,
        /**
         * CDMA if 3GPP2, WCDMA if 3GPP.
         */
        CDMA_OR_WCDMA,
        /**
         * CDMA EV-DO.
         */
        HDR,
        /**
         * LTE.
         */
        LTE,
    }
    /**
     * Flags specifying radio access technology mode preference.
     */

    /**
     * Flags specifying radio access technology mode preference.
     */
    export namespace NasRatModePreference {
        export const $gtype: GObject.GType<NasRatModePreference>;
    }

    enum NasRatModePreference {
        /**
         * CDMA2000 1X.
         */
        CDMA_1X,
        /**
         * CDMA2000 HRPD (1xEV-DO).
         */
        CDMA_1XEVDO,
        /**
         * GSM.
         */
        GSM,
        /**
         * UMTS.
         */
        UMTS,
        /**
         * LTE.
         */
        LTE,
        /**
         * TD-SCDMA.
         */
        TD_SCDMA,
        /**
         * 5GNR. Since 1.26.
         */
        '5GNR',
    }
    /**
     * Extra information to request when gathering Signal Strength.
     */

    /**
     * Extra information to request when gathering Signal Strength.
     */
    export namespace NasSignalStrengthRequest {
        export const $gtype: GObject.GType<NasSignalStrengthRequest>;
    }

    enum NasSignalStrengthRequest {
        /**
         * None.
         */
        NONE,
        /**
         * Request RSSI information.
         */
        RSSI,
        /**
         * Request ECIO information.
         */
        ECIO,
        /**
         * Request IO information.
         */
        IO,
        /**
         * Request SINR information.
         */
        SINR,
        /**
         * Request error rate information.
         */
        ERROR_RATE,
        /**
         * Request RSRQ information.
         */
        RSRQ,
        /**
         * Request LTE SNR information.
         */
        LTE_SNR,
        /**
         * Request LTE RSRP information.
         */
        LTE_RSRP,
    }
    /**
     * Flags to specify TD-SCDMA-specific frequency band preferences.
     */

    /**
     * Flags to specify TD-SCDMA-specific frequency band preferences.
     */
    export namespace NasTdScdmaBandPreference {
        export const $gtype: GObject.GType<NasTdScdmaBandPreference>;
    }

    enum NasTdScdmaBandPreference {
        /**
         * Band A.
         */
        A,
        /**
         * Band B.
         */
        B,
        /**
         * Band C.
         */
        C,
        /**
         * Band D.
         */
        D,
        /**
         * Band E.
         */
        E,
        /**
         * Band F.
         */
        F,
    }
    /**
     * Flags to use to register to phonebook indications.
     */

    /**
     * Flags to use to register to phonebook indications.
     */
    export namespace PbmEventRegistrationFlag {
        export const $gtype: GObject.GType<PbmEventRegistrationFlag>;
    }

    enum PbmEventRegistrationFlag {
        /**
         * Request indications when records are added/edited/deleted.
         */
        RECORD_UPDATE,
        /**
         * Request indications when phonebooks are ready.
         */
        PHONEBOOK_READY,
        /**
         * Request indications when emergency numbers are changed.
         */
        EMERGENCY_NUMBER_LIST,
        /**
         * Request indications when hidden record status is changed.
         */
        HIDDEN_RECORD_STATUS,
        /**
         * Request indications when Additional number Alpha String records are added/edited/deleted.
         */
        AAS_UPDATE,
        /**
         * Request indications when Grouping information Alpha String records are added/edited/deleted.
         */
        GAS_UPDATE,
    }
    /**
     * Phonebook type.
     */

    /**
     * Phonebook type.
     */
    export namespace PbmPhonebookType {
        export const $gtype: GObject.GType<PbmPhonebookType>;
    }

    enum PbmPhonebookType {
        /**
         * Abbreviated Dialing Number.
         */
        ADN,
        /**
         * Fixed Dialing Number.
         */
        FDN,
        /**
         * Mobile Subscriber Integrated Services Digital Network.
         */
        MSISDN,
        /**
         * Mail Box Dialing Number.
         */
        MBDN,
        /**
         * Service Dialing Number.
         */
        SDN,
        /**
         * Barred Dialing Number.
         */
        BDN,
        /**
         * Last Number Dialed.
         */
        LND,
        /**
         * Mail Box Number.
         */
        MBN,
    }
    /**
     * Flags to indicate which position data parameters are valid.
     */

    /**
     * Flags to indicate which position data parameters are valid.
     */
    export namespace PdsDataValid {
        export const $gtype: GObject.GType<PdsDataValid>;
    }

    enum PdsDataValid {
        /**
         * Timestamp calendar (GPS time).
         */
        TIMESTAMP_CALENDAR,
        /**
         * Timestamp (UTC).
         */
        TIMESTAMP_UTC,
        /**
         * Leap seconds.
         */
        LEAP_SECONDS,
        /**
         * Time uncertainty.
         */
        TIME_UNCERTAINTY,
        /**
         * Latitude.
         */
        LATITUDE,
        /**
         * Longitude.
         */
        LONGITUDE,
        /**
         * Ellipsoid altitude.
         */
        ELLIPSOID_ALTITUDE,
        /**
         * Mean sea level altitude.
         */
        MEAN_SEA_LEVEL_ALTITUDE,
        /**
         * Horizontal speed.
         */
        HORIZONTAL_SPEED,
        /**
         * Vertical speed.
         */
        VERTICAL_SPEED,
        /**
         * Heading.
         */
        HEADING,
        /**
         * Horizontal uncertainty circular.
         */
        HORIZONTAL_UNCERTAINTY_CIRCULAR,
        /**
         * Horizontal uncertainty ellipse semi-major.
         */
        HORIZONTAL_UNCERTAINTY_ELLIPSE_SEMI_MAJOR,
        /**
         * Horizontal uncertainty ellipse semi-minor.
         */
        HORIZONTAL_UNCERTAINTY_ELLIPSE_SEMI_MINOR,
        /**
         * Horizontal uncertainty ellipse orient azimuth.
         */
        HORIZONTAL_UNCERTAINTY_ELLIPSE_ORIENT_AZIMUTH,
        /**
         * Vertical uncertainty.
         */
        VERTICAL_UNCERTAINTY,
        /**
         * Horizontal velocity uncertainty.
         */
        HORIZONTAL_VELOCITY_UNCERTAINTY,
        /**
         * Vertical velocity uncertainty.
         */
        VERTICAL_VELOCITY_UNCERTAINTY,
        /**
         * Horizontal confidence.
         */
        HORIZONTAL_CONFIDENCE,
        /**
         * Position dillution of precision.
         */
        POSITION_DOP,
        /**
         * Horizontal dillution of precision.
         */
        HORIZONTAL_DOP,
        /**
         * Vertical dillution of precision.
         */
        VERTICAL_DOP,
        /**
         * Operating mode.
         */
        OPERATING_MODE,
    }
    /**
     * QMI flags in messages which are not of the %QMI_SERVICE_CTL service.
     */

    /**
     * QMI flags in messages which are not of the %QMI_SERVICE_CTL service.
     */
    export namespace ServiceFlag {
        export const $gtype: GObject.GType<ServiceFlag>;
    }

    enum ServiceFlag {
        /**
         * None.
         */
        NONE,
        /**
         * Message is compound.
         */
        COMPOUND,
        /**
         * Message is a response.
         */
        RESPONSE,
        /**
         * Message is an indication.
         */
        INDICATION,
    }
    /**
     * Requested configurations. If none explicitly requested, all configuration
     * items are returned.
     */

    /**
     * Requested configurations. If none explicitly requested, all configuration
     * items are returned.
     */
    export namespace UimConfiguration {
        export const $gtype: GObject.GType<UimConfiguration>;
    }

    enum UimConfiguration {
        /**
         * Automatic selection.
         */
        AUTOMATIC_SELECTION,
        /**
         * Personalization status.
         */
        PERSONALIZATION_STATUS,
        /**
         * Halt publication of subscription.
         */
        HALT_SUBSCRIPTION,
    }
    /**
     * Flags to use to register to UIM indications.
     */

    /**
     * Flags to use to register to UIM indications.
     */
    export namespace UimEventRegistrationFlag {
        export const $gtype: GObject.GType<UimEventRegistrationFlag>;
    }

    enum UimEventRegistrationFlag {
        /**
         * Card status.
         */
        CARD_STATUS,
        /**
         * SAP connection.
         */
        SAP_CONNECTION,
        /**
         * Extended card status.
         */
        EXTENDED_CARD_STATUS,
        /**
         * Physical slot status. Since 1.26.
         */
        PHYSICAL_SLOT_STATUS,
    }
    /**
     * Security Attributes.
     */

    /**
     * Security Attributes.
     */
    export namespace UimSecurityAttribute {
        export const $gtype: GObject.GType<UimSecurityAttribute>;
    }

    enum UimSecurityAttribute {
        /**
         * PIN1.
         */
        PIN1,
        /**
         * PIN2.
         */
        PIN2,
        /**
         * UPIN.
         */
        UPIN,
        /**
         * ADM.
         */
        ADM,
    }
    /**
     * WCDMA AMR status.
     */

    /**
     * WCDMA AMR status.
     */
    export namespace VoiceWcdmaAmrStatus {
        export const $gtype: GObject.GType<VoiceWcdmaAmrStatus>;
    }

    enum VoiceWcdmaAmrStatus {
        /**
         * Not supported.
         */
        NOT_SUPPORTED,
        /**
         * WCDMA AMR wideband.
         */
        WCDMA_AMR_WB,
        /**
         * GSM half-rate AMR.
         */
        GSM_HR_AMR,
        /**
         * GSM AMR wideband.
         */
        GSM_AMR_WB,
        /**
         * GSM AMR narrowband.
         */
        GSM_AMR_NB,
    }
    /**
     * APN type as a bitmask.
     */

    /**
     * APN type as a bitmask.
     */
    export namespace WdsApnTypeMask {
        export const $gtype: GObject.GType<WdsApnTypeMask>;
    }

    enum WdsApnTypeMask {
        /**
         * Default/Internet traffic.
         */
        DEFAULT,
        /**
         * IP Multimedia Subsystem.
         */
        IMS,
        /**
         * Multimedia Messaging Service.
         */
        MMS,
        /**
         * over the air administration.
         */
        FOTA,
        /**
         * Initial Attach.
         */
        IA,
        /**
         * Emergency.
         */
        EMERGENCY,
    }
    /**
     * PDP context authentication protocols.
     */

    /**
     * PDP context authentication protocols.
     */
    export namespace WdsAuthentication {
        export const $gtype: GObject.GType<WdsAuthentication>;
    }

    enum WdsAuthentication {
        /**
         * no authentication
         */
        NONE,
        /**
         * PAP authentication
         */
        PAP,
        /**
         * CHAP authentication
         */
        CHAP,
    }
    /**
     * 3GPP extended data bearer technologies.
     */

    /**
     * 3GPP extended data bearer technologies.
     */
    export namespace WdsExtendedDataBearerTechnology3gpp {
        export const $gtype: GObject.GType<WdsExtendedDataBearerTechnology3gpp>;
    }

    enum WdsExtendedDataBearerTechnology3gpp {
        /**
         * unknown.
         */
        UNKNOWN,
        /**
         * WCDMA.
         */
        WCDMA,
        /**
         * HSDPA.
         */
        HSDPA,
        /**
         * HSUPA.
         */
        HSUPA,
        /**
         * HSDPA+.
         */
        HSDPA_PLUS,
        /**
         * Dual-cell HSDPA+.
         */
        DC_HSDPA_PLUS,
        /**
         * 64-QAM.
         */
        '64QAM',
        /**
         * HSPA.
         */
        HSPA,
        /**
         * GPRS.
         */
        GPRS,
        /**
         * EDGE.
         */
        EDGE,
        /**
         * GSM.
         */
        GSM,
        /**
         * S2B.
         */
        S2B,
        /**
         * LTE limited service.
         */
        LTE_LIMITED_SERVICE,
        /**
         * LTE FDD.
         */
        LTE_FDD,
        /**
         * LTE TDD.
         */
        LTE_TDD,
    }
    /**
     * 3GPP2 extended data bearer technologies.
     */

    /**
     * 3GPP2 extended data bearer technologies.
     */
    export namespace WdsExtendedDataBearerTechnology3gpp2 {
        export const $gtype: GObject.GType<WdsExtendedDataBearerTechnology3gpp2>;
    }

    enum WdsExtendedDataBearerTechnology3gpp2 {
        /**
         * unknown.
         */
        UNKNOWN,
        /**
         * reserved.
         */
        RESERVED,
        /**
         * CDMA1x IS-95.
         */
        CDMA1X_IS95,
        /**
         * CDMA1x IS-2000.
         */
        CDMA1X_IS2000,
        /**
         * CDMA1x IS-2000 Release A.
         */
        CDMA1X_IS2000_REL_A,
        /**
         * HDR EVDO Rev 0 DPA.
         */
        HDR_REV_0_DPA,
        /**
         * HDR EVDO Rev A DPA.
         */
        HDR_REV_A_DPA,
        /**
         * HDR EVDO Rev B DPA.
         */
        HDR_REV_B_DPA,
        /**
         * HDR EVDO Rev A MPA.
         */
        HDR_REV_A_MPA,
        /**
         * HDR EVDO Rev B MPA.
         */
        HDR_REV_B_MPA,
        /**
         * HDR EVDO Rev A EMPA.
         */
        HDR_REV_A_EMPA,
        /**
         * HDR EVDO Rev B EMPA.
         */
        HDR_REV_B_EMPA,
        /**
         * HDR EVDO Rev B MMPA.
         */
        HDR_REV_B_MMPA,
        /**
         * HDR EVDO FMC.
         */
        HDR_EVDO_FMC,
    }
    /**
     * Mask to use when requesting packet statistics.
     */

    /**
     * Mask to use when requesting packet statistics.
     */
    export namespace WdsPacketStatisticsMaskFlag {
        export const $gtype: GObject.GType<WdsPacketStatisticsMaskFlag>;
    }

    enum WdsPacketStatisticsMaskFlag {
        /**
         * Request count of correctly sent packets.
         */
        TX_PACKETS_OK,
        /**
         * Request count of correctly received packets.
         */
        RX_PACKETS_OK,
        /**
         * Request count of sent packets with error.
         */
        TX_PACKETS_ERROR,
        /**
         * Request count of received packets with error.
         */
        RX_PACKETS_ERROR,
        /**
         * Request count of transmitter overflows.
         */
        TX_OVERFLOWS,
        /**
         * Request count of receiver overflows.
         */
        RX_OVERFLOWS,
        /**
         * Request count of correctly sent bytes.
         */
        TX_BYTES_OK,
        /**
         * Request count of correctly received bytes.
         */
        RX_BYTES_OK,
        /**
         * Request count of dropped packets in transmission.
         */
        TX_PACKETS_DROPPED,
        /**
         * Request count of dropped packets in reception.
         */
        RX_PACKETS_DROPPED,
    }
    /**
     * Flags specifying the 3GPP-specific Radio Access Technology, when the data
     * bearer network type is `QMI_WDS_NETWORK_TYPE_3`GPP.
     */

    /**
     * Flags specifying the 3GPP-specific Radio Access Technology, when the data
     * bearer network type is `QMI_WDS_NETWORK_TYPE_3`GPP.
     */
    export namespace WdsRat3gpp {
        export const $gtype: GObject.GType<WdsRat3gpp>;
    }

    enum WdsRat3gpp {
        /**
         * Unknown, to be ignored.
         */
        NONE,
        /**
         * WCDMA.
         */
        WCDMA,
        /**
         * GPRS.
         */
        GPRS,
        /**
         * HSDPA.
         */
        HSDPA,
        /**
         * HSUPA.
         */
        HSUPA,
        /**
         * EDGE.
         */
        EDGE,
        /**
         * LTE.
         */
        LTE,
        /**
         * HSDPA+.
         */
        HSDPAPLUS,
        /**
         * DC-HSDPA+.
         */
        DCHSDPAPLUS,
        /**
         * 64QAM. Since: 1.18.
         */
        '64QAM',
        /**
         * TD-SCDMA. Since: 1.18.
         */
        TDSCDMA,
        /**
         * No bearer.
         */
        NULL_BEARER,
    }
    /**
     * Flags specifying the 3GPP2-specific Radio Access Technology, when the data
     * bearer network type is `QMI_WDS_NETWORK_TYPE_3`GPP2.
     */

    /**
     * Flags specifying the 3GPP2-specific Radio Access Technology, when the data
     * bearer network type is `QMI_WDS_NETWORK_TYPE_3`GPP2.
     */
    export namespace WdsRat3gpp2 {
        export const $gtype: GObject.GType<WdsRat3gpp2>;
    }

    enum WdsRat3gpp2 {
        /**
         * Unknown, to be ignored.
         */
        NONE,
        /**
         * CDMA 1x.
         */
        CDMA1X,
        /**
         * EVDO Rev0.
         */
        EVDO_REV0,
        /**
         * EVDO RevA.
         */
        EVDO_REVA,
        /**
         * EVDO RevB.
         */
        EVDO_REVB,
        /**
         * eHRPD. Since: 1.18.
         */
        EHRPD,
        /**
         * FMC. Since: 1.18.
         */
        FMC,
        /**
         * No bearer.
         */
        NULL_BEARER,
    }
    /**
     * Flags specifying requested WDS settings.
     */

    /**
     * Flags specifying requested WDS settings.
     */
    export namespace WdsRequestedSettings {
        export const $gtype: GObject.GType<WdsRequestedSettings>;
    }

    enum WdsRequestedSettings {
        /**
         * no settings.
         */
        NONE,
        /**
         * profile ID.
         */
        PROFILE_ID,
        /**
         * profile name.
         */
        PROFILE_NAME,
        /**
         * PDP context type.
         */
        PDP_TYPE,
        /**
         * APN name.
         */
        APN_NAME,
        /**
         * DNS server addresses.
         */
        DNS_ADDRESS,
        /**
         * granted QoS.
         */
        GRANTED_QOS,
        /**
         * username.
         */
        USERNAME,
        /**
         * authentication protocol, ie PAP/CHAP/none.
         */
        AUTH_PROTOCOL,
        /**
         * IP address.
         */
        IP_ADDRESS,
        /**
         * gateway address.
         */
        GATEWAY_INFO,
        /**
         * PCSCF address.
         */
        PCSCF_ADDRESS,
        /**
         * PCSCF server address list.
         */
        PCSCF_SERVER_ADDRESS_LIST,
        /**
         * PCSCF domain name list.
         */
        PCSCF_DOMAIN_NAME_LIST,
        /**
         * MTU.
         */
        MTU,
        /**
         * domain name list.
         */
        DOMAIN_NAME_LIST,
        /**
         * IP family, ie IPv4 or IPv6.
         */
        IP_FAMILY,
        /**
         * IMCN flag.
         */
        IMCN_FLAG,
        /**
         * extended technology info.
         */
        EXTENDED_TECHNOLOGY,
        /**
         * operator reserved protocol configuration option.
         */
        OPERATOR_RESERVED_PCO,
    }
    /**
     * Flags indicating which WDS Set Event Report Transfer Statistics indicators
     * should be emitted.
     */

    /**
     * Flags indicating which WDS Set Event Report Transfer Statistics indicators
     * should be emitted.
     */
    export namespace WdsSetEventReportTransferStatistics {
        export const $gtype: GObject.GType<WdsSetEventReportTransferStatistics>;
    }

    enum WdsSetEventReportTransferStatistics {
        /**
         * report TX packet successes.
         */
        TX_PACKETS_OK,
        /**
         * report RX packet successes.
         */
        RX_PACKETS_OK,
        /**
         * report TX packet errors.
         */
        TX_PACKETS_ERROR,
        /**
         * report RX packet errors.
         */
        RX_PACKETS_ERROR,
        /**
         * report TX overflows.
         */
        TX_OVERFLOWS,
        /**
         * report RX overflows.
         */
        RX_OVERFLOWS,
        /**
         * report TX byte total.
         */
        TX_BYTES_OK,
        /**
         * report RX byte total.
         */
        RX_BYTES_OK,
        /**
         * report TX packets dropped.
         */
        TX_PACKETS_DROPPED,
        /**
         * report RX packets dropped.
         */
        RX_PACKETS_DROPPED,
    }
    /**
     * Flags specifying the Service Option when the bearer network type is
     * `QMI_WDS_NETWORK_TYPE_3`GPP2 and when the Radio Access Technology mask
     * contains `QMI_WDS_RAT_3`GPP2_CDMA1X.
     */

    /**
     * Flags specifying the Service Option when the bearer network type is
     * `QMI_WDS_NETWORK_TYPE_3`GPP2 and when the Radio Access Technology mask
     * contains `QMI_WDS_RAT_3`GPP2_CDMA1X.
     */
    export namespace WdsSoCdma1x {
        export const $gtype: GObject.GType<WdsSoCdma1x>;
    }

    enum WdsSoCdma1x {
        /**
         * Unknown, to be ignored.
         */
        NONE,
        /**
         * IS95.
         */
        IS95,
        /**
         * IS2000.
         */
        IS2000,
        /**
         * IS2000 RelA.
         */
        IS2000_REL_A,
    }
    /**
     * Flags specifying the Service Option when the bearer network type is
     * `QMI_WDS_NETWORK_TYPE_3`GPP2 and when the Radio Access Technology mask
     * contains `QMI_WDS_RAT_3`GPP2_EVDO_REV0.
     */

    /**
     * Flags specifying the Service Option when the bearer network type is
     * `QMI_WDS_NETWORK_TYPE_3`GPP2 and when the Radio Access Technology mask
     * contains `QMI_WDS_RAT_3`GPP2_EVDO_REV0.
     */
    export namespace WdsSoEvdoRev0 {
        export const $gtype: GObject.GType<WdsSoEvdoRev0>;
    }

    enum WdsSoEvdoRev0 {
        /**
         * Unknown, to be ignored.
         */
        NONE,
        /**
         * DPA.
         */
        DPA,
    }
    /**
     * Flags specifying the Service Option when the bearer network type is
     * `QMI_WDS_NETWORK_TYPE_3`GPP2 and when the Radio Access Technology mask
     * contains `QMI_WDS_RAT_3`GPP2_EVDO_REVA.
     */

    /**
     * Flags specifying the Service Option when the bearer network type is
     * `QMI_WDS_NETWORK_TYPE_3`GPP2 and when the Radio Access Technology mask
     * contains `QMI_WDS_RAT_3`GPP2_EVDO_REVA.
     */
    export namespace WdsSoEvdoRevA {
        export const $gtype: GObject.GType<WdsSoEvdoRevA>;
    }

    enum WdsSoEvdoRevA {
        /**
         * Unknown, to be ignored.
         */
        NONE,
        /**
         * DPA.
         */
        DPA,
        /**
         * MFPA.
         */
        MFPA,
        /**
         * EMPA.
         */
        EMPA,
        /**
         * EMPA eHRPD.
         */
        EMPA_EHRPD,
    }
    /**
     * Flags specifying the Service Option when the bearer network type is
     * `QMI_WDS_NETWORK_TYPE_3`GPP2 and when the Radio Access Technology mask
     * contains `QMI_WDS_RAT_3`GPP2_EVDO_REVB.
     */

    /**
     * Flags specifying the Service Option when the bearer network type is
     * `QMI_WDS_NETWORK_TYPE_3`GPP2 and when the Radio Access Technology mask
     * contains `QMI_WDS_RAT_3`GPP2_EVDO_REVB.
     */
    export namespace WdsSoEvdoRevB {
        export const $gtype: GObject.GType<WdsSoEvdoRevB>;
    }

    enum WdsSoEvdoRevB {
        /**
         * Unknown, to be ignored.
         */
        NONE,
        /**
         * DPA.
         */
        DPA,
        /**
         * MFPA.
         */
        MFPA,
        /**
         * EMPA.
         */
        EMPA,
        /**
         * EMPA eHRPD.
         */
        EMPA_EHRPD,
        /**
         * MMPA.
         */
        MMPA,
        /**
         * MMPA eHRPD.
         */
        MMPA_EHRPD,
    }
    /**
     * Type of network allowed when trying to connect.
     */

    /**
     * Type of network allowed when trying to connect.
     */
    export namespace WdsTechnologyPreference {
        export const $gtype: GObject.GType<WdsTechnologyPreference>;
    }

    enum WdsTechnologyPreference {
        /**
         * 3GPP allowed.
         */
        '3GPP',
        /**
         * 3GPP2 allowed.
         */
        '3GPP2',
    }
    module Client {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            client_cid: number;
            clientCid: number;
            client_device: Device;
            clientDevice: Device;
            client_service: Service;
            clientService: Service;
            client_valid: boolean;
            clientValid: boolean;
            client_version_major: number;
            clientVersionMajor: number;
            client_version_minor: number;
            clientVersionMinor: number;
        }
    }

    /**
     * The #QmiClient structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class Client extends GObject.Object {
        static $gtype: GObject.GType<Client>;

        // Properties

        get client_cid(): number;
        set client_cid(val: number);
        get clientCid(): number;
        set clientCid(val: number);
        get client_device(): Device;
        set client_device(val: Device);
        get clientDevice(): Device;
        set clientDevice(val: Device);
        get client_service(): Service;
        set client_service(val: Service);
        get clientService(): Service;
        set clientService(val: Service);
        get client_valid(): boolean;
        get clientValid(): boolean;
        get client_version_major(): number;
        set client_version_major(val: number);
        get clientVersionMajor(): number;
        set clientVersionMajor(val: number);
        get client_version_minor(): number;
        set client_version_minor(val: number);
        get clientVersionMinor(): number;
        set clientVersionMinor(val: number);

        // Constructors

        constructor(properties?: Partial<Client.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        vfunc_process_indication(message: Message): void;

        // Methods

        /**
         * Checks if the version of the service handled by this #QmiClient is greater
         * or equal than the given version.
         * @param major a major version.
         * @param minor a minor version.
         * @returns %TRUE if the version of the service is greater or equal than the one given, %FALSE otherwise.
         */
        check_version(major: number, minor: number): boolean;
        /**
         * Get the client ID of this #QmiClient.
         * @returns the client ID.
         */
        get_cid(): number;
        /**
         * Get the #QmiDevice associated with this #QmiClient.
         * @returns a #GObject that must be freed with g_object_unref().
         */
        get_device<T = GObject.Object>(): T;
        /**
         * Acquire the next transaction ID of this #QmiClient.
         * The internal transaction ID gets incremented.
         * @returns the next transaction ID.
         */
        get_next_transaction_id(): number;
        /**
         * Get the service being used by this #QmiClient.
         * @returns a #QmiService.
         */
        get_service(): Service;
        /**
         * Get the version of the service handled by this #QmiClient.
         * @param major placeholder for the output major version.
         * @param minor placeholder for the output minor version.
         * @returns %TRUE if the version was properly reported, %FALSE otherwise.
         */
        get_version(major: number, minor: number): boolean;
        /**
         * Checks whether #QmiClient is a valid and usable client.
         *
         * The client is marked as invalid as soon as the client id is released or when
         * the associated #QmiDevice is closed.
         *
         * This method may be used if the caller needs to ensure validity before a
         * command is attempted, e.g. if the lifecycle of the object is managed in some
         * other place and the caller just has a reference to the #QmiClient.
         * @returns %TRUE if the client is valid, %FALSE otherwise.
         */
        is_valid(): boolean;
        /**
         * Get the #QmiDevice associated with this #QmiClient, without increasing the reference count
         * on the returned object.
         * @returns a #GObject. Do not free the returned object, it is owned by @self.
         */
        peek_device<T = GObject.Object>(): T;
    }

    module ClientAtr {
        // Signal callback interfaces

        interface Received {
            (output: IndicationAtrReceivedOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientAtr structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientAtr extends Client {
        static $gtype: GObject.GType<ClientAtr>;

        // Constructors

        constructor(properties?: Partial<ClientAtr.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'received', callback: (_source: this, output: IndicationAtrReceivedOutput) => void): number;
        connect_after(
            signal: 'received',
            callback: (_source: this, output: IndicationAtrReceivedOutput) => void,
        ): number;
        emit(signal: 'received', output: IndicationAtrReceivedOutput): void;

        // Methods

        /**
         * Asynchronously sends a Send request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_atr_send_finish() to get the result of the operation.
         * @param input a #QmiMessageAtrSendInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        send(
            input: MessageAtrSendInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageAtrSendOutput>;
        /**
         * Asynchronously sends a Send request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_atr_send_finish() to get the result of the operation.
         * @param input a #QmiMessageAtrSendInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        send(
            input: MessageAtrSendInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Send request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_atr_send_finish() to get the result of the operation.
         * @param input a #QmiMessageAtrSendInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        send(
            input: MessageAtrSendInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageAtrSendOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_atr_send().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_atr_send().
         * @returns a #QmiMessageAtrSendOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_atr_send_output_unref().
         */
        send_finish(res: Gio.AsyncResult): MessageAtrSendOutput;
    }

    module ClientDms {
        // Signal callback interfaces

        interface EventReport {
            (output: IndicationDmsEventReportOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientDms structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientDms extends Client {
        static $gtype: GObject.GType<ClientDms>;

        // Constructors

        constructor(properties?: Partial<ClientDms.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'event-report',
            callback: (_source: this, output: IndicationDmsEventReportOutput) => void,
        ): number;
        connect_after(
            signal: 'event-report',
            callback: (_source: this, output: IndicationDmsEventReportOutput) => void,
        ): number;
        emit(signal: 'event-report', output: IndicationDmsEventReportOutput): void;

        // Methods

        /**
         * Asynchronously sends a Activate Automatic request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_activate_automatic_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsActivateAutomaticInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        activate_automatic(
            input: MessageDmsActivateAutomaticInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsActivateAutomaticOutput>;
        /**
         * Asynchronously sends a Activate Automatic request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_activate_automatic_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsActivateAutomaticInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        activate_automatic(
            input: MessageDmsActivateAutomaticInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Activate Automatic request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_activate_automatic_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsActivateAutomaticInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        activate_automatic(
            input: MessageDmsActivateAutomaticInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsActivateAutomaticOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_activate_automatic().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_activate_automatic().
         * @returns a #QmiMessageDmsActivateAutomaticOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_activate_automatic_output_unref().
         */
        activate_automatic_finish(res: Gio.AsyncResult): MessageDmsActivateAutomaticOutput;
        /**
         * Asynchronously sends a Activate Manual request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_activate_manual_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsActivateManualInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        activate_manual(
            input: MessageDmsActivateManualInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsActivateManualOutput>;
        /**
         * Asynchronously sends a Activate Manual request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_activate_manual_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsActivateManualInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        activate_manual(
            input: MessageDmsActivateManualInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Activate Manual request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_activate_manual_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsActivateManualInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        activate_manual(
            input: MessageDmsActivateManualInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsActivateManualOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_activate_manual().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_activate_manual().
         * @returns a #QmiMessageDmsActivateManualOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_activate_manual_output_unref().
         */
        activate_manual_finish(res: Gio.AsyncResult): MessageDmsActivateManualOutput;
        /**
         * Asynchronously sends a Delete Stored Image request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_delete_stored_image_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsDeleteStoredImageInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        delete_stored_image(
            input: MessageDmsDeleteStoredImageInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsDeleteStoredImageOutput>;
        /**
         * Asynchronously sends a Delete Stored Image request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_delete_stored_image_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsDeleteStoredImageInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        delete_stored_image(
            input: MessageDmsDeleteStoredImageInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Delete Stored Image request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_delete_stored_image_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsDeleteStoredImageInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        delete_stored_image(
            input: MessageDmsDeleteStoredImageInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsDeleteStoredImageOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_delete_stored_image().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_delete_stored_image().
         * @returns a #QmiMessageDmsDeleteStoredImageOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_delete_stored_image_output_unref().
         */
        delete_stored_image_finish(res: Gio.AsyncResult): MessageDmsDeleteStoredImageOutput;
        /**
         * Asynchronously sends a Foxconn Change Device Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_foxconn_change_device_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsFoxconnChangeDeviceModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        foxconn_change_device_mode(
            input: MessageDmsFoxconnChangeDeviceModeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsFoxconnChangeDeviceModeOutput>;
        /**
         * Asynchronously sends a Foxconn Change Device Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_foxconn_change_device_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsFoxconnChangeDeviceModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        foxconn_change_device_mode(
            input: MessageDmsFoxconnChangeDeviceModeInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Foxconn Change Device Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_foxconn_change_device_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsFoxconnChangeDeviceModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        foxconn_change_device_mode(
            input: MessageDmsFoxconnChangeDeviceModeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsFoxconnChangeDeviceModeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_foxconn_change_device_mode().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_foxconn_change_device_mode().
         * @returns a #QmiMessageDmsFoxconnChangeDeviceModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_foxconn_change_device_mode_output_unref().
         */
        foxconn_change_device_mode_finish(res: Gio.AsyncResult): MessageDmsFoxconnChangeDeviceModeOutput;
        /**
         * Asynchronously sends a Foxconn Get Firmware Version request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_foxconn_get_firmware_version_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsFoxconnGetFirmwareVersionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        foxconn_get_firmware_version(
            input: MessageDmsFoxconnGetFirmwareVersionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsFoxconnGetFirmwareVersionOutput>;
        /**
         * Asynchronously sends a Foxconn Get Firmware Version request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_foxconn_get_firmware_version_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsFoxconnGetFirmwareVersionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        foxconn_get_firmware_version(
            input: MessageDmsFoxconnGetFirmwareVersionInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Foxconn Get Firmware Version request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_foxconn_get_firmware_version_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsFoxconnGetFirmwareVersionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        foxconn_get_firmware_version(
            input: MessageDmsFoxconnGetFirmwareVersionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsFoxconnGetFirmwareVersionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_foxconn_get_firmware_version().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_foxconn_get_firmware_version().
         * @returns a #QmiMessageDmsFoxconnGetFirmwareVersionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_foxconn_get_firmware_version_output_unref().
         */
        foxconn_get_firmware_version_finish(res: Gio.AsyncResult): MessageDmsFoxconnGetFirmwareVersionOutput;
        /**
         * Asynchronously sends a Foxconn Set FCC Authentication request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_foxconn_set_fcc_authentication_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsFoxconnSetFccAuthenticationInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        foxconn_set_fcc_authentication(
            input: MessageDmsFoxconnSetFccAuthenticationInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsFoxconnSetFccAuthenticationOutput>;
        /**
         * Asynchronously sends a Foxconn Set FCC Authentication request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_foxconn_set_fcc_authentication_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsFoxconnSetFccAuthenticationInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        foxconn_set_fcc_authentication(
            input: MessageDmsFoxconnSetFccAuthenticationInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Foxconn Set FCC Authentication request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_foxconn_set_fcc_authentication_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsFoxconnSetFccAuthenticationInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        foxconn_set_fcc_authentication(
            input: MessageDmsFoxconnSetFccAuthenticationInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsFoxconnSetFccAuthenticationOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_foxconn_set_fcc_authentication().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_foxconn_set_fcc_authentication().
         * @returns a #QmiMessageDmsFoxconnSetFccAuthenticationOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_foxconn_set_fcc_authentication_output_unref().
         */
        foxconn_set_fcc_authentication_finish(res: Gio.AsyncResult): MessageDmsFoxconnSetFccAuthenticationOutput;
        /**
         * Asynchronously sends a Foxconn Set FCC Authentication v2 request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_foxconn_set_fcc_authentication_v2_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsFoxconnSetFccAuthenticationV2Input.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        foxconn_set_fcc_authentication_v2(
            input: MessageDmsFoxconnSetFccAuthenticationV2Input,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsFoxconnSetFccAuthenticationV2Output>;
        /**
         * Asynchronously sends a Foxconn Set FCC Authentication v2 request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_foxconn_set_fcc_authentication_v2_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsFoxconnSetFccAuthenticationV2Input.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        foxconn_set_fcc_authentication_v2(
            input: MessageDmsFoxconnSetFccAuthenticationV2Input,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Foxconn Set FCC Authentication v2 request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_foxconn_set_fcc_authentication_v2_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsFoxconnSetFccAuthenticationV2Input.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        foxconn_set_fcc_authentication_v2(
            input: MessageDmsFoxconnSetFccAuthenticationV2Input,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsFoxconnSetFccAuthenticationV2Output> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_foxconn_set_fcc_authentication_v2().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_foxconn_set_fcc_authentication_v2().
         * @returns a #QmiMessageDmsFoxconnSetFccAuthenticationV2Output, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_foxconn_set_fcc_authentication_v2_output_unref().
         */
        foxconn_set_fcc_authentication_v2_finish(res: Gio.AsyncResult): MessageDmsFoxconnSetFccAuthenticationV2Output;
        /**
         * Asynchronously sends a Get Activation State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_activation_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_activation_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetActivationStateOutput>;
        /**
         * Asynchronously sends a Get Activation State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_activation_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_activation_state(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Activation State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_activation_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_activation_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetActivationStateOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_activation_state().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_activation_state().
         * @returns a #QmiMessageDmsGetActivationStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_activation_state_output_unref().
         */
        get_activation_state_finish(res: Gio.AsyncResult): MessageDmsGetActivationStateOutput;
        /**
         * Asynchronously sends a Get Alt Net Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_alt_net_config_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_alt_net_config(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetAltNetConfigOutput>;
        /**
         * Asynchronously sends a Get Alt Net Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_alt_net_config_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_alt_net_config(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Alt Net Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_alt_net_config_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_alt_net_config(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetAltNetConfigOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_alt_net_config().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_alt_net_config().
         * @returns a #QmiMessageDmsGetAltNetConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_alt_net_config_output_unref().
         */
        get_alt_net_config_finish(res: Gio.AsyncResult): MessageDmsGetAltNetConfigOutput;
        /**
         * Asynchronously sends a Get Band Capabilities request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_band_capabilities_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_band_capabilities(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetBandCapabilitiesOutput>;
        /**
         * Asynchronously sends a Get Band Capabilities request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_band_capabilities_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_band_capabilities(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Band Capabilities request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_band_capabilities_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_band_capabilities(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetBandCapabilitiesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_band_capabilities().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_band_capabilities().
         * @returns a #QmiMessageDmsGetBandCapabilitiesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_band_capabilities_output_unref().
         */
        get_band_capabilities_finish(res: Gio.AsyncResult): MessageDmsGetBandCapabilitiesOutput;
        /**
         * Asynchronously sends a Get Boot Image Download Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_boot_image_download_mode_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_boot_image_download_mode(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetBootImageDownloadModeOutput>;
        /**
         * Asynchronously sends a Get Boot Image Download Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_boot_image_download_mode_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_boot_image_download_mode(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Boot Image Download Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_boot_image_download_mode_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_boot_image_download_mode(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetBootImageDownloadModeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_boot_image_download_mode().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_boot_image_download_mode().
         * @returns a #QmiMessageDmsGetBootImageDownloadModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_boot_image_download_mode_output_unref().
         */
        get_boot_image_download_mode_finish(res: Gio.AsyncResult): MessageDmsGetBootImageDownloadModeOutput;
        /**
         * Asynchronously sends a Get Capabilities request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_capabilities_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_capabilities(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetCapabilitiesOutput>;
        /**
         * Asynchronously sends a Get Capabilities request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_capabilities_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_capabilities(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Capabilities request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_capabilities_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_capabilities(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetCapabilitiesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_capabilities().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_capabilities().
         * @returns a #QmiMessageDmsGetCapabilitiesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_capabilities_output_unref().
         */
        get_capabilities_finish(res: Gio.AsyncResult): MessageDmsGetCapabilitiesOutput;
        /**
         * Asynchronously sends a Get Factory SKU request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_factory_sku_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_factory_sku(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetFactorySkuOutput>;
        /**
         * Asynchronously sends a Get Factory SKU request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_factory_sku_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_factory_sku(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Factory SKU request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_factory_sku_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_factory_sku(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetFactorySkuOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_factory_sku().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_factory_sku().
         * @returns a #QmiMessageDmsGetFactorySkuOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_factory_sku_output_unref().
         */
        get_factory_sku_finish(res: Gio.AsyncResult): MessageDmsGetFactorySkuOutput;
        /**
         * Asynchronously sends a Get Firmware Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_firmware_preference_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_firmware_preference(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetFirmwarePreferenceOutput>;
        /**
         * Asynchronously sends a Get Firmware Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_firmware_preference_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_firmware_preference(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Firmware Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_firmware_preference_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_firmware_preference(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetFirmwarePreferenceOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_firmware_preference().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_firmware_preference().
         * @returns a #QmiMessageDmsGetFirmwarePreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_firmware_preference_output_unref().
         */
        get_firmware_preference_finish(res: Gio.AsyncResult): MessageDmsGetFirmwarePreferenceOutput;
        /**
         * Asynchronously sends a Get Hardware Revision request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_hardware_revision_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_hardware_revision(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetHardwareRevisionOutput>;
        /**
         * Asynchronously sends a Get Hardware Revision request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_hardware_revision_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_hardware_revision(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Hardware Revision request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_hardware_revision_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_hardware_revision(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetHardwareRevisionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_hardware_revision().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_hardware_revision().
         * @returns a #QmiMessageDmsGetHardwareRevisionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_hardware_revision_output_unref().
         */
        get_hardware_revision_finish(res: Gio.AsyncResult): MessageDmsGetHardwareRevisionOutput;
        /**
         * Asynchronously sends a Get IDs request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_ids_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_ids(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetIdsOutput>;
        /**
         * Asynchronously sends a Get IDs request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_ids_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_ids(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get IDs request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_ids_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_ids(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetIdsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_ids().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_ids().
         * @returns a #QmiMessageDmsGetIdsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_ids_output_unref().
         */
        get_ids_finish(res: Gio.AsyncResult): MessageDmsGetIdsOutput;
        /**
         * Asynchronously sends a Get MAC Address request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_mac_address_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsGetMacAddressInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_mac_address(
            input: MessageDmsGetMacAddressInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetMacAddressOutput>;
        /**
         * Asynchronously sends a Get MAC Address request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_mac_address_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsGetMacAddressInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_mac_address(
            input: MessageDmsGetMacAddressInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get MAC Address request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_mac_address_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsGetMacAddressInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_mac_address(
            input: MessageDmsGetMacAddressInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetMacAddressOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_mac_address().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_mac_address().
         * @returns a #QmiMessageDmsGetMacAddressOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_mac_address_output_unref().
         */
        get_mac_address_finish(res: Gio.AsyncResult): MessageDmsGetMacAddressOutput;
        /**
         * Asynchronously sends a Get Manufacturer request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_manufacturer_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_manufacturer(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetManufacturerOutput>;
        /**
         * Asynchronously sends a Get Manufacturer request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_manufacturer_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_manufacturer(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Manufacturer request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_manufacturer_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_manufacturer(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetManufacturerOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_manufacturer().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_manufacturer().
         * @returns a #QmiMessageDmsGetManufacturerOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_manufacturer_output_unref().
         */
        get_manufacturer_finish(res: Gio.AsyncResult): MessageDmsGetManufacturerOutput;
        /**
         * Asynchronously sends a Get Model request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_model_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_model(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetModelOutput>;
        /**
         * Asynchronously sends a Get Model request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_model_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_model(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Model request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_model_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_model(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetModelOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_model().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_model().
         * @returns a #QmiMessageDmsGetModelOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_model_output_unref().
         */
        get_model_finish(res: Gio.AsyncResult): MessageDmsGetModelOutput;
        /**
         * Asynchronously sends a Get MSISDN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_msisdn_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_msisdn(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetMsisdnOutput>;
        /**
         * Asynchronously sends a Get MSISDN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_msisdn_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_msisdn(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get MSISDN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_msisdn_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_msisdn(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetMsisdnOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_msisdn().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_msisdn().
         * @returns a #QmiMessageDmsGetMsisdnOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_msisdn_output_unref().
         */
        get_msisdn_finish(res: Gio.AsyncResult): MessageDmsGetMsisdnOutput;
        /**
         * Asynchronously sends a Get Operating Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_operating_mode_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_operating_mode(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetOperatingModeOutput>;
        /**
         * Asynchronously sends a Get Operating Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_operating_mode_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_operating_mode(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Operating Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_operating_mode_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_operating_mode(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetOperatingModeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_operating_mode().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_operating_mode().
         * @returns a #QmiMessageDmsGetOperatingModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_operating_mode_output_unref().
         */
        get_operating_mode_finish(res: Gio.AsyncResult): MessageDmsGetOperatingModeOutput;
        /**
         * Asynchronously sends a Get Power State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_power_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_power_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetPowerStateOutput>;
        /**
         * Asynchronously sends a Get Power State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_power_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_power_state(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Power State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_power_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_power_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetPowerStateOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_power_state().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_power_state().
         * @returns a #QmiMessageDmsGetPowerStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_power_state_output_unref().
         */
        get_power_state_finish(res: Gio.AsyncResult): MessageDmsGetPowerStateOutput;
        /**
         * Asynchronously sends a Get PRL Version request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_prl_version_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_prl_version(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetPrlVersionOutput>;
        /**
         * Asynchronously sends a Get PRL Version request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_prl_version_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_prl_version(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get PRL Version request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_prl_version_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_prl_version(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetPrlVersionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_prl_version().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_prl_version().
         * @returns a #QmiMessageDmsGetPrlVersionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_prl_version_output_unref().
         */
        get_prl_version_finish(res: Gio.AsyncResult): MessageDmsGetPrlVersionOutput;
        /**
         * Asynchronously sends a Get Revision request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_revision_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_revision(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetRevisionOutput>;
        /**
         * Asynchronously sends a Get Revision request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_revision_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_revision(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Revision request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_revision_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_revision(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetRevisionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_revision().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_revision().
         * @returns a #QmiMessageDmsGetRevisionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_revision_output_unref().
         */
        get_revision_finish(res: Gio.AsyncResult): MessageDmsGetRevisionOutput;
        /**
         * Asynchronously sends a Get Software Version request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_software_version_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_software_version(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetSoftwareVersionOutput>;
        /**
         * Asynchronously sends a Get Software Version request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_software_version_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_software_version(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Software Version request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_software_version_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_software_version(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetSoftwareVersionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_software_version().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_software_version().
         * @returns a #QmiMessageDmsGetSoftwareVersionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_software_version_output_unref().
         */
        get_software_version_finish(res: Gio.AsyncResult): MessageDmsGetSoftwareVersionOutput;
        /**
         * Asynchronously sends a Get Stored Image Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_stored_image_info_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsGetStoredImageInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_stored_image_info(
            input: MessageDmsGetStoredImageInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetStoredImageInfoOutput>;
        /**
         * Asynchronously sends a Get Stored Image Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_stored_image_info_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsGetStoredImageInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_stored_image_info(
            input: MessageDmsGetStoredImageInfoInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Stored Image Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_stored_image_info_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsGetStoredImageInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_stored_image_info(
            input: MessageDmsGetStoredImageInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetStoredImageInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_stored_image_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_stored_image_info().
         * @returns a #QmiMessageDmsGetStoredImageInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_stored_image_info_output_unref().
         */
        get_stored_image_info_finish(res: Gio.AsyncResult): MessageDmsGetStoredImageInfoOutput;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetSupportedMessagesOutput>;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetSupportedMessagesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_supported_messages().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_supported_messages().
         * @returns a #QmiMessageDmsGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_supported_messages_output_unref().
         */
        get_supported_messages_finish(res: Gio.AsyncResult): MessageDmsGetSupportedMessagesOutput;
        /**
         * Asynchronously sends a Get Time request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_time_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_time(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetTimeOutput>;
        /**
         * Asynchronously sends a Get Time request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_time_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_time(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Time request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_time_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_time(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetTimeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_time().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_time().
         * @returns a #QmiMessageDmsGetTimeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_time_output_unref().
         */
        get_time_finish(res: Gio.AsyncResult): MessageDmsGetTimeOutput;
        /**
         * Asynchronously sends a Get User Lock State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_user_lock_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_user_lock_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsGetUserLockStateOutput>;
        /**
         * Asynchronously sends a Get User Lock State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_user_lock_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_user_lock_state(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get User Lock State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_get_user_lock_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_user_lock_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsGetUserLockStateOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_get_user_lock_state().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_user_lock_state().
         * @returns a #QmiMessageDmsGetUserLockStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_user_lock_state_output_unref().
         */
        get_user_lock_state_finish(res: Gio.AsyncResult): MessageDmsGetUserLockStateOutput;
        /**
         * Asynchronously sends a HP Change Device Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_hp_change_device_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsHpChangeDeviceModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        hp_change_device_mode(
            input: MessageDmsHpChangeDeviceModeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsHpChangeDeviceModeOutput>;
        /**
         * Asynchronously sends a HP Change Device Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_hp_change_device_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsHpChangeDeviceModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        hp_change_device_mode(
            input: MessageDmsHpChangeDeviceModeInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a HP Change Device Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_hp_change_device_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsHpChangeDeviceModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        hp_change_device_mode(
            input: MessageDmsHpChangeDeviceModeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsHpChangeDeviceModeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_hp_change_device_mode().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_hp_change_device_mode().
         * @returns a #QmiMessageDmsHpChangeDeviceModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_hp_change_device_mode_output_unref().
         */
        hp_change_device_mode_finish(res: Gio.AsyncResult): MessageDmsHpChangeDeviceModeOutput;
        /**
         * Asynchronously sends a List Stored Images request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_list_stored_images_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        list_stored_images(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsListStoredImagesOutput>;
        /**
         * Asynchronously sends a List Stored Images request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_list_stored_images_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        list_stored_images(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a List Stored Images request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_list_stored_images_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        list_stored_images(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsListStoredImagesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_list_stored_images().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_list_stored_images().
         * @returns a #QmiMessageDmsListStoredImagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_list_stored_images_output_unref().
         */
        list_stored_images_finish(res: Gio.AsyncResult): MessageDmsListStoredImagesOutput;
        /**
         * Asynchronously sends a Read ERI File request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_read_eri_file_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        read_eri_file(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsReadEriFileOutput>;
        /**
         * Asynchronously sends a Read ERI File request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_read_eri_file_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        read_eri_file(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Read ERI File request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_read_eri_file_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        read_eri_file(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsReadEriFileOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_read_eri_file().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_read_eri_file().
         * @returns a #QmiMessageDmsReadEriFileOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_read_eri_file_output_unref().
         */
        read_eri_file_finish(res: Gio.AsyncResult): MessageDmsReadEriFileOutput;
        /**
         * Asynchronously sends a Read User Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_read_user_data_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        read_user_data(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsReadUserDataOutput>;
        /**
         * Asynchronously sends a Read User Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_read_user_data_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        read_user_data(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Read User Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_read_user_data_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        read_user_data(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsReadUserDataOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_read_user_data().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_read_user_data().
         * @returns a #QmiMessageDmsReadUserDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_read_user_data_output_unref().
         */
        read_user_data_finish(res: Gio.AsyncResult): MessageDmsReadUserDataOutput;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsResetOutput>;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsResetOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_reset().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_reset().
         * @returns a #QmiMessageDmsResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_reset_output_unref().
         */
        reset_finish(res: Gio.AsyncResult): MessageDmsResetOutput;
        /**
         * Asynchronously sends a Restore Factory Defaults request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_restore_factory_defaults_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsRestoreFactoryDefaultsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        restore_factory_defaults(
            input: MessageDmsRestoreFactoryDefaultsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsRestoreFactoryDefaultsOutput>;
        /**
         * Asynchronously sends a Restore Factory Defaults request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_restore_factory_defaults_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsRestoreFactoryDefaultsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        restore_factory_defaults(
            input: MessageDmsRestoreFactoryDefaultsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Restore Factory Defaults request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_restore_factory_defaults_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsRestoreFactoryDefaultsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        restore_factory_defaults(
            input: MessageDmsRestoreFactoryDefaultsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsRestoreFactoryDefaultsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_restore_factory_defaults().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_restore_factory_defaults().
         * @returns a #QmiMessageDmsRestoreFactoryDefaultsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_restore_factory_defaults_output_unref().
         */
        restore_factory_defaults_finish(res: Gio.AsyncResult): MessageDmsRestoreFactoryDefaultsOutput;
        /**
         * Asynchronously sends a Set Alt Net Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_alt_net_config_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetAltNetConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_alt_net_config(
            input: MessageDmsSetAltNetConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSetAltNetConfigOutput>;
        /**
         * Asynchronously sends a Set Alt Net Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_alt_net_config_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetAltNetConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_alt_net_config(
            input: MessageDmsSetAltNetConfigInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Alt Net Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_alt_net_config_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetAltNetConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_alt_net_config(
            input: MessageDmsSetAltNetConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSetAltNetConfigOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_set_alt_net_config().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_alt_net_config().
         * @returns a #QmiMessageDmsSetAltNetConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_alt_net_config_output_unref().
         */
        set_alt_net_config_finish(res: Gio.AsyncResult): MessageDmsSetAltNetConfigOutput;
        /**
         * Asynchronously sends a Set Boot Image Download Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_boot_image_download_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetBootImageDownloadModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_boot_image_download_mode(
            input: MessageDmsSetBootImageDownloadModeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSetBootImageDownloadModeOutput>;
        /**
         * Asynchronously sends a Set Boot Image Download Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_boot_image_download_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetBootImageDownloadModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_boot_image_download_mode(
            input: MessageDmsSetBootImageDownloadModeInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Boot Image Download Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_boot_image_download_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetBootImageDownloadModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_boot_image_download_mode(
            input: MessageDmsSetBootImageDownloadModeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSetBootImageDownloadModeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_set_boot_image_download_mode().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_boot_image_download_mode().
         * @returns a #QmiMessageDmsSetBootImageDownloadModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_boot_image_download_mode_output_unref().
         */
        set_boot_image_download_mode_finish(res: Gio.AsyncResult): MessageDmsSetBootImageDownloadModeOutput;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_event_report(
            input: MessageDmsSetEventReportInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSetEventReportOutput>;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_event_report(
            input: MessageDmsSetEventReportInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_event_report(
            input: MessageDmsSetEventReportInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSetEventReportOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_set_event_report().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_event_report().
         * @returns a #QmiMessageDmsSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_event_report_output_unref().
         */
        set_event_report_finish(res: Gio.AsyncResult): MessageDmsSetEventReportOutput;
        /**
         * Asynchronously sends a Set FCC Authentication request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_fcc_authentication_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_fcc_authentication(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSetFccAuthenticationOutput>;
        /**
         * Asynchronously sends a Set FCC Authentication request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_fcc_authentication_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_fcc_authentication(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set FCC Authentication request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_fcc_authentication_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_fcc_authentication(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSetFccAuthenticationOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_set_fcc_authentication().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_fcc_authentication().
         * @returns a #QmiMessageDmsSetFccAuthenticationOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_fcc_authentication_output_unref().
         */
        set_fcc_authentication_finish(res: Gio.AsyncResult): MessageDmsSetFccAuthenticationOutput;
        /**
         * Asynchronously sends a Set Firmware ID request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_firmware_id_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_firmware_id(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSetFirmwareIdOutput>;
        /**
         * Asynchronously sends a Set Firmware ID request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_firmware_id_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_firmware_id(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Firmware ID request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_firmware_id_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_firmware_id(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSetFirmwareIdOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_set_firmware_id().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_firmware_id().
         * @returns a #QmiMessageDmsSetFirmwareIdOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_firmware_id_output_unref().
         */
        set_firmware_id_finish(res: Gio.AsyncResult): MessageDmsSetFirmwareIdOutput;
        /**
         * Asynchronously sends a Set Firmware Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_firmware_preference_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetFirmwarePreferenceInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_firmware_preference(
            input: MessageDmsSetFirmwarePreferenceInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSetFirmwarePreferenceOutput>;
        /**
         * Asynchronously sends a Set Firmware Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_firmware_preference_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetFirmwarePreferenceInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_firmware_preference(
            input: MessageDmsSetFirmwarePreferenceInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Firmware Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_firmware_preference_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetFirmwarePreferenceInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_firmware_preference(
            input: MessageDmsSetFirmwarePreferenceInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSetFirmwarePreferenceOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_set_firmware_preference().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_firmware_preference().
         * @returns a #QmiMessageDmsSetFirmwarePreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_firmware_preference_output_unref().
         */
        set_firmware_preference_finish(res: Gio.AsyncResult): MessageDmsSetFirmwarePreferenceOutput;
        /**
         * Asynchronously sends a Set Operating Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_operating_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetOperatingModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_operating_mode(
            input: MessageDmsSetOperatingModeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSetOperatingModeOutput>;
        /**
         * Asynchronously sends a Set Operating Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_operating_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetOperatingModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_operating_mode(
            input: MessageDmsSetOperatingModeInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Operating Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_operating_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetOperatingModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_operating_mode(
            input: MessageDmsSetOperatingModeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSetOperatingModeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_set_operating_mode().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_operating_mode().
         * @returns a #QmiMessageDmsSetOperatingModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_operating_mode_output_unref().
         */
        set_operating_mode_finish(res: Gio.AsyncResult): MessageDmsSetOperatingModeOutput;
        /**
         * Asynchronously sends a Set Service Programming Code request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_service_programming_code_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetServiceProgrammingCodeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_service_programming_code(
            input: MessageDmsSetServiceProgrammingCodeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSetServiceProgrammingCodeOutput>;
        /**
         * Asynchronously sends a Set Service Programming Code request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_service_programming_code_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetServiceProgrammingCodeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_service_programming_code(
            input: MessageDmsSetServiceProgrammingCodeInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Service Programming Code request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_service_programming_code_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetServiceProgrammingCodeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_service_programming_code(
            input: MessageDmsSetServiceProgrammingCodeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSetServiceProgrammingCodeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_set_service_programming_code().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_service_programming_code().
         * @returns a #QmiMessageDmsSetServiceProgrammingCodeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_service_programming_code_output_unref().
         */
        set_service_programming_code_finish(res: Gio.AsyncResult): MessageDmsSetServiceProgrammingCodeOutput;
        /**
         * Asynchronously sends a Set Time request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_time_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetTimeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_time(
            input: MessageDmsSetTimeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSetTimeOutput>;
        /**
         * Asynchronously sends a Set Time request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_time_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetTimeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_time(
            input: MessageDmsSetTimeInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Time request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_time_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetTimeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_time(
            input: MessageDmsSetTimeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSetTimeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_set_time().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_time().
         * @returns a #QmiMessageDmsSetTimeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_time_output_unref().
         */
        set_time_finish(res: Gio.AsyncResult): MessageDmsSetTimeOutput;
        /**
         * Asynchronously sends a Set User Lock Code request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_user_lock_code_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetUserLockCodeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_user_lock_code(
            input: MessageDmsSetUserLockCodeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSetUserLockCodeOutput>;
        /**
         * Asynchronously sends a Set User Lock Code request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_user_lock_code_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetUserLockCodeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_user_lock_code(
            input: MessageDmsSetUserLockCodeInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set User Lock Code request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_user_lock_code_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetUserLockCodeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_user_lock_code(
            input: MessageDmsSetUserLockCodeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSetUserLockCodeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_set_user_lock_code().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_user_lock_code().
         * @returns a #QmiMessageDmsSetUserLockCodeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_user_lock_code_output_unref().
         */
        set_user_lock_code_finish(res: Gio.AsyncResult): MessageDmsSetUserLockCodeOutput;
        /**
         * Asynchronously sends a Set User Lock State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_user_lock_state_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetUserLockStateInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_user_lock_state(
            input: MessageDmsSetUserLockStateInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSetUserLockStateOutput>;
        /**
         * Asynchronously sends a Set User Lock State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_user_lock_state_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetUserLockStateInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_user_lock_state(
            input: MessageDmsSetUserLockStateInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set User Lock State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_set_user_lock_state_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSetUserLockStateInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_user_lock_state(
            input: MessageDmsSetUserLockStateInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSetUserLockStateOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_set_user_lock_state().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_user_lock_state().
         * @returns a #QmiMessageDmsSetUserLockStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_user_lock_state_output_unref().
         */
        set_user_lock_state_finish(res: Gio.AsyncResult): MessageDmsSetUserLockStateOutput;
        /**
         * Asynchronously sends a Swi Get Current Firmware request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_swi_get_current_firmware_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        swi_get_current_firmware(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSwiGetCurrentFirmwareOutput>;
        /**
         * Asynchronously sends a Swi Get Current Firmware request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_swi_get_current_firmware_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        swi_get_current_firmware(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Swi Get Current Firmware request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_swi_get_current_firmware_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        swi_get_current_firmware(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSwiGetCurrentFirmwareOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_swi_get_current_firmware().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_swi_get_current_firmware().
         * @returns a #QmiMessageDmsSwiGetCurrentFirmwareOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_swi_get_current_firmware_output_unref().
         */
        swi_get_current_firmware_finish(res: Gio.AsyncResult): MessageDmsSwiGetCurrentFirmwareOutput;
        /**
         * Asynchronously sends a Swi Get USB Composition request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_swi_get_usb_composition_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        swi_get_usb_composition(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSwiGetUsbCompositionOutput>;
        /**
         * Asynchronously sends a Swi Get USB Composition request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_swi_get_usb_composition_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        swi_get_usb_composition(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Swi Get USB Composition request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_swi_get_usb_composition_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        swi_get_usb_composition(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSwiGetUsbCompositionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_swi_get_usb_composition().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_swi_get_usb_composition().
         * @returns a #QmiMessageDmsSwiGetUsbCompositionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_swi_get_usb_composition_output_unref().
         */
        swi_get_usb_composition_finish(res: Gio.AsyncResult): MessageDmsSwiGetUsbCompositionOutput;
        /**
         * Asynchronously sends a Swi Set USB Composition request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_swi_set_usb_composition_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSwiSetUsbCompositionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        swi_set_usb_composition(
            input: MessageDmsSwiSetUsbCompositionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsSwiSetUsbCompositionOutput>;
        /**
         * Asynchronously sends a Swi Set USB Composition request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_swi_set_usb_composition_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSwiSetUsbCompositionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        swi_set_usb_composition(
            input: MessageDmsSwiSetUsbCompositionInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Swi Set USB Composition request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_swi_set_usb_composition_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsSwiSetUsbCompositionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        swi_set_usb_composition(
            input: MessageDmsSwiSetUsbCompositionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsSwiSetUsbCompositionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_swi_set_usb_composition().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_swi_set_usb_composition().
         * @returns a #QmiMessageDmsSwiSetUsbCompositionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_swi_set_usb_composition_output_unref().
         */
        swi_set_usb_composition_finish(res: Gio.AsyncResult): MessageDmsSwiSetUsbCompositionOutput;
        /**
         * Asynchronously sends a UIM Change PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_change_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimChangePinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        uim_change_pin(
            input: MessageDmsUimChangePinInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsUimChangePinOutput>;
        /**
         * Asynchronously sends a UIM Change PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_change_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimChangePinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_change_pin(
            input: MessageDmsUimChangePinInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a UIM Change PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_change_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimChangePinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_change_pin(
            input: MessageDmsUimChangePinInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsUimChangePinOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_uim_change_pin().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_change_pin().
         * @returns a #QmiMessageDmsUimChangePinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_change_pin_output_unref().
         */
        uim_change_pin_finish(res: Gio.AsyncResult): MessageDmsUimChangePinOutput;
        /**
         * Asynchronously sends a UIM Get CK Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_ck_status_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimGetCkStatusInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        uim_get_ck_status(
            input: MessageDmsUimGetCkStatusInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsUimGetCkStatusOutput>;
        /**
         * Asynchronously sends a UIM Get CK Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_ck_status_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimGetCkStatusInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_get_ck_status(
            input: MessageDmsUimGetCkStatusInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a UIM Get CK Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_ck_status_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimGetCkStatusInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_get_ck_status(
            input: MessageDmsUimGetCkStatusInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsUimGetCkStatusOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_uim_get_ck_status().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_ck_status().
         * @returns a #QmiMessageDmsUimGetCkStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_ck_status_output_unref().
         */
        uim_get_ck_status_finish(res: Gio.AsyncResult): MessageDmsUimGetCkStatusOutput;
        /**
         * Asynchronously sends a UIM Get ICCID request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_iccid_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        uim_get_iccid(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsUimGetIccidOutput>;
        /**
         * Asynchronously sends a UIM Get ICCID request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_iccid_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_get_iccid(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a UIM Get ICCID request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_iccid_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_get_iccid(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsUimGetIccidOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_uim_get_iccid().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_iccid().
         * @returns a #QmiMessageDmsUimGetIccidOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_iccid_output_unref().
         */
        uim_get_iccid_finish(res: Gio.AsyncResult): MessageDmsUimGetIccidOutput;
        /**
         * Asynchronously sends a UIM Get IMSI request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_imsi_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        uim_get_imsi(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsUimGetImsiOutput>;
        /**
         * Asynchronously sends a UIM Get IMSI request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_imsi_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_get_imsi(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a UIM Get IMSI request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_imsi_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_get_imsi(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsUimGetImsiOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_uim_get_imsi().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_imsi().
         * @returns a #QmiMessageDmsUimGetImsiOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_imsi_output_unref().
         */
        uim_get_imsi_finish(res: Gio.AsyncResult): MessageDmsUimGetImsiOutput;
        /**
         * Asynchronously sends a UIM Get PIN Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_pin_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        uim_get_pin_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsUimGetPinStatusOutput>;
        /**
         * Asynchronously sends a UIM Get PIN Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_pin_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_get_pin_status(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a UIM Get PIN Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_pin_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_get_pin_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsUimGetPinStatusOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_uim_get_pin_status().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_pin_status().
         * @returns a #QmiMessageDmsUimGetPinStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_pin_status_output_unref().
         */
        uim_get_pin_status_finish(res: Gio.AsyncResult): MessageDmsUimGetPinStatusOutput;
        /**
         * Asynchronously sends a UIM Get State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        uim_get_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsUimGetStateOutput>;
        /**
         * Asynchronously sends a UIM Get State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_get_state(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a UIM Get State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_get_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_get_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsUimGetStateOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_uim_get_state().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_state().
         * @returns a #QmiMessageDmsUimGetStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_state_output_unref().
         */
        uim_get_state_finish(res: Gio.AsyncResult): MessageDmsUimGetStateOutput;
        /**
         * Asynchronously sends a UIM Set CK Protection request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_set_ck_protection_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimSetCkProtectionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        uim_set_ck_protection(
            input: MessageDmsUimSetCkProtectionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsUimSetCkProtectionOutput>;
        /**
         * Asynchronously sends a UIM Set CK Protection request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_set_ck_protection_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimSetCkProtectionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_set_ck_protection(
            input: MessageDmsUimSetCkProtectionInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a UIM Set CK Protection request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_set_ck_protection_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimSetCkProtectionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_set_ck_protection(
            input: MessageDmsUimSetCkProtectionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsUimSetCkProtectionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_uim_set_ck_protection().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_set_ck_protection().
         * @returns a #QmiMessageDmsUimSetCkProtectionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_set_ck_protection_output_unref().
         */
        uim_set_ck_protection_finish(res: Gio.AsyncResult): MessageDmsUimSetCkProtectionOutput;
        /**
         * Asynchronously sends a UIM Set PIN Protection request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_set_pin_protection_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimSetPinProtectionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        uim_set_pin_protection(
            input: MessageDmsUimSetPinProtectionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsUimSetPinProtectionOutput>;
        /**
         * Asynchronously sends a UIM Set PIN Protection request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_set_pin_protection_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimSetPinProtectionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_set_pin_protection(
            input: MessageDmsUimSetPinProtectionInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a UIM Set PIN Protection request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_set_pin_protection_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimSetPinProtectionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_set_pin_protection(
            input: MessageDmsUimSetPinProtectionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsUimSetPinProtectionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_uim_set_pin_protection().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_set_pin_protection().
         * @returns a #QmiMessageDmsUimSetPinProtectionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_set_pin_protection_output_unref().
         */
        uim_set_pin_protection_finish(res: Gio.AsyncResult): MessageDmsUimSetPinProtectionOutput;
        /**
         * Asynchronously sends a UIM Unblock CK request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_unblock_ck_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimUnblockCkInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        uim_unblock_ck(
            input: MessageDmsUimUnblockCkInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsUimUnblockCkOutput>;
        /**
         * Asynchronously sends a UIM Unblock CK request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_unblock_ck_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimUnblockCkInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_unblock_ck(
            input: MessageDmsUimUnblockCkInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a UIM Unblock CK request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_unblock_ck_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimUnblockCkInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_unblock_ck(
            input: MessageDmsUimUnblockCkInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsUimUnblockCkOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_uim_unblock_ck().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_unblock_ck().
         * @returns a #QmiMessageDmsUimUnblockCkOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_unblock_ck_output_unref().
         */
        uim_unblock_ck_finish(res: Gio.AsyncResult): MessageDmsUimUnblockCkOutput;
        /**
         * Asynchronously sends a UIM Unblock PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_unblock_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimUnblockPinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        uim_unblock_pin(
            input: MessageDmsUimUnblockPinInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsUimUnblockPinOutput>;
        /**
         * Asynchronously sends a UIM Unblock PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_unblock_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimUnblockPinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_unblock_pin(
            input: MessageDmsUimUnblockPinInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a UIM Unblock PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_unblock_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimUnblockPinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_unblock_pin(
            input: MessageDmsUimUnblockPinInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsUimUnblockPinOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_uim_unblock_pin().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_unblock_pin().
         * @returns a #QmiMessageDmsUimUnblockPinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_unblock_pin_output_unref().
         */
        uim_unblock_pin_finish(res: Gio.AsyncResult): MessageDmsUimUnblockPinOutput;
        /**
         * Asynchronously sends a UIM Verify PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_verify_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimVerifyPinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        uim_verify_pin(
            input: MessageDmsUimVerifyPinInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsUimVerifyPinOutput>;
        /**
         * Asynchronously sends a UIM Verify PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_verify_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimVerifyPinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_verify_pin(
            input: MessageDmsUimVerifyPinInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a UIM Verify PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_uim_verify_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsUimVerifyPinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        uim_verify_pin(
            input: MessageDmsUimVerifyPinInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsUimVerifyPinOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_uim_verify_pin().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_verify_pin().
         * @returns a #QmiMessageDmsUimVerifyPinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_verify_pin_output_unref().
         */
        uim_verify_pin_finish(res: Gio.AsyncResult): MessageDmsUimVerifyPinOutput;
        /**
         * Asynchronously sends a Validate Service Programming Code request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_validate_service_programming_code_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsValidateServiceProgrammingCodeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        validate_service_programming_code(
            input: MessageDmsValidateServiceProgrammingCodeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsValidateServiceProgrammingCodeOutput>;
        /**
         * Asynchronously sends a Validate Service Programming Code request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_validate_service_programming_code_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsValidateServiceProgrammingCodeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        validate_service_programming_code(
            input: MessageDmsValidateServiceProgrammingCodeInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Validate Service Programming Code request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_validate_service_programming_code_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsValidateServiceProgrammingCodeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        validate_service_programming_code(
            input: MessageDmsValidateServiceProgrammingCodeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsValidateServiceProgrammingCodeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_validate_service_programming_code().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_validate_service_programming_code().
         * @returns a #QmiMessageDmsValidateServiceProgrammingCodeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_validate_service_programming_code_output_unref().
         */
        validate_service_programming_code_finish(res: Gio.AsyncResult): MessageDmsValidateServiceProgrammingCodeOutput;
        /**
         * Asynchronously sends a Write User Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_write_user_data_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsWriteUserDataInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        write_user_data(
            input: MessageDmsWriteUserDataInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDmsWriteUserDataOutput>;
        /**
         * Asynchronously sends a Write User Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_write_user_data_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsWriteUserDataInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        write_user_data(
            input: MessageDmsWriteUserDataInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Write User Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dms_write_user_data_finish() to get the result of the operation.
         * @param input a #QmiMessageDmsWriteUserDataInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        write_user_data(
            input: MessageDmsWriteUserDataInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDmsWriteUserDataOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dms_write_user_data().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_write_user_data().
         * @returns a #QmiMessageDmsWriteUserDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_write_user_data_output_unref().
         */
        write_user_data_finish(res: Gio.AsyncResult): MessageDmsWriteUserDataOutput;
    }

    module ClientDpm {
        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientDpm structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientDpm extends Client {
        static $gtype: GObject.GType<ClientDpm>;

        // Constructors

        constructor(properties?: Partial<ClientDpm.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Asynchronously sends a Close Port request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dpm_close_port_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        close_port(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDpmClosePortOutput>;
        /**
         * Asynchronously sends a Close Port request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dpm_close_port_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        close_port(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Close Port request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dpm_close_port_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        close_port(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDpmClosePortOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dpm_close_port().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dpm_close_port().
         * @returns a #QmiMessageDpmClosePortOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dpm_close_port_output_unref().
         */
        close_port_finish(res: Gio.AsyncResult): MessageDpmClosePortOutput;
        /**
         * Asynchronously sends a Open Port request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dpm_open_port_finish() to get the result of the operation.
         * @param input a #QmiMessageDpmOpenPortInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        open_port(
            input: MessageDpmOpenPortInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDpmOpenPortOutput>;
        /**
         * Asynchronously sends a Open Port request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dpm_open_port_finish() to get the result of the operation.
         * @param input a #QmiMessageDpmOpenPortInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        open_port(
            input: MessageDpmOpenPortInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Open Port request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dpm_open_port_finish() to get the result of the operation.
         * @param input a #QmiMessageDpmOpenPortInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        open_port(
            input: MessageDpmOpenPortInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDpmOpenPortOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dpm_open_port().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dpm_open_port().
         * @returns a #QmiMessageDpmOpenPortOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dpm_open_port_output_unref().
         */
        open_port_finish(res: Gio.AsyncResult): MessageDpmOpenPortOutput;
    }

    module ClientDsd {
        // Signal callback interfaces

        interface SystemStatus {
            (output: IndicationDsdSystemStatusOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientDsd structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientDsd extends Client {
        static $gtype: GObject.GType<ClientDsd>;

        // Constructors

        constructor(properties?: Partial<ClientDsd.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'system-status',
            callback: (_source: this, output: IndicationDsdSystemStatusOutput) => void,
        ): number;
        connect_after(
            signal: 'system-status',
            callback: (_source: this, output: IndicationDsdSystemStatusOutput) => void,
        ): number;
        emit(signal: 'system-status', output: IndicationDsdSystemStatusOutput): void;

        // Methods

        /**
         * Asynchronously sends a Get APN Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dsd_get_apn_info_finish() to get the result of the operation.
         * @param input a #QmiMessageDsdGetApnInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_apn_info(
            input: MessageDsdGetApnInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDsdGetApnInfoOutput>;
        /**
         * Asynchronously sends a Get APN Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dsd_get_apn_info_finish() to get the result of the operation.
         * @param input a #QmiMessageDsdGetApnInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_apn_info(
            input: MessageDsdGetApnInfoInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get APN Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dsd_get_apn_info_finish() to get the result of the operation.
         * @param input a #QmiMessageDsdGetApnInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_apn_info(
            input: MessageDsdGetApnInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDsdGetApnInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dsd_get_apn_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dsd_get_apn_info().
         * @returns a #QmiMessageDsdGetApnInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dsd_get_apn_info_output_unref().
         */
        get_apn_info_finish(res: Gio.AsyncResult): MessageDsdGetApnInfoOutput;
        /**
         * Asynchronously sends a Get System Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dsd_get_system_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_system_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDsdGetSystemStatusOutput>;
        /**
         * Asynchronously sends a Get System Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dsd_get_system_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_system_status(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get System Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dsd_get_system_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_system_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDsdGetSystemStatusOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dsd_get_system_status().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dsd_get_system_status().
         * @returns a #QmiMessageDsdGetSystemStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dsd_get_system_status_output_unref().
         */
        get_system_status_finish(res: Gio.AsyncResult): MessageDsdGetSystemStatusOutput;
        /**
         * Asynchronously sends a Set APN Type request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dsd_set_apn_type_finish() to get the result of the operation.
         * @param input a #QmiMessageDsdSetApnTypeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_apn_type(
            input: MessageDsdSetApnTypeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDsdSetApnTypeOutput>;
        /**
         * Asynchronously sends a Set APN Type request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dsd_set_apn_type_finish() to get the result of the operation.
         * @param input a #QmiMessageDsdSetApnTypeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_apn_type(
            input: MessageDsdSetApnTypeInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set APN Type request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dsd_set_apn_type_finish() to get the result of the operation.
         * @param input a #QmiMessageDsdSetApnTypeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_apn_type(
            input: MessageDsdSetApnTypeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDsdSetApnTypeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dsd_set_apn_type().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dsd_set_apn_type().
         * @returns a #QmiMessageDsdSetApnTypeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dsd_set_apn_type_output_unref().
         */
        set_apn_type_finish(res: Gio.AsyncResult): MessageDsdSetApnTypeOutput;
        /**
         * Asynchronously sends a System Status Change request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dsd_system_status_change_finish() to get the result of the operation.
         * @param input a #QmiMessageDsdSystemStatusChangeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        system_status_change(
            input: MessageDsdSystemStatusChangeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageDsdSystemStatusChangeOutput>;
        /**
         * Asynchronously sends a System Status Change request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dsd_system_status_change_finish() to get the result of the operation.
         * @param input a #QmiMessageDsdSystemStatusChangeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        system_status_change(
            input: MessageDsdSystemStatusChangeInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a System Status Change request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_dsd_system_status_change_finish() to get the result of the operation.
         * @param input a #QmiMessageDsdSystemStatusChangeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        system_status_change(
            input: MessageDsdSystemStatusChangeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageDsdSystemStatusChangeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_dsd_system_status_change().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dsd_system_status_change().
         * @returns a #QmiMessageDsdSystemStatusChangeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dsd_system_status_change_output_unref().
         */
        system_status_change_finish(res: Gio.AsyncResult): MessageDsdSystemStatusChangeOutput;
    }

    module ClientFox {
        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientFox structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientFox extends Client {
        static $gtype: GObject.GType<ClientFox>;

        // Constructors

        constructor(properties?: Partial<ClientFox.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Asynchronously sends a Get Firmware Version request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_fox_get_firmware_version_finish() to get the result of the operation.
         * @param input a #QmiMessageFoxGetFirmwareVersionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_firmware_version(
            input: MessageFoxGetFirmwareVersionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageFoxGetFirmwareVersionOutput>;
        /**
         * Asynchronously sends a Get Firmware Version request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_fox_get_firmware_version_finish() to get the result of the operation.
         * @param input a #QmiMessageFoxGetFirmwareVersionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_firmware_version(
            input: MessageFoxGetFirmwareVersionInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Firmware Version request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_fox_get_firmware_version_finish() to get the result of the operation.
         * @param input a #QmiMessageFoxGetFirmwareVersionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_firmware_version(
            input: MessageFoxGetFirmwareVersionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageFoxGetFirmwareVersionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_fox_get_firmware_version().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_fox_get_firmware_version().
         * @returns a #QmiMessageFoxGetFirmwareVersionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_fox_get_firmware_version_output_unref().
         */
        get_firmware_version_finish(res: Gio.AsyncResult): MessageFoxGetFirmwareVersionOutput;
    }

    module ClientGas {
        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientGas structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientGas extends Client {
        static $gtype: GObject.GType<ClientGas>;

        // Constructors

        constructor(properties?: Partial<ClientGas.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Asynchronously sends a DMS Get Firmware List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gas_dms_get_firmware_list_finish() to get the result of the operation.
         * @param input a #QmiMessageGasDmsGetFirmwareListInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        dms_get_firmware_list(
            input: MessageGasDmsGetFirmwareListInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageGasDmsGetFirmwareListOutput>;
        /**
         * Asynchronously sends a DMS Get Firmware List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gas_dms_get_firmware_list_finish() to get the result of the operation.
         * @param input a #QmiMessageGasDmsGetFirmwareListInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        dms_get_firmware_list(
            input: MessageGasDmsGetFirmwareListInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a DMS Get Firmware List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gas_dms_get_firmware_list_finish() to get the result of the operation.
         * @param input a #QmiMessageGasDmsGetFirmwareListInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        dms_get_firmware_list(
            input: MessageGasDmsGetFirmwareListInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageGasDmsGetFirmwareListOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_gas_dms_get_firmware_list().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_gas_dms_get_firmware_list().
         * @returns a #QmiMessageGasDmsGetFirmwareListOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_gas_dms_get_firmware_list_output_unref().
         */
        dms_get_firmware_list_finish(res: Gio.AsyncResult): MessageGasDmsGetFirmwareListOutput;
        /**
         * Asynchronously sends a DMS Get USB Composition request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gas_dms_get_usb_composition_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        dms_get_usb_composition(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageGasDmsGetUsbCompositionOutput>;
        /**
         * Asynchronously sends a DMS Get USB Composition request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gas_dms_get_usb_composition_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        dms_get_usb_composition(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a DMS Get USB Composition request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gas_dms_get_usb_composition_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        dms_get_usb_composition(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageGasDmsGetUsbCompositionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_gas_dms_get_usb_composition().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_gas_dms_get_usb_composition().
         * @returns a #QmiMessageGasDmsGetUsbCompositionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_gas_dms_get_usb_composition_output_unref().
         */
        dms_get_usb_composition_finish(res: Gio.AsyncResult): MessageGasDmsGetUsbCompositionOutput;
        /**
         * Asynchronously sends a DMS Set Active Firmware request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gas_dms_set_active_firmware_finish() to get the result of the operation.
         * @param input a #QmiMessageGasDmsSetActiveFirmwareInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        dms_set_active_firmware(
            input: MessageGasDmsSetActiveFirmwareInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageGasDmsSetActiveFirmwareOutput>;
        /**
         * Asynchronously sends a DMS Set Active Firmware request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gas_dms_set_active_firmware_finish() to get the result of the operation.
         * @param input a #QmiMessageGasDmsSetActiveFirmwareInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        dms_set_active_firmware(
            input: MessageGasDmsSetActiveFirmwareInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a DMS Set Active Firmware request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gas_dms_set_active_firmware_finish() to get the result of the operation.
         * @param input a #QmiMessageGasDmsSetActiveFirmwareInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        dms_set_active_firmware(
            input: MessageGasDmsSetActiveFirmwareInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageGasDmsSetActiveFirmwareOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_gas_dms_set_active_firmware().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_gas_dms_set_active_firmware().
         * @returns a #QmiMessageGasDmsSetActiveFirmwareOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_gas_dms_set_active_firmware_output_unref().
         */
        dms_set_active_firmware_finish(res: Gio.AsyncResult): MessageGasDmsSetActiveFirmwareOutput;
        /**
         * Asynchronously sends a DMS Set USB Composition request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gas_dms_set_usb_composition_finish() to get the result of the operation.
         * @param input a #QmiMessageGasDmsSetUsbCompositionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        dms_set_usb_composition(
            input: MessageGasDmsSetUsbCompositionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageGasDmsSetUsbCompositionOutput>;
        /**
         * Asynchronously sends a DMS Set USB Composition request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gas_dms_set_usb_composition_finish() to get the result of the operation.
         * @param input a #QmiMessageGasDmsSetUsbCompositionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        dms_set_usb_composition(
            input: MessageGasDmsSetUsbCompositionInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a DMS Set USB Composition request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gas_dms_set_usb_composition_finish() to get the result of the operation.
         * @param input a #QmiMessageGasDmsSetUsbCompositionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        dms_set_usb_composition(
            input: MessageGasDmsSetUsbCompositionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageGasDmsSetUsbCompositionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_gas_dms_set_usb_composition().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_gas_dms_set_usb_composition().
         * @returns a #QmiMessageGasDmsSetUsbCompositionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_gas_dms_set_usb_composition_output_unref().
         */
        dms_set_usb_composition_finish(res: Gio.AsyncResult): MessageGasDmsSetUsbCompositionOutput;
    }

    module ClientGms {
        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientGms structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientGms extends Client {
        static $gtype: GObject.GType<ClientGms>;

        // Constructors

        constructor(properties?: Partial<ClientGms.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Asynchronously sends a Test Get Value request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gms_test_get_value_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        test_get_value(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageGmsTestGetValueOutput>;
        /**
         * Asynchronously sends a Test Get Value request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gms_test_get_value_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        test_get_value(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Test Get Value request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gms_test_get_value_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        test_get_value(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageGmsTestGetValueOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_gms_test_get_value().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_gms_test_get_value().
         * @returns a #QmiMessageGmsTestGetValueOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_gms_test_get_value_output_unref().
         */
        test_get_value_finish(res: Gio.AsyncResult): MessageGmsTestGetValueOutput;
        /**
         * Asynchronously sends a Test Set Value request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gms_test_set_value_finish() to get the result of the operation.
         * @param input a #QmiMessageGmsTestSetValueInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        test_set_value(
            input: MessageGmsTestSetValueInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageGmsTestSetValueOutput>;
        /**
         * Asynchronously sends a Test Set Value request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gms_test_set_value_finish() to get the result of the operation.
         * @param input a #QmiMessageGmsTestSetValueInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        test_set_value(
            input: MessageGmsTestSetValueInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Test Set Value request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_gms_test_set_value_finish() to get the result of the operation.
         * @param input a #QmiMessageGmsTestSetValueInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        test_set_value(
            input: MessageGmsTestSetValueInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageGmsTestSetValueOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_gms_test_set_value().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_gms_test_set_value().
         * @returns a #QmiMessageGmsTestSetValueOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_gms_test_set_value_output_unref().
         */
        test_set_value_finish(res: Gio.AsyncResult): MessageGmsTestSetValueOutput;
    }

    module ClientIms {
        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientIms structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientIms extends Client {
        static $gtype: GObject.GType<ClientIms>;

        // Constructors

        constructor(properties?: Partial<ClientIms.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Asynchronously sends a Get IMS Services Enabled Setting request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_ims_get_ims_services_enabled_setting_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_ims_services_enabled_setting(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageImsGetImsServicesEnabledSettingOutput>;
        /**
         * Asynchronously sends a Get IMS Services Enabled Setting request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_ims_get_ims_services_enabled_setting_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_ims_services_enabled_setting(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get IMS Services Enabled Setting request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_ims_get_ims_services_enabled_setting_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_ims_services_enabled_setting(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageImsGetImsServicesEnabledSettingOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_ims_get_ims_services_enabled_setting().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_ims_get_ims_services_enabled_setting().
         * @returns a #QmiMessageImsGetImsServicesEnabledSettingOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_ims_get_ims_services_enabled_setting_output_unref().
         */
        get_ims_services_enabled_setting_finish(res: Gio.AsyncResult): MessageImsGetImsServicesEnabledSettingOutput;
    }

    module ClientImsa {
        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientImsa structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientImsa extends Client {
        static $gtype: GObject.GType<ClientImsa>;

        // Constructors

        constructor(properties?: Partial<ClientImsa.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Asynchronously sends a Get IMS Registration Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_imsa_get_ims_registration_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_ims_registration_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageImsaGetImsRegistrationStatusOutput>;
        /**
         * Asynchronously sends a Get IMS Registration Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_imsa_get_ims_registration_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_ims_registration_status(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get IMS Registration Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_imsa_get_ims_registration_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_ims_registration_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageImsaGetImsRegistrationStatusOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_imsa_get_ims_registration_status().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_imsa_get_ims_registration_status().
         * @returns a #QmiMessageImsaGetImsRegistrationStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_imsa_get_ims_registration_status_output_unref().
         */
        get_ims_registration_status_finish(res: Gio.AsyncResult): MessageImsaGetImsRegistrationStatusOutput;
        /**
         * Asynchronously sends a Get IMS Services Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_imsa_get_ims_services_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_ims_services_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageImsaGetImsServicesStatusOutput>;
        /**
         * Asynchronously sends a Get IMS Services Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_imsa_get_ims_services_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_ims_services_status(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get IMS Services Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_imsa_get_ims_services_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_ims_services_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageImsaGetImsServicesStatusOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_imsa_get_ims_services_status().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_imsa_get_ims_services_status().
         * @returns a #QmiMessageImsaGetImsServicesStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_imsa_get_ims_services_status_output_unref().
         */
        get_ims_services_status_finish(res: Gio.AsyncResult): MessageImsaGetImsServicesStatusOutput;
    }

    module ClientImsp {
        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientImsp structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientImsp extends Client {
        static $gtype: GObject.GType<ClientImsp>;

        // Constructors

        constructor(properties?: Partial<ClientImsp.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Asynchronously sends a Get Enabler State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_imsp_get_enabler_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_enabler_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageImspGetEnablerStateOutput>;
        /**
         * Asynchronously sends a Get Enabler State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_imsp_get_enabler_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_enabler_state(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Enabler State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_imsp_get_enabler_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_enabler_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageImspGetEnablerStateOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_imsp_get_enabler_state().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_imsp_get_enabler_state().
         * @returns a #QmiMessageImspGetEnablerStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_imsp_get_enabler_state_output_unref().
         */
        get_enabler_state_finish(res: Gio.AsyncResult): MessageImspGetEnablerStateOutput;
    }

    module ClientLoc {
        // Signal callback interfaces

        interface DeleteAssistanceData {
            (output: IndicationLocDeleteAssistanceDataOutput): void;
        }

        interface EngineState {
            (output: IndicationLocEngineStateOutput): void;
        }

        interface FixRecurrenceType {
            (output: IndicationLocFixRecurrenceTypeOutput): void;
        }

        interface GetEngineLock {
            (output: IndicationLocGetEngineLockOutput): void;
        }

        interface GetNmeaTypes {
            (output: IndicationLocGetNmeaTypesOutput): void;
        }

        interface GetOperationMode {
            (output: IndicationLocGetOperationModeOutput): void;
        }

        interface GetPredictedOrbitsDataSource {
            (output: IndicationLocGetPredictedOrbitsDataSourceOutput): void;
        }

        interface GetServer {
            (output: IndicationLocGetServerOutput): void;
        }

        interface GnssSvInfo {
            (output: IndicationLocGnssSvInfoOutput): void;
        }

        interface InjectPredictedOrbitsData {
            (output: IndicationLocInjectPredictedOrbitsDataOutput): void;
        }

        interface InjectXtraData {
            (output: IndicationLocInjectXtraDataOutput): void;
        }

        interface Nmea {
            (output: IndicationLocNmeaOutput): void;
        }

        interface PositionReport {
            (output: IndicationLocPositionReportOutput): void;
        }

        interface SetEngineLock {
            (output: IndicationLocSetEngineLockOutput): void;
        }

        interface SetNmeaTypes {
            (output: IndicationLocSetNmeaTypesOutput): void;
        }

        interface SetOperationMode {
            (output: IndicationLocSetOperationModeOutput): void;
        }

        interface SetServer {
            (output: IndicationLocSetServerOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientLoc structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientLoc extends Client {
        static $gtype: GObject.GType<ClientLoc>;

        // Constructors

        constructor(properties?: Partial<ClientLoc.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'delete-assistance-data',
            callback: (_source: this, output: IndicationLocDeleteAssistanceDataOutput) => void,
        ): number;
        connect_after(
            signal: 'delete-assistance-data',
            callback: (_source: this, output: IndicationLocDeleteAssistanceDataOutput) => void,
        ): number;
        emit(signal: 'delete-assistance-data', output: IndicationLocDeleteAssistanceDataOutput): void;
        connect(
            signal: 'engine-state',
            callback: (_source: this, output: IndicationLocEngineStateOutput) => void,
        ): number;
        connect_after(
            signal: 'engine-state',
            callback: (_source: this, output: IndicationLocEngineStateOutput) => void,
        ): number;
        emit(signal: 'engine-state', output: IndicationLocEngineStateOutput): void;
        connect(
            signal: 'fix-recurrence-type',
            callback: (_source: this, output: IndicationLocFixRecurrenceTypeOutput) => void,
        ): number;
        connect_after(
            signal: 'fix-recurrence-type',
            callback: (_source: this, output: IndicationLocFixRecurrenceTypeOutput) => void,
        ): number;
        emit(signal: 'fix-recurrence-type', output: IndicationLocFixRecurrenceTypeOutput): void;
        connect(
            signal: 'get-engine-lock',
            callback: (_source: this, output: IndicationLocGetEngineLockOutput) => void,
        ): number;
        connect_after(
            signal: 'get-engine-lock',
            callback: (_source: this, output: IndicationLocGetEngineLockOutput) => void,
        ): number;
        emit(signal: 'get-engine-lock', output: IndicationLocGetEngineLockOutput): void;
        connect(
            signal: 'get-nmea-types',
            callback: (_source: this, output: IndicationLocGetNmeaTypesOutput) => void,
        ): number;
        connect_after(
            signal: 'get-nmea-types',
            callback: (_source: this, output: IndicationLocGetNmeaTypesOutput) => void,
        ): number;
        emit(signal: 'get-nmea-types', output: IndicationLocGetNmeaTypesOutput): void;
        connect(
            signal: 'get-operation-mode',
            callback: (_source: this, output: IndicationLocGetOperationModeOutput) => void,
        ): number;
        connect_after(
            signal: 'get-operation-mode',
            callback: (_source: this, output: IndicationLocGetOperationModeOutput) => void,
        ): number;
        emit(signal: 'get-operation-mode', output: IndicationLocGetOperationModeOutput): void;
        connect(
            signal: 'get-predicted-orbits-data-source',
            callback: (_source: this, output: IndicationLocGetPredictedOrbitsDataSourceOutput) => void,
        ): number;
        connect_after(
            signal: 'get-predicted-orbits-data-source',
            callback: (_source: this, output: IndicationLocGetPredictedOrbitsDataSourceOutput) => void,
        ): number;
        emit(signal: 'get-predicted-orbits-data-source', output: IndicationLocGetPredictedOrbitsDataSourceOutput): void;
        connect(signal: 'get-server', callback: (_source: this, output: IndicationLocGetServerOutput) => void): number;
        connect_after(
            signal: 'get-server',
            callback: (_source: this, output: IndicationLocGetServerOutput) => void,
        ): number;
        emit(signal: 'get-server', output: IndicationLocGetServerOutput): void;
        connect(
            signal: 'gnss-sv-info',
            callback: (_source: this, output: IndicationLocGnssSvInfoOutput) => void,
        ): number;
        connect_after(
            signal: 'gnss-sv-info',
            callback: (_source: this, output: IndicationLocGnssSvInfoOutput) => void,
        ): number;
        emit(signal: 'gnss-sv-info', output: IndicationLocGnssSvInfoOutput): void;
        connect(
            signal: 'inject-predicted-orbits-data',
            callback: (_source: this, output: IndicationLocInjectPredictedOrbitsDataOutput) => void,
        ): number;
        connect_after(
            signal: 'inject-predicted-orbits-data',
            callback: (_source: this, output: IndicationLocInjectPredictedOrbitsDataOutput) => void,
        ): number;
        emit(signal: 'inject-predicted-orbits-data', output: IndicationLocInjectPredictedOrbitsDataOutput): void;
        connect(
            signal: 'inject-xtra-data',
            callback: (_source: this, output: IndicationLocInjectXtraDataOutput) => void,
        ): number;
        connect_after(
            signal: 'inject-xtra-data',
            callback: (_source: this, output: IndicationLocInjectXtraDataOutput) => void,
        ): number;
        emit(signal: 'inject-xtra-data', output: IndicationLocInjectXtraDataOutput): void;
        connect(signal: 'nmea', callback: (_source: this, output: IndicationLocNmeaOutput) => void): number;
        connect_after(signal: 'nmea', callback: (_source: this, output: IndicationLocNmeaOutput) => void): number;
        emit(signal: 'nmea', output: IndicationLocNmeaOutput): void;
        connect(
            signal: 'position-report',
            callback: (_source: this, output: IndicationLocPositionReportOutput) => void,
        ): number;
        connect_after(
            signal: 'position-report',
            callback: (_source: this, output: IndicationLocPositionReportOutput) => void,
        ): number;
        emit(signal: 'position-report', output: IndicationLocPositionReportOutput): void;
        connect(
            signal: 'set-engine-lock',
            callback: (_source: this, output: IndicationLocSetEngineLockOutput) => void,
        ): number;
        connect_after(
            signal: 'set-engine-lock',
            callback: (_source: this, output: IndicationLocSetEngineLockOutput) => void,
        ): number;
        emit(signal: 'set-engine-lock', output: IndicationLocSetEngineLockOutput): void;
        connect(
            signal: 'set-nmea-types',
            callback: (_source: this, output: IndicationLocSetNmeaTypesOutput) => void,
        ): number;
        connect_after(
            signal: 'set-nmea-types',
            callback: (_source: this, output: IndicationLocSetNmeaTypesOutput) => void,
        ): number;
        emit(signal: 'set-nmea-types', output: IndicationLocSetNmeaTypesOutput): void;
        connect(
            signal: 'set-operation-mode',
            callback: (_source: this, output: IndicationLocSetOperationModeOutput) => void,
        ): number;
        connect_after(
            signal: 'set-operation-mode',
            callback: (_source: this, output: IndicationLocSetOperationModeOutput) => void,
        ): number;
        emit(signal: 'set-operation-mode', output: IndicationLocSetOperationModeOutput): void;
        connect(signal: 'set-server', callback: (_source: this, output: IndicationLocSetServerOutput) => void): number;
        connect_after(
            signal: 'set-server',
            callback: (_source: this, output: IndicationLocSetServerOutput) => void,
        ): number;
        emit(signal: 'set-server', output: IndicationLocSetServerOutput): void;

        // Methods

        /**
         * Asynchronously sends a Delete Assistance Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_delete_assistance_data_finish() to get the result of the operation.
         * @param input a #QmiMessageLocDeleteAssistanceDataInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        delete_assistance_data(
            input: MessageLocDeleteAssistanceDataInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocDeleteAssistanceDataOutput>;
        /**
         * Asynchronously sends a Delete Assistance Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_delete_assistance_data_finish() to get the result of the operation.
         * @param input a #QmiMessageLocDeleteAssistanceDataInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        delete_assistance_data(
            input: MessageLocDeleteAssistanceDataInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Delete Assistance Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_delete_assistance_data_finish() to get the result of the operation.
         * @param input a #QmiMessageLocDeleteAssistanceDataInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        delete_assistance_data(
            input: MessageLocDeleteAssistanceDataInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocDeleteAssistanceDataOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_delete_assistance_data().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_delete_assistance_data().
         * @returns a #QmiMessageLocDeleteAssistanceDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_delete_assistance_data_output_unref().
         */
        delete_assistance_data_finish(res: Gio.AsyncResult): MessageLocDeleteAssistanceDataOutput;
        /**
         * Asynchronously sends a Get Engine Lock request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_engine_lock_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_engine_lock(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocGetEngineLockOutput>;
        /**
         * Asynchronously sends a Get Engine Lock request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_engine_lock_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_engine_lock(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Engine Lock request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_engine_lock_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_engine_lock(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocGetEngineLockOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_get_engine_lock().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_get_engine_lock().
         * @returns a #QmiMessageLocGetEngineLockOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_get_engine_lock_output_unref().
         */
        get_engine_lock_finish(res: Gio.AsyncResult): MessageLocGetEngineLockOutput;
        /**
         * Asynchronously sends a Get NMEA Types request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_nmea_types_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_nmea_types(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocGetNmeaTypesOutput>;
        /**
         * Asynchronously sends a Get NMEA Types request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_nmea_types_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_nmea_types(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get NMEA Types request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_nmea_types_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_nmea_types(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocGetNmeaTypesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_get_nmea_types().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_get_nmea_types().
         * @returns a #QmiMessageLocGetNmeaTypesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_get_nmea_types_output_unref().
         */
        get_nmea_types_finish(res: Gio.AsyncResult): MessageLocGetNmeaTypesOutput;
        /**
         * Asynchronously sends a Get Operation Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_operation_mode_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_operation_mode(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocGetOperationModeOutput>;
        /**
         * Asynchronously sends a Get Operation Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_operation_mode_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_operation_mode(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Operation Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_operation_mode_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_operation_mode(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocGetOperationModeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_get_operation_mode().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_get_operation_mode().
         * @returns a #QmiMessageLocGetOperationModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_get_operation_mode_output_unref().
         */
        get_operation_mode_finish(res: Gio.AsyncResult): MessageLocGetOperationModeOutput;
        /**
         * Asynchronously sends a Get Predicted Orbits Data Source request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_predicted_orbits_data_source_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_predicted_orbits_data_source(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocGetPredictedOrbitsDataSourceOutput>;
        /**
         * Asynchronously sends a Get Predicted Orbits Data Source request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_predicted_orbits_data_source_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_predicted_orbits_data_source(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Predicted Orbits Data Source request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_predicted_orbits_data_source_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_predicted_orbits_data_source(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocGetPredictedOrbitsDataSourceOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_get_predicted_orbits_data_source().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_get_predicted_orbits_data_source().
         * @returns a #QmiMessageLocGetPredictedOrbitsDataSourceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_get_predicted_orbits_data_source_output_unref().
         */
        get_predicted_orbits_data_source_finish(res: Gio.AsyncResult): MessageLocGetPredictedOrbitsDataSourceOutput;
        /**
         * Asynchronously sends a Get Server request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_server_finish() to get the result of the operation.
         * @param input a #QmiMessageLocGetServerInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_server(
            input: MessageLocGetServerInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocGetServerOutput>;
        /**
         * Asynchronously sends a Get Server request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_server_finish() to get the result of the operation.
         * @param input a #QmiMessageLocGetServerInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_server(
            input: MessageLocGetServerInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Server request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_get_server_finish() to get the result of the operation.
         * @param input a #QmiMessageLocGetServerInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_server(
            input: MessageLocGetServerInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocGetServerOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_get_server().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_get_server().
         * @returns a #QmiMessageLocGetServerOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_get_server_output_unref().
         */
        get_server_finish(res: Gio.AsyncResult): MessageLocGetServerOutput;
        /**
         * Asynchronously sends a Inject Predicted Orbits Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_inject_predicted_orbits_data_finish() to get the result of the operation.
         * @param input a #QmiMessageLocInjectPredictedOrbitsDataInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        inject_predicted_orbits_data(
            input: MessageLocInjectPredictedOrbitsDataInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocInjectPredictedOrbitsDataOutput>;
        /**
         * Asynchronously sends a Inject Predicted Orbits Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_inject_predicted_orbits_data_finish() to get the result of the operation.
         * @param input a #QmiMessageLocInjectPredictedOrbitsDataInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        inject_predicted_orbits_data(
            input: MessageLocInjectPredictedOrbitsDataInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Inject Predicted Orbits Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_inject_predicted_orbits_data_finish() to get the result of the operation.
         * @param input a #QmiMessageLocInjectPredictedOrbitsDataInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        inject_predicted_orbits_data(
            input: MessageLocInjectPredictedOrbitsDataInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocInjectPredictedOrbitsDataOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_inject_predicted_orbits_data().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_inject_predicted_orbits_data().
         * @returns a #QmiMessageLocInjectPredictedOrbitsDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_inject_predicted_orbits_data_output_unref().
         */
        inject_predicted_orbits_data_finish(res: Gio.AsyncResult): MessageLocInjectPredictedOrbitsDataOutput;
        /**
         * Asynchronously sends a Inject Xtra Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_inject_xtra_data_finish() to get the result of the operation.
         * @param input a #QmiMessageLocInjectXtraDataInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        inject_xtra_data(
            input: MessageLocInjectXtraDataInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocInjectXtraDataOutput>;
        /**
         * Asynchronously sends a Inject Xtra Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_inject_xtra_data_finish() to get the result of the operation.
         * @param input a #QmiMessageLocInjectXtraDataInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        inject_xtra_data(
            input: MessageLocInjectXtraDataInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Inject Xtra Data request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_inject_xtra_data_finish() to get the result of the operation.
         * @param input a #QmiMessageLocInjectXtraDataInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        inject_xtra_data(
            input: MessageLocInjectXtraDataInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocInjectXtraDataOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_inject_xtra_data().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_inject_xtra_data().
         * @returns a #QmiMessageLocInjectXtraDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_inject_xtra_data_output_unref().
         */
        inject_xtra_data_finish(res: Gio.AsyncResult): MessageLocInjectXtraDataOutput;
        /**
         * Asynchronously sends a Register Events request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_register_events_finish() to get the result of the operation.
         * @param input a #QmiMessageLocRegisterEventsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        register_events(
            input: MessageLocRegisterEventsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocRegisterEventsOutput>;
        /**
         * Asynchronously sends a Register Events request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_register_events_finish() to get the result of the operation.
         * @param input a #QmiMessageLocRegisterEventsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        register_events(
            input: MessageLocRegisterEventsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Register Events request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_register_events_finish() to get the result of the operation.
         * @param input a #QmiMessageLocRegisterEventsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        register_events(
            input: MessageLocRegisterEventsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocRegisterEventsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_register_events().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_register_events().
         * @returns a #QmiMessageLocRegisterEventsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_register_events_output_unref().
         */
        register_events_finish(res: Gio.AsyncResult): MessageLocRegisterEventsOutput;
        /**
         * Asynchronously sends a Set Engine Lock request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_set_engine_lock_finish() to get the result of the operation.
         * @param input a #QmiMessageLocSetEngineLockInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_engine_lock(
            input: MessageLocSetEngineLockInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocSetEngineLockOutput>;
        /**
         * Asynchronously sends a Set Engine Lock request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_set_engine_lock_finish() to get the result of the operation.
         * @param input a #QmiMessageLocSetEngineLockInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_engine_lock(
            input: MessageLocSetEngineLockInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Engine Lock request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_set_engine_lock_finish() to get the result of the operation.
         * @param input a #QmiMessageLocSetEngineLockInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_engine_lock(
            input: MessageLocSetEngineLockInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocSetEngineLockOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_set_engine_lock().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_set_engine_lock().
         * @returns a #QmiMessageLocSetEngineLockOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_set_engine_lock_output_unref().
         */
        set_engine_lock_finish(res: Gio.AsyncResult): MessageLocSetEngineLockOutput;
        /**
         * Asynchronously sends a Set NMEA Types request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_set_nmea_types_finish() to get the result of the operation.
         * @param input a #QmiMessageLocSetNmeaTypesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_nmea_types(
            input: MessageLocSetNmeaTypesInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocSetNmeaTypesOutput>;
        /**
         * Asynchronously sends a Set NMEA Types request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_set_nmea_types_finish() to get the result of the operation.
         * @param input a #QmiMessageLocSetNmeaTypesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_nmea_types(
            input: MessageLocSetNmeaTypesInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set NMEA Types request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_set_nmea_types_finish() to get the result of the operation.
         * @param input a #QmiMessageLocSetNmeaTypesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_nmea_types(
            input: MessageLocSetNmeaTypesInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocSetNmeaTypesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_set_nmea_types().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_set_nmea_types().
         * @returns a #QmiMessageLocSetNmeaTypesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_set_nmea_types_output_unref().
         */
        set_nmea_types_finish(res: Gio.AsyncResult): MessageLocSetNmeaTypesOutput;
        /**
         * Asynchronously sends a Set Operation Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_set_operation_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageLocSetOperationModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_operation_mode(
            input: MessageLocSetOperationModeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocSetOperationModeOutput>;
        /**
         * Asynchronously sends a Set Operation Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_set_operation_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageLocSetOperationModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_operation_mode(
            input: MessageLocSetOperationModeInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Operation Mode request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_set_operation_mode_finish() to get the result of the operation.
         * @param input a #QmiMessageLocSetOperationModeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_operation_mode(
            input: MessageLocSetOperationModeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocSetOperationModeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_set_operation_mode().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_set_operation_mode().
         * @returns a #QmiMessageLocSetOperationModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_set_operation_mode_output_unref().
         */
        set_operation_mode_finish(res: Gio.AsyncResult): MessageLocSetOperationModeOutput;
        /**
         * Asynchronously sends a Set Server request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_set_server_finish() to get the result of the operation.
         * @param input a #QmiMessageLocSetServerInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_server(
            input: MessageLocSetServerInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocSetServerOutput>;
        /**
         * Asynchronously sends a Set Server request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_set_server_finish() to get the result of the operation.
         * @param input a #QmiMessageLocSetServerInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_server(
            input: MessageLocSetServerInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Server request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_set_server_finish() to get the result of the operation.
         * @param input a #QmiMessageLocSetServerInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_server(
            input: MessageLocSetServerInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocSetServerOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_set_server().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_set_server().
         * @returns a #QmiMessageLocSetServerOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_set_server_output_unref().
         */
        set_server_finish(res: Gio.AsyncResult): MessageLocSetServerOutput;
        /**
         * Asynchronously sends a Start request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_start_finish() to get the result of the operation.
         * @param input a #QmiMessageLocStartInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        start(
            input: MessageLocStartInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocStartOutput>;
        /**
         * Asynchronously sends a Start request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_start_finish() to get the result of the operation.
         * @param input a #QmiMessageLocStartInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        start(
            input: MessageLocStartInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Start request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_start_finish() to get the result of the operation.
         * @param input a #QmiMessageLocStartInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        start(
            input: MessageLocStartInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocStartOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_start().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_start().
         * @returns a #QmiMessageLocStartOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_start_output_unref().
         */
        start_finish(res: Gio.AsyncResult): MessageLocStartOutput;
        /**
         * Asynchronously sends a Stop request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_stop_finish() to get the result of the operation.
         * @param input a #QmiMessageLocStopInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        stop(
            input: MessageLocStopInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageLocStopOutput>;
        /**
         * Asynchronously sends a Stop request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_stop_finish() to get the result of the operation.
         * @param input a #QmiMessageLocStopInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        stop(
            input: MessageLocStopInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Stop request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_loc_stop_finish() to get the result of the operation.
         * @param input a #QmiMessageLocStopInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        stop(
            input: MessageLocStopInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageLocStopOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_loc_stop().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_loc_stop().
         * @returns a #QmiMessageLocStopOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_loc_stop_output_unref().
         */
        stop_finish(res: Gio.AsyncResult): MessageLocStopOutput;
    }

    module ClientNas {
        // Signal callback interfaces

        interface EventReport {
            (output: IndicationNasEventReportOutput): void;
        }

        interface NetworkReject {
            (output: IndicationNasNetworkRejectOutput): void;
        }

        interface NetworkTime {
            (output: IndicationNasNetworkTimeOutput): void;
        }

        interface OperatorName {
            (output: IndicationNasOperatorNameOutput): void;
        }

        interface ServingSystem {
            (output: IndicationNasServingSystemOutput): void;
        }

        interface SignalInfo {
            (output: IndicationNasSignalInfoOutput): void;
        }

        interface SystemInfo {
            (output: IndicationNasSystemInfoOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientNas structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientNas extends Client {
        static $gtype: GObject.GType<ClientNas>;

        // Constructors

        constructor(properties?: Partial<ClientNas.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'event-report',
            callback: (_source: this, output: IndicationNasEventReportOutput) => void,
        ): number;
        connect_after(
            signal: 'event-report',
            callback: (_source: this, output: IndicationNasEventReportOutput) => void,
        ): number;
        emit(signal: 'event-report', output: IndicationNasEventReportOutput): void;
        connect(
            signal: 'network-reject',
            callback: (_source: this, output: IndicationNasNetworkRejectOutput) => void,
        ): number;
        connect_after(
            signal: 'network-reject',
            callback: (_source: this, output: IndicationNasNetworkRejectOutput) => void,
        ): number;
        emit(signal: 'network-reject', output: IndicationNasNetworkRejectOutput): void;
        connect(
            signal: 'network-time',
            callback: (_source: this, output: IndicationNasNetworkTimeOutput) => void,
        ): number;
        connect_after(
            signal: 'network-time',
            callback: (_source: this, output: IndicationNasNetworkTimeOutput) => void,
        ): number;
        emit(signal: 'network-time', output: IndicationNasNetworkTimeOutput): void;
        connect(
            signal: 'operator-name',
            callback: (_source: this, output: IndicationNasOperatorNameOutput) => void,
        ): number;
        connect_after(
            signal: 'operator-name',
            callback: (_source: this, output: IndicationNasOperatorNameOutput) => void,
        ): number;
        emit(signal: 'operator-name', output: IndicationNasOperatorNameOutput): void;
        connect(
            signal: 'serving-system',
            callback: (_source: this, output: IndicationNasServingSystemOutput) => void,
        ): number;
        connect_after(
            signal: 'serving-system',
            callback: (_source: this, output: IndicationNasServingSystemOutput) => void,
        ): number;
        emit(signal: 'serving-system', output: IndicationNasServingSystemOutput): void;
        connect(
            signal: 'signal-info',
            callback: (_source: this, output: IndicationNasSignalInfoOutput) => void,
        ): number;
        connect_after(
            signal: 'signal-info',
            callback: (_source: this, output: IndicationNasSignalInfoOutput) => void,
        ): number;
        emit(signal: 'signal-info', output: IndicationNasSignalInfoOutput): void;
        connect(
            signal: 'system-info',
            callback: (_source: this, output: IndicationNasSystemInfoOutput) => void,
        ): number;
        connect_after(
            signal: 'system-info',
            callback: (_source: this, output: IndicationNasSystemInfoOutput) => void,
        ): number;
        emit(signal: 'system-info', output: IndicationNasSystemInfoOutput): void;

        // Methods

        /**
         * Asynchronously sends a Attach Detach request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_attach_detach_finish() to get the result of the operation.
         * @param input a #QmiMessageNasAttachDetachInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        attach_detach(
            input: MessageNasAttachDetachInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasAttachDetachOutput>;
        /**
         * Asynchronously sends a Attach Detach request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_attach_detach_finish() to get the result of the operation.
         * @param input a #QmiMessageNasAttachDetachInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        attach_detach(
            input: MessageNasAttachDetachInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Attach Detach request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_attach_detach_finish() to get the result of the operation.
         * @param input a #QmiMessageNasAttachDetachInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        attach_detach(
            input: MessageNasAttachDetachInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasAttachDetachOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_attach_detach().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_attach_detach().
         * @returns a #QmiMessageNasAttachDetachOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_attach_detach_output_unref().
         */
        attach_detach_finish(res: Gio.AsyncResult): MessageNasAttachDetachOutput;
        /**
         * Asynchronously sends a Config Signal Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_config_signal_info_finish() to get the result of the operation.
         * @param input a #QmiMessageNasConfigSignalInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        config_signal_info(
            input: MessageNasConfigSignalInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasConfigSignalInfoOutput>;
        /**
         * Asynchronously sends a Config Signal Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_config_signal_info_finish() to get the result of the operation.
         * @param input a #QmiMessageNasConfigSignalInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        config_signal_info(
            input: MessageNasConfigSignalInfoInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Config Signal Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_config_signal_info_finish() to get the result of the operation.
         * @param input a #QmiMessageNasConfigSignalInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        config_signal_info(
            input: MessageNasConfigSignalInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasConfigSignalInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_config_signal_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_config_signal_info().
         * @returns a #QmiMessageNasConfigSignalInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_config_signal_info_output_unref().
         */
        config_signal_info_finish(res: Gio.AsyncResult): MessageNasConfigSignalInfoOutput;
        /**
         * Asynchronously sends a Config Signal Info v2 request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_config_signal_info_v2_finish() to get the result of the operation.
         * @param input a #QmiMessageNasConfigSignalInfoV2Input.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        config_signal_info_v2(
            input: MessageNasConfigSignalInfoV2Input,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasConfigSignalInfoV2Output>;
        /**
         * Asynchronously sends a Config Signal Info v2 request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_config_signal_info_v2_finish() to get the result of the operation.
         * @param input a #QmiMessageNasConfigSignalInfoV2Input.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        config_signal_info_v2(
            input: MessageNasConfigSignalInfoV2Input,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Config Signal Info v2 request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_config_signal_info_v2_finish() to get the result of the operation.
         * @param input a #QmiMessageNasConfigSignalInfoV2Input.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        config_signal_info_v2(
            input: MessageNasConfigSignalInfoV2Input,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasConfigSignalInfoV2Output> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_config_signal_info_v2().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_config_signal_info_v2().
         * @returns a #QmiMessageNasConfigSignalInfoV2Output, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_config_signal_info_v2_output_unref().
         */
        config_signal_info_v2_finish(res: Gio.AsyncResult): MessageNasConfigSignalInfoV2Output;
        /**
         * Asynchronously sends a Force Network Search request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_force_network_search_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        force_network_search(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasForceNetworkSearchOutput>;
        /**
         * Asynchronously sends a Force Network Search request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_force_network_search_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        force_network_search(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Force Network Search request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_force_network_search_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        force_network_search(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasForceNetworkSearchOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_force_network_search().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_force_network_search().
         * @returns a #QmiMessageNasForceNetworkSearchOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_force_network_search_output_unref().
         */
        force_network_search_finish(res: Gio.AsyncResult): MessageNasForceNetworkSearchOutput;
        /**
         * Asynchronously sends a Get CDMA Position Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_cdma_position_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_cdma_position_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetCdmaPositionInfoOutput>;
        /**
         * Asynchronously sends a Get CDMA Position Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_cdma_position_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_cdma_position_info(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get CDMA Position Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_cdma_position_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_cdma_position_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetCdmaPositionInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_cdma_position_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_cdma_position_info().
         * @returns a #QmiMessageNasGetCdmaPositionInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_cdma_position_info_output_unref().
         */
        get_cdma_position_info_finish(res: Gio.AsyncResult): MessageNasGetCdmaPositionInfoOutput;
        /**
         * Asynchronously sends a Get Cell Location Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_cell_location_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_cell_location_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetCellLocationInfoOutput>;
        /**
         * Asynchronously sends a Get Cell Location Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_cell_location_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_cell_location_info(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Cell Location Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_cell_location_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_cell_location_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetCellLocationInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_cell_location_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_cell_location_info().
         * @returns a #QmiMessageNasGetCellLocationInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_cell_location_info_output_unref().
         */
        get_cell_location_info_finish(res: Gio.AsyncResult): MessageNasGetCellLocationInfoOutput;
        /**
         * Asynchronously sends a Get DRX request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_drx_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_drx(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetDrxOutput>;
        /**
         * Asynchronously sends a Get DRX request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_drx_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_drx(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get DRX request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_drx_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_drx(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetDrxOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_drx().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_drx().
         * @returns a #QmiMessageNasGetDrxOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_drx_output_unref().
         */
        get_drx_finish(res: Gio.AsyncResult): MessageNasGetDrxOutput;
        /**
         * Asynchronously sends a Get Home Network request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_home_network_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_home_network(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetHomeNetworkOutput>;
        /**
         * Asynchronously sends a Get Home Network request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_home_network_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_home_network(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Home Network request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_home_network_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_home_network(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetHomeNetworkOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_home_network().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_home_network().
         * @returns a #QmiMessageNasGetHomeNetworkOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_home_network_output_unref().
         */
        get_home_network_finish(res: Gio.AsyncResult): MessageNasGetHomeNetworkOutput;
        /**
         * Asynchronously sends a Get LTE Cphy CA Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_lte_cphy_ca_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_lte_cphy_ca_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetLteCphyCaInfoOutput>;
        /**
         * Asynchronously sends a Get LTE Cphy CA Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_lte_cphy_ca_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_lte_cphy_ca_info(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get LTE Cphy CA Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_lte_cphy_ca_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_lte_cphy_ca_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetLteCphyCaInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_lte_cphy_ca_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_lte_cphy_ca_info().
         * @returns a #QmiMessageNasGetLteCphyCaInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_lte_cphy_ca_info_output_unref().
         */
        get_lte_cphy_ca_info_finish(res: Gio.AsyncResult): MessageNasGetLteCphyCaInfoOutput;
        /**
         * Asynchronously sends a Get Operator Name request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_operator_name_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_operator_name(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetOperatorNameOutput>;
        /**
         * Asynchronously sends a Get Operator Name request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_operator_name_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_operator_name(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Operator Name request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_operator_name_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_operator_name(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetOperatorNameOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_operator_name().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_operator_name().
         * @returns a #QmiMessageNasGetOperatorNameOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_operator_name_output_unref().
         */
        get_operator_name_finish(res: Gio.AsyncResult): MessageNasGetOperatorNameOutput;
        /**
         * Asynchronously sends a Get PLMN Name request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_plmn_name_finish() to get the result of the operation.
         * @param input a #QmiMessageNasGetPlmnNameInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_plmn_name(
            input: MessageNasGetPlmnNameInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetPlmnNameOutput>;
        /**
         * Asynchronously sends a Get PLMN Name request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_plmn_name_finish() to get the result of the operation.
         * @param input a #QmiMessageNasGetPlmnNameInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_plmn_name(
            input: MessageNasGetPlmnNameInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get PLMN Name request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_plmn_name_finish() to get the result of the operation.
         * @param input a #QmiMessageNasGetPlmnNameInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_plmn_name(
            input: MessageNasGetPlmnNameInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetPlmnNameOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_plmn_name().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_plmn_name().
         * @returns a #QmiMessageNasGetPlmnNameOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_plmn_name_output_unref().
         */
        get_plmn_name_finish(res: Gio.AsyncResult): MessageNasGetPlmnNameOutput;
        /**
         * Asynchronously sends a Get Preferred Networks request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_preferred_networks_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_preferred_networks(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetPreferredNetworksOutput>;
        /**
         * Asynchronously sends a Get Preferred Networks request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_preferred_networks_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_preferred_networks(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Preferred Networks request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_preferred_networks_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_preferred_networks(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetPreferredNetworksOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_preferred_networks().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_preferred_networks().
         * @returns a #QmiMessageNasGetPreferredNetworksOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_preferred_networks_output_unref().
         */
        get_preferred_networks_finish(res: Gio.AsyncResult): MessageNasGetPreferredNetworksOutput;
        /**
         * Asynchronously sends a Get RF Band Information request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_rf_band_information_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_rf_band_information(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetRfBandInformationOutput>;
        /**
         * Asynchronously sends a Get RF Band Information request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_rf_band_information_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_rf_band_information(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get RF Band Information request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_rf_band_information_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_rf_band_information(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetRfBandInformationOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_rf_band_information().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_rf_band_information().
         * @returns a #QmiMessageNasGetRfBandInformationOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_rf_band_information_output_unref().
         */
        get_rf_band_information_finish(res: Gio.AsyncResult): MessageNasGetRfBandInformationOutput;
        /**
         * Asynchronously sends a Get Serving System request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_serving_system_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_serving_system(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetServingSystemOutput>;
        /**
         * Asynchronously sends a Get Serving System request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_serving_system_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_serving_system(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Serving System request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_serving_system_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_serving_system(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetServingSystemOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_serving_system().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_serving_system().
         * @returns a #QmiMessageNasGetServingSystemOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_serving_system_output_unref().
         */
        get_serving_system_finish(res: Gio.AsyncResult): MessageNasGetServingSystemOutput;
        /**
         * Asynchronously sends a Get Signal Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_signal_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_signal_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetSignalInfoOutput>;
        /**
         * Asynchronously sends a Get Signal Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_signal_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_signal_info(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Signal Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_signal_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_signal_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetSignalInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_signal_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_signal_info().
         * @returns a #QmiMessageNasGetSignalInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_signal_info_output_unref().
         */
        get_signal_info_finish(res: Gio.AsyncResult): MessageNasGetSignalInfoOutput;
        /**
         * Asynchronously sends a Get Signal Strength request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_signal_strength_finish() to get the result of the operation.
         * @param input a #QmiMessageNasGetSignalStrengthInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_signal_strength(
            input: MessageNasGetSignalStrengthInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetSignalStrengthOutput>;
        /**
         * Asynchronously sends a Get Signal Strength request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_signal_strength_finish() to get the result of the operation.
         * @param input a #QmiMessageNasGetSignalStrengthInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_signal_strength(
            input: MessageNasGetSignalStrengthInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Signal Strength request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_signal_strength_finish() to get the result of the operation.
         * @param input a #QmiMessageNasGetSignalStrengthInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_signal_strength(
            input: MessageNasGetSignalStrengthInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetSignalStrengthOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_signal_strength().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_signal_strength().
         * @returns a #QmiMessageNasGetSignalStrengthOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_signal_strength_output_unref().
         */
        get_signal_strength_finish(res: Gio.AsyncResult): MessageNasGetSignalStrengthOutput;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetSupportedMessagesOutput>;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetSupportedMessagesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_supported_messages().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_supported_messages().
         * @returns a #QmiMessageNasGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_supported_messages_output_unref().
         */
        get_supported_messages_finish(res: Gio.AsyncResult): MessageNasGetSupportedMessagesOutput;
        /**
         * Asynchronously sends a Get System Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_system_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_system_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetSystemInfoOutput>;
        /**
         * Asynchronously sends a Get System Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_system_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_system_info(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get System Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_system_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_system_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetSystemInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_system_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_system_info().
         * @returns a #QmiMessageNasGetSystemInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_system_info_output_unref().
         */
        get_system_info_finish(res: Gio.AsyncResult): MessageNasGetSystemInfoOutput;
        /**
         * Asynchronously sends a Get System Selection Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_system_selection_preference_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_system_selection_preference(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetSystemSelectionPreferenceOutput>;
        /**
         * Asynchronously sends a Get System Selection Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_system_selection_preference_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_system_selection_preference(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get System Selection Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_system_selection_preference_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_system_selection_preference(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetSystemSelectionPreferenceOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_system_selection_preference().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_system_selection_preference().
         * @returns a #QmiMessageNasGetSystemSelectionPreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_system_selection_preference_output_unref().
         */
        get_system_selection_preference_finish(res: Gio.AsyncResult): MessageNasGetSystemSelectionPreferenceOutput;
        /**
         * Asynchronously sends a Get Technology Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_technology_preference_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_technology_preference(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetTechnologyPreferenceOutput>;
        /**
         * Asynchronously sends a Get Technology Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_technology_preference_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_technology_preference(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Technology Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_technology_preference_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_technology_preference(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetTechnologyPreferenceOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_technology_preference().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_technology_preference().
         * @returns a #QmiMessageNasGetTechnologyPreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_technology_preference_output_unref().
         */
        get_technology_preference_finish(res: Gio.AsyncResult): MessageNasGetTechnologyPreferenceOutput;
        /**
         * Asynchronously sends a Get Tx Rx Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_tx_rx_info_finish() to get the result of the operation.
         * @param input a #QmiMessageNasGetTxRxInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_tx_rx_info(
            input: MessageNasGetTxRxInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasGetTxRxInfoOutput>;
        /**
         * Asynchronously sends a Get Tx Rx Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_tx_rx_info_finish() to get the result of the operation.
         * @param input a #QmiMessageNasGetTxRxInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_tx_rx_info(
            input: MessageNasGetTxRxInfoInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Tx Rx Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_get_tx_rx_info_finish() to get the result of the operation.
         * @param input a #QmiMessageNasGetTxRxInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_tx_rx_info(
            input: MessageNasGetTxRxInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasGetTxRxInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_get_tx_rx_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_tx_rx_info().
         * @returns a #QmiMessageNasGetTxRxInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_tx_rx_info_output_unref().
         */
        get_tx_rx_info_finish(res: Gio.AsyncResult): MessageNasGetTxRxInfoOutput;
        /**
         * Asynchronously sends a Initiate Network Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_initiate_network_register_finish() to get the result of the operation.
         * @param input a #QmiMessageNasInitiateNetworkRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        initiate_network_register(
            input: MessageNasInitiateNetworkRegisterInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasInitiateNetworkRegisterOutput>;
        /**
         * Asynchronously sends a Initiate Network Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_initiate_network_register_finish() to get the result of the operation.
         * @param input a #QmiMessageNasInitiateNetworkRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        initiate_network_register(
            input: MessageNasInitiateNetworkRegisterInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Initiate Network Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_initiate_network_register_finish() to get the result of the operation.
         * @param input a #QmiMessageNasInitiateNetworkRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        initiate_network_register(
            input: MessageNasInitiateNetworkRegisterInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasInitiateNetworkRegisterOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_initiate_network_register().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_initiate_network_register().
         * @returns a #QmiMessageNasInitiateNetworkRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_initiate_network_register_output_unref().
         */
        initiate_network_register_finish(res: Gio.AsyncResult): MessageNasInitiateNetworkRegisterOutput;
        /**
         * Asynchronously sends a Network Scan request to the device.
         *
         * This message is abortable. If `cancellable` is cancelled or if `timeout` expires,
         * an abort request will be sent to the device, and the asynchronous operation will
         * not return until the abort response is received. It is not an error if a successful
         * response is returned for the asynchronous operation even after the user has cancelled
         * the cancellable, because it may happen that the response is received before the
         * modem had a chance to run the abort.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_network_scan_finish() to get the result of the operation.
         * @param input a #QmiMessageNasNetworkScanInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        network_scan(
            input: MessageNasNetworkScanInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasNetworkScanOutput>;
        /**
         * Asynchronously sends a Network Scan request to the device.
         *
         * This message is abortable. If `cancellable` is cancelled or if `timeout` expires,
         * an abort request will be sent to the device, and the asynchronous operation will
         * not return until the abort response is received. It is not an error if a successful
         * response is returned for the asynchronous operation even after the user has cancelled
         * the cancellable, because it may happen that the response is received before the
         * modem had a chance to run the abort.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_network_scan_finish() to get the result of the operation.
         * @param input a #QmiMessageNasNetworkScanInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        network_scan(
            input: MessageNasNetworkScanInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Network Scan request to the device.
         *
         * This message is abortable. If `cancellable` is cancelled or if `timeout` expires,
         * an abort request will be sent to the device, and the asynchronous operation will
         * not return until the abort response is received. It is not an error if a successful
         * response is returned for the asynchronous operation even after the user has cancelled
         * the cancellable, because it may happen that the response is received before the
         * modem had a chance to run the abort.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_network_scan_finish() to get the result of the operation.
         * @param input a #QmiMessageNasNetworkScanInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        network_scan(
            input: MessageNasNetworkScanInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasNetworkScanOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_network_scan().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_network_scan().
         * @returns a #QmiMessageNasNetworkScanOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_network_scan_output_unref().
         */
        network_scan_finish(res: Gio.AsyncResult): MessageNasNetworkScanOutput;
        /**
         * Asynchronously sends a Register Indications request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_register_indications_finish() to get the result of the operation.
         * @param input a #QmiMessageNasRegisterIndicationsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        register_indications(
            input: MessageNasRegisterIndicationsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasRegisterIndicationsOutput>;
        /**
         * Asynchronously sends a Register Indications request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_register_indications_finish() to get the result of the operation.
         * @param input a #QmiMessageNasRegisterIndicationsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        register_indications(
            input: MessageNasRegisterIndicationsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Register Indications request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_register_indications_finish() to get the result of the operation.
         * @param input a #QmiMessageNasRegisterIndicationsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        register_indications(
            input: MessageNasRegisterIndicationsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasRegisterIndicationsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_register_indications().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_register_indications().
         * @returns a #QmiMessageNasRegisterIndicationsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_register_indications_output_unref().
         */
        register_indications_finish(res: Gio.AsyncResult): MessageNasRegisterIndicationsOutput;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasResetOutput>;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasResetOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_reset().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_reset().
         * @returns a #QmiMessageNasResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_reset_output_unref().
         */
        reset_finish(res: Gio.AsyncResult): MessageNasResetOutput;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageNasSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_event_report(
            input: MessageNasSetEventReportInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasSetEventReportOutput>;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageNasSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_event_report(
            input: MessageNasSetEventReportInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageNasSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_event_report(
            input: MessageNasSetEventReportInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasSetEventReportOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_set_event_report().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_set_event_report().
         * @returns a #QmiMessageNasSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_set_event_report_output_unref().
         */
        set_event_report_finish(res: Gio.AsyncResult): MessageNasSetEventReportOutput;
        /**
         * Asynchronously sends a Set Preferred Networks request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_set_preferred_networks_finish() to get the result of the operation.
         * @param input a #QmiMessageNasSetPreferredNetworksInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_preferred_networks(
            input: MessageNasSetPreferredNetworksInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasSetPreferredNetworksOutput>;
        /**
         * Asynchronously sends a Set Preferred Networks request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_set_preferred_networks_finish() to get the result of the operation.
         * @param input a #QmiMessageNasSetPreferredNetworksInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_preferred_networks(
            input: MessageNasSetPreferredNetworksInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Preferred Networks request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_set_preferred_networks_finish() to get the result of the operation.
         * @param input a #QmiMessageNasSetPreferredNetworksInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_preferred_networks(
            input: MessageNasSetPreferredNetworksInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasSetPreferredNetworksOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_set_preferred_networks().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_set_preferred_networks().
         * @returns a #QmiMessageNasSetPreferredNetworksOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_set_preferred_networks_output_unref().
         */
        set_preferred_networks_finish(res: Gio.AsyncResult): MessageNasSetPreferredNetworksOutput;
        /**
         * Asynchronously sends a Set System Selection Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_set_system_selection_preference_finish() to get the result of the operation.
         * @param input a #QmiMessageNasSetSystemSelectionPreferenceInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_system_selection_preference(
            input: MessageNasSetSystemSelectionPreferenceInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasSetSystemSelectionPreferenceOutput>;
        /**
         * Asynchronously sends a Set System Selection Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_set_system_selection_preference_finish() to get the result of the operation.
         * @param input a #QmiMessageNasSetSystemSelectionPreferenceInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_system_selection_preference(
            input: MessageNasSetSystemSelectionPreferenceInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set System Selection Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_set_system_selection_preference_finish() to get the result of the operation.
         * @param input a #QmiMessageNasSetSystemSelectionPreferenceInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_system_selection_preference(
            input: MessageNasSetSystemSelectionPreferenceInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasSetSystemSelectionPreferenceOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_set_system_selection_preference().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_set_system_selection_preference().
         * @returns a #QmiMessageNasSetSystemSelectionPreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_set_system_selection_preference_output_unref().
         */
        set_system_selection_preference_finish(res: Gio.AsyncResult): MessageNasSetSystemSelectionPreferenceOutput;
        /**
         * Asynchronously sends a Set Technology Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_set_technology_preference_finish() to get the result of the operation.
         * @param input a #QmiMessageNasSetTechnologyPreferenceInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_technology_preference(
            input: MessageNasSetTechnologyPreferenceInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasSetTechnologyPreferenceOutput>;
        /**
         * Asynchronously sends a Set Technology Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_set_technology_preference_finish() to get the result of the operation.
         * @param input a #QmiMessageNasSetTechnologyPreferenceInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_technology_preference(
            input: MessageNasSetTechnologyPreferenceInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Technology Preference request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_set_technology_preference_finish() to get the result of the operation.
         * @param input a #QmiMessageNasSetTechnologyPreferenceInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_technology_preference(
            input: MessageNasSetTechnologyPreferenceInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasSetTechnologyPreferenceOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_set_technology_preference().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_set_technology_preference().
         * @returns a #QmiMessageNasSetTechnologyPreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_set_technology_preference_output_unref().
         */
        set_technology_preference_finish(res: Gio.AsyncResult): MessageNasSetTechnologyPreferenceOutput;
        /**
         * Asynchronously sends a Swi Get Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_swi_get_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        swi_get_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageNasSwiGetStatusOutput>;
        /**
         * Asynchronously sends a Swi Get Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_swi_get_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        swi_get_status(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Swi Get Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_nas_swi_get_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        swi_get_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageNasSwiGetStatusOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_nas_swi_get_status().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_swi_get_status().
         * @returns a #QmiMessageNasSwiGetStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_swi_get_status_output_unref().
         */
        swi_get_status_finish(res: Gio.AsyncResult): MessageNasSwiGetStatusOutput;
    }

    module ClientOma {
        // Signal callback interfaces

        interface EventReport {
            (output: IndicationOmaEventReportOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientOma structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientOma extends Client {
        static $gtype: GObject.GType<ClientOma>;

        // Constructors

        constructor(properties?: Partial<ClientOma.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'event-report',
            callback: (_source: this, output: IndicationOmaEventReportOutput) => void,
        ): number;
        connect_after(
            signal: 'event-report',
            callback: (_source: this, output: IndicationOmaEventReportOutput) => void,
        ): number;
        emit(signal: 'event-report', output: IndicationOmaEventReportOutput): void;

        // Methods

        /**
         * Asynchronously sends a Cancel Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_cancel_session_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        cancel_session(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageOmaCancelSessionOutput>;
        /**
         * Asynchronously sends a Cancel Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_cancel_session_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        cancel_session(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Cancel Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_cancel_session_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        cancel_session(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageOmaCancelSessionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_oma_cancel_session().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_cancel_session().
         * @returns a #QmiMessageOmaCancelSessionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_cancel_session_output_unref().
         */
        cancel_session_finish(res: Gio.AsyncResult): MessageOmaCancelSessionOutput;
        /**
         * Asynchronously sends a Get Feature Setting request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_get_feature_setting_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_feature_setting(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageOmaGetFeatureSettingOutput>;
        /**
         * Asynchronously sends a Get Feature Setting request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_get_feature_setting_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_feature_setting(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Feature Setting request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_get_feature_setting_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_feature_setting(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageOmaGetFeatureSettingOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_oma_get_feature_setting().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_get_feature_setting().
         * @returns a #QmiMessageOmaGetFeatureSettingOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_get_feature_setting_output_unref().
         */
        get_feature_setting_finish(res: Gio.AsyncResult): MessageOmaGetFeatureSettingOutput;
        /**
         * Asynchronously sends a Get Session Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_get_session_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_session_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageOmaGetSessionInfoOutput>;
        /**
         * Asynchronously sends a Get Session Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_get_session_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_session_info(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Session Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_get_session_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_session_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageOmaGetSessionInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_oma_get_session_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_get_session_info().
         * @returns a #QmiMessageOmaGetSessionInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_get_session_info_output_unref().
         */
        get_session_info_finish(res: Gio.AsyncResult): MessageOmaGetSessionInfoOutput;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageOmaResetOutput>;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageOmaResetOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_oma_reset().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_reset().
         * @returns a #QmiMessageOmaResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_reset_output_unref().
         */
        reset_finish(res: Gio.AsyncResult): MessageOmaResetOutput;
        /**
         * Asynchronously sends a Send Selection request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_send_selection_finish() to get the result of the operation.
         * @param input a #QmiMessageOmaSendSelectionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        send_selection(
            input: MessageOmaSendSelectionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageOmaSendSelectionOutput>;
        /**
         * Asynchronously sends a Send Selection request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_send_selection_finish() to get the result of the operation.
         * @param input a #QmiMessageOmaSendSelectionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        send_selection(
            input: MessageOmaSendSelectionInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Send Selection request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_send_selection_finish() to get the result of the operation.
         * @param input a #QmiMessageOmaSendSelectionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        send_selection(
            input: MessageOmaSendSelectionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageOmaSendSelectionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_oma_send_selection().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_send_selection().
         * @returns a #QmiMessageOmaSendSelectionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_send_selection_output_unref().
         */
        send_selection_finish(res: Gio.AsyncResult): MessageOmaSendSelectionOutput;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageOmaSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_event_report(
            input: MessageOmaSetEventReportInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageOmaSetEventReportOutput>;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageOmaSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_event_report(
            input: MessageOmaSetEventReportInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageOmaSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_event_report(
            input: MessageOmaSetEventReportInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageOmaSetEventReportOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_oma_set_event_report().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_set_event_report().
         * @returns a #QmiMessageOmaSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_set_event_report_output_unref().
         */
        set_event_report_finish(res: Gio.AsyncResult): MessageOmaSetEventReportOutput;
        /**
         * Asynchronously sends a Set Feature Setting request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_set_feature_setting_finish() to get the result of the operation.
         * @param input a #QmiMessageOmaSetFeatureSettingInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_feature_setting(
            input: MessageOmaSetFeatureSettingInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageOmaSetFeatureSettingOutput>;
        /**
         * Asynchronously sends a Set Feature Setting request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_set_feature_setting_finish() to get the result of the operation.
         * @param input a #QmiMessageOmaSetFeatureSettingInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_feature_setting(
            input: MessageOmaSetFeatureSettingInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Feature Setting request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_set_feature_setting_finish() to get the result of the operation.
         * @param input a #QmiMessageOmaSetFeatureSettingInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_feature_setting(
            input: MessageOmaSetFeatureSettingInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageOmaSetFeatureSettingOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_oma_set_feature_setting().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_set_feature_setting().
         * @returns a #QmiMessageOmaSetFeatureSettingOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_set_feature_setting_output_unref().
         */
        set_feature_setting_finish(res: Gio.AsyncResult): MessageOmaSetFeatureSettingOutput;
        /**
         * Asynchronously sends a Start Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_start_session_finish() to get the result of the operation.
         * @param input a #QmiMessageOmaStartSessionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        start_session(
            input: MessageOmaStartSessionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageOmaStartSessionOutput>;
        /**
         * Asynchronously sends a Start Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_start_session_finish() to get the result of the operation.
         * @param input a #QmiMessageOmaStartSessionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        start_session(
            input: MessageOmaStartSessionInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Start Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_oma_start_session_finish() to get the result of the operation.
         * @param input a #QmiMessageOmaStartSessionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        start_session(
            input: MessageOmaStartSessionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageOmaStartSessionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_oma_start_session().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_oma_start_session().
         * @returns a #QmiMessageOmaStartSessionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_oma_start_session_output_unref().
         */
        start_session_finish(res: Gio.AsyncResult): MessageOmaStartSessionOutput;
    }

    module ClientPbm {
        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientPbm structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientPbm extends Client {
        static $gtype: GObject.GType<ClientPbm>;

        // Constructors

        constructor(properties?: Partial<ClientPbm.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Asynchronously sends a Get All Capabilities request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pbm_get_all_capabilities_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_all_capabilities(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePbmGetAllCapabilitiesOutput>;
        /**
         * Asynchronously sends a Get All Capabilities request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pbm_get_all_capabilities_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_all_capabilities(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get All Capabilities request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pbm_get_all_capabilities_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_all_capabilities(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePbmGetAllCapabilitiesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pbm_get_all_capabilities().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pbm_get_all_capabilities().
         * @returns a #QmiMessagePbmGetAllCapabilitiesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pbm_get_all_capabilities_output_unref().
         */
        get_all_capabilities_finish(res: Gio.AsyncResult): MessagePbmGetAllCapabilitiesOutput;
        /**
         * Asynchronously sends a Get Capabilities request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pbm_get_capabilities_finish() to get the result of the operation.
         * @param input a #QmiMessagePbmGetCapabilitiesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_capabilities(
            input: MessagePbmGetCapabilitiesInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePbmGetCapabilitiesOutput>;
        /**
         * Asynchronously sends a Get Capabilities request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pbm_get_capabilities_finish() to get the result of the operation.
         * @param input a #QmiMessagePbmGetCapabilitiesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_capabilities(
            input: MessagePbmGetCapabilitiesInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Capabilities request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pbm_get_capabilities_finish() to get the result of the operation.
         * @param input a #QmiMessagePbmGetCapabilitiesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_capabilities(
            input: MessagePbmGetCapabilitiesInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePbmGetCapabilitiesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pbm_get_capabilities().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pbm_get_capabilities().
         * @returns a #QmiMessagePbmGetCapabilitiesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pbm_get_capabilities_output_unref().
         */
        get_capabilities_finish(res: Gio.AsyncResult): MessagePbmGetCapabilitiesOutput;
        /**
         * Asynchronously sends a Indication Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pbm_indication_register_finish() to get the result of the operation.
         * @param input a #QmiMessagePbmIndicationRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        indication_register(
            input: MessagePbmIndicationRegisterInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePbmIndicationRegisterOutput>;
        /**
         * Asynchronously sends a Indication Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pbm_indication_register_finish() to get the result of the operation.
         * @param input a #QmiMessagePbmIndicationRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        indication_register(
            input: MessagePbmIndicationRegisterInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Indication Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pbm_indication_register_finish() to get the result of the operation.
         * @param input a #QmiMessagePbmIndicationRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        indication_register(
            input: MessagePbmIndicationRegisterInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePbmIndicationRegisterOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pbm_indication_register().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pbm_indication_register().
         * @returns a #QmiMessagePbmIndicationRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pbm_indication_register_output_unref().
         */
        indication_register_finish(res: Gio.AsyncResult): MessagePbmIndicationRegisterOutput;
    }

    module ClientPdc {
        // Signal callback interfaces

        interface ActivateConfig {
            (output: IndicationPdcActivateConfigOutput): void;
        }

        interface DeactivateConfig {
            (output: IndicationPdcDeactivateConfigOutput): void;
        }

        interface GetConfigInfo {
            (output: IndicationPdcGetConfigInfoOutput): void;
        }

        interface GetSelectedConfig {
            (output: IndicationPdcGetSelectedConfigOutput): void;
        }

        interface ListConfigs {
            (output: IndicationPdcListConfigsOutput): void;
        }

        interface LoadConfig {
            (output: IndicationPdcLoadConfigOutput): void;
        }

        interface Refresh {
            (output: IndicationPdcRefreshOutput): void;
        }

        interface SetSelectedConfig {
            (output: IndicationPdcSetSelectedConfigOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientPdc structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientPdc extends Client {
        static $gtype: GObject.GType<ClientPdc>;

        // Constructors

        constructor(properties?: Partial<ClientPdc.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'activate-config',
            callback: (_source: this, output: IndicationPdcActivateConfigOutput) => void,
        ): number;
        connect_after(
            signal: 'activate-config',
            callback: (_source: this, output: IndicationPdcActivateConfigOutput) => void,
        ): number;
        emit(signal: 'activate-config', output: IndicationPdcActivateConfigOutput): void;
        connect(
            signal: 'deactivate-config',
            callback: (_source: this, output: IndicationPdcDeactivateConfigOutput) => void,
        ): number;
        connect_after(
            signal: 'deactivate-config',
            callback: (_source: this, output: IndicationPdcDeactivateConfigOutput) => void,
        ): number;
        emit(signal: 'deactivate-config', output: IndicationPdcDeactivateConfigOutput): void;
        connect(
            signal: 'get-config-info',
            callback: (_source: this, output: IndicationPdcGetConfigInfoOutput) => void,
        ): number;
        connect_after(
            signal: 'get-config-info',
            callback: (_source: this, output: IndicationPdcGetConfigInfoOutput) => void,
        ): number;
        emit(signal: 'get-config-info', output: IndicationPdcGetConfigInfoOutput): void;
        connect(
            signal: 'get-selected-config',
            callback: (_source: this, output: IndicationPdcGetSelectedConfigOutput) => void,
        ): number;
        connect_after(
            signal: 'get-selected-config',
            callback: (_source: this, output: IndicationPdcGetSelectedConfigOutput) => void,
        ): number;
        emit(signal: 'get-selected-config', output: IndicationPdcGetSelectedConfigOutput): void;
        connect(
            signal: 'list-configs',
            callback: (_source: this, output: IndicationPdcListConfigsOutput) => void,
        ): number;
        connect_after(
            signal: 'list-configs',
            callback: (_source: this, output: IndicationPdcListConfigsOutput) => void,
        ): number;
        emit(signal: 'list-configs', output: IndicationPdcListConfigsOutput): void;
        connect(
            signal: 'load-config',
            callback: (_source: this, output: IndicationPdcLoadConfigOutput) => void,
        ): number;
        connect_after(
            signal: 'load-config',
            callback: (_source: this, output: IndicationPdcLoadConfigOutput) => void,
        ): number;
        emit(signal: 'load-config', output: IndicationPdcLoadConfigOutput): void;
        connect(signal: 'refresh', callback: (_source: this, output: IndicationPdcRefreshOutput) => void): number;
        connect_after(signal: 'refresh', callback: (_source: this, output: IndicationPdcRefreshOutput) => void): number;
        emit(signal: 'refresh', output: IndicationPdcRefreshOutput): void;
        connect(
            signal: 'set-selected-config',
            callback: (_source: this, output: IndicationPdcSetSelectedConfigOutput) => void,
        ): number;
        connect_after(
            signal: 'set-selected-config',
            callback: (_source: this, output: IndicationPdcSetSelectedConfigOutput) => void,
        ): number;
        emit(signal: 'set-selected-config', output: IndicationPdcSetSelectedConfigOutput): void;

        // Methods

        /**
         * Asynchronously sends a Activate Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_activate_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcActivateConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        activate_config(
            input: MessagePdcActivateConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcActivateConfigOutput>;
        /**
         * Asynchronously sends a Activate Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_activate_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcActivateConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        activate_config(
            input: MessagePdcActivateConfigInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Activate Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_activate_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcActivateConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        activate_config(
            input: MessagePdcActivateConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcActivateConfigOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_activate_config().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_activate_config().
         * @returns a #QmiMessagePdcActivateConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_activate_config_output_unref().
         */
        activate_config_finish(res: Gio.AsyncResult): MessagePdcActivateConfigOutput;
        /**
         * Asynchronously sends a Config Change request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_config_change_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcConfigChangeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        config_change(
            input: MessagePdcConfigChangeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcConfigChangeOutput>;
        /**
         * Asynchronously sends a Config Change request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_config_change_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcConfigChangeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        config_change(
            input: MessagePdcConfigChangeInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Config Change request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_config_change_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcConfigChangeInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        config_change(
            input: MessagePdcConfigChangeInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcConfigChangeOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_config_change().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_config_change().
         * @returns a #QmiMessagePdcConfigChangeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_config_change_output_unref().
         */
        config_change_finish(res: Gio.AsyncResult): MessagePdcConfigChangeOutput;
        /**
         * Asynchronously sends a Deactivate Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_deactivate_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcDeactivateConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        deactivate_config(
            input: MessagePdcDeactivateConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcDeactivateConfigOutput>;
        /**
         * Asynchronously sends a Deactivate Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_deactivate_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcDeactivateConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        deactivate_config(
            input: MessagePdcDeactivateConfigInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Deactivate Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_deactivate_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcDeactivateConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        deactivate_config(
            input: MessagePdcDeactivateConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcDeactivateConfigOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_deactivate_config().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_deactivate_config().
         * @returns a #QmiMessagePdcDeactivateConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_deactivate_config_output_unref().
         */
        deactivate_config_finish(res: Gio.AsyncResult): MessagePdcDeactivateConfigOutput;
        /**
         * Asynchronously sends a Delete Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_delete_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcDeleteConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        delete_config(
            input: MessagePdcDeleteConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcDeleteConfigOutput>;
        /**
         * Asynchronously sends a Delete Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_delete_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcDeleteConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        delete_config(
            input: MessagePdcDeleteConfigInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Delete Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_delete_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcDeleteConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        delete_config(
            input: MessagePdcDeleteConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcDeleteConfigOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_delete_config().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_delete_config().
         * @returns a #QmiMessagePdcDeleteConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_delete_config_output_unref().
         */
        delete_config_finish(res: Gio.AsyncResult): MessagePdcDeleteConfigOutput;
        /**
         * Asynchronously sends a Get Config Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_get_config_info_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcGetConfigInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_config_info(
            input: MessagePdcGetConfigInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcGetConfigInfoOutput>;
        /**
         * Asynchronously sends a Get Config Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_get_config_info_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcGetConfigInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_config_info(
            input: MessagePdcGetConfigInfoInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Config Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_get_config_info_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcGetConfigInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_config_info(
            input: MessagePdcGetConfigInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcGetConfigInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_get_config_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_get_config_info().
         * @returns a #QmiMessagePdcGetConfigInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_get_config_info_output_unref().
         */
        get_config_info_finish(res: Gio.AsyncResult): MessagePdcGetConfigInfoOutput;
        /**
         * Asynchronously sends a Get Config Limits request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_get_config_limits_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcGetConfigLimitsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_config_limits(
            input: MessagePdcGetConfigLimitsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcGetConfigLimitsOutput>;
        /**
         * Asynchronously sends a Get Config Limits request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_get_config_limits_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcGetConfigLimitsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_config_limits(
            input: MessagePdcGetConfigLimitsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Config Limits request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_get_config_limits_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcGetConfigLimitsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_config_limits(
            input: MessagePdcGetConfigLimitsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcGetConfigLimitsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_get_config_limits().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_get_config_limits().
         * @returns a #QmiMessagePdcGetConfigLimitsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_get_config_limits_output_unref().
         */
        get_config_limits_finish(res: Gio.AsyncResult): MessagePdcGetConfigLimitsOutput;
        /**
         * Asynchronously sends a Get Default Config Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_get_default_config_info_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcGetDefaultConfigInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_default_config_info(
            input: MessagePdcGetDefaultConfigInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcGetDefaultConfigInfoOutput>;
        /**
         * Asynchronously sends a Get Default Config Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_get_default_config_info_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcGetDefaultConfigInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_default_config_info(
            input: MessagePdcGetDefaultConfigInfoInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Default Config Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_get_default_config_info_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcGetDefaultConfigInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_default_config_info(
            input: MessagePdcGetDefaultConfigInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcGetDefaultConfigInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_get_default_config_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_get_default_config_info().
         * @returns a #QmiMessagePdcGetDefaultConfigInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_get_default_config_info_output_unref().
         */
        get_default_config_info_finish(res: Gio.AsyncResult): MessagePdcGetDefaultConfigInfoOutput;
        /**
         * Asynchronously sends a Get Selected Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_get_selected_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcGetSelectedConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_selected_config(
            input: MessagePdcGetSelectedConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcGetSelectedConfigOutput>;
        /**
         * Asynchronously sends a Get Selected Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_get_selected_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcGetSelectedConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_selected_config(
            input: MessagePdcGetSelectedConfigInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Selected Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_get_selected_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcGetSelectedConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_selected_config(
            input: MessagePdcGetSelectedConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcGetSelectedConfigOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_get_selected_config().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_get_selected_config().
         * @returns a #QmiMessagePdcGetSelectedConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_get_selected_config_output_unref().
         */
        get_selected_config_finish(res: Gio.AsyncResult): MessagePdcGetSelectedConfigOutput;
        /**
         * Asynchronously sends a List Configs request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_list_configs_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcListConfigsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        list_configs(
            input: MessagePdcListConfigsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcListConfigsOutput>;
        /**
         * Asynchronously sends a List Configs request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_list_configs_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcListConfigsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        list_configs(
            input: MessagePdcListConfigsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a List Configs request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_list_configs_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcListConfigsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        list_configs(
            input: MessagePdcListConfigsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcListConfigsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_list_configs().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_list_configs().
         * @returns a #QmiMessagePdcListConfigsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_list_configs_output_unref().
         */
        list_configs_finish(res: Gio.AsyncResult): MessagePdcListConfigsOutput;
        /**
         * Asynchronously sends a Load Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_load_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcLoadConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        load_config(
            input: MessagePdcLoadConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcLoadConfigOutput>;
        /**
         * Asynchronously sends a Load Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_load_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcLoadConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        load_config(
            input: MessagePdcLoadConfigInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Load Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_load_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcLoadConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        load_config(
            input: MessagePdcLoadConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcLoadConfigOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_load_config().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_load_config().
         * @returns a #QmiMessagePdcLoadConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_load_config_output_unref().
         */
        load_config_finish(res: Gio.AsyncResult): MessagePdcLoadConfigOutput;
        /**
         * Asynchronously sends a Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_register_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        register(
            input: MessagePdcRegisterInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcRegisterOutput>;
        /**
         * Asynchronously sends a Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_register_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        register(
            input: MessagePdcRegisterInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_register_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        register(
            input: MessagePdcRegisterInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcRegisterOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_register().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_register().
         * @returns a #QmiMessagePdcRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_register_output_unref().
         */
        register_finish(res: Gio.AsyncResult): MessagePdcRegisterOutput;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcResetOutput>;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcResetOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_reset().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_reset().
         * @returns a #QmiMessagePdcResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_reset_output_unref().
         */
        reset_finish(res: Gio.AsyncResult): MessagePdcResetOutput;
        /**
         * Asynchronously sends a Set Selected Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_set_selected_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcSetSelectedConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_selected_config(
            input: MessagePdcSetSelectedConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdcSetSelectedConfigOutput>;
        /**
         * Asynchronously sends a Set Selected Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_set_selected_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcSetSelectedConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_selected_config(
            input: MessagePdcSetSelectedConfigInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Selected Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pdc_set_selected_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdcSetSelectedConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_selected_config(
            input: MessagePdcSetSelectedConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdcSetSelectedConfigOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pdc_set_selected_config().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pdc_set_selected_config().
         * @returns a #QmiMessagePdcSetSelectedConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pdc_set_selected_config_output_unref().
         */
        set_selected_config_finish(res: Gio.AsyncResult): MessagePdcSetSelectedConfigOutput;
    }

    module ClientPds {
        // Signal callback interfaces

        interface EventReport {
            (output: IndicationPdsEventReportOutput): void;
        }

        interface GpsReady {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientPds structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientPds extends Client {
        static $gtype: GObject.GType<ClientPds>;

        // Constructors

        constructor(properties?: Partial<ClientPds.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'event-report',
            callback: (_source: this, output: IndicationPdsEventReportOutput) => void,
        ): number;
        connect_after(
            signal: 'event-report',
            callback: (_source: this, output: IndicationPdsEventReportOutput) => void,
        ): number;
        emit(signal: 'event-report', output: IndicationPdsEventReportOutput): void;
        connect(signal: 'gps-ready', callback: (_source: this) => void): number;
        connect_after(signal: 'gps-ready', callback: (_source: this) => void): number;
        emit(signal: 'gps-ready'): void;

        // Methods

        /**
         * Asynchronously sends a Get AGPS Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_get_agps_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsGetAgpsConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_agps_config(
            input: MessagePdsGetAgpsConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdsGetAgpsConfigOutput>;
        /**
         * Asynchronously sends a Get AGPS Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_get_agps_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsGetAgpsConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_agps_config(
            input: MessagePdsGetAgpsConfigInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get AGPS Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_get_agps_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsGetAgpsConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_agps_config(
            input: MessagePdsGetAgpsConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdsGetAgpsConfigOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pds_get_agps_config().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_get_agps_config().
         * @returns a #QmiMessagePdsGetAgpsConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_get_agps_config_output_unref().
         */
        get_agps_config_finish(res: Gio.AsyncResult): MessagePdsGetAgpsConfigOutput;
        /**
         * Asynchronously sends a Get Auto Tracking State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_get_auto_tracking_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_auto_tracking_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdsGetAutoTrackingStateOutput>;
        /**
         * Asynchronously sends a Get Auto Tracking State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_get_auto_tracking_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_auto_tracking_state(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Auto Tracking State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_get_auto_tracking_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_auto_tracking_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdsGetAutoTrackingStateOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pds_get_auto_tracking_state().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_get_auto_tracking_state().
         * @returns a #QmiMessagePdsGetAutoTrackingStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_get_auto_tracking_state_output_unref().
         */
        get_auto_tracking_state_finish(res: Gio.AsyncResult): MessagePdsGetAutoTrackingStateOutput;
        /**
         * Asynchronously sends a Get Default Tracking Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_get_default_tracking_session_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_default_tracking_session(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdsGetDefaultTrackingSessionOutput>;
        /**
         * Asynchronously sends a Get Default Tracking Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_get_default_tracking_session_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_default_tracking_session(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Default Tracking Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_get_default_tracking_session_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_default_tracking_session(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdsGetDefaultTrackingSessionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pds_get_default_tracking_session().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_get_default_tracking_session().
         * @returns a #QmiMessagePdsGetDefaultTrackingSessionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_get_default_tracking_session_output_unref().
         */
        get_default_tracking_session_finish(res: Gio.AsyncResult): MessagePdsGetDefaultTrackingSessionOutput;
        /**
         * Asynchronously sends a Get GPS Service State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_get_gps_service_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_gps_service_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdsGetGpsServiceStateOutput>;
        /**
         * Asynchronously sends a Get GPS Service State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_get_gps_service_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_gps_service_state(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get GPS Service State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_get_gps_service_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_gps_service_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdsGetGpsServiceStateOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pds_get_gps_service_state().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_get_gps_service_state().
         * @returns a #QmiMessagePdsGetGpsServiceStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_get_gps_service_state_output_unref().
         */
        get_gps_service_state_finish(res: Gio.AsyncResult): MessagePdsGetGpsServiceStateOutput;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdsResetOutput>;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdsResetOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pds_reset().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_reset().
         * @returns a #QmiMessagePdsResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_reset_output_unref().
         */
        reset_finish(res: Gio.AsyncResult): MessagePdsResetOutput;
        /**
         * Asynchronously sends a Set AGPS Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_agps_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetAgpsConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_agps_config(
            input: MessagePdsSetAgpsConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdsSetAgpsConfigOutput>;
        /**
         * Asynchronously sends a Set AGPS Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_agps_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetAgpsConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_agps_config(
            input: MessagePdsSetAgpsConfigInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set AGPS Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_agps_config_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetAgpsConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_agps_config(
            input: MessagePdsSetAgpsConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdsSetAgpsConfigOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pds_set_agps_config().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_set_agps_config().
         * @returns a #QmiMessagePdsSetAgpsConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_set_agps_config_output_unref().
         */
        set_agps_config_finish(res: Gio.AsyncResult): MessagePdsSetAgpsConfigOutput;
        /**
         * Asynchronously sends a Set Auto Tracking State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_auto_tracking_state_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetAutoTrackingStateInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_auto_tracking_state(
            input: MessagePdsSetAutoTrackingStateInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdsSetAutoTrackingStateOutput>;
        /**
         * Asynchronously sends a Set Auto Tracking State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_auto_tracking_state_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetAutoTrackingStateInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_auto_tracking_state(
            input: MessagePdsSetAutoTrackingStateInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Auto Tracking State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_auto_tracking_state_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetAutoTrackingStateInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_auto_tracking_state(
            input: MessagePdsSetAutoTrackingStateInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdsSetAutoTrackingStateOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pds_set_auto_tracking_state().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_set_auto_tracking_state().
         * @returns a #QmiMessagePdsSetAutoTrackingStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_set_auto_tracking_state_output_unref().
         */
        set_auto_tracking_state_finish(res: Gio.AsyncResult): MessagePdsSetAutoTrackingStateOutput;
        /**
         * Asynchronously sends a Set Default Tracking Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_default_tracking_session_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetDefaultTrackingSessionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_default_tracking_session(
            input: MessagePdsSetDefaultTrackingSessionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdsSetDefaultTrackingSessionOutput>;
        /**
         * Asynchronously sends a Set Default Tracking Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_default_tracking_session_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetDefaultTrackingSessionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_default_tracking_session(
            input: MessagePdsSetDefaultTrackingSessionInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Default Tracking Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_default_tracking_session_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetDefaultTrackingSessionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_default_tracking_session(
            input: MessagePdsSetDefaultTrackingSessionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdsSetDefaultTrackingSessionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pds_set_default_tracking_session().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_set_default_tracking_session().
         * @returns a #QmiMessagePdsSetDefaultTrackingSessionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_set_default_tracking_session_output_unref().
         */
        set_default_tracking_session_finish(res: Gio.AsyncResult): MessagePdsSetDefaultTrackingSessionOutput;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_event_report(
            input: MessagePdsSetEventReportInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdsSetEventReportOutput>;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_event_report(
            input: MessagePdsSetEventReportInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_event_report(
            input: MessagePdsSetEventReportInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdsSetEventReportOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pds_set_event_report().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_set_event_report().
         * @returns a #QmiMessagePdsSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_set_event_report_output_unref().
         */
        set_event_report_finish(res: Gio.AsyncResult): MessagePdsSetEventReportOutput;
        /**
         * Asynchronously sends a Set GPS Service State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_gps_service_state_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetGpsServiceStateInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_gps_service_state(
            input: MessagePdsSetGpsServiceStateInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessagePdsSetGpsServiceStateOutput>;
        /**
         * Asynchronously sends a Set GPS Service State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_gps_service_state_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetGpsServiceStateInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_gps_service_state(
            input: MessagePdsSetGpsServiceStateInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set GPS Service State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_pds_set_gps_service_state_finish() to get the result of the operation.
         * @param input a #QmiMessagePdsSetGpsServiceStateInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_gps_service_state(
            input: MessagePdsSetGpsServiceStateInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessagePdsSetGpsServiceStateOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_pds_set_gps_service_state().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_pds_set_gps_service_state().
         * @returns a #QmiMessagePdsSetGpsServiceStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_pds_set_gps_service_state_output_unref().
         */
        set_gps_service_state_finish(res: Gio.AsyncResult): MessagePdsSetGpsServiceStateOutput;
    }

    module ClientQos {
        // Signal callback interfaces

        interface FlowStatus {
            (output: IndicationQosFlowStatusOutput): void;
        }

        interface NetworkStatus {
            (output: IndicationQosNetworkStatusOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientQos structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientQos extends Client {
        static $gtype: GObject.GType<ClientQos>;

        // Constructors

        constructor(properties?: Partial<ClientQos.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'flow-status',
            callback: (_source: this, output: IndicationQosFlowStatusOutput) => void,
        ): number;
        connect_after(
            signal: 'flow-status',
            callback: (_source: this, output: IndicationQosFlowStatusOutput) => void,
        ): number;
        emit(signal: 'flow-status', output: IndicationQosFlowStatusOutput): void;
        connect(
            signal: 'network-status',
            callback: (_source: this, output: IndicationQosNetworkStatusOutput) => void,
        ): number;
        connect_after(
            signal: 'network-status',
            callback: (_source: this, output: IndicationQosNetworkStatusOutput) => void,
        ): number;
        emit(signal: 'network-status', output: IndicationQosNetworkStatusOutput): void;

        // Methods

        /**
         * Asynchronously sends a Get Flow Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_qos_get_flow_status_finish() to get the result of the operation.
         * @param input a #QmiMessageQosGetFlowStatusInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_flow_status(
            input: MessageQosGetFlowStatusInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageQosGetFlowStatusOutput>;
        /**
         * Asynchronously sends a Get Flow Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_qos_get_flow_status_finish() to get the result of the operation.
         * @param input a #QmiMessageQosGetFlowStatusInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_flow_status(
            input: MessageQosGetFlowStatusInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Flow Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_qos_get_flow_status_finish() to get the result of the operation.
         * @param input a #QmiMessageQosGetFlowStatusInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_flow_status(
            input: MessageQosGetFlowStatusInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageQosGetFlowStatusOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_qos_get_flow_status().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_qos_get_flow_status().
         * @returns a #QmiMessageQosGetFlowStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_qos_get_flow_status_output_unref().
         */
        get_flow_status_finish(res: Gio.AsyncResult): MessageQosGetFlowStatusOutput;
        /**
         * Asynchronously sends a Get Network Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_qos_get_network_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_network_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageQosGetNetworkStatusOutput>;
        /**
         * Asynchronously sends a Get Network Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_qos_get_network_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_network_status(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Network Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_qos_get_network_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_network_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageQosGetNetworkStatusOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_qos_get_network_status().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_qos_get_network_status().
         * @returns a #QmiMessageQosGetNetworkStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_qos_get_network_status_output_unref().
         */
        get_network_status_finish(res: Gio.AsyncResult): MessageQosGetNetworkStatusOutput;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_qos_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageQosResetOutput>;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_qos_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_qos_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageQosResetOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_qos_reset().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_qos_reset().
         * @returns a #QmiMessageQosResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_qos_reset_output_unref().
         */
        reset_finish(res: Gio.AsyncResult): MessageQosResetOutput;
        /**
         * Asynchronously sends a Swi Read Data Stats request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_qos_swi_read_data_stats_finish() to get the result of the operation.
         * @param input a #QmiMessageQosSwiReadDataStatsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        swi_read_data_stats(
            input: MessageQosSwiReadDataStatsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageQosSwiReadDataStatsOutput>;
        /**
         * Asynchronously sends a Swi Read Data Stats request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_qos_swi_read_data_stats_finish() to get the result of the operation.
         * @param input a #QmiMessageQosSwiReadDataStatsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        swi_read_data_stats(
            input: MessageQosSwiReadDataStatsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Swi Read Data Stats request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_qos_swi_read_data_stats_finish() to get the result of the operation.
         * @param input a #QmiMessageQosSwiReadDataStatsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        swi_read_data_stats(
            input: MessageQosSwiReadDataStatsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageQosSwiReadDataStatsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_qos_swi_read_data_stats().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_qos_swi_read_data_stats().
         * @returns a #QmiMessageQosSwiReadDataStatsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_qos_swi_read_data_stats_output_unref().
         */
        swi_read_data_stats_finish(res: Gio.AsyncResult): MessageQosSwiReadDataStatsOutput;
    }

    module ClientSar {
        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientSar structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientSar extends Client {
        static $gtype: GObject.GType<ClientSar>;

        // Constructors

        constructor(properties?: Partial<ClientSar.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Asynchronously sends a RF Get State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_sar_rf_get_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        rf_get_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageSarRfGetStateOutput>;
        /**
         * Asynchronously sends a RF Get State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_sar_rf_get_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        rf_get_state(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a RF Get State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_sar_rf_get_state_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        rf_get_state(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageSarRfGetStateOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_sar_rf_get_state().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_sar_rf_get_state().
         * @returns a #QmiMessageSarRfGetStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_sar_rf_get_state_output_unref().
         */
        rf_get_state_finish(res: Gio.AsyncResult): MessageSarRfGetStateOutput;
        /**
         * Asynchronously sends a RF Set State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_sar_rf_set_state_finish() to get the result of the operation.
         * @param input a #QmiMessageSarRfSetStateInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        rf_set_state(
            input: MessageSarRfSetStateInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageSarRfSetStateOutput>;
        /**
         * Asynchronously sends a RF Set State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_sar_rf_set_state_finish() to get the result of the operation.
         * @param input a #QmiMessageSarRfSetStateInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        rf_set_state(
            input: MessageSarRfSetStateInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a RF Set State request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_sar_rf_set_state_finish() to get the result of the operation.
         * @param input a #QmiMessageSarRfSetStateInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        rf_set_state(
            input: MessageSarRfSetStateInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageSarRfSetStateOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_sar_rf_set_state().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_sar_rf_set_state().
         * @returns a #QmiMessageSarRfSetStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_sar_rf_set_state_output_unref().
         */
        rf_set_state_finish(res: Gio.AsyncResult): MessageSarRfSetStateOutput;
    }

    module ClientSsc {
        // Signal callback interfaces

        interface ReportLarge {
            (output: IndicationSscReportLargeOutput): void;
        }

        interface ReportSmall {
            (output: IndicationSscReportSmallOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientSsc structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientSsc extends Client {
        static $gtype: GObject.GType<ClientSsc>;

        // Constructors

        constructor(properties?: Partial<ClientSsc.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'report-large',
            callback: (_source: this, output: IndicationSscReportLargeOutput) => void,
        ): number;
        connect_after(
            signal: 'report-large',
            callback: (_source: this, output: IndicationSscReportLargeOutput) => void,
        ): number;
        emit(signal: 'report-large', output: IndicationSscReportLargeOutput): void;
        connect(
            signal: 'report-small',
            callback: (_source: this, output: IndicationSscReportSmallOutput) => void,
        ): number;
        connect_after(
            signal: 'report-small',
            callback: (_source: this, output: IndicationSscReportSmallOutput) => void,
        ): number;
        emit(signal: 'report-small', output: IndicationSscReportSmallOutput): void;

        // Methods

        /**
         * Asynchronously sends a Control request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_ssc_control_finish() to get the result of the operation.
         * @param input a #QmiMessageSscControlInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        control(
            input: MessageSscControlInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageSscControlOutput>;
        /**
         * Asynchronously sends a Control request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_ssc_control_finish() to get the result of the operation.
         * @param input a #QmiMessageSscControlInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        control(
            input: MessageSscControlInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Control request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_ssc_control_finish() to get the result of the operation.
         * @param input a #QmiMessageSscControlInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        control(
            input: MessageSscControlInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageSscControlOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_ssc_control().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_ssc_control().
         * @returns a #QmiMessageSscControlOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_ssc_control_output_unref().
         */
        control_finish(res: Gio.AsyncResult): MessageSscControlOutput;
    }

    module ClientUim {
        // Signal callback interfaces

        interface CardStatus {
            (output: IndicationUimCardStatusOutput): void;
        }

        interface Refresh {
            (output: IndicationUimRefreshOutput): void;
        }

        interface SlotStatus {
            (output: IndicationUimSlotStatusOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientUim structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientUim extends Client {
        static $gtype: GObject.GType<ClientUim>;

        // Constructors

        constructor(properties?: Partial<ClientUim.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'card-status',
            callback: (_source: this, output: IndicationUimCardStatusOutput) => void,
        ): number;
        connect_after(
            signal: 'card-status',
            callback: (_source: this, output: IndicationUimCardStatusOutput) => void,
        ): number;
        emit(signal: 'card-status', output: IndicationUimCardStatusOutput): void;
        connect(signal: 'refresh', callback: (_source: this, output: IndicationUimRefreshOutput) => void): number;
        connect_after(signal: 'refresh', callback: (_source: this, output: IndicationUimRefreshOutput) => void): number;
        emit(signal: 'refresh', output: IndicationUimRefreshOutput): void;
        connect(
            signal: 'slot-status',
            callback: (_source: this, output: IndicationUimSlotStatusOutput) => void,
        ): number;
        connect_after(
            signal: 'slot-status',
            callback: (_source: this, output: IndicationUimSlotStatusOutput) => void,
        ): number;
        emit(signal: 'slot-status', output: IndicationUimSlotStatusOutput): void;

        // Methods

        /**
         * Asynchronously sends a Change PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_change_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageUimChangePinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        change_pin(
            input: MessageUimChangePinInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimChangePinOutput>;
        /**
         * Asynchronously sends a Change PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_change_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageUimChangePinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        change_pin(
            input: MessageUimChangePinInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Change PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_change_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageUimChangePinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        change_pin(
            input: MessageUimChangePinInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimChangePinOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_change_pin().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_change_pin().
         * @returns a #QmiMessageUimChangePinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_change_pin_output_unref().
         */
        change_pin_finish(res: Gio.AsyncResult): MessageUimChangePinOutput;
        /**
         * Asynchronously sends a Change Provisioning Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_change_provisioning_session_finish() to get the result of the operation.
         * @param input a #QmiMessageUimChangeProvisioningSessionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        change_provisioning_session(
            input: MessageUimChangeProvisioningSessionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimChangeProvisioningSessionOutput>;
        /**
         * Asynchronously sends a Change Provisioning Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_change_provisioning_session_finish() to get the result of the operation.
         * @param input a #QmiMessageUimChangeProvisioningSessionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        change_provisioning_session(
            input: MessageUimChangeProvisioningSessionInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Change Provisioning Session request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_change_provisioning_session_finish() to get the result of the operation.
         * @param input a #QmiMessageUimChangeProvisioningSessionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        change_provisioning_session(
            input: MessageUimChangeProvisioningSessionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimChangeProvisioningSessionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_change_provisioning_session().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_change_provisioning_session().
         * @returns a #QmiMessageUimChangeProvisioningSessionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_change_provisioning_session_output_unref().
         */
        change_provisioning_session_finish(res: Gio.AsyncResult): MessageUimChangeProvisioningSessionOutput;
        /**
         * Asynchronously sends a Depersonalization request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_depersonalization_finish() to get the result of the operation.
         * @param input a #QmiMessageUimDepersonalizationInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        depersonalization(
            input: MessageUimDepersonalizationInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimDepersonalizationOutput>;
        /**
         * Asynchronously sends a Depersonalization request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_depersonalization_finish() to get the result of the operation.
         * @param input a #QmiMessageUimDepersonalizationInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        depersonalization(
            input: MessageUimDepersonalizationInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Depersonalization request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_depersonalization_finish() to get the result of the operation.
         * @param input a #QmiMessageUimDepersonalizationInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        depersonalization(
            input: MessageUimDepersonalizationInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimDepersonalizationOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_depersonalization().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_depersonalization().
         * @returns a #QmiMessageUimDepersonalizationOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_depersonalization_output_unref().
         */
        depersonalization_finish(res: Gio.AsyncResult): MessageUimDepersonalizationOutput;
        /**
         * Asynchronously sends a Get Card Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_card_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_card_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimGetCardStatusOutput>;
        /**
         * Asynchronously sends a Get Card Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_card_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_card_status(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Card Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_card_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_card_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimGetCardStatusOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_get_card_status().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_get_card_status().
         * @returns a #QmiMessageUimGetCardStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_get_card_status_output_unref().
         */
        get_card_status_finish(res: Gio.AsyncResult): MessageUimGetCardStatusOutput;
        /**
         * Asynchronously sends a Get Configuration request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_configuration_finish() to get the result of the operation.
         * @param input a #QmiMessageUimGetConfigurationInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_configuration(
            input: MessageUimGetConfigurationInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimGetConfigurationOutput>;
        /**
         * Asynchronously sends a Get Configuration request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_configuration_finish() to get the result of the operation.
         * @param input a #QmiMessageUimGetConfigurationInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_configuration(
            input: MessageUimGetConfigurationInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Configuration request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_configuration_finish() to get the result of the operation.
         * @param input a #QmiMessageUimGetConfigurationInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_configuration(
            input: MessageUimGetConfigurationInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimGetConfigurationOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_get_configuration().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_get_configuration().
         * @returns a #QmiMessageUimGetConfigurationOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_get_configuration_output_unref().
         */
        get_configuration_finish(res: Gio.AsyncResult): MessageUimGetConfigurationOutput;
        /**
         * Asynchronously sends a Get File Attributes request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_file_attributes_finish() to get the result of the operation.
         * @param input a #QmiMessageUimGetFileAttributesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_file_attributes(
            input: MessageUimGetFileAttributesInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimGetFileAttributesOutput>;
        /**
         * Asynchronously sends a Get File Attributes request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_file_attributes_finish() to get the result of the operation.
         * @param input a #QmiMessageUimGetFileAttributesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_file_attributes(
            input: MessageUimGetFileAttributesInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get File Attributes request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_file_attributes_finish() to get the result of the operation.
         * @param input a #QmiMessageUimGetFileAttributesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_file_attributes(
            input: MessageUimGetFileAttributesInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimGetFileAttributesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_get_file_attributes().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_get_file_attributes().
         * @returns a #QmiMessageUimGetFileAttributesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_get_file_attributes_output_unref().
         */
        get_file_attributes_finish(res: Gio.AsyncResult): MessageUimGetFileAttributesOutput;
        /**
         * Asynchronously sends a Get Slot Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_slot_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_slot_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimGetSlotStatusOutput>;
        /**
         * Asynchronously sends a Get Slot Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_slot_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_slot_status(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Slot Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_slot_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_slot_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimGetSlotStatusOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_get_slot_status().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_get_slot_status().
         * @returns a #QmiMessageUimGetSlotStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_get_slot_status_output_unref().
         */
        get_slot_status_finish(res: Gio.AsyncResult): MessageUimGetSlotStatusOutput;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimGetSupportedMessagesOutput>;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimGetSupportedMessagesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_get_supported_messages().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_get_supported_messages().
         * @returns a #QmiMessageUimGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_get_supported_messages_output_unref().
         */
        get_supported_messages_finish(res: Gio.AsyncResult): MessageUimGetSupportedMessagesOutput;
        /**
         * Asynchronously sends a Power Off SIM request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_power_off_sim_finish() to get the result of the operation.
         * @param input a #QmiMessageUimPowerOffSimInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        power_off_sim(
            input: MessageUimPowerOffSimInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimPowerOffSimOutput>;
        /**
         * Asynchronously sends a Power Off SIM request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_power_off_sim_finish() to get the result of the operation.
         * @param input a #QmiMessageUimPowerOffSimInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        power_off_sim(
            input: MessageUimPowerOffSimInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Power Off SIM request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_power_off_sim_finish() to get the result of the operation.
         * @param input a #QmiMessageUimPowerOffSimInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        power_off_sim(
            input: MessageUimPowerOffSimInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimPowerOffSimOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_power_off_sim().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_power_off_sim().
         * @returns a #QmiMessageUimPowerOffSimOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_power_off_sim_output_unref().
         */
        power_off_sim_finish(res: Gio.AsyncResult): MessageUimPowerOffSimOutput;
        /**
         * Asynchronously sends a Power On SIM request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_power_on_sim_finish() to get the result of the operation.
         * @param input a #QmiMessageUimPowerOnSimInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        power_on_sim(
            input: MessageUimPowerOnSimInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimPowerOnSimOutput>;
        /**
         * Asynchronously sends a Power On SIM request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_power_on_sim_finish() to get the result of the operation.
         * @param input a #QmiMessageUimPowerOnSimInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        power_on_sim(
            input: MessageUimPowerOnSimInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Power On SIM request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_power_on_sim_finish() to get the result of the operation.
         * @param input a #QmiMessageUimPowerOnSimInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        power_on_sim(
            input: MessageUimPowerOnSimInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimPowerOnSimOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_power_on_sim().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_power_on_sim().
         * @returns a #QmiMessageUimPowerOnSimOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_power_on_sim_output_unref().
         */
        power_on_sim_finish(res: Gio.AsyncResult): MessageUimPowerOnSimOutput;
        /**
         * Asynchronously sends a Read Record request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_read_record_finish() to get the result of the operation.
         * @param input a #QmiMessageUimReadRecordInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        read_record(
            input: MessageUimReadRecordInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimReadRecordOutput>;
        /**
         * Asynchronously sends a Read Record request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_read_record_finish() to get the result of the operation.
         * @param input a #QmiMessageUimReadRecordInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        read_record(
            input: MessageUimReadRecordInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Read Record request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_read_record_finish() to get the result of the operation.
         * @param input a #QmiMessageUimReadRecordInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        read_record(
            input: MessageUimReadRecordInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimReadRecordOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_read_record().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_read_record().
         * @returns a #QmiMessageUimReadRecordOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_read_record_output_unref().
         */
        read_record_finish(res: Gio.AsyncResult): MessageUimReadRecordOutput;
        /**
         * Asynchronously sends a Read Transparent request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_read_transparent_finish() to get the result of the operation.
         * @param input a #QmiMessageUimReadTransparentInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        read_transparent(
            input: MessageUimReadTransparentInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimReadTransparentOutput>;
        /**
         * Asynchronously sends a Read Transparent request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_read_transparent_finish() to get the result of the operation.
         * @param input a #QmiMessageUimReadTransparentInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        read_transparent(
            input: MessageUimReadTransparentInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Read Transparent request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_read_transparent_finish() to get the result of the operation.
         * @param input a #QmiMessageUimReadTransparentInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        read_transparent(
            input: MessageUimReadTransparentInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimReadTransparentOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_read_transparent().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_read_transparent().
         * @returns a #QmiMessageUimReadTransparentOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_read_transparent_output_unref().
         */
        read_transparent_finish(res: Gio.AsyncResult): MessageUimReadTransparentOutput;
        /**
         * Asynchronously sends a Refresh Complete request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_refresh_complete_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRefreshCompleteInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        refresh_complete(
            input: MessageUimRefreshCompleteInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimRefreshCompleteOutput>;
        /**
         * Asynchronously sends a Refresh Complete request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_refresh_complete_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRefreshCompleteInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        refresh_complete(
            input: MessageUimRefreshCompleteInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Refresh Complete request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_refresh_complete_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRefreshCompleteInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        refresh_complete(
            input: MessageUimRefreshCompleteInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimRefreshCompleteOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_refresh_complete().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_refresh_complete().
         * @returns a #QmiMessageUimRefreshCompleteOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_refresh_complete_output_unref().
         */
        refresh_complete_finish(res: Gio.AsyncResult): MessageUimRefreshCompleteOutput;
        /**
         * Asynchronously sends a Refresh Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_refresh_register_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRefreshRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        refresh_register(
            input: MessageUimRefreshRegisterInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimRefreshRegisterOutput>;
        /**
         * Asynchronously sends a Refresh Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_refresh_register_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRefreshRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        refresh_register(
            input: MessageUimRefreshRegisterInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Refresh Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_refresh_register_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRefreshRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        refresh_register(
            input: MessageUimRefreshRegisterInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimRefreshRegisterOutput> | void;
        /**
         * Asynchronously sends a Refresh Register All request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_refresh_register_all_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRefreshRegisterAllInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        refresh_register_all(
            input: MessageUimRefreshRegisterAllInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimRefreshRegisterAllOutput>;
        /**
         * Asynchronously sends a Refresh Register All request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_refresh_register_all_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRefreshRegisterAllInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        refresh_register_all(
            input: MessageUimRefreshRegisterAllInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Refresh Register All request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_refresh_register_all_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRefreshRegisterAllInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        refresh_register_all(
            input: MessageUimRefreshRegisterAllInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimRefreshRegisterAllOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_refresh_register_all().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_refresh_register_all().
         * @returns a #QmiMessageUimRefreshRegisterAllOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_refresh_register_all_output_unref().
         */
        refresh_register_all_finish(res: Gio.AsyncResult): MessageUimRefreshRegisterAllOutput;
        /**
         * Finishes an async operation started with qmi_client_uim_refresh_register().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_refresh_register().
         * @returns a #QmiMessageUimRefreshRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_refresh_register_output_unref().
         */
        refresh_register_finish(res: Gio.AsyncResult): MessageUimRefreshRegisterOutput;
        /**
         * Asynchronously sends a Register Events request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_register_events_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRegisterEventsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        register_events(
            input: MessageUimRegisterEventsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimRegisterEventsOutput>;
        /**
         * Asynchronously sends a Register Events request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_register_events_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRegisterEventsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        register_events(
            input: MessageUimRegisterEventsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Register Events request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_register_events_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRegisterEventsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        register_events(
            input: MessageUimRegisterEventsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimRegisterEventsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_register_events().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_register_events().
         * @returns a #QmiMessageUimRegisterEventsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_register_events_output_unref().
         */
        register_events_finish(res: Gio.AsyncResult): MessageUimRegisterEventsOutput;
        /**
         * Asynchronously sends a Remote Unlock request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_remote_unlock_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRemoteUnlockInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        remote_unlock(
            input: MessageUimRemoteUnlockInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimRemoteUnlockOutput>;
        /**
         * Asynchronously sends a Remote Unlock request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_remote_unlock_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRemoteUnlockInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        remote_unlock(
            input: MessageUimRemoteUnlockInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Remote Unlock request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_remote_unlock_finish() to get the result of the operation.
         * @param input a #QmiMessageUimRemoteUnlockInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        remote_unlock(
            input: MessageUimRemoteUnlockInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimRemoteUnlockOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_remote_unlock().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_remote_unlock().
         * @returns a #QmiMessageUimRemoteUnlockOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_remote_unlock_output_unref().
         */
        remote_unlock_finish(res: Gio.AsyncResult): MessageUimRemoteUnlockOutput;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimResetOutput>;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimResetOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_reset().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_reset().
         * @returns a #QmiMessageUimResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_reset_output_unref().
         */
        reset_finish(res: Gio.AsyncResult): MessageUimResetOutput;
        /**
         * Asynchronously sends a Set PIN Protection request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_set_pin_protection_finish() to get the result of the operation.
         * @param input a #QmiMessageUimSetPinProtectionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_pin_protection(
            input: MessageUimSetPinProtectionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimSetPinProtectionOutput>;
        /**
         * Asynchronously sends a Set PIN Protection request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_set_pin_protection_finish() to get the result of the operation.
         * @param input a #QmiMessageUimSetPinProtectionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_pin_protection(
            input: MessageUimSetPinProtectionInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set PIN Protection request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_set_pin_protection_finish() to get the result of the operation.
         * @param input a #QmiMessageUimSetPinProtectionInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_pin_protection(
            input: MessageUimSetPinProtectionInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimSetPinProtectionOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_set_pin_protection().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_set_pin_protection().
         * @returns a #QmiMessageUimSetPinProtectionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_set_pin_protection_output_unref().
         */
        set_pin_protection_finish(res: Gio.AsyncResult): MessageUimSetPinProtectionOutput;
        /**
         * Asynchronously sends a Switch Slot request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_switch_slot_finish() to get the result of the operation.
         * @param input a #QmiMessageUimSwitchSlotInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        switch_slot(
            input: MessageUimSwitchSlotInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimSwitchSlotOutput>;
        /**
         * Asynchronously sends a Switch Slot request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_switch_slot_finish() to get the result of the operation.
         * @param input a #QmiMessageUimSwitchSlotInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        switch_slot(
            input: MessageUimSwitchSlotInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Switch Slot request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_switch_slot_finish() to get the result of the operation.
         * @param input a #QmiMessageUimSwitchSlotInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        switch_slot(
            input: MessageUimSwitchSlotInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimSwitchSlotOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_switch_slot().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_switch_slot().
         * @returns a #QmiMessageUimSwitchSlotOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_switch_slot_output_unref().
         */
        switch_slot_finish(res: Gio.AsyncResult): MessageUimSwitchSlotOutput;
        /**
         * Asynchronously sends a Unblock PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_unblock_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageUimUnblockPinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        unblock_pin(
            input: MessageUimUnblockPinInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimUnblockPinOutput>;
        /**
         * Asynchronously sends a Unblock PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_unblock_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageUimUnblockPinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        unblock_pin(
            input: MessageUimUnblockPinInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Unblock PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_unblock_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageUimUnblockPinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        unblock_pin(
            input: MessageUimUnblockPinInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimUnblockPinOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_unblock_pin().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_unblock_pin().
         * @returns a #QmiMessageUimUnblockPinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_unblock_pin_output_unref().
         */
        unblock_pin_finish(res: Gio.AsyncResult): MessageUimUnblockPinOutput;
        /**
         * Asynchronously sends a Verify PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_verify_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageUimVerifyPinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        verify_pin(
            input: MessageUimVerifyPinInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageUimVerifyPinOutput>;
        /**
         * Asynchronously sends a Verify PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_verify_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageUimVerifyPinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        verify_pin(
            input: MessageUimVerifyPinInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Verify PIN request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_uim_verify_pin_finish() to get the result of the operation.
         * @param input a #QmiMessageUimVerifyPinInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        verify_pin(
            input: MessageUimVerifyPinInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageUimVerifyPinOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_uim_verify_pin().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_uim_verify_pin().
         * @returns a #QmiMessageUimVerifyPinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_uim_verify_pin_output_unref().
         */
        verify_pin_finish(res: Gio.AsyncResult): MessageUimVerifyPinOutput;
    }

    module ClientVoice {
        // Signal callback interfaces

        interface AllCallStatus {
            (output: IndicationVoiceAllCallStatusOutput): void;
        }

        interface OriginateUssdNoWait {
            (output: IndicationVoiceOriginateUssdNoWaitOutput): void;
        }

        interface ReleaseUssd {
            (): void;
        }

        interface SupplementaryService {
            (output: IndicationVoiceSupplementaryServiceOutput): void;
        }

        interface Ussd {
            (output: IndicationVoiceUssdOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientVoice structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientVoice extends Client {
        static $gtype: GObject.GType<ClientVoice>;

        // Constructors

        constructor(properties?: Partial<ClientVoice.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'all-call-status',
            callback: (_source: this, output: IndicationVoiceAllCallStatusOutput) => void,
        ): number;
        connect_after(
            signal: 'all-call-status',
            callback: (_source: this, output: IndicationVoiceAllCallStatusOutput) => void,
        ): number;
        emit(signal: 'all-call-status', output: IndicationVoiceAllCallStatusOutput): void;
        connect(
            signal: 'originate-ussd-no-wait',
            callback: (_source: this, output: IndicationVoiceOriginateUssdNoWaitOutput) => void,
        ): number;
        connect_after(
            signal: 'originate-ussd-no-wait',
            callback: (_source: this, output: IndicationVoiceOriginateUssdNoWaitOutput) => void,
        ): number;
        emit(signal: 'originate-ussd-no-wait', output: IndicationVoiceOriginateUssdNoWaitOutput): void;
        connect(signal: 'release-ussd', callback: (_source: this) => void): number;
        connect_after(signal: 'release-ussd', callback: (_source: this) => void): number;
        emit(signal: 'release-ussd'): void;
        connect(
            signal: 'supplementary-service',
            callback: (_source: this, output: IndicationVoiceSupplementaryServiceOutput) => void,
        ): number;
        connect_after(
            signal: 'supplementary-service',
            callback: (_source: this, output: IndicationVoiceSupplementaryServiceOutput) => void,
        ): number;
        emit(signal: 'supplementary-service', output: IndicationVoiceSupplementaryServiceOutput): void;
        connect(signal: 'ussd', callback: (_source: this, output: IndicationVoiceUssdOutput) => void): number;
        connect_after(signal: 'ussd', callback: (_source: this, output: IndicationVoiceUssdOutput) => void): number;
        emit(signal: 'ussd', output: IndicationVoiceUssdOutput): void;

        // Methods

        /**
         * Asynchronously sends a Answer Call request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_answer_call_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceAnswerCallInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        answer_call(
            input: MessageVoiceAnswerCallInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceAnswerCallOutput>;
        /**
         * Asynchronously sends a Answer Call request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_answer_call_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceAnswerCallInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        answer_call(
            input: MessageVoiceAnswerCallInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Answer Call request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_answer_call_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceAnswerCallInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        answer_call(
            input: MessageVoiceAnswerCallInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceAnswerCallOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_answer_call().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_answer_call().
         * @returns a #QmiMessageVoiceAnswerCallOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_answer_call_output_unref().
         */
        answer_call_finish(res: Gio.AsyncResult): MessageVoiceAnswerCallOutput;
        /**
         * Asynchronously sends a Answer USSD request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_answer_ussd_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceAnswerUssdInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        answer_ussd(
            input: MessageVoiceAnswerUssdInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceAnswerUssdOutput>;
        /**
         * Asynchronously sends a Answer USSD request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_answer_ussd_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceAnswerUssdInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        answer_ussd(
            input: MessageVoiceAnswerUssdInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Answer USSD request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_answer_ussd_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceAnswerUssdInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        answer_ussd(
            input: MessageVoiceAnswerUssdInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceAnswerUssdOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_answer_ussd().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_answer_ussd().
         * @returns a #QmiMessageVoiceAnswerUssdOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_answer_ussd_output_unref().
         */
        answer_ussd_finish(res: Gio.AsyncResult): MessageVoiceAnswerUssdOutput;
        /**
         * Asynchronously sends a Burst DTMF request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_burst_dtmf_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceBurstDtmfInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        burst_dtmf(
            input: MessageVoiceBurstDtmfInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceBurstDtmfOutput>;
        /**
         * Asynchronously sends a Burst DTMF request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_burst_dtmf_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceBurstDtmfInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        burst_dtmf(
            input: MessageVoiceBurstDtmfInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Burst DTMF request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_burst_dtmf_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceBurstDtmfInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        burst_dtmf(
            input: MessageVoiceBurstDtmfInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceBurstDtmfOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_burst_dtmf().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_burst_dtmf().
         * @returns a #QmiMessageVoiceBurstDtmfOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_burst_dtmf_output_unref().
         */
        burst_dtmf_finish(res: Gio.AsyncResult): MessageVoiceBurstDtmfOutput;
        /**
         * Asynchronously sends a Cancel USSD request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_cancel_ussd_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        cancel_ussd(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceCancelUssdOutput>;
        /**
         * Asynchronously sends a Cancel USSD request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_cancel_ussd_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        cancel_ussd(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Cancel USSD request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_cancel_ussd_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        cancel_ussd(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceCancelUssdOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_cancel_ussd().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_cancel_ussd().
         * @returns a #QmiMessageVoiceCancelUssdOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_cancel_ussd_output_unref().
         */
        cancel_ussd_finish(res: Gio.AsyncResult): MessageVoiceCancelUssdOutput;
        /**
         * Asynchronously sends a Dial Call request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_dial_call_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceDialCallInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        dial_call(
            input: MessageVoiceDialCallInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceDialCallOutput>;
        /**
         * Asynchronously sends a Dial Call request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_dial_call_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceDialCallInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        dial_call(
            input: MessageVoiceDialCallInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Dial Call request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_dial_call_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceDialCallInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        dial_call(
            input: MessageVoiceDialCallInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceDialCallOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_dial_call().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_dial_call().
         * @returns a #QmiMessageVoiceDialCallOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_dial_call_output_unref().
         */
        dial_call_finish(res: Gio.AsyncResult): MessageVoiceDialCallOutput;
        /**
         * Asynchronously sends a End Call request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_end_call_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceEndCallInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        end_call(
            input: MessageVoiceEndCallInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceEndCallOutput>;
        /**
         * Asynchronously sends a End Call request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_end_call_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceEndCallInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        end_call(
            input: MessageVoiceEndCallInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a End Call request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_end_call_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceEndCallInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        end_call(
            input: MessageVoiceEndCallInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceEndCallOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_end_call().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_end_call().
         * @returns a #QmiMessageVoiceEndCallOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_end_call_output_unref().
         */
        end_call_finish(res: Gio.AsyncResult): MessageVoiceEndCallOutput;
        /**
         * Asynchronously sends a Get All Call Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_get_all_call_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_all_call_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceGetAllCallInfoOutput>;
        /**
         * Asynchronously sends a Get All Call Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_get_all_call_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_all_call_info(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get All Call Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_get_all_call_info_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_all_call_info(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceGetAllCallInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_get_all_call_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_get_all_call_info().
         * @returns a #QmiMessageVoiceGetAllCallInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_get_all_call_info_output_unref().
         */
        get_all_call_info_finish(res: Gio.AsyncResult): MessageVoiceGetAllCallInfoOutput;
        /**
         * Asynchronously sends a Get Call Waiting request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_get_call_waiting_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceGetCallWaitingInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_call_waiting(
            input: MessageVoiceGetCallWaitingInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceGetCallWaitingOutput>;
        /**
         * Asynchronously sends a Get Call Waiting request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_get_call_waiting_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceGetCallWaitingInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_call_waiting(
            input: MessageVoiceGetCallWaitingInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Call Waiting request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_get_call_waiting_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceGetCallWaitingInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_call_waiting(
            input: MessageVoiceGetCallWaitingInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceGetCallWaitingOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_get_call_waiting().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_get_call_waiting().
         * @returns a #QmiMessageVoiceGetCallWaitingOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_get_call_waiting_output_unref().
         */
        get_call_waiting_finish(res: Gio.AsyncResult): MessageVoiceGetCallWaitingOutput;
        /**
         * Asynchronously sends a Get Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_get_config_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceGetConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_config(
            input: MessageVoiceGetConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceGetConfigOutput>;
        /**
         * Asynchronously sends a Get Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_get_config_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceGetConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_config(
            input: MessageVoiceGetConfigInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Config request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_get_config_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceGetConfigInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_config(
            input: MessageVoiceGetConfigInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceGetConfigOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_get_config().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_get_config().
         * @returns a #QmiMessageVoiceGetConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_get_config_output_unref().
         */
        get_config_finish(res: Gio.AsyncResult): MessageVoiceGetConfigOutput;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceGetSupportedMessagesOutput>;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceGetSupportedMessagesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_get_supported_messages().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_get_supported_messages().
         * @returns a #QmiMessageVoiceGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_get_supported_messages_output_unref().
         */
        get_supported_messages_finish(res: Gio.AsyncResult): MessageVoiceGetSupportedMessagesOutput;
        /**
         * Asynchronously sends a Indication Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_indication_register_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceIndicationRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        indication_register(
            input: MessageVoiceIndicationRegisterInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceIndicationRegisterOutput>;
        /**
         * Asynchronously sends a Indication Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_indication_register_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceIndicationRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        indication_register(
            input: MessageVoiceIndicationRegisterInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Indication Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_indication_register_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceIndicationRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        indication_register(
            input: MessageVoiceIndicationRegisterInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceIndicationRegisterOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_indication_register().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_indication_register().
         * @returns a #QmiMessageVoiceIndicationRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_indication_register_output_unref().
         */
        indication_register_finish(res: Gio.AsyncResult): MessageVoiceIndicationRegisterOutput;
        /**
         * Asynchronously sends a Manage Calls request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_manage_calls_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceManageCallsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        manage_calls(
            input: MessageVoiceManageCallsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceManageCallsOutput>;
        /**
         * Asynchronously sends a Manage Calls request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_manage_calls_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceManageCallsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        manage_calls(
            input: MessageVoiceManageCallsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Manage Calls request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_manage_calls_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceManageCallsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        manage_calls(
            input: MessageVoiceManageCallsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceManageCallsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_manage_calls().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_manage_calls().
         * @returns a #QmiMessageVoiceManageCallsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_manage_calls_output_unref().
         */
        manage_calls_finish(res: Gio.AsyncResult): MessageVoiceManageCallsOutput;
        /**
         * Asynchronously sends a Originate USSD request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_originate_ussd_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceOriginateUssdInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        originate_ussd(
            input: MessageVoiceOriginateUssdInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceOriginateUssdOutput>;
        /**
         * Asynchronously sends a Originate USSD request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_originate_ussd_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceOriginateUssdInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        originate_ussd(
            input: MessageVoiceOriginateUssdInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Originate USSD request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_originate_ussd_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceOriginateUssdInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        originate_ussd(
            input: MessageVoiceOriginateUssdInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceOriginateUssdOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_originate_ussd().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_originate_ussd().
         * @returns a #QmiMessageVoiceOriginateUssdOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_originate_ussd_output_unref().
         */
        originate_ussd_finish(res: Gio.AsyncResult): MessageVoiceOriginateUssdOutput;
        /**
         * Asynchronously sends a Originate USSD No Wait request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_originate_ussd_no_wait_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceOriginateUssdNoWaitInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        originate_ussd_no_wait(
            input: MessageVoiceOriginateUssdNoWaitInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceOriginateUssdNoWaitOutput>;
        /**
         * Asynchronously sends a Originate USSD No Wait request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_originate_ussd_no_wait_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceOriginateUssdNoWaitInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        originate_ussd_no_wait(
            input: MessageVoiceOriginateUssdNoWaitInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Originate USSD No Wait request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_originate_ussd_no_wait_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceOriginateUssdNoWaitInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        originate_ussd_no_wait(
            input: MessageVoiceOriginateUssdNoWaitInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceOriginateUssdNoWaitOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_originate_ussd_no_wait().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_originate_ussd_no_wait().
         * @returns a #QmiMessageVoiceOriginateUssdNoWaitOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_originate_ussd_no_wait_output_unref().
         */
        originate_ussd_no_wait_finish(res: Gio.AsyncResult): MessageVoiceOriginateUssdNoWaitOutput;
        /**
         * Asynchronously sends a Set Supplementary Service request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_set_supplementary_service_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceSetSupplementaryServiceInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_supplementary_service(
            input: MessageVoiceSetSupplementaryServiceInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceSetSupplementaryServiceOutput>;
        /**
         * Asynchronously sends a Set Supplementary Service request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_set_supplementary_service_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceSetSupplementaryServiceInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_supplementary_service(
            input: MessageVoiceSetSupplementaryServiceInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Supplementary Service request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_set_supplementary_service_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceSetSupplementaryServiceInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_supplementary_service(
            input: MessageVoiceSetSupplementaryServiceInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceSetSupplementaryServiceOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_set_supplementary_service().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_set_supplementary_service().
         * @returns a #QmiMessageVoiceSetSupplementaryServiceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_set_supplementary_service_output_unref().
         */
        set_supplementary_service_finish(res: Gio.AsyncResult): MessageVoiceSetSupplementaryServiceOutput;
        /**
         * Asynchronously sends a Start Continuous DTMF request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_start_continuous_dtmf_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceStartContinuousDtmfInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        start_continuous_dtmf(
            input: MessageVoiceStartContinuousDtmfInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceStartContinuousDtmfOutput>;
        /**
         * Asynchronously sends a Start Continuous DTMF request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_start_continuous_dtmf_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceStartContinuousDtmfInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        start_continuous_dtmf(
            input: MessageVoiceStartContinuousDtmfInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Start Continuous DTMF request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_start_continuous_dtmf_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceStartContinuousDtmfInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        start_continuous_dtmf(
            input: MessageVoiceStartContinuousDtmfInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceStartContinuousDtmfOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_start_continuous_dtmf().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_start_continuous_dtmf().
         * @returns a #QmiMessageVoiceStartContinuousDtmfOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_start_continuous_dtmf_output_unref().
         */
        start_continuous_dtmf_finish(res: Gio.AsyncResult): MessageVoiceStartContinuousDtmfOutput;
        /**
         * Asynchronously sends a Stop Continuous DTMF request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_stop_continuous_dtmf_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceStopContinuousDtmfInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        stop_continuous_dtmf(
            input: MessageVoiceStopContinuousDtmfInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageVoiceStopContinuousDtmfOutput>;
        /**
         * Asynchronously sends a Stop Continuous DTMF request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_stop_continuous_dtmf_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceStopContinuousDtmfInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        stop_continuous_dtmf(
            input: MessageVoiceStopContinuousDtmfInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Stop Continuous DTMF request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_voice_stop_continuous_dtmf_finish() to get the result of the operation.
         * @param input a #QmiMessageVoiceStopContinuousDtmfInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        stop_continuous_dtmf(
            input: MessageVoiceStopContinuousDtmfInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageVoiceStopContinuousDtmfOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_voice_stop_continuous_dtmf().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_voice_stop_continuous_dtmf().
         * @returns a #QmiMessageVoiceStopContinuousDtmfOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_voice_stop_continuous_dtmf_output_unref().
         */
        stop_continuous_dtmf_finish(res: Gio.AsyncResult): MessageVoiceStopContinuousDtmfOutput;
    }

    module ClientWda {
        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientWda structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientWda extends Client {
        static $gtype: GObject.GType<ClientWda>;

        // Constructors

        constructor(properties?: Partial<ClientWda.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Asynchronously sends a Get Data Format request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wda_get_data_format_finish() to get the result of the operation.
         * @param input a #QmiMessageWdaGetDataFormatInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_data_format(
            input: MessageWdaGetDataFormatInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdaGetDataFormatOutput>;
        /**
         * Asynchronously sends a Get Data Format request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wda_get_data_format_finish() to get the result of the operation.
         * @param input a #QmiMessageWdaGetDataFormatInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_data_format(
            input: MessageWdaGetDataFormatInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Data Format request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wda_get_data_format_finish() to get the result of the operation.
         * @param input a #QmiMessageWdaGetDataFormatInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_data_format(
            input: MessageWdaGetDataFormatInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdaGetDataFormatOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wda_get_data_format().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wda_get_data_format().
         * @returns a #QmiMessageWdaGetDataFormatOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wda_get_data_format_output_unref().
         */
        get_data_format_finish(res: Gio.AsyncResult): MessageWdaGetDataFormatOutput;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wda_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdaGetSupportedMessagesOutput>;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wda_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wda_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdaGetSupportedMessagesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wda_get_supported_messages().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wda_get_supported_messages().
         * @returns a #QmiMessageWdaGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wda_get_supported_messages_output_unref().
         */
        get_supported_messages_finish(res: Gio.AsyncResult): MessageWdaGetSupportedMessagesOutput;
        /**
         * Asynchronously sends a Set Data Format request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wda_set_data_format_finish() to get the result of the operation.
         * @param input a #QmiMessageWdaSetDataFormatInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_data_format(
            input: MessageWdaSetDataFormatInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdaSetDataFormatOutput>;
        /**
         * Asynchronously sends a Set Data Format request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wda_set_data_format_finish() to get the result of the operation.
         * @param input a #QmiMessageWdaSetDataFormatInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_data_format(
            input: MessageWdaSetDataFormatInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Data Format request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wda_set_data_format_finish() to get the result of the operation.
         * @param input a #QmiMessageWdaSetDataFormatInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_data_format(
            input: MessageWdaSetDataFormatInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdaSetDataFormatOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wda_set_data_format().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wda_set_data_format().
         * @returns a #QmiMessageWdaSetDataFormatOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wda_set_data_format_output_unref().
         */
        set_data_format_finish(res: Gio.AsyncResult): MessageWdaSetDataFormatOutput;
    }

    module ClientWds {
        // Signal callback interfaces

        interface EventReport {
            (output: IndicationWdsEventReportOutput): void;
        }

        interface ExtendedIpConfig {
            (output: IndicationWdsExtendedIpConfigOutput): void;
        }

        interface PacketServiceStatus {
            (output: IndicationWdsPacketServiceStatusOutput): void;
        }

        interface ProfileChanged {
            (output: IndicationWdsProfileChangedOutput): void;
        }

        interface SetLteAttachPdnList {
            (output: IndicationWdsSetLteAttachPdnListOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientWds structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientWds extends Client {
        static $gtype: GObject.GType<ClientWds>;

        // Constructors

        constructor(properties?: Partial<ClientWds.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'event-report',
            callback: (_source: this, output: IndicationWdsEventReportOutput) => void,
        ): number;
        connect_after(
            signal: 'event-report',
            callback: (_source: this, output: IndicationWdsEventReportOutput) => void,
        ): number;
        emit(signal: 'event-report', output: IndicationWdsEventReportOutput): void;
        connect(
            signal: 'extended-ip-config',
            callback: (_source: this, output: IndicationWdsExtendedIpConfigOutput) => void,
        ): number;
        connect_after(
            signal: 'extended-ip-config',
            callback: (_source: this, output: IndicationWdsExtendedIpConfigOutput) => void,
        ): number;
        emit(signal: 'extended-ip-config', output: IndicationWdsExtendedIpConfigOutput): void;
        connect(
            signal: 'packet-service-status',
            callback: (_source: this, output: IndicationWdsPacketServiceStatusOutput) => void,
        ): number;
        connect_after(
            signal: 'packet-service-status',
            callback: (_source: this, output: IndicationWdsPacketServiceStatusOutput) => void,
        ): number;
        emit(signal: 'packet-service-status', output: IndicationWdsPacketServiceStatusOutput): void;
        connect(
            signal: 'profile-changed',
            callback: (_source: this, output: IndicationWdsProfileChangedOutput) => void,
        ): number;
        connect_after(
            signal: 'profile-changed',
            callback: (_source: this, output: IndicationWdsProfileChangedOutput) => void,
        ): number;
        emit(signal: 'profile-changed', output: IndicationWdsProfileChangedOutput): void;
        connect(
            signal: 'set-lte-attach-pdn-list',
            callback: (_source: this, output: IndicationWdsSetLteAttachPdnListOutput) => void,
        ): number;
        connect_after(
            signal: 'set-lte-attach-pdn-list',
            callback: (_source: this, output: IndicationWdsSetLteAttachPdnListOutput) => void,
        ): number;
        emit(signal: 'set-lte-attach-pdn-list', output: IndicationWdsSetLteAttachPdnListOutput): void;

        // Methods

        /**
         * Asynchronously sends a Bind Data Port request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_bind_data_port_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsBindDataPortInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        bind_data_port(
            input: MessageWdsBindDataPortInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsBindDataPortOutput>;
        /**
         * Asynchronously sends a Bind Data Port request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_bind_data_port_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsBindDataPortInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        bind_data_port(
            input: MessageWdsBindDataPortInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Bind Data Port request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_bind_data_port_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsBindDataPortInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        bind_data_port(
            input: MessageWdsBindDataPortInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsBindDataPortOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_bind_data_port().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_bind_data_port().
         * @returns a #QmiMessageWdsBindDataPortOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_bind_data_port_output_unref().
         */
        bind_data_port_finish(res: Gio.AsyncResult): MessageWdsBindDataPortOutput;
        /**
         * Asynchronously sends a Bind Mux Data Port request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_bind_mux_data_port_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsBindMuxDataPortInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        bind_mux_data_port(
            input: MessageWdsBindMuxDataPortInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsBindMuxDataPortOutput>;
        /**
         * Asynchronously sends a Bind Mux Data Port request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_bind_mux_data_port_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsBindMuxDataPortInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        bind_mux_data_port(
            input: MessageWdsBindMuxDataPortInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Bind Mux Data Port request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_bind_mux_data_port_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsBindMuxDataPortInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        bind_mux_data_port(
            input: MessageWdsBindMuxDataPortInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsBindMuxDataPortOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_bind_mux_data_port().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_bind_mux_data_port().
         * @returns a #QmiMessageWdsBindMuxDataPortOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_bind_mux_data_port_output_unref().
         */
        bind_mux_data_port_finish(res: Gio.AsyncResult): MessageWdsBindMuxDataPortOutput;
        /**
         * Asynchronously sends a Configure Profile Event List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_configure_profile_event_list_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsConfigureProfileEventListInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        configure_profile_event_list(
            input: MessageWdsConfigureProfileEventListInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsConfigureProfileEventListOutput>;
        /**
         * Asynchronously sends a Configure Profile Event List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_configure_profile_event_list_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsConfigureProfileEventListInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        configure_profile_event_list(
            input: MessageWdsConfigureProfileEventListInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Configure Profile Event List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_configure_profile_event_list_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsConfigureProfileEventListInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        configure_profile_event_list(
            input: MessageWdsConfigureProfileEventListInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsConfigureProfileEventListOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_configure_profile_event_list().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_configure_profile_event_list().
         * @returns a #QmiMessageWdsConfigureProfileEventListOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_configure_profile_event_list_output_unref().
         */
        configure_profile_event_list_finish(res: Gio.AsyncResult): MessageWdsConfigureProfileEventListOutput;
        /**
         * Asynchronously sends a Create Profile request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_create_profile_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsCreateProfileInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        create_profile(
            input: MessageWdsCreateProfileInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsCreateProfileOutput>;
        /**
         * Asynchronously sends a Create Profile request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_create_profile_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsCreateProfileInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        create_profile(
            input: MessageWdsCreateProfileInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Create Profile request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_create_profile_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsCreateProfileInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        create_profile(
            input: MessageWdsCreateProfileInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsCreateProfileOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_create_profile().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_create_profile().
         * @returns a #QmiMessageWdsCreateProfileOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_create_profile_output_unref().
         */
        create_profile_finish(res: Gio.AsyncResult): MessageWdsCreateProfileOutput;
        /**
         * Asynchronously sends a Delete Profile request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_delete_profile_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsDeleteProfileInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        delete_profile(
            input: MessageWdsDeleteProfileInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsDeleteProfileOutput>;
        /**
         * Asynchronously sends a Delete Profile request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_delete_profile_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsDeleteProfileInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        delete_profile(
            input: MessageWdsDeleteProfileInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Delete Profile request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_delete_profile_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsDeleteProfileInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        delete_profile(
            input: MessageWdsDeleteProfileInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsDeleteProfileOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_delete_profile().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_delete_profile().
         * @returns a #QmiMessageWdsDeleteProfileOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_delete_profile_output_unref().
         */
        delete_profile_finish(res: Gio.AsyncResult): MessageWdsDeleteProfileOutput;
        /**
         * Asynchronously sends a Get Autoconnect Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_autoconnect_settings_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_autoconnect_settings(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetAutoconnectSettingsOutput>;
        /**
         * Asynchronously sends a Get Autoconnect Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_autoconnect_settings_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_autoconnect_settings(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Autoconnect Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_autoconnect_settings_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_autoconnect_settings(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetAutoconnectSettingsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_autoconnect_settings().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_autoconnect_settings().
         * @returns a #QmiMessageWdsGetAutoconnectSettingsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_autoconnect_settings_output_unref().
         */
        get_autoconnect_settings_finish(res: Gio.AsyncResult): MessageWdsGetAutoconnectSettingsOutput;
        /**
         * Asynchronously sends a Get Channel Rates request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_channel_rates_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_channel_rates(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetChannelRatesOutput>;
        /**
         * Asynchronously sends a Get Channel Rates request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_channel_rates_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_channel_rates(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Channel Rates request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_channel_rates_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_channel_rates(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetChannelRatesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_channel_rates().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_channel_rates().
         * @returns a #QmiMessageWdsGetChannelRatesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_channel_rates_output_unref().
         */
        get_channel_rates_finish(res: Gio.AsyncResult): MessageWdsGetChannelRatesOutput;
        /**
         * Asynchronously sends a Get Current Data Bearer Technology request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_current_data_bearer_technology_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_current_data_bearer_technology(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetCurrentDataBearerTechnologyOutput>;
        /**
         * Asynchronously sends a Get Current Data Bearer Technology request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_current_data_bearer_technology_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_current_data_bearer_technology(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Current Data Bearer Technology request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_current_data_bearer_technology_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_current_data_bearer_technology(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetCurrentDataBearerTechnologyOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_current_data_bearer_technology().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_current_data_bearer_technology().
         * @returns a #QmiMessageWdsGetCurrentDataBearerTechnologyOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_current_data_bearer_technology_output_unref().
         */
        get_current_data_bearer_technology_finish(res: Gio.AsyncResult): MessageWdsGetCurrentDataBearerTechnologyOutput;
        /**
         * Asynchronously sends a Get Current Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_current_settings_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetCurrentSettingsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_current_settings(
            input: MessageWdsGetCurrentSettingsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetCurrentSettingsOutput>;
        /**
         * Asynchronously sends a Get Current Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_current_settings_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetCurrentSettingsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_current_settings(
            input: MessageWdsGetCurrentSettingsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Current Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_current_settings_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetCurrentSettingsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_current_settings(
            input: MessageWdsGetCurrentSettingsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetCurrentSettingsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_current_settings().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_current_settings().
         * @returns a #QmiMessageWdsGetCurrentSettingsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_current_settings_output_unref().
         */
        get_current_settings_finish(res: Gio.AsyncResult): MessageWdsGetCurrentSettingsOutput;
        /**
         * Asynchronously sends a Get Data Bearer Technology request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_data_bearer_technology_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_data_bearer_technology(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetDataBearerTechnologyOutput>;
        /**
         * Asynchronously sends a Get Data Bearer Technology request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_data_bearer_technology_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_data_bearer_technology(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Data Bearer Technology request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_data_bearer_technology_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_data_bearer_technology(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetDataBearerTechnologyOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_data_bearer_technology().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_data_bearer_technology().
         * @returns a #QmiMessageWdsGetDataBearerTechnologyOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_data_bearer_technology_output_unref().
         */
        get_data_bearer_technology_finish(res: Gio.AsyncResult): MessageWdsGetDataBearerTechnologyOutput;
        /**
         * Asynchronously sends a Get Default Profile Number request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_default_profile_number_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetDefaultProfileNumberInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_default_profile_number(
            input: MessageWdsGetDefaultProfileNumberInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetDefaultProfileNumberOutput>;
        /**
         * Asynchronously sends a Get Default Profile Number request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_default_profile_number_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetDefaultProfileNumberInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_default_profile_number(
            input: MessageWdsGetDefaultProfileNumberInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Default Profile Number request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_default_profile_number_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetDefaultProfileNumberInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_default_profile_number(
            input: MessageWdsGetDefaultProfileNumberInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetDefaultProfileNumberOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_default_profile_number().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_default_profile_number().
         * @returns a #QmiMessageWdsGetDefaultProfileNumberOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_default_profile_number_output_unref().
         */
        get_default_profile_number_finish(res: Gio.AsyncResult): MessageWdsGetDefaultProfileNumberOutput;
        /**
         * Asynchronously sends a Get Default Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_default_settings_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetDefaultSettingsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_default_settings(
            input: MessageWdsGetDefaultSettingsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetDefaultSettingsOutput>;
        /**
         * Asynchronously sends a Get Default Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_default_settings_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetDefaultSettingsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_default_settings(
            input: MessageWdsGetDefaultSettingsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Default Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_default_settings_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetDefaultSettingsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_default_settings(
            input: MessageWdsGetDefaultSettingsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetDefaultSettingsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_default_settings().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_default_settings().
         * @returns a #QmiMessageWdsGetDefaultSettingsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_default_settings_output_unref().
         */
        get_default_settings_finish(res: Gio.AsyncResult): MessageWdsGetDefaultSettingsOutput;
        /**
         * Asynchronously sends a Get Dormancy Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_dormancy_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_dormancy_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetDormancyStatusOutput>;
        /**
         * Asynchronously sends a Get Dormancy Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_dormancy_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_dormancy_status(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Dormancy Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_dormancy_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_dormancy_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetDormancyStatusOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_dormancy_status().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_dormancy_status().
         * @returns a #QmiMessageWdsGetDormancyStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_dormancy_status_output_unref().
         */
        get_dormancy_status_finish(res: Gio.AsyncResult): MessageWdsGetDormancyStatusOutput;
        /**
         * Asynchronously sends a Get LTE Attach Parameters request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_lte_attach_parameters_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_lte_attach_parameters(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetLteAttachParametersOutput>;
        /**
         * Asynchronously sends a Get LTE Attach Parameters request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_lte_attach_parameters_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_lte_attach_parameters(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get LTE Attach Parameters request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_lte_attach_parameters_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_lte_attach_parameters(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetLteAttachParametersOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_lte_attach_parameters().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_lte_attach_parameters().
         * @returns a #QmiMessageWdsGetLteAttachParametersOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_lte_attach_parameters_output_unref().
         */
        get_lte_attach_parameters_finish(res: Gio.AsyncResult): MessageWdsGetLteAttachParametersOutput;
        /**
         * Asynchronously sends a Get LTE Attach PDN List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_lte_attach_pdn_list_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_lte_attach_pdn_list(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetLteAttachPdnListOutput>;
        /**
         * Asynchronously sends a Get LTE Attach PDN List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_lte_attach_pdn_list_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_lte_attach_pdn_list(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get LTE Attach PDN List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_lte_attach_pdn_list_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_lte_attach_pdn_list(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetLteAttachPdnListOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_lte_attach_pdn_list().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_lte_attach_pdn_list().
         * @returns a #QmiMessageWdsGetLteAttachPdnListOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_lte_attach_pdn_list_output_unref().
         */
        get_lte_attach_pdn_list_finish(res: Gio.AsyncResult): MessageWdsGetLteAttachPdnListOutput;
        /**
         * Asynchronously sends a Get Max LTE Attach PDN Number request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_max_lte_attach_pdn_number_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_max_lte_attach_pdn_number(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetMaxLteAttachPdnNumberOutput>;
        /**
         * Asynchronously sends a Get Max LTE Attach PDN Number request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_max_lte_attach_pdn_number_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_max_lte_attach_pdn_number(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Max LTE Attach PDN Number request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_max_lte_attach_pdn_number_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_max_lte_attach_pdn_number(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetMaxLteAttachPdnNumberOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_max_lte_attach_pdn_number().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_max_lte_attach_pdn_number().
         * @returns a #QmiMessageWdsGetMaxLteAttachPdnNumberOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_max_lte_attach_pdn_number_output_unref().
         */
        get_max_lte_attach_pdn_number_finish(res: Gio.AsyncResult): MessageWdsGetMaxLteAttachPdnNumberOutput;
        /**
         * Asynchronously sends a Get Packet Service Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_packet_service_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_packet_service_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetPacketServiceStatusOutput>;
        /**
         * Asynchronously sends a Get Packet Service Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_packet_service_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_packet_service_status(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Packet Service Status request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_packet_service_status_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_packet_service_status(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetPacketServiceStatusOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_packet_service_status().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_packet_service_status().
         * @returns a #QmiMessageWdsGetPacketServiceStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_packet_service_status_output_unref().
         */
        get_packet_service_status_finish(res: Gio.AsyncResult): MessageWdsGetPacketServiceStatusOutput;
        /**
         * Asynchronously sends a Get Packet Statistics request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_packet_statistics_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetPacketStatisticsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_packet_statistics(
            input: MessageWdsGetPacketStatisticsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetPacketStatisticsOutput>;
        /**
         * Asynchronously sends a Get Packet Statistics request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_packet_statistics_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetPacketStatisticsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_packet_statistics(
            input: MessageWdsGetPacketStatisticsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Packet Statistics request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_packet_statistics_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetPacketStatisticsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_packet_statistics(
            input: MessageWdsGetPacketStatisticsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetPacketStatisticsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_packet_statistics().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_packet_statistics().
         * @returns a #QmiMessageWdsGetPacketStatisticsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_packet_statistics_output_unref().
         */
        get_packet_statistics_finish(res: Gio.AsyncResult): MessageWdsGetPacketStatisticsOutput;
        /**
         * Asynchronously sends a Get PDN Throttle Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_pdn_throttle_info_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetPdnThrottleInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_pdn_throttle_info(
            input: MessageWdsGetPdnThrottleInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetPdnThrottleInfoOutput>;
        /**
         * Asynchronously sends a Get PDN Throttle Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_pdn_throttle_info_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetPdnThrottleInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_pdn_throttle_info(
            input: MessageWdsGetPdnThrottleInfoInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get PDN Throttle Info request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_pdn_throttle_info_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetPdnThrottleInfoInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_pdn_throttle_info(
            input: MessageWdsGetPdnThrottleInfoInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetPdnThrottleInfoOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_pdn_throttle_info().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_pdn_throttle_info().
         * @returns a #QmiMessageWdsGetPdnThrottleInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_pdn_throttle_info_output_unref().
         */
        get_pdn_throttle_info_finish(res: Gio.AsyncResult): MessageWdsGetPdnThrottleInfoOutput;
        /**
         * Asynchronously sends a Get Profile List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_profile_list_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetProfileListInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_profile_list(
            input: MessageWdsGetProfileListInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetProfileListOutput>;
        /**
         * Asynchronously sends a Get Profile List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_profile_list_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetProfileListInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_profile_list(
            input: MessageWdsGetProfileListInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Profile List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_profile_list_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetProfileListInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_profile_list(
            input: MessageWdsGetProfileListInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetProfileListOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_profile_list().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_profile_list().
         * @returns a #QmiMessageWdsGetProfileListOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_profile_list_output_unref().
         */
        get_profile_list_finish(res: Gio.AsyncResult): MessageWdsGetProfileListOutput;
        /**
         * Asynchronously sends a Get Profile Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_profile_settings_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetProfileSettingsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_profile_settings(
            input: MessageWdsGetProfileSettingsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetProfileSettingsOutput>;
        /**
         * Asynchronously sends a Get Profile Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_profile_settings_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetProfileSettingsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_profile_settings(
            input: MessageWdsGetProfileSettingsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Profile Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_profile_settings_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsGetProfileSettingsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_profile_settings(
            input: MessageWdsGetProfileSettingsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetProfileSettingsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_profile_settings().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_profile_settings().
         * @returns a #QmiMessageWdsGetProfileSettingsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_profile_settings_output_unref().
         */
        get_profile_settings_finish(res: Gio.AsyncResult): MessageWdsGetProfileSettingsOutput;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGetSupportedMessagesOutput>;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGetSupportedMessagesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_get_supported_messages().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_get_supported_messages().
         * @returns a #QmiMessageWdsGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_get_supported_messages_output_unref().
         */
        get_supported_messages_finish(res: Gio.AsyncResult): MessageWdsGetSupportedMessagesOutput;
        /**
         * Asynchronously sends a Go Active request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_go_active_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        go_active(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGoActiveOutput>;
        /**
         * Asynchronously sends a Go Active request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_go_active_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        go_active(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Go Active request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_go_active_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        go_active(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGoActiveOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_go_active().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_go_active().
         * @returns a #QmiMessageWdsGoActiveOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_go_active_output_unref().
         */
        go_active_finish(res: Gio.AsyncResult): MessageWdsGoActiveOutput;
        /**
         * Asynchronously sends a Go Dormant request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_go_dormant_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        go_dormant(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsGoDormantOutput>;
        /**
         * Asynchronously sends a Go Dormant request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_go_dormant_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        go_dormant(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Go Dormant request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_go_dormant_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        go_dormant(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsGoDormantOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_go_dormant().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_go_dormant().
         * @returns a #QmiMessageWdsGoDormantOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_go_dormant_output_unref().
         */
        go_dormant_finish(res: Gio.AsyncResult): MessageWdsGoDormantOutput;
        /**
         * Asynchronously sends a Indication Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_indication_register_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsIndicationRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        indication_register(
            input: MessageWdsIndicationRegisterInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsIndicationRegisterOutput>;
        /**
         * Asynchronously sends a Indication Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_indication_register_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsIndicationRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        indication_register(
            input: MessageWdsIndicationRegisterInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Indication Register request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_indication_register_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsIndicationRegisterInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        indication_register(
            input: MessageWdsIndicationRegisterInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsIndicationRegisterOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_indication_register().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_indication_register().
         * @returns a #QmiMessageWdsIndicationRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_indication_register_output_unref().
         */
        indication_register_finish(res: Gio.AsyncResult): MessageWdsIndicationRegisterOutput;
        /**
         * Asynchronously sends a Modify Profile request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_modify_profile_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsModifyProfileInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        modify_profile(
            input: MessageWdsModifyProfileInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsModifyProfileOutput>;
        /**
         * Asynchronously sends a Modify Profile request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_modify_profile_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsModifyProfileInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        modify_profile(
            input: MessageWdsModifyProfileInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Modify Profile request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_modify_profile_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsModifyProfileInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        modify_profile(
            input: MessageWdsModifyProfileInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsModifyProfileOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_modify_profile().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_modify_profile().
         * @returns a #QmiMessageWdsModifyProfileOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_modify_profile_output_unref().
         */
        modify_profile_finish(res: Gio.AsyncResult): MessageWdsModifyProfileOutput;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsResetOutput>;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsResetOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_reset().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_reset().
         * @returns a #QmiMessageWdsResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_reset_output_unref().
         */
        reset_finish(res: Gio.AsyncResult): MessageWdsResetOutput;
        /**
         * Asynchronously sends a Set Autoconnect Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_autoconnect_settings_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetAutoconnectSettingsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_autoconnect_settings(
            input: MessageWdsSetAutoconnectSettingsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsSetAutoconnectSettingsOutput>;
        /**
         * Asynchronously sends a Set Autoconnect Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_autoconnect_settings_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetAutoconnectSettingsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_autoconnect_settings(
            input: MessageWdsSetAutoconnectSettingsInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Autoconnect Settings request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_autoconnect_settings_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetAutoconnectSettingsInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_autoconnect_settings(
            input: MessageWdsSetAutoconnectSettingsInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsSetAutoconnectSettingsOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_set_autoconnect_settings().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_set_autoconnect_settings().
         * @returns a #QmiMessageWdsSetAutoconnectSettingsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_set_autoconnect_settings_output_unref().
         */
        set_autoconnect_settings_finish(res: Gio.AsyncResult): MessageWdsSetAutoconnectSettingsOutput;
        /**
         * Asynchronously sends a Set Default Profile Number request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_default_profile_number_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetDefaultProfileNumberInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_default_profile_number(
            input: MessageWdsSetDefaultProfileNumberInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsSetDefaultProfileNumberOutput>;
        /**
         * Asynchronously sends a Set Default Profile Number request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_default_profile_number_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetDefaultProfileNumberInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_default_profile_number(
            input: MessageWdsSetDefaultProfileNumberInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Default Profile Number request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_default_profile_number_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetDefaultProfileNumberInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_default_profile_number(
            input: MessageWdsSetDefaultProfileNumberInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsSetDefaultProfileNumberOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_set_default_profile_number().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_set_default_profile_number().
         * @returns a #QmiMessageWdsSetDefaultProfileNumberOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_set_default_profile_number_output_unref().
         */
        set_default_profile_number_finish(res: Gio.AsyncResult): MessageWdsSetDefaultProfileNumberOutput;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_event_report(
            input: MessageWdsSetEventReportInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsSetEventReportOutput>;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_event_report(
            input: MessageWdsSetEventReportInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_event_report(
            input: MessageWdsSetEventReportInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsSetEventReportOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_set_event_report().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_set_event_report().
         * @returns a #QmiMessageWdsSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_set_event_report_output_unref().
         */
        set_event_report_finish(res: Gio.AsyncResult): MessageWdsSetEventReportOutput;
        /**
         * Asynchronously sends a Set IP Family request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_ip_family_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetIpFamilyInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_ip_family(
            input: MessageWdsSetIpFamilyInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsSetIpFamilyOutput>;
        /**
         * Asynchronously sends a Set IP Family request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_ip_family_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetIpFamilyInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_ip_family(
            input: MessageWdsSetIpFamilyInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set IP Family request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_ip_family_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetIpFamilyInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_ip_family(
            input: MessageWdsSetIpFamilyInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsSetIpFamilyOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_set_ip_family().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_set_ip_family().
         * @returns a #QmiMessageWdsSetIpFamilyOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_set_ip_family_output_unref().
         */
        set_ip_family_finish(res: Gio.AsyncResult): MessageWdsSetIpFamilyOutput;
        /**
         * Asynchronously sends a Set LTE Attach PDN List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_lte_attach_pdn_list_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetLteAttachPdnListInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_lte_attach_pdn_list(
            input: MessageWdsSetLteAttachPdnListInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsSetLteAttachPdnListOutput>;
        /**
         * Asynchronously sends a Set LTE Attach PDN List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_lte_attach_pdn_list_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetLteAttachPdnListInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_lte_attach_pdn_list(
            input: MessageWdsSetLteAttachPdnListInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set LTE Attach PDN List request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_set_lte_attach_pdn_list_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSetLteAttachPdnListInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_lte_attach_pdn_list(
            input: MessageWdsSetLteAttachPdnListInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsSetLteAttachPdnListOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_set_lte_attach_pdn_list().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_set_lte_attach_pdn_list().
         * @returns a #QmiMessageWdsSetLteAttachPdnListOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_set_lte_attach_pdn_list_output_unref().
         */
        set_lte_attach_pdn_list_finish(res: Gio.AsyncResult): MessageWdsSetLteAttachPdnListOutput;
        /**
         * Asynchronously sends a Start Network request to the device.
         *
         * This message is abortable. If `cancellable` is cancelled or if `timeout` expires,
         * an abort request will be sent to the device, and the asynchronous operation will
         * not return until the abort response is received. It is not an error if a successful
         * response is returned for the asynchronous operation even after the user has cancelled
         * the cancellable, because it may happen that the response is received before the
         * modem had a chance to run the abort.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_start_network_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsStartNetworkInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        start_network(
            input: MessageWdsStartNetworkInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsStartNetworkOutput>;
        /**
         * Asynchronously sends a Start Network request to the device.
         *
         * This message is abortable. If `cancellable` is cancelled or if `timeout` expires,
         * an abort request will be sent to the device, and the asynchronous operation will
         * not return until the abort response is received. It is not an error if a successful
         * response is returned for the asynchronous operation even after the user has cancelled
         * the cancellable, because it may happen that the response is received before the
         * modem had a chance to run the abort.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_start_network_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsStartNetworkInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        start_network(
            input: MessageWdsStartNetworkInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Start Network request to the device.
         *
         * This message is abortable. If `cancellable` is cancelled or if `timeout` expires,
         * an abort request will be sent to the device, and the asynchronous operation will
         * not return until the abort response is received. It is not an error if a successful
         * response is returned for the asynchronous operation even after the user has cancelled
         * the cancellable, because it may happen that the response is received before the
         * modem had a chance to run the abort.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_start_network_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsStartNetworkInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        start_network(
            input: MessageWdsStartNetworkInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsStartNetworkOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_start_network().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_start_network().
         * @returns a #QmiMessageWdsStartNetworkOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_start_network_output_unref().
         */
        start_network_finish(res: Gio.AsyncResult): MessageWdsStartNetworkOutput;
        /**
         * Asynchronously sends a Stop Network request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_stop_network_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsStopNetworkInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        stop_network(
            input: MessageWdsStopNetworkInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsStopNetworkOutput>;
        /**
         * Asynchronously sends a Stop Network request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_stop_network_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsStopNetworkInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        stop_network(
            input: MessageWdsStopNetworkInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Stop Network request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_stop_network_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsStopNetworkInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        stop_network(
            input: MessageWdsStopNetworkInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsStopNetworkOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_stop_network().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_stop_network().
         * @returns a #QmiMessageWdsStopNetworkOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_stop_network_output_unref().
         */
        stop_network_finish(res: Gio.AsyncResult): MessageWdsStopNetworkOutput;
        /**
         * Asynchronously sends a Swi Create Profile Indexed request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_swi_create_profile_indexed_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSwiCreateProfileIndexedInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        swi_create_profile_indexed(
            input: MessageWdsSwiCreateProfileIndexedInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWdsSwiCreateProfileIndexedOutput>;
        /**
         * Asynchronously sends a Swi Create Profile Indexed request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_swi_create_profile_indexed_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSwiCreateProfileIndexedInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        swi_create_profile_indexed(
            input: MessageWdsSwiCreateProfileIndexedInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Swi Create Profile Indexed request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wds_swi_create_profile_indexed_finish() to get the result of the operation.
         * @param input a #QmiMessageWdsSwiCreateProfileIndexedInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        swi_create_profile_indexed(
            input: MessageWdsSwiCreateProfileIndexedInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWdsSwiCreateProfileIndexedOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wds_swi_create_profile_indexed().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wds_swi_create_profile_indexed().
         * @returns a #QmiMessageWdsSwiCreateProfileIndexedOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wds_swi_create_profile_indexed_output_unref().
         */
        swi_create_profile_indexed_finish(res: Gio.AsyncResult): MessageWdsSwiCreateProfileIndexedOutput;
    }

    module ClientWms {
        // Signal callback interfaces

        interface EventReport {
            (output: IndicationWmsEventReportOutput): void;
        }

        interface SmscAddress {
            (output: IndicationWmsSmscAddressOutput): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Client.ConstructorProps {}
    }

    /**
     * The #QmiClientWms structure contains private data and should only be accessed
     * using the provided API.
     */
    class ClientWms extends Client {
        static $gtype: GObject.GType<ClientWms>;

        // Constructors

        constructor(properties?: Partial<ClientWms.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'event-report',
            callback: (_source: this, output: IndicationWmsEventReportOutput) => void,
        ): number;
        connect_after(
            signal: 'event-report',
            callback: (_source: this, output: IndicationWmsEventReportOutput) => void,
        ): number;
        emit(signal: 'event-report', output: IndicationWmsEventReportOutput): void;
        connect(
            signal: 'smsc-address',
            callback: (_source: this, output: IndicationWmsSmscAddressOutput) => void,
        ): number;
        connect_after(
            signal: 'smsc-address',
            callback: (_source: this, output: IndicationWmsSmscAddressOutput) => void,
        ): number;
        emit(signal: 'smsc-address', output: IndicationWmsSmscAddressOutput): void;

        // Methods

        /**
         * Asynchronously sends a Delete request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_delete_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsDeleteInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        ['delete'](
            input: MessageWmsDeleteInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsDeleteOutput>;
        /**
         * Asynchronously sends a Delete request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_delete_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsDeleteInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        ['delete'](
            input: MessageWmsDeleteInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Delete request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_delete_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsDeleteInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        ['delete'](
            input: MessageWmsDeleteInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsDeleteOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_delete().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_delete().
         * @returns a #QmiMessageWmsDeleteOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_delete_output_unref().
         */
        delete_finish(res: Gio.AsyncResult): MessageWmsDeleteOutput;
        /**
         * Asynchronously sends a Get Message Protocol request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_get_message_protocol_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_message_protocol(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsGetMessageProtocolOutput>;
        /**
         * Asynchronously sends a Get Message Protocol request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_get_message_protocol_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_message_protocol(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Message Protocol request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_get_message_protocol_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_message_protocol(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsGetMessageProtocolOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_get_message_protocol().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_get_message_protocol().
         * @returns a #QmiMessageWmsGetMessageProtocolOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_get_message_protocol_output_unref().
         */
        get_message_protocol_finish(res: Gio.AsyncResult): MessageWmsGetMessageProtocolOutput;
        /**
         * Asynchronously sends a Get Routes request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_get_routes_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_routes(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsGetRoutesOutput>;
        /**
         * Asynchronously sends a Get Routes request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_get_routes_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_routes(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Routes request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_get_routes_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_routes(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsGetRoutesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_get_routes().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_get_routes().
         * @returns a #QmiMessageWmsGetRoutesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_get_routes_output_unref().
         */
        get_routes_finish(res: Gio.AsyncResult): MessageWmsGetRoutesOutput;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsGetSupportedMessagesOutput>;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Get Supported Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_get_supported_messages_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_supported_messages(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsGetSupportedMessagesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_get_supported_messages().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_get_supported_messages().
         * @returns a #QmiMessageWmsGetSupportedMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_get_supported_messages_output_unref().
         */
        get_supported_messages_finish(res: Gio.AsyncResult): MessageWmsGetSupportedMessagesOutput;
        /**
         * Asynchronously sends a List Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_list_messages_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsListMessagesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        list_messages(
            input: MessageWmsListMessagesInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsListMessagesOutput>;
        /**
         * Asynchronously sends a List Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_list_messages_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsListMessagesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        list_messages(
            input: MessageWmsListMessagesInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a List Messages request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_list_messages_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsListMessagesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        list_messages(
            input: MessageWmsListMessagesInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsListMessagesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_list_messages().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_list_messages().
         * @returns a #QmiMessageWmsListMessagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_list_messages_output_unref().
         */
        list_messages_finish(res: Gio.AsyncResult): MessageWmsListMessagesOutput;
        /**
         * Asynchronously sends a Modify Tag request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_modify_tag_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsModifyTagInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        modify_tag(
            input: MessageWmsModifyTagInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsModifyTagOutput>;
        /**
         * Asynchronously sends a Modify Tag request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_modify_tag_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsModifyTagInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        modify_tag(
            input: MessageWmsModifyTagInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Modify Tag request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_modify_tag_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsModifyTagInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        modify_tag(
            input: MessageWmsModifyTagInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsModifyTagOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_modify_tag().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_modify_tag().
         * @returns a #QmiMessageWmsModifyTagOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_modify_tag_output_unref().
         */
        modify_tag_finish(res: Gio.AsyncResult): MessageWmsModifyTagOutput;
        /**
         * Asynchronously sends a Raw Read request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_raw_read_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsRawReadInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        raw_read(
            input: MessageWmsRawReadInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsRawReadOutput>;
        /**
         * Asynchronously sends a Raw Read request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_raw_read_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsRawReadInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        raw_read(
            input: MessageWmsRawReadInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Raw Read request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_raw_read_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsRawReadInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        raw_read(
            input: MessageWmsRawReadInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsRawReadOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_raw_read().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_raw_read().
         * @returns a #QmiMessageWmsRawReadOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_raw_read_output_unref().
         */
        raw_read_finish(res: Gio.AsyncResult): MessageWmsRawReadOutput;
        /**
         * Asynchronously sends a Raw Send request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_raw_send_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsRawSendInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        raw_send(
            input: MessageWmsRawSendInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsRawSendOutput>;
        /**
         * Asynchronously sends a Raw Send request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_raw_send_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsRawSendInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        raw_send(
            input: MessageWmsRawSendInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Raw Send request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_raw_send_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsRawSendInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        raw_send(
            input: MessageWmsRawSendInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsRawSendOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_raw_send().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_raw_send().
         * @returns a #QmiMessageWmsRawSendOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_raw_send_output_unref().
         */
        raw_send_finish(res: Gio.AsyncResult): MessageWmsRawSendOutput;
        /**
         * Asynchronously sends a Raw Write request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_raw_write_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsRawWriteInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        raw_write(
            input: MessageWmsRawWriteInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsRawWriteOutput>;
        /**
         * Asynchronously sends a Raw Write request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_raw_write_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsRawWriteInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        raw_write(
            input: MessageWmsRawWriteInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Raw Write request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_raw_write_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsRawWriteInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        raw_write(
            input: MessageWmsRawWriteInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsRawWriteOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_raw_write().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_raw_write().
         * @returns a #QmiMessageWmsRawWriteOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_raw_write_output_unref().
         */
        raw_write_finish(res: Gio.AsyncResult): MessageWmsRawWriteOutput;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsResetOutput>;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Reset request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_reset_finish() to get the result of the operation.
         * @param unused %NULL. This message doesn't have any input bundle.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        reset(
            unused: any | null,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsResetOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_reset().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_reset().
         * @returns a #QmiMessageWmsResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_reset_output_unref().
         */
        reset_finish(res: Gio.AsyncResult): MessageWmsResetOutput;
        /**
         * Asynchronously sends a Send Ack request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_send_ack_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsSendAckInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        send_ack(
            input: MessageWmsSendAckInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsSendAckOutput>;
        /**
         * Asynchronously sends a Send Ack request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_send_ack_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsSendAckInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        send_ack(
            input: MessageWmsSendAckInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Send Ack request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_send_ack_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsSendAckInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        send_ack(
            input: MessageWmsSendAckInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsSendAckOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_send_ack().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_send_ack().
         * @returns a #QmiMessageWmsSendAckOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_send_ack_output_unref().
         */
        send_ack_finish(res: Gio.AsyncResult): MessageWmsSendAckOutput;
        /**
         * Asynchronously sends a Send From Memory Storage request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_send_from_memory_storage_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsSendFromMemoryStorageInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        send_from_memory_storage(
            input: MessageWmsSendFromMemoryStorageInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsSendFromMemoryStorageOutput>;
        /**
         * Asynchronously sends a Send From Memory Storage request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_send_from_memory_storage_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsSendFromMemoryStorageInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        send_from_memory_storage(
            input: MessageWmsSendFromMemoryStorageInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Send From Memory Storage request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_send_from_memory_storage_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsSendFromMemoryStorageInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        send_from_memory_storage(
            input: MessageWmsSendFromMemoryStorageInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsSendFromMemoryStorageOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_send_from_memory_storage().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_send_from_memory_storage().
         * @returns a #QmiMessageWmsSendFromMemoryStorageOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_send_from_memory_storage_output_unref().
         */
        send_from_memory_storage_finish(res: Gio.AsyncResult): MessageWmsSendFromMemoryStorageOutput;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_event_report(
            input: MessageWmsSetEventReportInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsSetEventReportOutput>;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_event_report(
            input: MessageWmsSetEventReportInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Event Report request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_set_event_report_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsSetEventReportInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_event_report(
            input: MessageWmsSetEventReportInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsSetEventReportOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_set_event_report().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_set_event_report().
         * @returns a #QmiMessageWmsSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_set_event_report_output_unref().
         */
        set_event_report_finish(res: Gio.AsyncResult): MessageWmsSetEventReportOutput;
        /**
         * Asynchronously sends a Set Routes request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_set_routes_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsSetRoutesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        set_routes(
            input: MessageWmsSetRoutesInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<MessageWmsSetRoutesOutput>;
        /**
         * Asynchronously sends a Set Routes request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_set_routes_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsSetRoutesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_routes(
            input: MessageWmsSetRoutesInput,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a Set Routes request to the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_client_wms_set_routes_finish() to get the result of the operation.
         * @param input a #QmiMessageWmsSetRoutesInput.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        set_routes(
            input: MessageWmsSetRoutesInput,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<MessageWmsSetRoutesOutput> | void;
        /**
         * Finishes an async operation started with qmi_client_wms_set_routes().
         * @param res the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_wms_set_routes().
         * @returns a #QmiMessageWmsSetRoutesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_wms_set_routes_output_unref().
         */
        set_routes_finish(res: Gio.AsyncResult): MessageWmsSetRoutesOutput;
    }

    module Device {
        // Signal callback interfaces

        interface DeviceRemoved {
            (): void;
        }

        interface Indication {
            (output: Uint8Array | string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Gio.AsyncInitable.ConstructorProps {
            device_consecutive_timeouts: number;
            deviceConsecutiveTimeouts: number;
            device_file: Gio.File;
            deviceFile: Gio.File;
            device_no_file_check: boolean;
            deviceNoFileCheck: boolean;
            device_node: Qrtr.Node;
            deviceNode: Qrtr.Node;
            device_proxy_path: string;
            deviceProxyPath: string;
            device_wwan_iface: string;
            deviceWwanIface: string;
        }
    }

    /**
     * The #QmiDevice structure contains private data and should only be accessed
     * using the provided API.
     */
    class Device extends GObject.Object implements Gio.AsyncInitable<Device> {
        static $gtype: GObject.GType<Device>;

        // Properties

        get device_consecutive_timeouts(): number;
        get deviceConsecutiveTimeouts(): number;
        get device_file(): Gio.File;
        get deviceFile(): Gio.File;
        set device_no_file_check(val: boolean);
        set deviceNoFileCheck(val: boolean);
        get device_node(): Qrtr.Node;
        get deviceNode(): Qrtr.Node;
        set device_proxy_path(val: string);
        set deviceProxyPath(val: string);
        get device_wwan_iface(): string;
        get deviceWwanIface(): string;

        // Constructors

        constructor(properties?: Partial<Device.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_finish(res: Gio.AsyncResult): Device;
        // Conflicted with Gio.AsyncInitable.new_finish

        static new_finish(...args: never[]): any;

        static new_from_node_finish(res: Gio.AsyncResult): Device;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'device-removed', callback: (_source: this) => void): number;
        connect_after(signal: 'device-removed', callback: (_source: this) => void): number;
        emit(signal: 'device-removed'): void;
        connect(signal: 'indication', callback: (_source: this, output: Uint8Array) => void): number;
        connect_after(signal: 'indication', callback: (_source: this, output: Uint8Array) => void): number;
        emit(signal: 'indication', output: Uint8Array | string): void;

        // Static methods

        /**
         * Asynchronously creates a #QmiDevice object to manage `file`.
         * When the operation is finished, `callback` will be invoked. You can then call
         * qmi_device_new_finish() to get the result of the operation.
         * @param file a #GFile.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the initialization is finished.
         */
        static ['new'](
            file: Gio.File,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<Device> | null,
        ): void;
        /**
         * Asynchronously creates a #QmiDevice object to manage `node`.
         * When the operation is finished, `callback` will be invoked. You can then call
         * qmi_device_new_finish() to get the result of the operation.
         *
         * <note><para>
         * This method is only available when the library is built with QRTR support.
         * </para></note>
         * @param node a #QrtrNode.
         * @param cancellable optional #GCancellable object, #NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the initialization is finished.
         */
        static new_from_node(
            node: Qrtr.Node,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<Device> | null,
        ): void;

        // Methods

        /**
         * Asynchronously creates a new virtual network device node with a custom prefix
         * on top of `base_ifname`. This allows having multiple net interfaces running on
         * top of another using multiplexing.
         *
         * If the kernel driver doesn't allow this functionality, a
         * %QMI_CORE_ERROR_UNSUPPORTED error will be returned.
         *
         * The operation may fail if the given interface name is not associated to the
         * QMI control port managed by the #QmiDevice.
         *
         * Depending on the kernel driver in use and the multiplexing method, the given
         * `ifname_prefix` may be ignored. The user should not assume that the returned
         * link interface name is prefixed with `ifname_prefix` as it may not be the
         * case.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_add_link_finish() to get the result of the operation.
         *
         * <note><para>
         * When using the qmi_wwan kernel driver, the configured expected kernel data
         * format will be used to select the type of multiplexing method. If the
         * format is %QMI_DEVICE_EXPECTED_DATA_FORMAT_RAW_IP the qmi_wwan specific
         * add_mux/del_mux operations will be used. If the format is
         * %QMI_DEVICE_EXPECTED_DATA_FORMAT_QMAP_PASS_THROUGH, the generic rmnet netlink
         * operations will be used. No multiplexing support exists when the format is
         * %QMI_DEVICE_EXPECTED_DATA_FORMAT_802_3.
         * </para><para>
         * For every other kernel driver (e.g. ipa), rmnet netlink operations are
         * assumed to be supported.
         * </para></note>
         *
         * <note><para>
         * When using the qmi_wwan driver from a kernel older than v5.12, some of the
         * multiplexing features like using %QMI_DEVICE_MUX_ID_AUTOMATIC may not be fully
         * available for programs that use ephimeral #QmiDevice objects for single
         * operations.
         * </para></note>
         * @param mux_id the mux id for the link, in the   [%QMI_DEVICE_MUX_ID_MIN,%QMI_DEVICE_MUX_ID_MAX] range, or   %QMI_DEVICE_MUX_ID_AUTOMATIC to find the first available mux id.
         * @param base_ifname the interface which the new link will be created on.
         * @param ifname_prefix the prefix suggested to be used for the name of the new link   created.
         * @param cancellable a #GCancellable, or %NULL.
         */
        add_link(
            mux_id: number,
            base_ifname: string,
            ifname_prefix: string,
            cancellable?: Gio.Cancellable | null,
        ): Promise<string>;
        /**
         * Asynchronously creates a new virtual network device node with a custom prefix
         * on top of `base_ifname`. This allows having multiple net interfaces running on
         * top of another using multiplexing.
         *
         * If the kernel driver doesn't allow this functionality, a
         * %QMI_CORE_ERROR_UNSUPPORTED error will be returned.
         *
         * The operation may fail if the given interface name is not associated to the
         * QMI control port managed by the #QmiDevice.
         *
         * Depending on the kernel driver in use and the multiplexing method, the given
         * `ifname_prefix` may be ignored. The user should not assume that the returned
         * link interface name is prefixed with `ifname_prefix` as it may not be the
         * case.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_add_link_finish() to get the result of the operation.
         *
         * <note><para>
         * When using the qmi_wwan kernel driver, the configured expected kernel data
         * format will be used to select the type of multiplexing method. If the
         * format is %QMI_DEVICE_EXPECTED_DATA_FORMAT_RAW_IP the qmi_wwan specific
         * add_mux/del_mux operations will be used. If the format is
         * %QMI_DEVICE_EXPECTED_DATA_FORMAT_QMAP_PASS_THROUGH, the generic rmnet netlink
         * operations will be used. No multiplexing support exists when the format is
         * %QMI_DEVICE_EXPECTED_DATA_FORMAT_802_3.
         * </para><para>
         * For every other kernel driver (e.g. ipa), rmnet netlink operations are
         * assumed to be supported.
         * </para></note>
         *
         * <note><para>
         * When using the qmi_wwan driver from a kernel older than v5.12, some of the
         * multiplexing features like using %QMI_DEVICE_MUX_ID_AUTOMATIC may not be fully
         * available for programs that use ephimeral #QmiDevice objects for single
         * operations.
         * </para></note>
         * @param mux_id the mux id for the link, in the   [%QMI_DEVICE_MUX_ID_MIN,%QMI_DEVICE_MUX_ID_MAX] range, or   %QMI_DEVICE_MUX_ID_AUTOMATIC to find the first available mux id.
         * @param base_ifname the interface which the new link will be created on.
         * @param ifname_prefix the prefix suggested to be used for the name of the new link   created.
         * @param cancellable a #GCancellable, or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        add_link(
            mux_id: number,
            base_ifname: string,
            ifname_prefix: string,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously creates a new virtual network device node with a custom prefix
         * on top of `base_ifname`. This allows having multiple net interfaces running on
         * top of another using multiplexing.
         *
         * If the kernel driver doesn't allow this functionality, a
         * %QMI_CORE_ERROR_UNSUPPORTED error will be returned.
         *
         * The operation may fail if the given interface name is not associated to the
         * QMI control port managed by the #QmiDevice.
         *
         * Depending on the kernel driver in use and the multiplexing method, the given
         * `ifname_prefix` may be ignored. The user should not assume that the returned
         * link interface name is prefixed with `ifname_prefix` as it may not be the
         * case.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_add_link_finish() to get the result of the operation.
         *
         * <note><para>
         * When using the qmi_wwan kernel driver, the configured expected kernel data
         * format will be used to select the type of multiplexing method. If the
         * format is %QMI_DEVICE_EXPECTED_DATA_FORMAT_RAW_IP the qmi_wwan specific
         * add_mux/del_mux operations will be used. If the format is
         * %QMI_DEVICE_EXPECTED_DATA_FORMAT_QMAP_PASS_THROUGH, the generic rmnet netlink
         * operations will be used. No multiplexing support exists when the format is
         * %QMI_DEVICE_EXPECTED_DATA_FORMAT_802_3.
         * </para><para>
         * For every other kernel driver (e.g. ipa), rmnet netlink operations are
         * assumed to be supported.
         * </para></note>
         *
         * <note><para>
         * When using the qmi_wwan driver from a kernel older than v5.12, some of the
         * multiplexing features like using %QMI_DEVICE_MUX_ID_AUTOMATIC may not be fully
         * available for programs that use ephimeral #QmiDevice objects for single
         * operations.
         * </para></note>
         * @param mux_id the mux id for the link, in the   [%QMI_DEVICE_MUX_ID_MIN,%QMI_DEVICE_MUX_ID_MAX] range, or   %QMI_DEVICE_MUX_ID_AUTOMATIC to find the first available mux id.
         * @param base_ifname the interface which the new link will be created on.
         * @param ifname_prefix the prefix suggested to be used for the name of the new link   created.
         * @param cancellable a #GCancellable, or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        add_link(
            mux_id: number,
            base_ifname: string,
            ifname_prefix: string,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<string> | void;
        /**
         * Finishes an operation started with qmi_device_add_link().
         * @param res a #GAsyncResult.
         * @param mux_id the mux ID for the link created.
         * @returns The name of the net interface created, %NULL if @error is set.
         */
        add_link_finish(res: Gio.AsyncResult, mux_id: number): string;
        /**
         * Asynchronously creates a new virtual network device in the same way as
         * qmi_device_add_link() does, but passing the additional `flags` to the kernel
         * during the operation.
         *
         * Using %QMI_DEVICE_ADD_LINK_FLAGS_NONE as `flags` is equivalent to calling
         * qmi_device_add_link() directly.
         *
         * If the link creation with the given set of `flags` is unsupported by the
         * backend, the operation may fail.
         *
         * <note><para>
         * None of the `flags` supported are applicable when using the multiplexing
         * support provided by the qmi_wwan kernel driver, they are only used if using
         * the rmnet backend for link management support.
         * </para></note>
         * @param mux_id the mux id for the link, in the   [%QMI_DEVICE_MUX_ID_MIN,%QMI_DEVICE_MUX_ID_MAX] range, or   %QMI_DEVICE_MUX_ID_AUTOMATIC to find the first available mux id.
         * @param base_ifname the interface which the new link will be created on.
         * @param ifname_prefix the prefix suggested to be used for the name of the new link   created.
         * @param flags bitmask of %QmiDeviceAddLinkFlags values to pass to the kernel when   creating the new link.
         * @param cancellable a #GCancellable, or %NULL.
         */
        add_link_with_flags(
            mux_id: number,
            base_ifname: string,
            ifname_prefix: string,
            flags: DeviceAddLinkFlags,
            cancellable?: Gio.Cancellable | null,
        ): Promise<string>;
        /**
         * Asynchronously creates a new virtual network device in the same way as
         * qmi_device_add_link() does, but passing the additional `flags` to the kernel
         * during the operation.
         *
         * Using %QMI_DEVICE_ADD_LINK_FLAGS_NONE as `flags` is equivalent to calling
         * qmi_device_add_link() directly.
         *
         * If the link creation with the given set of `flags` is unsupported by the
         * backend, the operation may fail.
         *
         * <note><para>
         * None of the `flags` supported are applicable when using the multiplexing
         * support provided by the qmi_wwan kernel driver, they are only used if using
         * the rmnet backend for link management support.
         * </para></note>
         * @param mux_id the mux id for the link, in the   [%QMI_DEVICE_MUX_ID_MIN,%QMI_DEVICE_MUX_ID_MAX] range, or   %QMI_DEVICE_MUX_ID_AUTOMATIC to find the first available mux id.
         * @param base_ifname the interface which the new link will be created on.
         * @param ifname_prefix the prefix suggested to be used for the name of the new link   created.
         * @param flags bitmask of %QmiDeviceAddLinkFlags values to pass to the kernel when   creating the new link.
         * @param cancellable a #GCancellable, or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        add_link_with_flags(
            mux_id: number,
            base_ifname: string,
            ifname_prefix: string,
            flags: DeviceAddLinkFlags,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously creates a new virtual network device in the same way as
         * qmi_device_add_link() does, but passing the additional `flags` to the kernel
         * during the operation.
         *
         * Using %QMI_DEVICE_ADD_LINK_FLAGS_NONE as `flags` is equivalent to calling
         * qmi_device_add_link() directly.
         *
         * If the link creation with the given set of `flags` is unsupported by the
         * backend, the operation may fail.
         *
         * <note><para>
         * None of the `flags` supported are applicable when using the multiplexing
         * support provided by the qmi_wwan kernel driver, they are only used if using
         * the rmnet backend for link management support.
         * </para></note>
         * @param mux_id the mux id for the link, in the   [%QMI_DEVICE_MUX_ID_MIN,%QMI_DEVICE_MUX_ID_MAX] range, or   %QMI_DEVICE_MUX_ID_AUTOMATIC to find the first available mux id.
         * @param base_ifname the interface which the new link will be created on.
         * @param ifname_prefix the prefix suggested to be used for the name of the new link   created.
         * @param flags bitmask of %QmiDeviceAddLinkFlags values to pass to the kernel when   creating the new link.
         * @param cancellable a #GCancellable, or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        add_link_with_flags(
            mux_id: number,
            base_ifname: string,
            ifname_prefix: string,
            flags: DeviceAddLinkFlags,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<string> | void;
        /**
         * Finishes an operation started with qmi_device_add_link_finish().
         * @param res a #GAsyncResult.
         * @param mux_id the mux ID for the link created.
         * @returns The name of the net interface created, %NULL if @error is set.
         */
        add_link_with_flags_finish(res: Gio.AsyncResult, mux_id: number): string;
        /**
         * Asynchronously allocates a new #QmiClient in `self`.
         *
         * If %QMI_CID_NONE is given in `cid,` a new client ID will be allocated;
         * otherwise a client with the given `cid` will be generated.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_allocate_client_finish() to get the result of the operation.
         *
         * Note: Clients for the %QMI_SERVICE_CTL cannot be created with this method;
         * instead get/peek the implicit one from `self`.
         * @param service a valid #QmiService.
         * @param cid a valid client ID, or %QMI_CID_NONE.
         * @param timeout maximum time to wait.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        allocate_client(
            service: Service,
            cid: number,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<Client>;
        /**
         * Asynchronously allocates a new #QmiClient in `self`.
         *
         * If %QMI_CID_NONE is given in `cid,` a new client ID will be allocated;
         * otherwise a client with the given `cid` will be generated.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_allocate_client_finish() to get the result of the operation.
         *
         * Note: Clients for the %QMI_SERVICE_CTL cannot be created with this method;
         * instead get/peek the implicit one from `self`.
         * @param service a valid #QmiService.
         * @param cid a valid client ID, or %QMI_CID_NONE.
         * @param timeout maximum time to wait.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        allocate_client(
            service: Service,
            cid: number,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously allocates a new #QmiClient in `self`.
         *
         * If %QMI_CID_NONE is given in `cid,` a new client ID will be allocated;
         * otherwise a client with the given `cid` will be generated.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_allocate_client_finish() to get the result of the operation.
         *
         * Note: Clients for the %QMI_SERVICE_CTL cannot be created with this method;
         * instead get/peek the implicit one from `self`.
         * @param service a valid #QmiService.
         * @param cid a valid client ID, or %QMI_CID_NONE.
         * @param timeout maximum time to wait.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        allocate_client(
            service: Service,
            cid: number,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<Client> | void;
        /**
         * Finishes an operation started with qmi_device_allocate_client().
         * @param res a #GAsyncResult.
         * @returns a newly allocated #QmiClient, or %NULL if @error is set.
         */
        allocate_client_finish(res: Gio.AsyncResult): Client;
        /**
         * Checks whether the given data format is supported by the kernel.
         * interface.
         *
         * <note><para>
         * This method is only applicable when using the qmi_wwan kernel driver.
         * </para></note>
         * @param format a known #QmiDeviceExpectedDataFormat.
         * @returns %TRUE if the data format is supported, or %FALSE if @error is set.
         */
        check_expected_data_format_supported(format: DeviceExpectedDataFormat): boolean;
        /**
         * Checks whether link management is supported by the kernel.
         * @returns %TRUE if link management is supported, or %FALSE if @error is set.
         */
        check_link_supported(): boolean;
        /**
         * Asynchronously closes a #QmiDevice, preventing any further I/O.
         *
         * If this device was opened with `QMI_DEVICE_OPEN_FLAGS_MBIM,` this
         * operation will wait for the response of the underlying MBIM close
         * sequence.
         *
         * Closing a #QmiDevice multiple times will not return an error.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_close_finish() to get the result of the operation.
         * @param timeout maximum time, in seconds, to wait for the device to be closed.
         * @param cancellable a #GCancellable, or %NULL.
         */
        close_async(timeout: number, cancellable?: Gio.Cancellable | null): Promise<boolean>;
        /**
         * Asynchronously closes a #QmiDevice, preventing any further I/O.
         *
         * If this device was opened with `QMI_DEVICE_OPEN_FLAGS_MBIM,` this
         * operation will wait for the response of the underlying MBIM close
         * sequence.
         *
         * Closing a #QmiDevice multiple times will not return an error.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_close_finish() to get the result of the operation.
         * @param timeout maximum time, in seconds, to wait for the device to be closed.
         * @param cancellable a #GCancellable, or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        close_async(
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously closes a #QmiDevice, preventing any further I/O.
         *
         * If this device was opened with `QMI_DEVICE_OPEN_FLAGS_MBIM,` this
         * operation will wait for the response of the underlying MBIM close
         * sequence.
         *
         * Closing a #QmiDevice multiple times will not return an error.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_close_finish() to get the result of the operation.
         * @param timeout maximum time, in seconds, to wait for the device to be closed.
         * @param cancellable a #GCancellable, or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        close_async(
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<boolean> | void;
        /**
         * Finishes an operation started with qmi_device_close_async().
         * @param res a #GAsyncResult.
         * @returns %TRUE if successful, %FALSE if @error is set.
         */
        close_finish(res: Gio.AsyncResult): boolean;
        /**
         * Finishes an operation started with qmi_device_command_abortable().
         * @param res a #GAsyncResult.
         * @returns a #QmiMessage response, or %NULL if @error is set. The returned value should be freed with qmi_message_unref().
         */
        command_abortable_finish(res: Gio.AsyncResult): Message;
        /**
         * Asynchronously sends a #QmiMessage to the device.
         *
         * The message will be processed according to the specific `message_context`
         * given. If no `context` given, the behavior is the same as qmi_device_command().
         *
         * If the operation is cancelled via `cancellable,` a %QMI_PROTOCOL_ERROR_ABORTED
         * error will be returned always. If the QMI method may be aborted, there is
         * no guarantee that the operation is truly aborted before the error is returned
         * so it may really happen that the operation really succeeded and the method
         * would still return %QMI_PROTOCOL_ERROR_ABORTED. In order to use abortable
         * methods and make sure the response is the correct one, use
         * qmi_device_command_abortable().
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_command_full_finish() to get the result of the operation.
         * @param message the message to send.
         * @param message_context the context of the message.
         * @param timeout maximum time, in seconds, to wait for the response.
         * @param cancellable a #GCancellable, or %NULL.
         */
        command_full(
            message: Message,
            message_context: MessageContext,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<Message>;
        /**
         * Asynchronously sends a #QmiMessage to the device.
         *
         * The message will be processed according to the specific `message_context`
         * given. If no `context` given, the behavior is the same as qmi_device_command().
         *
         * If the operation is cancelled via `cancellable,` a %QMI_PROTOCOL_ERROR_ABORTED
         * error will be returned always. If the QMI method may be aborted, there is
         * no guarantee that the operation is truly aborted before the error is returned
         * so it may really happen that the operation really succeeded and the method
         * would still return %QMI_PROTOCOL_ERROR_ABORTED. In order to use abortable
         * methods and make sure the response is the correct one, use
         * qmi_device_command_abortable().
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_command_full_finish() to get the result of the operation.
         * @param message the message to send.
         * @param message_context the context of the message.
         * @param timeout maximum time, in seconds, to wait for the response.
         * @param cancellable a #GCancellable, or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        command_full(
            message: Message,
            message_context: MessageContext,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously sends a #QmiMessage to the device.
         *
         * The message will be processed according to the specific `message_context`
         * given. If no `context` given, the behavior is the same as qmi_device_command().
         *
         * If the operation is cancelled via `cancellable,` a %QMI_PROTOCOL_ERROR_ABORTED
         * error will be returned always. If the QMI method may be aborted, there is
         * no guarantee that the operation is truly aborted before the error is returned
         * so it may really happen that the operation really succeeded and the method
         * would still return %QMI_PROTOCOL_ERROR_ABORTED. In order to use abortable
         * methods and make sure the response is the correct one, use
         * qmi_device_command_abortable().
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_command_full_finish() to get the result of the operation.
         * @param message the message to send.
         * @param message_context the context of the message.
         * @param timeout maximum time, in seconds, to wait for the response.
         * @param cancellable a #GCancellable, or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        command_full(
            message: Message,
            message_context: MessageContext,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<Message> | void;
        /**
         * Finishes an operation started with qmi_device_command_full().
         * @param res a #GAsyncResult.
         * @returns a #QmiMessage response, or %NULL if @error is set. The returned value should be freed with qmi_message_unref().
         */
        command_full_finish(res: Gio.AsyncResult): Message;
        /**
         * Asynchronously deletes all virtual network interfaces that have been previously
         * created with qmi_device_add_link() in `base_ifname`.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_delete_link_finish() to get the result of the operation.
         *
         * <note><para>
         * There is no guarantee that other processes haven't created new links by the
         * time this method returns. This method should be used with caution, or in setups
         * where only one single process is expected to do QMI network interface link
         * management.
         * </para></note>
         * @param base_ifname the interface where all links are available.
         * @param cancellable a #GCancellable, or %NULL.
         */
        delete_all_links(base_ifname: string, cancellable?: Gio.Cancellable | null): Promise<boolean>;
        /**
         * Asynchronously deletes all virtual network interfaces that have been previously
         * created with qmi_device_add_link() in `base_ifname`.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_delete_link_finish() to get the result of the operation.
         *
         * <note><para>
         * There is no guarantee that other processes haven't created new links by the
         * time this method returns. This method should be used with caution, or in setups
         * where only one single process is expected to do QMI network interface link
         * management.
         * </para></note>
         * @param base_ifname the interface where all links are available.
         * @param cancellable a #GCancellable, or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        delete_all_links(
            base_ifname: string,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously deletes all virtual network interfaces that have been previously
         * created with qmi_device_add_link() in `base_ifname`.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_delete_link_finish() to get the result of the operation.
         *
         * <note><para>
         * There is no guarantee that other processes haven't created new links by the
         * time this method returns. This method should be used with caution, or in setups
         * where only one single process is expected to do QMI network interface link
         * management.
         * </para></note>
         * @param base_ifname the interface where all links are available.
         * @param cancellable a #GCancellable, or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        delete_all_links(
            base_ifname: string,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<boolean> | void;
        /**
         * Finishes an operation started with qmi_device_delete_all_links().
         * @param res a #GAsyncResult.
         * @returns %TRUE if successful, %FALSE if @error is set.
         */
        delete_all_links_finish(res: Gio.AsyncResult): boolean;
        /**
         * Asynchronously deletes a virtual network interface that has been previously
         * created with qmi_device_add_link().
         *
         * If the kernel driver doesn't allow this functionality, a
         * %QMI_CORE_ERROR_UNSUPPORTED error will be returned.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_delete_link_finish() to get the result of the operation.
         *
         * <note><para>
         * The %QMI_DEVICE_MUX_ID_UNBOUND value may be given as `mux_id` if the user
         * can guarantee that the underlying kernel support doesn't require the
         * mux id info to delete the link. When using the qmi_wwan driver from a kernel
         * older than v5.12, a valid `mux_id` is required.
         * </para></note>
         * @param ifname the name of the link to remove.
         * @param mux_id the mux ID of the link to remove.
         * @param cancellable a #GCancellable, or %NULL.
         */
        delete_link(ifname: string, mux_id: number, cancellable?: Gio.Cancellable | null): Promise<boolean>;
        /**
         * Asynchronously deletes a virtual network interface that has been previously
         * created with qmi_device_add_link().
         *
         * If the kernel driver doesn't allow this functionality, a
         * %QMI_CORE_ERROR_UNSUPPORTED error will be returned.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_delete_link_finish() to get the result of the operation.
         *
         * <note><para>
         * The %QMI_DEVICE_MUX_ID_UNBOUND value may be given as `mux_id` if the user
         * can guarantee that the underlying kernel support doesn't require the
         * mux id info to delete the link. When using the qmi_wwan driver from a kernel
         * older than v5.12, a valid `mux_id` is required.
         * </para></note>
         * @param ifname the name of the link to remove.
         * @param mux_id the mux ID of the link to remove.
         * @param cancellable a #GCancellable, or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        delete_link(
            ifname: string,
            mux_id: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously deletes a virtual network interface that has been previously
         * created with qmi_device_add_link().
         *
         * If the kernel driver doesn't allow this functionality, a
         * %QMI_CORE_ERROR_UNSUPPORTED error will be returned.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_delete_link_finish() to get the result of the operation.
         *
         * <note><para>
         * The %QMI_DEVICE_MUX_ID_UNBOUND value may be given as `mux_id` if the user
         * can guarantee that the underlying kernel support doesn't require the
         * mux id info to delete the link. When using the qmi_wwan driver from a kernel
         * older than v5.12, a valid `mux_id` is required.
         * </para></note>
         * @param ifname the name of the link to remove.
         * @param mux_id the mux ID of the link to remove.
         * @param cancellable a #GCancellable, or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        delete_link(
            ifname: string,
            mux_id: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<boolean> | void;
        /**
         * Finishes an operation started with qmi_device_delete_link().
         * @param res a #GAsyncResult.
         * @returns %TRUE if successful, %FALSE if @error is set.
         */
        delete_link_finish(res: Gio.AsyncResult): boolean;
        /**
         * Gets the number of consecutive transaction timeouts in the device.
         * @returns a #guint.
         */
        get_consecutive_timeouts(): number;
        /**
         * Retrieves the data format currently expected by the kernel in the network
         * interface.
         *
         * If `QMI_DEVICE_EXPECTED_DATA_FORMAT_UNKNOWN` is returned, the user should
         * assume that 802.3 is the expected format, as that is what the qmi_wwan
         * driver expected by default before kernel 4.5.
         *
         * <note><para>
         * This method is only applicable when using the qmi_wwan kernel driver.
         * </para></note>
         * @returns a valid #QmiDeviceExpectedDataFormat, or @QMI_DEVICE_EXPECTED_DATA_FORMAT_UNKNOWN if @error is set.
         */
        get_expected_data_format(): DeviceExpectedDataFormat;
        /**
         * Get the #GFile associated with this #QmiDevice.
         * @returns a #GFile that must be freed with g_object_unref().
         */
        get_file(): Gio.File;
        /**
         * Get the #QrtrNode associated with this #QmiDevice.
         *
         * <note><para>
         * This method is only available when the library is built with QRTR support.
         * </para></note>
         * @returns a #QrtrNode that must be freed with g_object_unref() or %NULL if none available.
         */
        get_node(): Qrtr.Node;
        /**
         * Get the system path of the underlying QMI device.
         * @returns the system path of the device.
         */
        get_path(): string;
        /**
         * Get the system path of the underlying QMI device in UTF-8.
         * @returns UTF-8 encoded system path of the device.
         */
        get_path_display(): string;
        /**
         * Asynchronously requests the service version information of the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_device_get_service_version_info_finish() to get the result of the operation.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         */
        get_service_version_info(
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<DeviceServiceVersionInfo[]>;
        /**
         * Asynchronously requests the service version information of the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_device_get_service_version_info_finish() to get the result of the operation.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_service_version_info(
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously requests the service version information of the device.
         *
         * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from.
         *
         * You can then call qmi_device_get_service_version_info_finish() to get the result of the operation.
         * @param timeout maximum time to wait for the method to complete, in seconds.
         * @param cancellable a #GCancellable or %NULL.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied.
         */
        get_service_version_info(
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<DeviceServiceVersionInfo[]> | void;
        /**
         * Finishes an operation started with qmi_device_get_service_version_info().
         * @param res a #GAsyncResult.
         * @returns a #GArray of #QmiDeviceServiceVersionInfo elements, or %NULL if @error  is set. The returned value should be freed with g_array_unref().
         */
        get_service_version_info_finish(res: Gio.AsyncResult): DeviceServiceVersionInfo[];
        /**
         * Get the WWAN interface name associated with the QMI control port.
         * This value will be loaded every time it's asked for it.
         *
         * <note><para>
         * This method is only applicable when using the qmi_wwan kernel driver.
         * </para></note>
         * @returns UTF-8 encoded network interface name, or %NULL if not available.
         */
        get_wwan_iface(): string;
        /**
         * Checks whether the #QmiDevice is open for I/O.
         * @returns %TRUE if @self is open, %FALSE otherwise.
         */
        is_open(): boolean;
        /**
         * Synchronously lists all virtual network interfaces that have been previously
         * created with qmi_device_add_link() in `base_ifname`.
         * @param base_ifname the base interface.
         * @returns %TRUE if successful, %FALSE if @error is set.
         */
        list_links(base_ifname: string): [boolean, string[]];
        /**
         * Asynchronously opens a #QmiDevice for I/O.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_open_finish() to get the result of the operation.
         * @param flags mask of #QmiDeviceOpenFlags specifying how the device should be opened.
         * @param timeout maximum time, in seconds, to wait for the device to be opened.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        open(flags: DeviceOpenFlags, timeout: number, cancellable?: Gio.Cancellable | null): Promise<boolean>;
        /**
         * Asynchronously opens a #QmiDevice for I/O.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_open_finish() to get the result of the operation.
         * @param flags mask of #QmiDeviceOpenFlags specifying how the device should be opened.
         * @param timeout maximum time, in seconds, to wait for the device to be opened.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        open(
            flags: DeviceOpenFlags,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously opens a #QmiDevice for I/O.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_open_finish() to get the result of the operation.
         * @param flags mask of #QmiDeviceOpenFlags specifying how the device should be opened.
         * @param timeout maximum time, in seconds, to wait for the device to be opened.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        open(
            flags: DeviceOpenFlags,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<boolean> | void;
        /**
         * Finishes an asynchronous open operation started with qmi_device_open().
         * @param res a #GAsyncResult.
         * @returns %TRUE if successful, %FALSE if @error is set.
         */
        open_finish(res: Gio.AsyncResult): boolean;
        /**
         * Get the #GFile associated with this #QmiDevice, without increasing the reference count
         * on the returned object.
         * @returns a #GFile. Do not free the returned object, it is owned by @self.
         */
        peek_file(): Gio.File;
        /**
         * Get the #QrtrNode associated with this #QmiDevice, without increasing the
         * reference count on the returned object.
         *
         * <note><para>
         * This method is only available when the library is built with QRTR support.
         * </para></note>
         * @returns a #QrtrNode or %NULL if none available. Do not free the returned object, it is owned by @self.
         */
        peek_node(): Qrtr.Node;
        /**
         * Asynchronously releases the #QmiClient from the #QmiDevice.
         *
         * Once the #QmiClient has been released, it cannot be used any more to
         * perform operations.
         *
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_release_client_finish() to get the result of the operation.
         * @param client the #QmiClient to release.
         * @param flags mask of #QmiDeviceReleaseClientFlags specifying how the client should be released.
         * @param timeout maximum time to wait.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        release_client(
            client: Client,
            flags: DeviceReleaseClientFlags,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
        ): Promise<boolean>;
        /**
         * Asynchronously releases the #QmiClient from the #QmiDevice.
         *
         * Once the #QmiClient has been released, it cannot be used any more to
         * perform operations.
         *
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_release_client_finish() to get the result of the operation.
         * @param client the #QmiClient to release.
         * @param flags mask of #QmiDeviceReleaseClientFlags specifying how the client should be released.
         * @param timeout maximum time to wait.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        release_client(
            client: Client,
            flags: DeviceReleaseClientFlags,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Asynchronously releases the #QmiClient from the #QmiDevice.
         *
         * Once the #QmiClient has been released, it cannot be used any more to
         * perform operations.
         *
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_release_client_finish() to get the result of the operation.
         * @param client the #QmiClient to release.
         * @param flags mask of #QmiDeviceReleaseClientFlags specifying how the client should be released.
         * @param timeout maximum time to wait.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        release_client(
            client: Client,
            flags: DeviceReleaseClientFlags,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<boolean> | void;
        /**
         * Finishes an operation started with qmi_device_release_client().
         *
         * Note that even if the release operation returns an error, the client should
         * anyway be considered released, and shouldn't be used afterwards.
         * @param res a #GAsyncResult.
         * @returns %TRUE if successful, or %NULL if @error is set.
         */
        release_client_finish(res: Gio.AsyncResult): boolean;
        /**
         * Configures the data format currently expected by the kernel in the network
         * interface.
         *
         * <note><para>
         * This method is only applicable when using the qmi_wwan kernel driver.
         * </para></note>
         * @param format a known #QmiDeviceExpectedDataFormat.
         * @returns %TRUE if successful, or %FALSE if @error is set.
         */
        set_expected_data_format(format: DeviceExpectedDataFormat): boolean;
        /**
         * Sets the instance ID of the #QmiDevice.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_set_instance_id_finish() to get the result of the operation.
         * @param instance_id the instance ID.
         * @param timeout maximum time to wait.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        set_instance_id(instance_id: number, timeout: number, cancellable?: Gio.Cancellable | null): Promise<boolean>;
        /**
         * Sets the instance ID of the #QmiDevice.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_set_instance_id_finish() to get the result of the operation.
         * @param instance_id the instance ID.
         * @param timeout maximum time to wait.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        set_instance_id(
            instance_id: number,
            timeout: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Sets the instance ID of the #QmiDevice.
         *
         * When the operation is finished `callback` will be called. You can then call
         * qmi_device_set_instance_id_finish() to get the result of the operation.
         * @param instance_id the instance ID.
         * @param timeout maximum time to wait.
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the operation is finished.
         */
        set_instance_id(
            instance_id: number,
            timeout: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<boolean> | void;
        /**
         * Finishes an operation started with qmi_device_set_instance_id().
         * @param res a #GAsyncResult.
         * @param link_id a placeholder for the output #guint16, or %NULL if not required.
         * @returns %TRUE if successful, %FALSE if @error is set.
         */
        set_instance_id_finish(res: Gio.AsyncResult, link_id: number): boolean;

        // Inherited methods
        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority](iface.AsyncResult.html#io-priority) of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         */
        init_async(io_priority: number, cancellable?: Gio.Cancellable | null): Promise<boolean>;
        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority](iface.AsyncResult.html#io-priority) of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        init_async(
            io_priority: number,
            cancellable: Gio.Cancellable | null,
            callback: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority](iface.AsyncResult.html#io-priority) of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        init_async(
            io_priority: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): Promise<boolean> | void;
        /**
         * Finishes asynchronous initialization and returns the result.
         * See g_async_initable_init_async().
         * @param res a #GAsyncResult.
         * @returns %TRUE if successful. If an error has occurred, this function will return %FALSE and set @error appropriately if present.
         */
        init_finish(res: Gio.AsyncResult): boolean;
        /**
         * Finishes the async construction for the various g_async_initable_new
         * calls, returning the created object or %NULL on error.
         * @param res the #GAsyncResult from the callback
         * @returns a newly created #GObject,      or %NULL on error. Free with g_object_unref().
         */
        new_finish(res: Gio.AsyncResult): Device;
        /**
         * Starts asynchronous initialization of the object implementing the
         * interface. This must be done before any real use of the object after
         * initial construction. If the object also implements #GInitable you can
         * optionally call g_initable_init() instead.
         *
         * This method is intended for language bindings. If writing in C,
         * g_async_initable_new_async() should typically be used instead.
         *
         * When the initialization is finished, `callback` will be called. You can
         * then call g_async_initable_init_finish() to get the result of the
         * initialization.
         *
         * Implementations may also support cancellation. If `cancellable` is not
         * %NULL, then initialization can be cancelled by triggering the cancellable
         * object from another thread. If the operation was cancelled, the error
         * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
         * the object doesn't support cancellable initialization, the error
         * %G_IO_ERROR_NOT_SUPPORTED will be returned.
         *
         * As with #GInitable, if the object is not initialized, or initialization
         * returns with an error, then all operations on the object except
         * g_object_ref() and g_object_unref() are considered to be invalid, and
         * have undefined behaviour. They will often fail with g_critical() or
         * g_warning(), but this must not be relied on.
         *
         * Callers should not assume that a class which implements #GAsyncInitable can
         * be initialized multiple times; for more information, see g_initable_init().
         * If a class explicitly supports being initialized multiple times,
         * implementation requires yielding all subsequent calls to init_async() on the
         * results of the first call.
         *
         * For classes that also support the #GInitable interface, the default
         * implementation of this method will run the g_initable_init() function
         * in a thread, so if you want to support asynchronous initialization via
         * threads, just implement the #GAsyncInitable interface without overriding
         * any interface methods.
         * @param io_priority the [I/O priority](iface.AsyncResult.html#io-priority) of the operation
         * @param cancellable optional #GCancellable object, %NULL to ignore.
         * @param callback a #GAsyncReadyCallback to call when the request is satisfied
         */
        vfunc_init_async(
            io_priority: number,
            cancellable?: Gio.Cancellable | null,
            callback?: Gio.AsyncReadyCallback<this> | null,
        ): void;
        /**
         * Finishes asynchronous initialization and returns the result.
         * See g_async_initable_init_async().
         * @param res a #GAsyncResult.
         */
        vfunc_init_finish(res: Gio.AsyncResult): boolean;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Proxy {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            qmi_proxy_n_clients: number;
            qmiProxyNClients: number;
        }
    }

    /**
     * The #QmiProxy structure contains private data and should only be accessed
     * using the provided API.
     */
    class Proxy extends GObject.Object {
        static $gtype: GObject.GType<Proxy>;

        // Properties

        get qmi_proxy_n_clients(): number;
        get qmiProxyNClients(): number;

        // Constructors

        constructor(properties?: Partial<Proxy.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Proxy;

        // Methods

        /**
         * Get the number of clients currently connected to the proxy.
         * @returns a #guint.
         */
        get_n_clients(): number;
    }

    type ClientAtrClass = typeof ClientAtr;
    type ClientClass = typeof Client;
    type ClientDmsClass = typeof ClientDms;
    type ClientDpmClass = typeof ClientDpm;
    type ClientDsdClass = typeof ClientDsd;
    type ClientFoxClass = typeof ClientFox;
    type ClientGasClass = typeof ClientGas;
    type ClientGmsClass = typeof ClientGms;
    type ClientImsClass = typeof ClientIms;
    type ClientImsaClass = typeof ClientImsa;
    type ClientImspClass = typeof ClientImsp;
    type ClientLocClass = typeof ClientLoc;
    type ClientNasClass = typeof ClientNas;
    type ClientOmaClass = typeof ClientOma;
    type ClientPbmClass = typeof ClientPbm;
    type ClientPdcClass = typeof ClientPdc;
    type ClientPdsClass = typeof ClientPds;
    abstract class ClientPrivate {
        static $gtype: GObject.GType<ClientPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ClientQosClass = typeof ClientQos;
    type ClientSarClass = typeof ClientSar;
    type ClientSscClass = typeof ClientSsc;
    type ClientUimClass = typeof ClientUim;
    type ClientVoiceClass = typeof ClientVoice;
    type ClientWdaClass = typeof ClientWda;
    type ClientWdsClass = typeof ClientWds;
    type ClientWmsClass = typeof ClientWms;
    type DeviceClass = typeof Device;
    abstract class DevicePrivate {
        static $gtype: GObject.GType<DevicePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Version information for a service.
     */
    class DeviceServiceVersionInfo {
        static $gtype: GObject.GType<DeviceServiceVersionInfo>;

        // Fields

        service: Service;
        major_version: number;
        minor_version: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiIndicationAtrReceivedOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationAtrReceivedOutput {
        static $gtype: GObject.GType<IndicationAtrReceivedOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Message' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationAtrReceivedOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationDmsEventReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationDmsEventReportOutput {
        static $gtype: GObject.GType<IndicationDmsEventReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Activation State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_activation_state(): [boolean, DmsActivationState | null];
        /**
         * Get the 'Operating Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_operating_mode(): [boolean, DmsOperatingMode | null];
        /**
         * Get the 'PIN1 Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pin1_status(): [boolean, DmsUimPinStatus | null, number, number];
        /**
         * Get the 'PIN2 Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pin2_status(): [boolean, DmsUimPinStatus | null, number, number];
        /**
         * Get the 'Power State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_power_state(): [boolean, number, number];
        /**
         * Get the 'PRL Init Notification' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_prl_init_notification(): [boolean, boolean];
        /**
         * Get the 'UIM State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uim_state(): [boolean, DmsUimState | null];
        /**
         * Get the 'Wireless Disable State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wireless_disable_state(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationDmsEventReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationDsdSystemStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationDsdSystemStatusOutput {
        static $gtype: GObject.GType<IndicationDsdSystemStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Available Systems' field from `self`.
         *
         * Version of qmi_indication_dsd_system_status_output_get_available_systems() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_available_systems(): [boolean, IndicationDsdSystemStatusOutputAvailableSystemsSystem[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationDsdSystemStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiIndicationDsdSystemStatusOutputAvailableSystemsSystem struct.
     */
    class IndicationDsdSystemStatusOutputAvailableSystemsSystem {
        static $gtype: GObject.GType<IndicationDsdSystemStatusOutputAvailableSystemsSystem>;

        // Fields

        technology: DsdDataSystemNetworkType;
        rat: DsdRadioAccessTechnology;
        so_mask: DsdSoMask;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiIndicationLocDeleteAssistanceDataOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocDeleteAssistanceDataOutput {
        static $gtype: GObject.GType<IndicationLocDeleteAssistanceDataOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_status(): [boolean, LocIndicationStatus | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocDeleteAssistanceDataOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocEngineStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocEngineStateOutput {
        static $gtype: GObject.GType<IndicationLocEngineStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Engine State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_engine_state(): [boolean, LocEngineState | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocEngineStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocFixRecurrenceTypeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocFixRecurrenceTypeOutput {
        static $gtype: GObject.GType<IndicationLocFixRecurrenceTypeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Fix Recurrence Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_fix_recurrence_type(): [boolean, LocFixRecurrenceType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocFixRecurrenceTypeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocGetEngineLockOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocGetEngineLockOutput {
        static $gtype: GObject.GType<IndicationLocGetEngineLockOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_status(): [boolean, LocIndicationStatus | null];
        /**
         * Get the 'Lock Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lock_type(): [boolean, LocLockType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocGetEngineLockOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocGetNmeaTypesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocGetNmeaTypesOutput {
        static $gtype: GObject.GType<IndicationLocGetNmeaTypesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_status(): [boolean, LocIndicationStatus | null];
        /**
         * Get the 'NMEA Types' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nmea_types(): [boolean, LocNmeaType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocGetNmeaTypesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocGetOperationModeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocGetOperationModeOutput {
        static $gtype: GObject.GType<IndicationLocGetOperationModeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_status(): [boolean, LocIndicationStatus | null];
        /**
         * Get the 'Operation Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_operation_mode(): [boolean, LocOperationMode | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocGetOperationModeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocGetPredictedOrbitsDataSourceOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocGetPredictedOrbitsDataSourceOutput {
        static $gtype: GObject.GType<IndicationLocGetPredictedOrbitsDataSourceOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Allowed Sizes' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_allowed_sizes(): [boolean, number, number];
        /**
         * Get the 'Indication Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_status(): [boolean, LocIndicationStatus | null];
        /**
         * Get the 'Server List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_server_list(): [boolean, string[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocGetPredictedOrbitsDataSourceOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocGetServerOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocGetServerOutput {
        static $gtype: GObject.GType<IndicationLocGetServerOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_status(): [boolean, LocIndicationStatus | null];
        /**
         * Get the 'IPv4' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv4(): [boolean, number, number];
        /**
         * Get the 'IPv6' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6(): [boolean, number[] | null, number];
        /**
         * Get the 'Server Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_server_type(): [boolean, LocServerType | null];
        /**
         * Get the 'URL' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_url(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocGetServerOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocGnssSvInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocGnssSvInfoOutput {
        static $gtype: GObject.GType<IndicationLocGnssSvInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Altitude Assumed' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_altitude_assumed(): [boolean, boolean];
        /**
         * Get the 'List' field from `self`.
         *
         * Version of qmi_indication_loc_gnss_sv_info_output_get_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, IndicationLocGnssSvInfoOutputListElement[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocGnssSvInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiIndicationLocGnssSvInfoOutputListElement struct.
     */
    class IndicationLocGnssSvInfoOutputListElement {
        static $gtype: GObject.GType<IndicationLocGnssSvInfoOutputListElement>;

        // Fields

        valid_information: LocSatelliteValidInformation;
        system: LocSystem;
        gnss_satellite_id: number;
        health_status: LocHealthStatus;
        satellite_status: LocSatelliteStatus;
        navigation_data: LocNavigationData;
        elevation_degrees: number;
        azimuth_degrees: number;
        signal_to_noise_ratio_bhz: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiIndicationLocInjectPredictedOrbitsDataOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocInjectPredictedOrbitsDataOutput {
        static $gtype: GObject.GType<IndicationLocInjectPredictedOrbitsDataOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_status(): [boolean, LocIndicationStatus | null];
        /**
         * Get the 'Part Number' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_part_number(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocInjectPredictedOrbitsDataOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocInjectXtraDataOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocInjectXtraDataOutput {
        static $gtype: GObject.GType<IndicationLocInjectXtraDataOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_status(): [boolean, LocIndicationStatus | null];
        /**
         * Get the 'Part Number' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_part_number(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocInjectXtraDataOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocNmeaOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocNmeaOutput {
        static $gtype: GObject.GType<IndicationLocNmeaOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'NMEA String' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nmea_string(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocNmeaOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocPositionReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocPositionReportOutput {
        static $gtype: GObject.GType<IndicationLocPositionReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Altitude Assumed' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_altitude_assumed(): [boolean, boolean];
        /**
         * Get the 'Altitude from Ellipsoid' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_altitude_from_ellipsoid(): [boolean, number];
        /**
         * Get the 'Altitude from Sealevel' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_altitude_from_sealevel(): [boolean, number];
        /**
         * Get the 'DOP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_dop(): [boolean, number, number, number];
        /**
         * Get the 'GPS Date Time' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gps_date_time(): [boolean, number, number];
        /**
         * Get the 'Heading' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_heading(): [boolean, number];
        /**
         * Get the 'Heading Uncertainty' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_heading_uncertainty(): [boolean, number];
        /**
         * Get the 'Horizontal Confidence' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_horizontal_confidence(): [boolean, number];
        /**
         * Get the 'Horizontal Reliability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_horizontal_reliability(): [boolean, LocReliability | null];
        /**
         * Get the 'Horizontal Speed' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_horizontal_speed(): [boolean, number];
        /**
         * Get the 'Horizontal Uncertainty Circular' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_horizontal_uncertainty_circular(): [boolean, number];
        /**
         * Get the 'Horizontal Uncertainty Elliptical Azimuth' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_horizontal_uncertainty_elliptical_azimuth(): [boolean, number];
        /**
         * Get the 'Horizontal Uncertainty Elliptical Major' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_horizontal_uncertainty_elliptical_major(): [boolean, number];
        /**
         * Get the 'Horizontal Uncertainty Elliptical Minor' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_horizontal_uncertainty_elliptical_minor(): [boolean, number];
        /**
         * Get the 'Latitude' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_latitude(): [boolean, number];
        /**
         * Get the 'Leap Seconds' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_leap_seconds(): [boolean, number];
        /**
         * Get the 'Longitude' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_longitude(): [boolean, number];
        /**
         * Get the 'Magnetic Deviation' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_magnetic_deviation(): [boolean, number];
        /**
         * Get the 'Satellites Used' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_satellites_used(): [boolean, number[] | null];
        /**
         * Get the 'Sensor Data Usage' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sensor_data_usage(): [boolean, LocSensorDataUsage | null];
        /**
         * Get the 'Session Fix Count' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session_fix_count(): [boolean, number];
        /**
         * Get the 'Session ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session_id(): [boolean, number];
        /**
         * Get the 'Session Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session_status(): [boolean, LocSessionStatus | null];
        /**
         * Get the 'Speed Uncertainty' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_speed_uncertainty(): [boolean, number];
        /**
         * Get the 'Technology Used' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_technology_used(): [boolean, LocTechnologyUsed | null];
        /**
         * Get the 'Time Source' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_time_source(): [boolean, LocTimeSource | null];
        /**
         * Get the 'Time Uncertainty' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_time_uncertainty(): [boolean, number];
        /**
         * Get the 'UTC Timestamp' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_utc_timestamp(): [boolean, number];
        /**
         * Get the 'Vertical Confidence' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_vertical_confidence(): [boolean, number];
        /**
         * Get the 'Vertical Reliability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_vertical_reliability(): [boolean, number];
        /**
         * Get the 'Vertical Speed' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_vertical_speed(): [boolean, number];
        /**
         * Get the 'Vertical Uncertainty' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_vertical_uncertainty(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocPositionReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocSetEngineLockOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocSetEngineLockOutput {
        static $gtype: GObject.GType<IndicationLocSetEngineLockOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_status(): [boolean, LocIndicationStatus | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocSetEngineLockOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocSetNmeaTypesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocSetNmeaTypesOutput {
        static $gtype: GObject.GType<IndicationLocSetNmeaTypesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_status(): [boolean, LocIndicationStatus | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocSetNmeaTypesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocSetOperationModeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocSetOperationModeOutput {
        static $gtype: GObject.GType<IndicationLocSetOperationModeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_status(): [boolean, LocIndicationStatus | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocSetOperationModeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationLocSetServerOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationLocSetServerOutput {
        static $gtype: GObject.GType<IndicationLocSetServerOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_status(): [boolean, LocIndicationStatus | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationLocSetServerOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationNasEventReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationNasEventReportOutput {
        static $gtype: GObject.GType<IndicationNasEventReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'ECIO' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ecio(): [boolean, number, NasRadioInterface | null];
        /**
         * Get the 'Error Rate' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_error_rate(): [boolean, number, NasRadioInterface | null];
        /**
         * Get the 'IO' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_io(): [boolean, number];
        /**
         * Get the 'LTE RSRP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_rsrp(): [boolean, number];
        /**
         * Get the 'LTE SNR' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_snr(): [boolean, number];
        /**
         * Get the 'Registration Reject Reason' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_registration_reject_reason(): [boolean, NasNetworkServiceDomain | null, number];
        /**
         * Get the 'RF Band Information' field from `self`.
         *
         * Version of qmi_indication_nas_event_report_output_get_rf_band_information() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rf_band_information(): [boolean, IndicationNasEventReportOutputRfBandInformationElement[] | null];
        /**
         * Get the 'RSRQ' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rsrq(): [boolean, number, NasRadioInterface | null];
        /**
         * Get the 'RSSI' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rssi(): [boolean, number, NasRadioInterface | null];
        /**
         * Get the 'Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_signal_strength(): [boolean, number, NasRadioInterface | null];
        /**
         * Get the 'SINR' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sinr(): [boolean, NasEvdoSinrLevel | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationNasEventReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiIndicationNasEventReportOutputRfBandInformationElement struct.
     */
    class IndicationNasEventReportOutputRfBandInformationElement {
        static $gtype: GObject.GType<IndicationNasEventReportOutputRfBandInformationElement>;

        // Fields

        radio_interface: NasRadioInterface;
        active_band_class: NasActiveBand;
        active_channel: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiIndicationNasNetworkRejectOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationNasNetworkRejectOutput {
        static $gtype: GObject.GType<IndicationNasNetworkRejectOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Closed Subscriber Group' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_closed_subscriber_group(): [boolean, number];
        /**
         * Get the 'PLMN' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_plmn(): [boolean, number, number, boolean];
        /**
         * Get the 'Radio Interface' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_radio_interface(): [boolean, NasRadioInterface | null];
        /**
         * Get the 'Reject Cause' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_reject_cause(): [boolean, NasRejectCause | null];
        /**
         * Get the 'Service Domain' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_service_domain(): [boolean, NasNetworkServiceDomain | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationNasNetworkRejectOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationNasNetworkTimeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationNasNetworkTimeOutput {
        static $gtype: GObject.GType<IndicationNasNetworkTimeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Daylight Savings Adjustment' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_daylight_savings_adjustment(): [boolean, NasDaylightSavingsAdjustment | null];
        /**
         * Get the 'Radio Interface' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_radio_interface(): [boolean, NasRadioInterface | null];
        /**
         * Get the 'Timezone Offset' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_timezone_offset(): [boolean, number];
        /**
         * Get the 'Universal Time' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_universal_time(): [boolean, number, number, number, number, number, number, NasDayOfWeek | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationNasNetworkTimeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationNasOperatorNameOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationNasOperatorNameOutput {
        static $gtype: GObject.GType<IndicationNasOperatorNameOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'NITZ Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nitz_information(): [
            boolean,
            NasPlmnEncodingScheme | null,
            NasPlmnNameCountryInitials | null,
            NasPlmnNameSpareBits | null,
            NasPlmnNameSpareBits | null,
            Uint8Array | null,
            Uint8Array | null,
        ];
        /**
         * Get the 'Operator PLMN List' field from `self`.
         *
         * Version of qmi_indication_nas_operator_name_output_get_operator_plmn_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_operator_plmn_list(): [boolean, IndicationNasOperatorNameOutputOperatorPlmnListElement[] | null];
        /**
         * Get the 'Operator PLMN Name' field from `self`.
         *
         * Version of qmi_indication_nas_operator_name_output_get_operator_plmn_name() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_operator_plmn_name(): [boolean, IndicationNasOperatorNameOutputOperatorPlmnNameElement[] | null];
        /**
         * Get the 'Operator String Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_operator_string_name(): [boolean, string];
        /**
         * Get the 'Service Provider Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_service_provider_name(): [boolean, NasNetworkNameDisplayCondition | null, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationNasOperatorNameOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiIndicationNasOperatorNameOutputOperatorPlmnListElement struct.
     */
    class IndicationNasOperatorNameOutputOperatorPlmnListElement {
        static $gtype: GObject.GType<IndicationNasOperatorNameOutputOperatorPlmnListElement>;

        // Fields

        mcc: string;
        mnc: string;
        lac1: number;
        lac2: number;
        plmn_name_record_identifier: number;

        // Constructors

        constructor(
            properties?: Partial<{
                mcc: string;
                mnc: string;
                lac1: number;
                lac2: number;
                plmn_name_record_identifier: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiIndicationNasOperatorNameOutputOperatorPlmnNameElement struct.
     */
    class IndicationNasOperatorNameOutputOperatorPlmnNameElement {
        static $gtype: GObject.GType<IndicationNasOperatorNameOutputOperatorPlmnNameElement>;

        // Fields

        name_encoding: NasPlmnEncodingScheme;
        short_country_initials: NasPlmnNameCountryInitials;
        long_name_spare_bits: NasPlmnNameSpareBits;
        short_name_spare_bits: NasPlmnNameSpareBits;
        long_name: any[];
        short_name: any[];

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiIndicationNasServingSystemOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationNasServingSystemOutput {
        static $gtype: GObject.GType<IndicationNasServingSystemOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Call Barring Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_barring_status(): [boolean, NasCallBarringStatus | null, NasCallBarringStatus | null];
        /**
         * Get the 'CDMA Base Station Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_base_station_info(): [boolean, number, number, number];
        /**
         * Get the 'CDMA P Rev' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_p_rev(): [boolean, number];
        /**
         * Get the 'CDMA System ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_system_id(): [boolean, number, number];
        /**
         * Get the 'CDMA System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_system_info(): [boolean, number, number];
        /**
         * Get the 'CID 3GPP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cid_3gpp(): [boolean, number];
        /**
         * Get the 'Concurrent Service Info 3GPP2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_concurrent_service_info_3gpp2(): [boolean, boolean];
        /**
         * Get the 'Current PLMN' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_plmn(): [boolean, number, number, string];
        /**
         * Get the 'Data Service Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data_service_capability(): [boolean, NasDataCapability[] | null];
        /**
         * Get the 'Daylight Saving Time Adjustment 3GPP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_daylight_saving_time_adjustment_3gpp(): [boolean, number];
        /**
         * Get the 'Default Roaming Indicator' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_default_roaming_indicator(): [boolean, NasRoamingIndicatorStatus | null];
        /**
         * Get the 'Detailed Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_detailed_service_status(): [
            boolean,
            NasServiceStatus | null,
            NasNetworkServiceDomain | null,
            NasServiceStatus | null,
            boolean,
            boolean,
        ];
        /**
         * Get the 'DTM Support' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_dtm_support(): [boolean, boolean];
        /**
         * Get the 'HDR Personality' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_personality(): [boolean, NasHdrPersonality | null];
        /**
         * Get the 'LAC 3GPP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lac_3gpp(): [boolean, number];
        /**
         * Get the 'LTE TAC' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_tac(): [boolean, number];
        /**
         * Get the 'MNC PCS Digit Include Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mnc_pcs_digit_include_status(): [boolean, number, number, boolean];
        /**
         * Get the 'Network Name Source' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_name_source(): [boolean, NasNetworkNameSource | null];
        /**
         * Get the 'PLMN Name Flag 3GPP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_plmn_name_flag_3gpp(): [boolean, boolean];
        /**
         * Get the 'PLMN Not Changed Indication' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_plmn_not_changed_indication(): [boolean, boolean];
        /**
         * Get the 'PRL Indicator 3GPP2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_prl_indicator_3gpp2(): [boolean, boolean];
        /**
         * Get the 'Roaming Indicator' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roaming_indicator(): [boolean, NasRoamingIndicatorStatus | null];
        /**
         * Get the 'Roaming Indicator List' field from `self`.
         *
         * Version of qmi_indication_nas_serving_system_output_get_roaming_indicator_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roaming_indicator_list(): [boolean, IndicationNasServingSystemOutputRoamingIndicatorListElement[] | null];
        /**
         * Get the 'Serving System' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_serving_system(): [
            boolean,
            NasRegistrationState | null,
            NasAttachState | null,
            NasAttachState | null,
            NasNetworkType | null,
            NasRadioInterface[] | null,
        ];
        /**
         * Get the 'Time Zone 3GPP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_time_zone_3gpp(): [boolean, number];
        /**
         * Get the 'Time Zone 3GPP2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_time_zone_3gpp2(): [boolean, number, number, boolean];
        /**
         * Get the 'UMTS Primary Scrambling Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_primary_scrambling_code(): [boolean, number];
        /**
         * Get the 'Universal Time and Local Time Zone 3GPP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_universal_time_and_local_time_zone_3gpp(): [
            boolean,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
        ];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationNasServingSystemOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiIndicationNasServingSystemOutputRoamingIndicatorListElement struct.
     */
    class IndicationNasServingSystemOutputRoamingIndicatorListElement {
        static $gtype: GObject.GType<IndicationNasServingSystemOutputRoamingIndicatorListElement>;

        // Fields

        radio_interface: NasRadioInterface;
        roaming_indicator: NasRoamingIndicatorStatus;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiIndicationNasSignalInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationNasSignalInfoOutput {
        static $gtype: GObject.GType<IndicationNasSignalInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the '5G Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_5g_signal_strength(): [boolean, number, number];
        /**
         * Get the '5G Signal Strength Extended' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_5g_signal_strength_extended(): [boolean, number];
        /**
         * Get the 'CDMA Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_signal_strength(): [boolean, number, number];
        /**
         * Get the 'GSM Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_signal_strength(): [boolean, number];
        /**
         * Get the 'HDR Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_signal_strength(): [boolean, number, number, NasEvdoSinrLevel | null, number];
        /**
         * Get the 'LTE Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_signal_strength(): [boolean, number, number, number, number];
        /**
         * Get the 'TDMA Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tdma_signal_strength(): [boolean, number];
        /**
         * Get the 'WCDMA RSCP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_rscp(): [boolean, number];
        /**
         * Get the 'WCDMA Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_signal_strength(): [boolean, number, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationNasSignalInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationNasSystemInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationNasSystemInfoOutput {
        static $gtype: GObject.GType<IndicationNasSystemInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Additional CDMA System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_cdma_system_info(): [boolean, number, number];
        /**
         * Get the 'Additional GSM System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_gsm_system_info(): [boolean, number, NasCellBroadcastCapability | null];
        /**
         * Get the 'Additional HDR System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_hdr_system_info(): [boolean, number];
        /**
         * Get the 'Additional LTE System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_lte_system_info(): [boolean, number];
        /**
         * Get the 'Additional WCDMA System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_wcdma_system_info(): [boolean, number, NasCellBroadcastCapability | null];
        /**
         * Get the 'CDMA Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_service_status(): [boolean, NasServiceStatus | null, boolean];
        /**
         * Get the 'CDMA System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_system_info(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            boolean,
            boolean,
            number,
            boolean,
            number,
            boolean,
            boolean,
            boolean,
            number,
            number,
            boolean,
            number,
            number,
            number,
            boolean,
            number,
            boolean,
            string,
            string,
        ];
        /**
         * Get the 'DCNR restriction Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_dcnr_restriction_info(): [boolean, boolean];
        /**
         * Get the 'EUTRA with NR5G availability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_eutra_with_nr5g_availability(): [boolean, boolean];
        /**
         * Get the 'GSM Call Barring Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_call_barring_status(): [boolean, NasCallBarringStatus | null, NasCallBarringStatus | null];
        /**
         * Get the 'GSM Cipher Domain' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_cipher_domain(): [boolean, NasNetworkServiceDomain | null];
        /**
         * Get the 'GSM Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_service_status(): [boolean, NasServiceStatus | null, NasServiceStatus | null, boolean];
        /**
         * Get the 'GSM System Info v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_system_info_v2(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            number,
            boolean,
            number,
            boolean,
            NasNetworkServiceDomain | null,
            NasRejectCause | null,
            boolean,
            string,
            string,
            boolean,
            boolean,
            boolean,
            boolean,
        ];
        /**
         * Get the 'HDR Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_service_status(): [boolean, NasServiceStatus | null, boolean];
        /**
         * Get the 'HDR System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_system_info(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            boolean,
            boolean,
            NasHdrPersonality | null,
            boolean,
            NasHdrProtocolRevision | null,
            boolean,
            string,
        ];
        /**
         * Get the 'LTE eMBMS Coverage Info Support' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_embms_coverage_info_support(): [boolean, boolean];
        /**
         * Get the 'LTE Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_service_status(): [boolean, NasServiceStatus | null, NasServiceStatus | null, boolean];
        /**
         * Get the 'LTE System Info v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_system_info_v2(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            number,
            boolean,
            number,
            boolean,
            NasNetworkServiceDomain | null,
            NasRejectCause | null,
            boolean,
            string,
            string,
            boolean,
            number,
        ];
        /**
         * Get the 'LTE Voice Support' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_voice_support(): [boolean, boolean];
        /**
         * Get the 'NR5G Service Status Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_service_status_info(): [boolean, NasServiceStatus | null, NasServiceStatus | null, boolean];
        /**
         * Get the 'NR5G System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_system_info(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            number,
            boolean,
            number,
            boolean,
            NasNetworkServiceDomain | null,
            number,
            boolean,
            string,
            string,
            boolean,
            number,
        ];
        /**
         * Get the 'NR5G Tracking Area Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_tracking_area_code(): [boolean, Uint8Array | null];
        /**
         * Get the 'PLMN Not Changed Indication' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_plmn_not_changed_indication(): [boolean, boolean];
        /**
         * Get the 'SIM Reject Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sim_reject_info(): [boolean, NasSimRejectState | null];
        /**
         * Get the 'TD SCDMA Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_td_scdma_service_status(): [boolean, NasServiceStatus | null, NasServiceStatus | null, boolean];
        /**
         * Get the 'TD SCMA System Info v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_td_scma_system_info_v2(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            number,
            boolean,
            number,
            boolean,
            NasNetworkServiceDomain | null,
            NasRejectCause | null,
            boolean,
            string,
            string,
            boolean,
            NasWcdmaHsService | null,
            boolean,
            NasWcdmaHsService | null,
            boolean,
            number,
            boolean,
            NasCellBroadcastCapability | null,
            boolean,
            NasCallBarringStatus | null,
            boolean,
            NasCallBarringStatus | null,
            boolean,
            NasNetworkServiceDomain | null,
        ];
        /**
         * Get the 'WCDMA Call Barring Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_call_barring_status(): [boolean, NasCallBarringStatus | null, NasCallBarringStatus | null];
        /**
         * Get the 'WCDMA Cipher Domain' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_cipher_domain(): [boolean, NasNetworkServiceDomain | null];
        /**
         * Get the 'WCDMA Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_service_status(): [boolean, NasServiceStatus | null, NasServiceStatus | null, boolean];
        /**
         * Get the 'WCDMA System Info v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_system_info_v2(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            number,
            boolean,
            number,
            boolean,
            NasNetworkServiceDomain | null,
            NasRejectCause | null,
            boolean,
            string,
            string,
            boolean,
            NasWcdmaHsService | null,
            boolean,
            NasWcdmaHsService | null,
            boolean,
            number,
        ];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationNasSystemInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationOmaEventReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationOmaEventReportOutput {
        static $gtype: GObject.GType<IndicationOmaEventReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Network Initiated Alert' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_initiated_alert(): [boolean, OmaSessionType | null, number];
        /**
         * Get the 'Session Fail Reason' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session_fail_reason(): [boolean, OmaSessionFailedReason | null];
        /**
         * Get the 'Session State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session_state(): [boolean, OmaSessionState | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationOmaEventReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationPdcActivateConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationPdcActivateConfigOutput {
        static $gtype: GObject.GType<IndicationPdcActivateConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_result(): [boolean, number];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationPdcActivateConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationPdcDeactivateConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationPdcDeactivateConfigOutput {
        static $gtype: GObject.GType<IndicationPdcDeactivateConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_result(): [boolean, number];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationPdcDeactivateConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationPdcGetConfigInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationPdcGetConfigInfoOutput {
        static $gtype: GObject.GType<IndicationPdcGetConfigInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Description' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_description(): [boolean, string];
        /**
         * Get the 'Indication Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_result(): [boolean, number];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Get the 'Total Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_total_size(): [boolean, number];
        /**
         * Get the 'Version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_version(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationPdcGetConfigInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationPdcGetSelectedConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationPdcGetSelectedConfigOutput {
        static $gtype: GObject.GType<IndicationPdcGetSelectedConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Active Id' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_active_id(): [boolean, Uint8Array | null];
        /**
         * Get the 'Indication Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_result(): [boolean, number];
        /**
         * Get the 'Pending Id' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pending_id(): [boolean, Uint8Array | null];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationPdcGetSelectedConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationPdcListConfigsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationPdcListConfigsOutput {
        static $gtype: GObject.GType<IndicationPdcListConfigsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Configs' field from `self`.
         *
         * Version of qmi_indication_pdc_list_configs_output_get_configs() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_configs(): [boolean, IndicationPdcListConfigsOutputConfigsElement[] | null];
        /**
         * Get the 'Indication Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_result(): [boolean, number];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationPdcListConfigsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiIndicationPdcListConfigsOutputConfigsElement struct.
     */
    class IndicationPdcListConfigsOutputConfigsElement {
        static $gtype: GObject.GType<IndicationPdcListConfigsOutputConfigsElement>;

        // Fields

        config_type: PdcConfigurationType;
        id: any[];

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiIndicationPdcLoadConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationPdcLoadConfigOutput {
        static $gtype: GObject.GType<IndicationPdcLoadConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Frame Reset' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_frame_reset(): [boolean, boolean];
        /**
         * Get the 'Indication Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_result(): [boolean, number];
        /**
         * Get the 'Received' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_received(): [boolean, number];
        /**
         * Get the 'Remaining Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_remaining_size(): [boolean, number];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationPdcLoadConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationPdcRefreshOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationPdcRefreshOutput {
        static $gtype: GObject.GType<IndicationPdcRefreshOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Refresh Event' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_refresh_event(): [boolean, PdcRefreshEventType | null];
        /**
         * Get the 'Slot ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_slot_id(): [boolean, number];
        /**
         * Get the 'Subscription ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_subscription_id(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationPdcRefreshOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationPdcSetSelectedConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationPdcSetSelectedConfigOutput {
        static $gtype: GObject.GType<IndicationPdcSetSelectedConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Indication Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_indication_result(): [boolean, number];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationPdcSetSelectedConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationPdsEventReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationPdsEventReportOutput {
        static $gtype: GObject.GType<IndicationPdsEventReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Extended NMEA Position' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_nmea_position(): [boolean, PdsOperationMode | null, string];
        /**
         * Get the 'NMEA Position' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nmea_position(): [boolean, string];
        /**
         * Get the 'Position Session Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_position_session_status(): [boolean, PdsPositionSessionStatus | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationPdsEventReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationQosFlowStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationQosFlowStatusOutput {
        static $gtype: GObject.GType<IndicationQosFlowStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Value' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_value(): [boolean, number, QosStatus | null, QosEvent | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationQosFlowStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationQosNetworkStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationQosNetworkStatusOutput {
        static $gtype: GObject.GType<IndicationQosNetworkStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'QoS Supported' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_qos_supported(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationQosNetworkStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationSscReportLargeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationSscReportLargeOutput {
        static $gtype: GObject.GType<IndicationSscReportLargeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Client ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_client_id(): [boolean, number];
        /**
         * Get the 'Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data(): [boolean, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationSscReportLargeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationSscReportSmallOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationSscReportSmallOutput {
        static $gtype: GObject.GType<IndicationSscReportSmallOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Client ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_client_id(): [boolean, number];
        /**
         * Get the 'Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data(): [boolean, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationSscReportSmallOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationUimCardStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationUimCardStatusOutput {
        static $gtype: GObject.GType<IndicationUimCardStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Card Status' field from `self`.
         *
         * Version of qmi_indication_uim_card_status_output_get_card_status() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_card_status(): [
            boolean,
            number,
            number,
            number,
            number,
            IndicationUimCardStatusOutputCardStatusCardsElementGir[] | null,
        ];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationUimCardStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiIndicationUimCardStatusOutputCardStatusCardsElementApplicationsElementV2 struct.
     */
    class IndicationUimCardStatusOutputCardStatusCardsElementApplicationsElementV2 {
        static $gtype: GObject.GType<IndicationUimCardStatusOutputCardStatusCardsElementApplicationsElementV2>;

        // Fields

        type: UimCardApplicationType;
        state: UimCardApplicationState;
        personalization_state: UimCardApplicationPersonalizationState;
        personalization_feature: UimCardApplicationPersonalizationFeatureStatus;
        personalization_retries: number;
        personalization_unblock_retries: number;
        application_identifier_value: any[];
        upin_replaces_pin1: boolean;
        pin1_state: UimPinState;
        pin1_retries: number;
        puk1_retries: number;
        pin2_state: UimPinState;
        pin2_retries: number;
        puk2_retries: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiIndicationUimCardStatusOutputCardStatusCardsElementGir struct.
     *
     * This type is a version of #QmiIndicationUimCardStatusOutputCardStatusCardsElement, using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    class IndicationUimCardStatusOutputCardStatusCardsElementGir {
        static $gtype: GObject.GType<IndicationUimCardStatusOutputCardStatusCardsElementGir>;

        // Fields

        card_state: UimCardState;
        upin_state: UimPinState;
        upin_retries: number;
        upuk_retries: number;
        error_code: UimCardError;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiIndicationUimRefreshOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationUimRefreshOutput {
        static $gtype: GObject.GType<IndicationUimRefreshOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Event' field from `self`.
         *
         * Version of qmi_indication_uim_refresh_output_get_event() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_event(): [
            boolean,
            UimRefreshStage | null,
            UimRefreshMode | null,
            UimSessionType | null,
            Uint8Array | null,
            IndicationUimRefreshOutputEventFilesElement[] | null,
        ];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationUimRefreshOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiIndicationUimRefreshOutputEventFilesElement struct.
     */
    class IndicationUimRefreshOutputEventFilesElement {
        static $gtype: GObject.GType<IndicationUimRefreshOutputEventFilesElement>;

        // Fields

        file_id: number;
        path: any[];

        // Constructors

        constructor(
            properties?: Partial<{
                file_id: number;
                path: any[];
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * The #QmiIndicationUimSlotStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationUimSlotStatusOutput {
        static $gtype: GObject.GType<IndicationUimSlotStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        get_compat_context(): any | null;
        /**
         * Get the 'Physical Slot Information' field from `self`.
         *
         * Version of qmi_indication_uim_slot_status_output_get_physical_slot_information() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_physical_slot_information(): [boolean, PhysicalSlotInformationSlot[] | null];
        /**
         * Get the 'Physical Slot Status' field from `self`.
         *
         * Version of qmi_indication_uim_slot_status_output_get_physical_slot_status() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_physical_slot_status(): [boolean, PhysicalSlotStatusSlot[] | null];
        /**
         * Get the 'Slot EID' field from `self`.
         *
         * Version of qmi_indication_uim_slot_status_output_get_slot_eid() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_slot_eid(): [boolean, SlotEidElement[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationUimSlotStatusOutput;
        set_compat_context(compat_context?: any | null): void;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationVoiceAllCallStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationVoiceAllCallStatusOutput {
        static $gtype: GObject.GType<IndicationVoiceAllCallStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Call Information' field from `self`.
         *
         * Version of qmi_indication_voice_all_call_status_output_get_call_information() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_information(): [boolean, IndicationVoiceAllCallStatusOutputCallInformationCall[] | null];
        /**
         * Get the 'Remote Party Number' field from `self`.
         *
         * Version of qmi_indication_voice_all_call_status_output_get_remote_party_number() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_remote_party_number(): [boolean, IndicationVoiceAllCallStatusOutputRemotePartyNumberCall[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationVoiceAllCallStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiIndicationVoiceAllCallStatusOutputCallInformationCall struct.
     */
    class IndicationVoiceAllCallStatusOutputCallInformationCall {
        static $gtype: GObject.GType<IndicationVoiceAllCallStatusOutputCallInformationCall>;

        // Fields

        id: number;
        state: VoiceCallState;
        type: VoiceCallType;
        direction: VoiceCallDirection;
        mode: VoiceCallMode;
        multipart_indicator: boolean;
        als: VoiceAls;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiIndicationVoiceAllCallStatusOutputRemotePartyNumberCall struct.
     */
    class IndicationVoiceAllCallStatusOutputRemotePartyNumberCall {
        static $gtype: GObject.GType<IndicationVoiceAllCallStatusOutputRemotePartyNumberCall>;

        // Fields

        id: number;
        presentation_indicator: VoicePresentation;
        type: string;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiIndicationVoiceOriginateUssdNoWaitOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationVoiceOriginateUssdNoWaitOutput {
        static $gtype: GObject.GType<IndicationVoiceOriginateUssdNoWaitOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Alpha Identifier' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_alpha_identifier(): [boolean, VoiceAlphaDataCodingScheme | null, Uint8Array | null];
        /**
         * Get the 'Error Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_error_code(): [boolean, number];
        /**
         * Get the 'Failure Cause' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_failure_cause(): [boolean, VoiceCallEndReason | null];
        /**
         * Get the 'USS Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uss_data(): [boolean, VoiceUssDataCodingScheme | null, Uint8Array | null];
        /**
         * Get the 'USS Data UTF16' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uss_data_utf16(): [boolean, number[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationVoiceOriginateUssdNoWaitOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationVoiceSupplementaryServiceOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationVoiceSupplementaryServiceOutput {
        static $gtype: GObject.GType<IndicationVoiceSupplementaryServiceOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, number, VoiceSupplementaryServiceNotificationType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationVoiceSupplementaryServiceOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationVoiceUssdOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationVoiceUssdOutput {
        static $gtype: GObject.GType<IndicationVoiceUssdOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'User Action' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_user_action(): [boolean, VoiceUserAction | null];
        /**
         * Get the 'USS Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uss_data(): [boolean, VoiceUssDataCodingScheme | null, Uint8Array | null];
        /**
         * Get the 'USS Data UTF16' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uss_data_utf16(): [boolean, number[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationVoiceUssdOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationWdsEventReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationWdsEventReportOutput {
        static $gtype: GObject.GType<IndicationWdsEventReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Channel Rates' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_channel_rates(): [boolean, number, number];
        /**
         * Get the 'Current Data Bearer Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_data_bearer_technology(): [boolean, WdsNetworkType | null, number, number];
        /**
         * Get the 'Data Bearer Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data_bearer_technology(): [boolean, WdsDataBearerTechnology | null];
        /**
         * Get the 'Data Call Address Family' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data_call_address_family(): [boolean, WdsIpFamily | null];
        /**
         * Get the 'Data Call Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data_call_status(): [boolean, WdsDataCallStatus | null];
        /**
         * Get the 'Data Call Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data_call_type(): [boolean, WdsDataCallType | null, WdsTetheredCallType | null];
        /**
         * Get the 'Data Systems' field from `self`.
         *
         * Version of qmi_indication_wds_event_report_output_get_data_systems() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data_systems(): [
            boolean,
            WdsDataSystemNetworkType | null,
            IndicationWdsEventReportOutputDataSystemsNetworksNetwork[] | null,
        ];
        /**
         * Get the 'Dormancy Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_dormancy_status(): [boolean, WdsDormancyStatus | null];
        /**
         * Get the 'EVDO Page Monitor Period Change' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_evdo_page_monitor_period_change(): [boolean, number, boolean];
        /**
         * Get the 'Extended Data Bearer Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_data_bearer_technology(): [
            boolean,
            WdsDataSystemNetworkType | null,
            WdsRadioAccessTechnology | null,
            WdsExtendedDataBearerTechnology3gpp | null,
            WdsExtendedDataBearerTechnology3gpp2 | null,
        ];
        /**
         * Get the 'MIP Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mip_status(): [boolean, boolean];
        /**
         * Get the 'PDN Filters Removed' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdn_filters_removed(): [boolean, number[] | null];
        /**
         * Get the 'Preferred Data System' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_preferred_data_system(): [boolean, WdsDataSystem | null];
        /**
         * Get the 'Rx Bytes Ok' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_bytes_ok(): [boolean, number];
        /**
         * Get the 'Rx Overflows' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_overflows(): [boolean, number];
        /**
         * Get the 'Rx Packets Dropped' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_packets_dropped(): [boolean, number];
        /**
         * Get the 'Rx Packets Error' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_packets_error(): [boolean, number];
        /**
         * Get the 'Rx Packets Ok' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_packets_ok(): [boolean, number];
        /**
         * Get the 'Tx Bytes Ok' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tx_bytes_ok(): [boolean, number];
        /**
         * Get the 'Tx Overflows' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tx_overflows(): [boolean, number];
        /**
         * Get the 'Tx Packets Dropped' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tx_packets_dropped(): [boolean, number];
        /**
         * Get the 'Tx Packets Error' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tx_packets_error(): [boolean, number];
        /**
         * Get the 'Tx Packets Ok' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tx_packets_ok(): [boolean, number];
        /**
         * Get the 'Uplink Flow Control Enabled' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uplink_flow_control_enabled(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationWdsEventReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiIndicationWdsEventReportOutputDataSystemsNetworksNetwork struct.
     */
    class IndicationWdsEventReportOutputDataSystemsNetworksNetwork {
        static $gtype: GObject.GType<IndicationWdsEventReportOutputDataSystemsNetworksNetwork>;

        // Fields

        network_type: WdsDataSystemNetworkType;
        rat_mask: number;
        so_mask: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiIndicationWdsExtendedIpConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationWdsExtendedIpConfigOutput {
        static $gtype: GObject.GType<IndicationWdsExtendedIpConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Changed IP Configuration' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_changed_ip_configuration(): [boolean, WdsRequestedSettings | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationWdsExtendedIpConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationWdsPacketServiceStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationWdsPacketServiceStatusOutput {
        static $gtype: GObject.GType<IndicationWdsPacketServiceStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Call End Reason' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_end_reason(): [boolean, WdsCallEndReason | null];
        /**
         * Get the 'Connection Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_connection_status(): [boolean, WdsConnectionStatus | null, boolean];
        /**
         * Get the 'Extended Technology Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_technology_preference(): [boolean, WdsExtendedTechnologyPreference | null];
        /**
         * Get the 'IP Family' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ip_family(): [boolean, WdsIpFamily | null];
        /**
         * Get the 'Verbose Call End Reason' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_verbose_call_end_reason(): [boolean, WdsVerboseCallEndReasonType | null, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationWdsPacketServiceStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationWdsProfileChangedOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationWdsProfileChangedOutput {
        static $gtype: GObject.GType<IndicationWdsProfileChangedOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Profile Event' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_event(): [boolean, WdsProfileType | null, number, WdsProfileChangeEvent | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationWdsProfileChangedOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationWdsSetLteAttachPdnListOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationWdsSetLteAttachPdnListOutput {
        static $gtype: GObject.GType<IndicationWdsSetLteAttachPdnListOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Action Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_action_result(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationWdsSetLteAttachPdnListOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationWmsEventReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationWmsEventReportOutput {
        static $gtype: GObject.GType<IndicationWmsEventReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'ETWS Message' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_etws_message(): [boolean, WmsNotificationType | null, Uint8Array | null];
        /**
         * Get the 'ETWS PLMN Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_etws_plmn_information(): [boolean, number, number];
        /**
         * Get the 'Message Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_mode(): [boolean, WmsMessageMode | null];
        /**
         * Get the 'MT Message' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mt_message(): [boolean, WmsStorageType | null, number];
        /**
         * Get the 'SMS on IMS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sms_on_ims(): [boolean, boolean];
        /**
         * Get the 'SMSC Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_smsc_address(): [boolean, string];
        /**
         * Get the 'Transfer Route MT Message' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_transfer_route_mt_message(): [
            boolean,
            WmsAckIndicator | null,
            number,
            WmsMessageFormat | null,
            Uint8Array | null,
        ];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationWmsEventReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiIndicationWmsSmscAddressOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class IndicationWmsSmscAddressOutput {
        static $gtype: GObject.GType<IndicationWmsSmscAddressOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_address(): [boolean, string, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): IndicationWmsSmscAddressOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageAtrSendInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageAtrSendInput {
        static $gtype: GObject.GType<MessageAtrSendInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageAtrSendInput;

        // Methods

        /**
         * Get the 'Message' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageAtrSendInput;
        /**
         * Set the 'Message' field in the message.
         * @param value_message a constant string with a maximum length of 1024 characters.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_message(value_message: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageAtrSendOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageAtrSendOutput {
        static $gtype: GObject.GType<MessageAtrSendOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageAtrSendOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * An opaque type representing a QMI message context.
     */
    class MessageContext {
        static $gtype: GObject.GType<MessageContext>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageContext;

        // Methods

        /**
         * Gets the vendor ID associated to the message.
         * @returns the vendor ID.
         */
        get_vendor_id(): number;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageContext;
        /**
         * Sets the vendor ID associated to the message.
         * @param vendor_id the vendor ID.
         */
        set_vendor_id(vendor_id: number): void;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsActivateAutomaticInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsActivateAutomaticInput {
        static $gtype: GObject.GType<MessageDmsActivateAutomaticInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsActivateAutomaticInput;

        // Methods

        /**
         * Get the 'Activation Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_activation_code(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsActivateAutomaticInput;
        /**
         * Set the 'Activation Code' field in the message.
         * @param value_activation_code a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_activation_code(value_activation_code: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsActivateAutomaticOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsActivateAutomaticOutput {
        static $gtype: GObject.GType<MessageDmsActivateAutomaticOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsActivateAutomaticOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsActivateManualInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsActivateManualInput {
        static $gtype: GObject.GType<MessageDmsActivateManualInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsActivateManualInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, string, number, string, string];
        /**
         * Get the 'MN AAA key' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mn_aaa_key(): [boolean, string];
        /**
         * Get the 'MN HA key' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mn_ha_key(): [boolean, string];
        /**
         * Get the 'PRL' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_prl(): [boolean, number, number, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsActivateManualInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_service_programming_code a constant string of exactly 6 characters.
         * @param value_info_system_identification_number a #guint16.
         * @param value_info_mobile_directory_number a constant string with a maximum length of 15 characters.
         * @param value_info_mobile_identification_number a constant string with a maximum length of 15 characters.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(
            value_info_service_programming_code: string,
            value_info_system_identification_number: number,
            value_info_mobile_directory_number: string,
            value_info_mobile_identification_number: string,
        ): boolean;
        /**
         * Set the 'MN AAA key' field in the message.
         * @param value_mn_aaa_key a constant string with a maximum length of 16 characters.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mn_aaa_key(value_mn_aaa_key: string): boolean;
        /**
         * Set the 'MN HA key' field in the message.
         * @param value_mn_ha_key a constant string with a maximum length of 16 characters.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mn_ha_key(value_mn_ha_key: string): boolean;
        /**
         * Set the 'PRL' field in the message.
         * @param value_prl_prl_total_length a #guint16.
         * @param value_prl_prl_segment_sequence the sequence number.
         * @param value_prl_prl_segment a #GArray of #guint8 elements. A new reference to @value_prl_prl_segment will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_prl(
            value_prl_prl_total_length: number,
            value_prl_prl_segment_sequence: number,
            value_prl_prl_segment: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsActivateManualOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsActivateManualOutput {
        static $gtype: GObject.GType<MessageDmsActivateManualOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsActivateManualOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsDeleteStoredImageInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsDeleteStoredImageInput {
        static $gtype: GObject.GType<MessageDmsDeleteStoredImageInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsDeleteStoredImageInput;

        // Methods

        /**
         * Get the 'Image Details' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_image_details(): [boolean, DmsFirmwareImageType | null, Uint8Array | null, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsDeleteStoredImageInput;
        /**
         * Set the 'Image Details' field in the message.
         * @param value_image_details_type a #QmiDmsFirmwareImageType.
         * @param value_image_details_unique_id a #GArray of #guint8 elements. A new reference to @value_image_details_unique_id will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @param value_image_details_build_id a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_image_details(
            value_image_details_type: DmsFirmwareImageType,
            value_image_details_unique_id: Uint8Array | string,
            value_image_details_build_id: string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsDeleteStoredImageOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsDeleteStoredImageOutput {
        static $gtype: GObject.GType<MessageDmsDeleteStoredImageOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsDeleteStoredImageOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsFoxconnChangeDeviceModeInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsFoxconnChangeDeviceModeInput {
        static $gtype: GObject.GType<MessageDmsFoxconnChangeDeviceModeInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsFoxconnChangeDeviceModeInput;

        // Methods

        /**
         * Get the 'Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mode(): [boolean, DmsFoxconnDeviceMode | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsFoxconnChangeDeviceModeInput;
        /**
         * Set the 'Mode' field in the message.
         * @param value_mode a #QmiDmsFoxconnDeviceMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mode(value_mode: DmsFoxconnDeviceMode): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsFoxconnChangeDeviceModeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsFoxconnChangeDeviceModeOutput {
        static $gtype: GObject.GType<MessageDmsFoxconnChangeDeviceModeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsFoxconnChangeDeviceModeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsFoxconnGetFirmwareVersionInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsFoxconnGetFirmwareVersionInput {
        static $gtype: GObject.GType<MessageDmsFoxconnGetFirmwareVersionInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsFoxconnGetFirmwareVersionInput;

        // Methods

        /**
         * Get the 'Version Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_version_type(): [boolean, DmsFoxconnFirmwareVersionType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsFoxconnGetFirmwareVersionInput;
        /**
         * Set the 'Version Type' field in the message.
         * @param value_version_type a #QmiDmsFoxconnFirmwareVersionType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_version_type(value_version_type: DmsFoxconnFirmwareVersionType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsFoxconnGetFirmwareVersionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsFoxconnGetFirmwareVersionOutput {
        static $gtype: GObject.GType<MessageDmsFoxconnGetFirmwareVersionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_version(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsFoxconnGetFirmwareVersionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsFoxconnSetFccAuthenticationInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsFoxconnSetFccAuthenticationInput {
        static $gtype: GObject.GType<MessageDmsFoxconnSetFccAuthenticationInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsFoxconnSetFccAuthenticationInput;

        // Methods

        /**
         * Get the 'Value' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_value(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsFoxconnSetFccAuthenticationInput;
        /**
         * Set the 'Value' field in the message.
         * @param value_value a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_value(value_value: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsFoxconnSetFccAuthenticationOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsFoxconnSetFccAuthenticationOutput {
        static $gtype: GObject.GType<MessageDmsFoxconnSetFccAuthenticationOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsFoxconnSetFccAuthenticationOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsFoxconnSetFccAuthenticationV2Input structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsFoxconnSetFccAuthenticationV2Input {
        static $gtype: GObject.GType<MessageDmsFoxconnSetFccAuthenticationV2Input>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsFoxconnSetFccAuthenticationV2Input;

        // Methods

        /**
         * Get the 'Magic Number' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_magic_number(): [boolean, number];
        /**
         * Get the 'Magic String' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_magic_string(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsFoxconnSetFccAuthenticationV2Input;
        /**
         * Set the 'Magic Number' field in the message.
         * @param value_magic_number a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_magic_number(value_magic_number: number): boolean;
        /**
         * Set the 'Magic String' field in the message.
         * @param value_magic_string a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_magic_string(value_magic_string: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsFoxconnSetFccAuthenticationV2Output structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsFoxconnSetFccAuthenticationV2Output {
        static $gtype: GObject.GType<MessageDmsFoxconnSetFccAuthenticationV2Output>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsFoxconnSetFccAuthenticationV2Output;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetActivationStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetActivationStateOutput {
        static $gtype: GObject.GType<MessageDmsGetActivationStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, DmsActivationState | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetActivationStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetAltNetConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetAltNetConfigOutput {
        static $gtype: GObject.GType<MessageDmsGetAltNetConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Config' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_config(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetAltNetConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetBandCapabilitiesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetBandCapabilitiesOutput {
        static $gtype: GObject.GType<MessageDmsGetBandCapabilitiesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Band Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_band_capability(): [boolean, DmsBandCapability | null];
        /**
         * Get the 'Extended LTE Band Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_lte_band_capability(): [boolean, number[] | null];
        /**
         * Get the 'LTE Band Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_band_capability(): [boolean, DmsLteBandCapability | null];
        /**
         * Get the 'NR5G Band Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_band_capability(): [boolean, number[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetBandCapabilitiesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetBootImageDownloadModeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetBootImageDownloadModeOutput {
        static $gtype: GObject.GType<MessageDmsGetBootImageDownloadModeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mode(): [boolean, DmsBootImageDownloadMode | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetBootImageDownloadModeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetCapabilitiesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetCapabilitiesOutput {
        static $gtype: GObject.GType<MessageDmsGetCapabilitiesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [
            boolean,
            number,
            number,
            DmsDataServiceCapability | null,
            DmsSimCapability | null,
            DmsRadioInterface[] | null,
        ];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetCapabilitiesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetFactorySkuOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetFactorySkuOutput {
        static $gtype: GObject.GType<MessageDmsGetFactorySkuOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'SKU' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sku(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetFactorySkuOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetFirmwarePreferenceOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetFirmwarePreferenceOutput {
        static $gtype: GObject.GType<MessageDmsGetFirmwarePreferenceOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'List' field from `self`.
         *
         * Version of qmi_message_dms_get_firmware_preference_output_get_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, MessageDmsGetFirmwarePreferenceOutputListImage[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetFirmwarePreferenceOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageDmsGetFirmwarePreferenceOutputListImage struct.
     */
    class MessageDmsGetFirmwarePreferenceOutputListImage {
        static $gtype: GObject.GType<MessageDmsGetFirmwarePreferenceOutputListImage>;

        // Fields

        type: DmsFirmwareImageType;
        unique_id: any[];
        build_id: string;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageDmsGetHardwareRevisionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetHardwareRevisionOutput {
        static $gtype: GObject.GType<MessageDmsGetHardwareRevisionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Revision' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_revision(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetHardwareRevisionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetIdsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetIdsOutput {
        static $gtype: GObject.GType<MessageDmsGetIdsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Esn' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_esn(): [boolean, string];
        /**
         * Get the 'Imei' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_imei(): [boolean, string];
        /**
         * Get the 'Imei Software Version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_imei_software_version(): [boolean, string];
        /**
         * Get the 'Meid' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_meid(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetIdsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetMacAddressInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsGetMacAddressInput {
        static $gtype: GObject.GType<MessageDmsGetMacAddressInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsGetMacAddressInput;

        // Methods

        /**
         * Get the 'Device' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_device(): [boolean, DmsMacType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetMacAddressInput;
        /**
         * Set the 'Device' field in the message.
         * @param value_device a #QmiDmsMacType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_device(value_device: DmsMacType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetMacAddressOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetMacAddressOutput {
        static $gtype: GObject.GType<MessageDmsGetMacAddressOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'MAC Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mac_address(): [boolean, Uint8Array | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetMacAddressOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetManufacturerOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetManufacturerOutput {
        static $gtype: GObject.GType<MessageDmsGetManufacturerOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Manufacturer' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_manufacturer(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetManufacturerOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetModelOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetModelOutput {
        static $gtype: GObject.GType<MessageDmsGetModelOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Model' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_model(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetModelOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetMsisdnOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetMsisdnOutput {
        static $gtype: GObject.GType<MessageDmsGetMsisdnOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'MSISDN' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_msisdn(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetMsisdnOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetOperatingModeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetOperatingModeOutput {
        static $gtype: GObject.GType<MessageDmsGetOperatingModeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Hardware Restricted Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hardware_restricted_mode(): [boolean, boolean];
        /**
         * Get the 'Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mode(): [boolean, DmsOperatingMode | null];
        /**
         * Get the 'Offline Reason' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_offline_reason(): [boolean, DmsOfflineReason | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetOperatingModeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetPowerStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetPowerStateOutput {
        static $gtype: GObject.GType<MessageDmsGetPowerStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, number, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetPowerStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetPrlVersionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetPrlVersionOutput {
        static $gtype: GObject.GType<MessageDmsGetPrlVersionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'PRL Only Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_prl_only_preference(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_version(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetPrlVersionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetRevisionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetRevisionOutput {
        static $gtype: GObject.GType<MessageDmsGetRevisionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Revision' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_revision(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetRevisionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetSoftwareVersionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetSoftwareVersionOutput {
        static $gtype: GObject.GType<MessageDmsGetSoftwareVersionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_version(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetSoftwareVersionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetStoredImageInfoInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsGetStoredImageInfoInput {
        static $gtype: GObject.GType<MessageDmsGetStoredImageInfoInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsGetStoredImageInfoInput;

        // Methods

        /**
         * Get the 'Image Details' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_image_details(): [boolean, DmsFirmwareImageType | null, Uint8Array | null, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetStoredImageInfoInput;
        /**
         * Set the 'Image Details' field in the message.
         * @param value_image_details_type a #QmiDmsFirmwareImageType.
         * @param value_image_details_unique_id a #GArray of #guint8 elements. A new reference to @value_image_details_unique_id will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @param value_image_details_build_id a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_image_details(
            value_image_details_type: DmsFirmwareImageType,
            value_image_details_unique_id: Uint8Array | string,
            value_image_details_build_id: string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetStoredImageInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetStoredImageInfoOutput {
        static $gtype: GObject.GType<MessageDmsGetStoredImageInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Boot Version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_boot_version(): [boolean, number, number];
        /**
         * Get the 'OEM Lock ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_oem_lock_id(): [boolean, number];
        /**
         * Get the 'PRI Version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pri_version(): [boolean, number, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetStoredImageInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetSupportedMessagesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetSupportedMessagesOutput {
        static $gtype: GObject.GType<MessageDmsGetSupportedMessagesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, Uint8Array | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetSupportedMessagesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetTimeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetTimeOutput {
        static $gtype: GObject.GType<MessageDmsGetTimeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Device Time' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_device_time(): [boolean, number, DmsTimeSource | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'System Time' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_system_time(): [boolean, number];
        /**
         * Get the 'User Time' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_user_time(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetTimeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsGetUserLockStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsGetUserLockStateOutput {
        static $gtype: GObject.GType<MessageDmsGetUserLockStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Enabled' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_enabled(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsGetUserLockStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsHpChangeDeviceModeInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsHpChangeDeviceModeInput {
        static $gtype: GObject.GType<MessageDmsHpChangeDeviceModeInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsHpChangeDeviceModeInput;

        // Methods

        /**
         * Get the 'Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mode(): [boolean, DmsHpDeviceMode | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsHpChangeDeviceModeInput;
        /**
         * Set the 'Mode' field in the message.
         * @param value_mode a #QmiDmsHpDeviceMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mode(value_mode: DmsHpDeviceMode): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsHpChangeDeviceModeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsHpChangeDeviceModeOutput {
        static $gtype: GObject.GType<MessageDmsHpChangeDeviceModeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsHpChangeDeviceModeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsListStoredImagesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsListStoredImagesOutput {
        static $gtype: GObject.GType<MessageDmsListStoredImagesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'List' field from `self`.
         *
         * Version of qmi_message_dms_list_stored_images_output_get_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, MessageDmsListStoredImagesOutputListImageGir[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsListStoredImagesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageDmsListStoredImagesOutputListImageGir struct.
     *
     * This type is a version of #QmiMessageDmsListStoredImagesOutputListImage, using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    class MessageDmsListStoredImagesOutputListImageGir {
        static $gtype: GObject.GType<MessageDmsListStoredImagesOutputListImageGir>;

        // Fields

        type: DmsFirmwareImageType;
        maximum_images: number;
        index_of_running_image: number;
        sublist: MessageDmsListStoredImagesOutputListImageSublistSublistElement[];

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageDmsListStoredImagesOutputListImageSublistSublistElement struct.
     */
    class MessageDmsListStoredImagesOutputListImageSublistSublistElement {
        static $gtype: GObject.GType<MessageDmsListStoredImagesOutputListImageSublistSublistElement>;

        // Fields

        storage_index: number;
        failure_count: number;
        unique_id: any[];
        build_id: string;

        // Constructors

        constructor(
            properties?: Partial<{
                storage_index: number;
                failure_count: number;
                unique_id: any[];
                build_id: string;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageDmsReadEriFileOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsReadEriFileOutput {
        static $gtype: GObject.GType<MessageDmsReadEriFileOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'ERI File' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_eri_file(): [boolean, Uint8Array | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsReadEriFileOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsReadUserDataOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsReadUserDataOutput {
        static $gtype: GObject.GType<MessageDmsReadUserDataOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'User Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_user_data(): [boolean, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsReadUserDataOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsResetOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsResetOutput {
        static $gtype: GObject.GType<MessageDmsResetOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsResetOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsRestoreFactoryDefaultsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsRestoreFactoryDefaultsInput {
        static $gtype: GObject.GType<MessageDmsRestoreFactoryDefaultsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsRestoreFactoryDefaultsInput;

        // Methods

        /**
         * Get the 'Service Programming Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_service_programming_code(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsRestoreFactoryDefaultsInput;
        /**
         * Set the 'Service Programming Code' field in the message.
         * @param value_service_programming_code a constant string of exactly 6 characters.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_service_programming_code(value_service_programming_code: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsRestoreFactoryDefaultsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsRestoreFactoryDefaultsOutput {
        static $gtype: GObject.GType<MessageDmsRestoreFactoryDefaultsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsRestoreFactoryDefaultsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetAltNetConfigInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsSetAltNetConfigInput {
        static $gtype: GObject.GType<MessageDmsSetAltNetConfigInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsSetAltNetConfigInput;

        // Methods

        /**
         * Get the 'Config' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_config(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetAltNetConfigInput;
        /**
         * Set the 'Config' field in the message.
         * @param value_config a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_config(value_config: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetAltNetConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSetAltNetConfigOutput {
        static $gtype: GObject.GType<MessageDmsSetAltNetConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetAltNetConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetBootImageDownloadModeInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsSetBootImageDownloadModeInput {
        static $gtype: GObject.GType<MessageDmsSetBootImageDownloadModeInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsSetBootImageDownloadModeInput;

        // Methods

        /**
         * Get the 'Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mode(): [boolean, DmsBootImageDownloadMode | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetBootImageDownloadModeInput;
        /**
         * Set the 'Mode' field in the message.
         * @param value_mode a #QmiDmsBootImageDownloadMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mode(value_mode: DmsBootImageDownloadMode): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetBootImageDownloadModeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSetBootImageDownloadModeOutput {
        static $gtype: GObject.GType<MessageDmsSetBootImageDownloadModeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetBootImageDownloadModeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetEventReportInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsSetEventReportInput {
        static $gtype: GObject.GType<MessageDmsSetEventReportInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsSetEventReportInput;

        // Methods

        /**
         * Get the 'Activation State Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_activation_state_reporting(): [boolean, boolean];
        /**
         * Get the 'Battery Level Report Limits' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_battery_level_report_limits(): [boolean, number, number];
        /**
         * Get the 'Operating Mode Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_operating_mode_reporting(): [boolean, boolean];
        /**
         * Get the 'PIN State Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pin_state_reporting(): [boolean, boolean];
        /**
         * Get the 'Power State Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_power_state_reporting(): [boolean, boolean];
        /**
         * Get the 'PRL Init Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_prl_init_reporting(): [boolean, boolean];
        /**
         * Get the 'UIM State Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uim_state_reporting(): [boolean, boolean];
        /**
         * Get the 'Wireless Disable State Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wireless_disable_state_reporting(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetEventReportInput;
        /**
         * Set the 'Activation State Reporting' field in the message.
         * @param value_activation_state_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_activation_state_reporting(value_activation_state_reporting: boolean): boolean;
        /**
         * Set the 'Battery Level Report Limits' field in the message.
         * @param value_battery_level_report_limits_lower_limit a #guint8.
         * @param value_battery_level_report_limits_upper_limit a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_battery_level_report_limits(
            value_battery_level_report_limits_lower_limit: number,
            value_battery_level_report_limits_upper_limit: number,
        ): boolean;
        /**
         * Set the 'Operating Mode Reporting' field in the message.
         * @param value_operating_mode_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_operating_mode_reporting(value_operating_mode_reporting: boolean): boolean;
        /**
         * Set the 'PIN State Reporting' field in the message.
         * @param value_pin_state_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pin_state_reporting(value_pin_state_reporting: boolean): boolean;
        /**
         * Set the 'Power State Reporting' field in the message.
         * @param value_power_state_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_power_state_reporting(value_power_state_reporting: boolean): boolean;
        /**
         * Set the 'PRL Init Reporting' field in the message.
         * @param value_prl_init_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_prl_init_reporting(value_prl_init_reporting: boolean): boolean;
        /**
         * Set the 'UIM State Reporting' field in the message.
         * @param value_uim_state_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_uim_state_reporting(value_uim_state_reporting: boolean): boolean;
        /**
         * Set the 'Wireless Disable State Reporting' field in the message.
         * @param value_wireless_disable_state_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_wireless_disable_state_reporting(value_wireless_disable_state_reporting: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetEventReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSetEventReportOutput {
        static $gtype: GObject.GType<MessageDmsSetEventReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetEventReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetFccAuthenticationOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSetFccAuthenticationOutput {
        static $gtype: GObject.GType<MessageDmsSetFccAuthenticationOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetFccAuthenticationOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetFirmwareIdOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSetFirmwareIdOutput {
        static $gtype: GObject.GType<MessageDmsSetFirmwareIdOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetFirmwareIdOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetFirmwarePreferenceInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsSetFirmwarePreferenceInput {
        static $gtype: GObject.GType<MessageDmsSetFirmwarePreferenceInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsSetFirmwarePreferenceInput;

        // Methods

        /**
         * Get the 'Download Override' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_download_override(): [boolean, boolean];
        /**
         * Get the 'List' field from `self`.
         *
         * Version of qmi_message_dms_set_firmware_preference_input_get_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, MessageDmsSetFirmwarePreferenceInputListImage[] | null];
        /**
         * Get the 'Modem Storage Index' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_modem_storage_index(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetFirmwarePreferenceInput;
        /**
         * Set the 'Download Override' field in the message.
         * @param value_download_override a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_download_override(value_download_override: boolean): boolean;
        /**
         * Set the 'List' field in the message.
         * @param value_list_ptr array of #QmiMessageDmsSetFirmwarePreferenceInputListImage elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_list(value_list_ptr: MessageDmsSetFirmwarePreferenceInputListImage[]): boolean;
        /**
         * Set the 'Modem Storage Index' field in the message.
         * @param value_modem_storage_index a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_modem_storage_index(value_modem_storage_index: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageDmsSetFirmwarePreferenceInputListImage struct.
     */
    class MessageDmsSetFirmwarePreferenceInputListImage {
        static $gtype: GObject.GType<MessageDmsSetFirmwarePreferenceInputListImage>;

        // Fields

        type: DmsFirmwareImageType;
        unique_id: any[];
        build_id: string;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageDmsSetFirmwarePreferenceOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSetFirmwarePreferenceOutput {
        static $gtype: GObject.GType<MessageDmsSetFirmwarePreferenceOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Image Download List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_image_download_list(): [boolean, DmsFirmwareImageType[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetFirmwarePreferenceOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetOperatingModeInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsSetOperatingModeInput {
        static $gtype: GObject.GType<MessageDmsSetOperatingModeInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsSetOperatingModeInput;

        // Methods

        /**
         * Get the 'Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mode(): [boolean, DmsOperatingMode | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetOperatingModeInput;
        /**
         * Set the 'Mode' field in the message.
         * @param value_mode a #QmiDmsOperatingMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mode(value_mode: DmsOperatingMode): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetOperatingModeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSetOperatingModeOutput {
        static $gtype: GObject.GType<MessageDmsSetOperatingModeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetOperatingModeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetServiceProgrammingCodeInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsSetServiceProgrammingCodeInput {
        static $gtype: GObject.GType<MessageDmsSetServiceProgrammingCodeInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsSetServiceProgrammingCodeInput;

        // Methods

        /**
         * Get the 'Current Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_code(): [boolean, string];
        /**
         * Get the 'New Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_new_code(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetServiceProgrammingCodeInput;
        /**
         * Set the 'Current Code' field in the message.
         * @param value_current_code a constant string of exactly 6 characters.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_current_code(value_current_code: string): boolean;
        /**
         * Set the 'New Code' field in the message.
         * @param value_new_code a constant string of exactly 6 characters.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_new_code(value_new_code: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetServiceProgrammingCodeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSetServiceProgrammingCodeOutput {
        static $gtype: GObject.GType<MessageDmsSetServiceProgrammingCodeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetServiceProgrammingCodeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetTimeInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsSetTimeInput {
        static $gtype: GObject.GType<MessageDmsSetTimeInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsSetTimeInput;

        // Methods

        /**
         * Get the 'Time Reference Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_time_reference_type(): [boolean, DmsTimeReferenceType | null];
        /**
         * Get the 'Time Value' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_time_value(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetTimeInput;
        /**
         * Set the 'Time Reference Type' field in the message.
         * @param value_time_reference_type a #QmiDmsTimeReferenceType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_time_reference_type(value_time_reference_type: DmsTimeReferenceType): boolean;
        /**
         * Set the 'Time Value' field in the message.
         * @param value_time_value a #guint64.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_time_value(value_time_value: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetTimeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSetTimeOutput {
        static $gtype: GObject.GType<MessageDmsSetTimeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetTimeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetUserLockCodeInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsSetUserLockCodeInput {
        static $gtype: GObject.GType<MessageDmsSetUserLockCodeInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsSetUserLockCodeInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, string, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetUserLockCodeInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_old_code a constant string of exactly 4 characters.
         * @param value_info_new_code a constant string of exactly 4 characters.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(value_info_old_code: string, value_info_new_code: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetUserLockCodeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSetUserLockCodeOutput {
        static $gtype: GObject.GType<MessageDmsSetUserLockCodeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetUserLockCodeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetUserLockStateInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsSetUserLockStateInput {
        static $gtype: GObject.GType<MessageDmsSetUserLockStateInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsSetUserLockStateInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetUserLockStateInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_enabled a #gboolean.
         * @param value_info_lock_code a constant string of exactly 4 characters.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(value_info_enabled: boolean, value_info_lock_code: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSetUserLockStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSetUserLockStateOutput {
        static $gtype: GObject.GType<MessageDmsSetUserLockStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSetUserLockStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSwiGetCurrentFirmwareOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSwiGetCurrentFirmwareOutput {
        static $gtype: GObject.GType<MessageDmsSwiGetCurrentFirmwareOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'AMSS version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_amss_version(): [boolean, string];
        /**
         * Get the 'Boot version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_boot_version(): [boolean, string];
        /**
         * Get the 'Carrier' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_carrier(): [boolean, string];
        /**
         * Get the 'Carrier ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_carrier_id(): [boolean, string];
        /**
         * Get the 'Config version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_config_version(): [boolean, string];
        /**
         * Get the 'Model' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_model(): [boolean, string];
        /**
         * Get the 'Package ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_package_id(): [boolean, string];
        /**
         * Get the 'PRI version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pri_version(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'SKU ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sku_id(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSwiGetCurrentFirmwareOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSwiGetUsbCompositionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSwiGetUsbCompositionOutput {
        static $gtype: GObject.GType<MessageDmsSwiGetUsbCompositionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Current' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current(): [boolean, DmsSwiUsbComposition | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Supported' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_supported(): [boolean, DmsSwiUsbComposition[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSwiGetUsbCompositionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSwiSetUsbCompositionInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsSwiSetUsbCompositionInput {
        static $gtype: GObject.GType<MessageDmsSwiSetUsbCompositionInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsSwiSetUsbCompositionInput;

        // Methods

        /**
         * Get the 'Current' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current(): [boolean, DmsSwiUsbComposition | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSwiSetUsbCompositionInput;
        /**
         * Set the 'Current' field in the message.
         * @param value_current a #QmiDmsSwiUsbComposition.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_current(value_current: DmsSwiUsbComposition): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsSwiSetUsbCompositionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsSwiSetUsbCompositionOutput {
        static $gtype: GObject.GType<MessageDmsSwiSetUsbCompositionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsSwiSetUsbCompositionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimChangePinInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsUimChangePinInput {
        static $gtype: GObject.GType<MessageDmsUimChangePinInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsUimChangePinInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, DmsUimPinId | null, string, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimChangePinInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_pin_id a #QmiDmsUimPinId.
         * @param value_info_old_pin a constant string.
         * @param value_info_new_pin a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(value_info_pin_id: DmsUimPinId, value_info_old_pin: string, value_info_new_pin: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimChangePinOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsUimChangePinOutput {
        static $gtype: GObject.GType<MessageDmsUimChangePinOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Pin Retries Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pin_retries_status(): [boolean, number, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimChangePinOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimGetCkStatusInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsUimGetCkStatusInput {
        static $gtype: GObject.GType<MessageDmsUimGetCkStatusInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsUimGetCkStatusInput;

        // Methods

        /**
         * Get the 'Facility' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_facility(): [boolean, DmsUimFacility | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimGetCkStatusInput;
        /**
         * Set the 'Facility' field in the message.
         * @param value_facility a #QmiDmsUimFacility.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_facility(value_facility: DmsUimFacility): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimGetCkStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsUimGetCkStatusOutput {
        static $gtype: GObject.GType<MessageDmsUimGetCkStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'CK Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ck_status(): [boolean, DmsUimFacilityState | null, number, number];
        /**
         * Get the 'Operation Blocking Facility' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_operation_blocking_facility(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimGetCkStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimGetIccidOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsUimGetIccidOutput {
        static $gtype: GObject.GType<MessageDmsUimGetIccidOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'ICCID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_iccid(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimGetIccidOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimGetImsiOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsUimGetImsiOutput {
        static $gtype: GObject.GType<MessageDmsUimGetImsiOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'IMSI' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_imsi(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimGetImsiOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimGetPinStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsUimGetPinStatusOutput {
        static $gtype: GObject.GType<MessageDmsUimGetPinStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'PIN1 Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pin1_status(): [boolean, DmsUimPinStatus | null, number, number];
        /**
         * Get the 'PIN2 Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pin2_status(): [boolean, DmsUimPinStatus | null, number, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimGetPinStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimGetStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsUimGetStateOutput {
        static $gtype: GObject.GType<MessageDmsUimGetStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_state(): [boolean, DmsUimState | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimGetStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimSetCkProtectionInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsUimSetCkProtectionInput {
        static $gtype: GObject.GType<MessageDmsUimSetCkProtectionInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsUimSetCkProtectionInput;

        // Methods

        /**
         * Get the 'Facility' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_facility(): [boolean, DmsUimFacility | null, DmsUimFacilityState | null, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimSetCkProtectionInput;
        /**
         * Set the 'Facility' field in the message.
         * @param value_facility_facility a #QmiDmsUimFacility.
         * @param value_facility_facility_state a #QmiDmsUimFacilityState.
         * @param value_facility_facility_depersonalization_control_key a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_facility(
            value_facility_facility: DmsUimFacility,
            value_facility_facility_state: DmsUimFacilityState,
            value_facility_facility_depersonalization_control_key: string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimSetCkProtectionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsUimSetCkProtectionOutput {
        static $gtype: GObject.GType<MessageDmsUimSetCkProtectionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Verify Retries Left' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_verify_retries_left(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimSetCkProtectionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimSetPinProtectionInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsUimSetPinProtectionInput {
        static $gtype: GObject.GType<MessageDmsUimSetPinProtectionInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsUimSetPinProtectionInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, DmsUimPinId | null, boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimSetPinProtectionInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_pin_id a #QmiDmsUimPinId.
         * @param value_info_protection_enabled a #gboolean.
         * @param value_info_pin a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(
            value_info_pin_id: DmsUimPinId,
            value_info_protection_enabled: boolean,
            value_info_pin: string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimSetPinProtectionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsUimSetPinProtectionOutput {
        static $gtype: GObject.GType<MessageDmsUimSetPinProtectionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Pin Retries Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pin_retries_status(): [boolean, number, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimSetPinProtectionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimUnblockCkInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsUimUnblockCkInput {
        static $gtype: GObject.GType<MessageDmsUimUnblockCkInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsUimUnblockCkInput;

        // Methods

        /**
         * Get the 'Facility' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_facility(): [boolean, DmsUimFacility | null, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimUnblockCkInput;
        /**
         * Set the 'Facility' field in the message.
         * @param value_facility_facility a #QmiDmsUimFacility.
         * @param value_facility_facility_control_key a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_facility(value_facility_facility: DmsUimFacility, value_facility_facility_control_key: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimUnblockCkOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsUimUnblockCkOutput {
        static $gtype: GObject.GType<MessageDmsUimUnblockCkOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Unblock Retries Left' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_unblock_retries_left(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimUnblockCkOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimUnblockPinInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsUimUnblockPinInput {
        static $gtype: GObject.GType<MessageDmsUimUnblockPinInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsUimUnblockPinInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, DmsUimPinId | null, string, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimUnblockPinInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_pin_id a #QmiDmsUimPinId.
         * @param value_info_puk a constant string.
         * @param value_info_new_pin a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(value_info_pin_id: DmsUimPinId, value_info_puk: string, value_info_new_pin: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimUnblockPinOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsUimUnblockPinOutput {
        static $gtype: GObject.GType<MessageDmsUimUnblockPinOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Pin Retries Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pin_retries_status(): [boolean, number, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimUnblockPinOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimVerifyPinInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsUimVerifyPinInput {
        static $gtype: GObject.GType<MessageDmsUimVerifyPinInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsUimVerifyPinInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, DmsUimPinId | null, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimVerifyPinInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_pin_id a #QmiDmsUimPinId.
         * @param value_info_pin a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(value_info_pin_id: DmsUimPinId, value_info_pin: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsUimVerifyPinOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsUimVerifyPinOutput {
        static $gtype: GObject.GType<MessageDmsUimVerifyPinOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Pin Retries Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pin_retries_status(): [boolean, number, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsUimVerifyPinOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsValidateServiceProgrammingCodeInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsValidateServiceProgrammingCodeInput {
        static $gtype: GObject.GType<MessageDmsValidateServiceProgrammingCodeInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsValidateServiceProgrammingCodeInput;

        // Methods

        /**
         * Get the 'Service Programming Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_service_programming_code(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsValidateServiceProgrammingCodeInput;
        /**
         * Set the 'Service Programming Code' field in the message.
         * @param value_service_programming_code a constant string of exactly 6 characters.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_service_programming_code(value_service_programming_code: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsValidateServiceProgrammingCodeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsValidateServiceProgrammingCodeOutput {
        static $gtype: GObject.GType<MessageDmsValidateServiceProgrammingCodeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsValidateServiceProgrammingCodeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsWriteUserDataInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDmsWriteUserDataInput {
        static $gtype: GObject.GType<MessageDmsWriteUserDataInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDmsWriteUserDataInput;

        // Methods

        /**
         * Get the 'User Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_user_data(): [boolean, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsWriteUserDataInput;
        /**
         * Set the 'User Data' field in the message.
         * @param value_user_data a #GArray of #guint8 elements. A new reference to @value_user_data will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_user_data(value_user_data: Uint8Array | string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDmsWriteUserDataOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDmsWriteUserDataOutput {
        static $gtype: GObject.GType<MessageDmsWriteUserDataOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDmsWriteUserDataOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDpmClosePortOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDpmClosePortOutput {
        static $gtype: GObject.GType<MessageDpmClosePortOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDpmClosePortOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDpmOpenPortInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDpmOpenPortInput {
        static $gtype: GObject.GType<MessageDpmOpenPortInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDpmOpenPortInput;

        // Methods

        /**
         * Get the 'Control Ports' field from `self`.
         *
         * Version of qmi_message_dpm_open_port_input_get_control_ports() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_control_ports(): [boolean, MessageDpmOpenPortInputControlPortsElement[] | null];
        /**
         * Get the 'Hardware Data Ports' field from `self`.
         *
         * Version of qmi_message_dpm_open_port_input_get_hardware_data_ports() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hardware_data_ports(): [boolean, MessageDpmOpenPortInputHardwareDataPortsElement[] | null];
        /**
         * Get the 'Software Data Ports' field from `self`.
         *
         * Version of qmi_message_dpm_open_port_input_get_software_data_ports() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_software_data_ports(): [boolean, MessageDpmOpenPortInputSoftwareDataPortsElement[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDpmOpenPortInput;
        /**
         * Set the 'Control Ports' field in the message.
         * @param value_control_ports_ptr array of #QmiMessageDpmOpenPortInputControlPortsElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_control_ports(value_control_ports_ptr: MessageDpmOpenPortInputControlPortsElement[]): boolean;
        /**
         * Set the 'Hardware Data Ports' field in the message.
         * @param value_hardware_data_ports_ptr array of #QmiMessageDpmOpenPortInputHardwareDataPortsElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_hardware_data_ports(
            value_hardware_data_ports_ptr: MessageDpmOpenPortInputHardwareDataPortsElement[],
        ): boolean;
        /**
         * Set the 'Software Data Ports' field in the message.
         * @param value_software_data_ports_ptr array of #QmiMessageDpmOpenPortInputSoftwareDataPortsElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_software_data_ports(
            value_software_data_ports_ptr: MessageDpmOpenPortInputSoftwareDataPortsElement[],
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageDpmOpenPortInputControlPortsElement struct.
     */
    class MessageDpmOpenPortInputControlPortsElement {
        static $gtype: GObject.GType<MessageDpmOpenPortInputControlPortsElement>;

        // Fields

        port_name: string;
        endpoint_type: DataEndpointType;
        interface_number: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageDpmOpenPortInputHardwareDataPortsElement struct.
     */
    class MessageDpmOpenPortInputHardwareDataPortsElement {
        static $gtype: GObject.GType<MessageDpmOpenPortInputHardwareDataPortsElement>;

        // Fields

        endpoint_type: DataEndpointType;
        interface_number: number;
        rx_endpoint_number: number;
        tx_endpoint_number: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageDpmOpenPortInputSoftwareDataPortsElement struct.
     */
    class MessageDpmOpenPortInputSoftwareDataPortsElement {
        static $gtype: GObject.GType<MessageDpmOpenPortInputSoftwareDataPortsElement>;

        // Fields

        endpoint_type: DataEndpointType;
        interface_number: number;
        port_name: string;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageDpmOpenPortOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDpmOpenPortOutput {
        static $gtype: GObject.GType<MessageDpmOpenPortOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDpmOpenPortOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDsdGetApnInfoInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDsdGetApnInfoInput {
        static $gtype: GObject.GType<MessageDsdGetApnInfoInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDsdGetApnInfoInput;

        // Methods

        /**
         * Get the 'APN Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_type(): [boolean, DsdApnType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDsdGetApnInfoInput;
        /**
         * Set the 'APN Type' field in the message.
         * @param value_apn_type a #QmiDsdApnType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn_type(value_apn_type: DsdApnType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDsdGetApnInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDsdGetApnInfoOutput {
        static $gtype: GObject.GType<MessageDsdGetApnInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'APN Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_name(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDsdGetApnInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDsdGetSystemStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDsdGetSystemStatusOutput {
        static $gtype: GObject.GType<MessageDsdGetSystemStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Available Systems' field from `self`.
         *
         * Version of qmi_message_dsd_get_system_status_output_get_available_systems() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_available_systems(): [boolean, MessageDsdGetSystemStatusOutputAvailableSystemsSystem[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDsdGetSystemStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageDsdGetSystemStatusOutputAvailableSystemsSystem struct.
     */
    class MessageDsdGetSystemStatusOutputAvailableSystemsSystem {
        static $gtype: GObject.GType<MessageDsdGetSystemStatusOutputAvailableSystemsSystem>;

        // Fields

        technology: DsdDataSystemNetworkType;
        rat: DsdRadioAccessTechnology;
        so_mask: DsdSoMask;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageDsdSetApnTypeInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDsdSetApnTypeInput {
        static $gtype: GObject.GType<MessageDsdSetApnTypeInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDsdSetApnTypeInput;

        // Methods

        /**
         * Get the 'APN Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_type(): [boolean, string, DsdApnTypePreference | null];
        /**
         * Get the 'APN Type Preference Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_type_preference_mask(): [boolean, DsdApnTypePreference | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDsdSetApnTypeInput;
        /**
         * Set the 'APN Type' field in the message.
         * @param value_apn_type_name a constant string.
         * @param value_apn_type_type a #QmiDsdApnTypePreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn_type(value_apn_type_name: string, value_apn_type_type: DsdApnTypePreference): boolean;
        /**
         * Set the 'APN Type Preference Mask' field in the message.
         * @param value_apn_type_preference_mask a #QmiDsdApnTypePreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn_type_preference_mask(value_apn_type_preference_mask: DsdApnTypePreference): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDsdSetApnTypeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDsdSetApnTypeOutput {
        static $gtype: GObject.GType<MessageDsdSetApnTypeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDsdSetApnTypeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDsdSystemStatusChangeInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageDsdSystemStatusChangeInput {
        static $gtype: GObject.GType<MessageDsdSystemStatusChangeInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageDsdSystemStatusChangeInput;

        // Methods

        /**
         * Get the 'Register Indication' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_register_indication(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDsdSystemStatusChangeInput;
        /**
         * Set the 'Register Indication' field in the message.
         * @param value_register_indication a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_register_indication(value_register_indication: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageDsdSystemStatusChangeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageDsdSystemStatusChangeOutput {
        static $gtype: GObject.GType<MessageDsdSystemStatusChangeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageDsdSystemStatusChangeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageFoxGetFirmwareVersionInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageFoxGetFirmwareVersionInput {
        static $gtype: GObject.GType<MessageFoxGetFirmwareVersionInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageFoxGetFirmwareVersionInput;

        // Methods

        /**
         * Get the 'Version Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_version_type(): [boolean, FoxFirmwareVersionType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageFoxGetFirmwareVersionInput;
        /**
         * Set the 'Version Type' field in the message.
         * @param value_version_type a #QmiFoxFirmwareVersionType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_version_type(value_version_type: FoxFirmwareVersionType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageFoxGetFirmwareVersionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageFoxGetFirmwareVersionOutput {
        static $gtype: GObject.GType<MessageFoxGetFirmwareVersionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_version(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageFoxGetFirmwareVersionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageGasDmsGetFirmwareListInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageGasDmsGetFirmwareListInput {
        static $gtype: GObject.GType<MessageGasDmsGetFirmwareListInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageGasDmsGetFirmwareListInput;

        // Methods

        /**
         * Get the 'Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mode(): [boolean, GasFirmwareListingMode | null];
        /**
         * Get the 'Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_name(): [boolean, string];
        /**
         * Get the 'Slot Index' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_slot_index(): [boolean, number];
        /**
         * Get the 'Version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_version(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageGasDmsGetFirmwareListInput;
        /**
         * Set the 'Mode' field in the message.
         * @param value_mode a #QmiGasFirmwareListingMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mode(value_mode: GasFirmwareListingMode): boolean;
        /**
         * Set the 'Name' field in the message.
         * @param value_name a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_name(value_name: string): boolean;
        /**
         * Set the 'Slot Index' field in the message.
         * @param value_slot_index a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_slot_index(value_slot_index: number): boolean;
        /**
         * Set the 'Version' field in the message.
         * @param value_version a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_version(value_version: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageGasDmsGetFirmwareListOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageGasDmsGetFirmwareListOutput {
        static $gtype: GObject.GType<MessageGasDmsGetFirmwareListOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mode(): [boolean, GasFirmwareListingMode | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Stored Firmware 1' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_stored_firmware_1(): [boolean, number, string, string, string];
        /**
         * Get the 'Stored Firmware 2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_stored_firmware_2(): [boolean, number, string, string, string];
        /**
         * Get the 'Stored Firmware 3' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_stored_firmware_3(): [boolean, number, string, string, string];
        /**
         * Get the 'Stored Firmware 4' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_stored_firmware_4(): [boolean, number, string, string, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageGasDmsGetFirmwareListOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageGasDmsGetUsbCompositionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageGasDmsGetUsbCompositionOutput {
        static $gtype: GObject.GType<MessageGasDmsGetUsbCompositionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Composition Persistence' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_composition_persistence(): [boolean, boolean];
        /**
         * Get the 'Endpoint Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_endpoint_type(): [boolean, GasUsbCompositionEndpointType | null];
        /**
         * Get the 'Immediate Setting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_immediate_setting(): [boolean, boolean];
        /**
         * Get the 'Reboot After Setting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_reboot_after_setting(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'USB Composition' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_usb_composition(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageGasDmsGetUsbCompositionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageGasDmsSetActiveFirmwareInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageGasDmsSetActiveFirmwareInput {
        static $gtype: GObject.GType<MessageGasDmsSetActiveFirmwareInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageGasDmsSetActiveFirmwareInput;

        // Methods

        /**
         * Get the 'Carrier Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_carrier_name(): [boolean, string];
        /**
         * Get the 'Slot Index' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_slot_index(): [boolean, number];
        /**
         * Get the 'Version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_version(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageGasDmsSetActiveFirmwareInput;
        /**
         * Set the 'Carrier Name' field in the message.
         * @param value_carrier_name a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_carrier_name(value_carrier_name: string): boolean;
        /**
         * Set the 'Slot Index' field in the message.
         * @param value_slot_index a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_slot_index(value_slot_index: number): boolean;
        /**
         * Set the 'Version' field in the message.
         * @param value_version a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_version(value_version: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageGasDmsSetActiveFirmwareOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageGasDmsSetActiveFirmwareOutput {
        static $gtype: GObject.GType<MessageGasDmsSetActiveFirmwareOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageGasDmsSetActiveFirmwareOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageGasDmsSetUsbCompositionInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageGasDmsSetUsbCompositionInput {
        static $gtype: GObject.GType<MessageGasDmsSetUsbCompositionInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageGasDmsSetUsbCompositionInput;

        // Methods

        /**
         * Get the 'Composition Persistence' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_composition_persistence(): [boolean, boolean];
        /**
         * Get the 'Endpoint Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_endpoint_type(): [boolean, GasUsbCompositionEndpointType | null];
        /**
         * Get the 'Immediate Setting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_immediate_setting(): [boolean, boolean];
        /**
         * Get the 'Reboot After Setting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_reboot_after_setting(): [boolean, boolean];
        /**
         * Get the 'USB Composition' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_usb_composition(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageGasDmsSetUsbCompositionInput;
        /**
         * Set the 'Composition Persistence' field in the message.
         * @param value_composition_persistence a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_composition_persistence(value_composition_persistence: boolean): boolean;
        /**
         * Set the 'Endpoint Type' field in the message.
         * @param value_endpoint_type a #QmiGasUsbCompositionEndpointType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_endpoint_type(value_endpoint_type: GasUsbCompositionEndpointType): boolean;
        /**
         * Set the 'Immediate Setting' field in the message.
         * @param value_immediate_setting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_immediate_setting(value_immediate_setting: boolean): boolean;
        /**
         * Set the 'Reboot After Setting' field in the message.
         * @param value_reboot_after_setting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_reboot_after_setting(value_reboot_after_setting: boolean): boolean;
        /**
         * Set the 'USB Composition' field in the message.
         * @param value_usb_composition a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_usb_composition(value_usb_composition: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageGasDmsSetUsbCompositionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageGasDmsSetUsbCompositionOutput {
        static $gtype: GObject.GType<MessageGasDmsSetUsbCompositionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageGasDmsSetUsbCompositionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageGmsTestGetValueOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageGmsTestGetValueOutput {
        static $gtype: GObject.GType<MessageGmsTestGetValueOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Test Mandatory Value' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_test_mandatory_value(): [boolean, number];
        /**
         * Get the 'Test Optional Value' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_test_optional_value(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageGmsTestGetValueOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageGmsTestSetValueInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageGmsTestSetValueInput {
        static $gtype: GObject.GType<MessageGmsTestSetValueInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageGmsTestSetValueInput;

        // Methods

        /**
         * Get the 'Test Mandatory Value' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_test_mandatory_value(): [boolean, number];
        /**
         * Get the 'Test Optional Value' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_test_optional_value(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageGmsTestSetValueInput;
        /**
         * Set the 'Test Mandatory Value' field in the message.
         * @param value_test_mandatory_value a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_test_mandatory_value(value_test_mandatory_value: number): boolean;
        /**
         * Set the 'Test Optional Value' field in the message.
         * @param value_test_optional_value a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_test_optional_value(value_test_optional_value: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageGmsTestSetValueOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageGmsTestSetValueOutput {
        static $gtype: GObject.GType<MessageGmsTestSetValueOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageGmsTestSetValueOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageImsGetImsServicesEnabledSettingOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageImsGetImsServicesEnabledSettingOutput {
        static $gtype: GObject.GType<MessageImsGetImsServicesEnabledSettingOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'IMS Registration Service Enabled' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_registration_service_enabled(): [boolean, boolean];
        /**
         * Get the 'IMS SMS Service Enabled' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_sms_service_enabled(): [boolean, boolean];
        /**
         * Get the 'IMS USSD Service Enabled' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_ussd_service_enabled(): [boolean, boolean];
        /**
         * Get the 'IMS UT Service Enabled' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_ut_service_enabled(): [boolean, boolean];
        /**
         * Get the 'IMS Video Telephony Service Enabled' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_video_telephony_service_enabled(): [boolean, boolean];
        /**
         * Get the 'IMS Voice Service Enabled' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_voice_service_enabled(): [boolean, boolean];
        /**
         * Get the 'IMS Voice WiFi Service Enabled' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_voice_wifi_service_enabled(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageImsGetImsServicesEnabledSettingOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageImsaGetImsRegistrationStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageImsaGetImsRegistrationStatusOutput {
        static $gtype: GObject.GType<MessageImsaGetImsRegistrationStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'IMS Registration Error Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_registration_error_code(): [boolean, number];
        /**
         * Get the 'IMS Registration Error Message' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_registration_error_message(): [boolean, string];
        /**
         * Get the 'IMS Registration Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_registration_status(): [boolean, ImsaImsRegistrationStatus | null];
        /**
         * Get the 'IMS Registration Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_registration_technology(): [boolean, ImsaRegistrationTechnology | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageImsaGetImsRegistrationStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageImsaGetImsServicesStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageImsaGetImsServicesStatusOutput {
        static $gtype: GObject.GType<MessageImsaGetImsServicesStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'IMS SMS Service Registration Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_sms_service_registration_technology(): [boolean, ImsaRegistrationTechnology | null];
        /**
         * Get the 'IMS SMS Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_sms_service_status(): [boolean, ImsaServiceStatus | null];
        /**
         * Get the 'IMS UE to TAS Service Registration Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_ue_to_tas_service_registration_technology(): [boolean, ImsaRegistrationTechnology | null];
        /**
         * Get the 'IMS UE to TAS Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_ue_to_tas_service_status(): [boolean, ImsaServiceStatus | null];
        /**
         * Get the 'IMS Video Share Service Registration Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_video_share_service_registration_technology(): [boolean, ImsaRegistrationTechnology | null];
        /**
         * Get the 'IMS Video Share Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_video_share_service_status(): [boolean, ImsaServiceStatus | null];
        /**
         * Get the 'IMS Video Telephony Service Registration Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_video_telephony_service_registration_technology(): [boolean, ImsaRegistrationTechnology | null];
        /**
         * Get the 'IMS Video Telephony Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_video_telephony_service_status(): [boolean, ImsaServiceStatus | null];
        /**
         * Get the 'IMS Voice Service Registration Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_voice_service_registration_technology(): [boolean, ImsaRegistrationTechnology | null];
        /**
         * Get the 'IMS Voice Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_voice_service_status(): [boolean, ImsaServiceStatus | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageImsaGetImsServicesStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageImspGetEnablerStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageImspGetEnablerStateOutput {
        static $gtype: GObject.GType<MessageImspGetEnablerStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Enabler State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_enabler_state(): [boolean, ImspEnablerState | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageImspGetEnablerStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocDeleteAssistanceDataInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageLocDeleteAssistanceDataInput {
        static $gtype: GObject.GType<MessageLocDeleteAssistanceDataInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageLocDeleteAssistanceDataInput;

        // Methods

        /**
         * Get the 'Delete All' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_delete_all(): [boolean, boolean];
        /**
         * Get the 'Delete Cell Database Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_delete_cell_database_mask(): [boolean, LocDeleteCellDatabase | null];
        /**
         * Get the 'Delete Clock Info Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_delete_clock_info_mask(): [boolean, LocDeleteClockInfo | null];
        /**
         * Get the 'Delete GNSS Data Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_delete_gnss_data_mask(): [boolean, LocDeleteGnssData | null];
        /**
         * Get the 'Delete SV Info' field from `self`.
         *
         * Version of qmi_message_loc_delete_assistance_data_input_get_delete_sv_info() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_delete_sv_info(): [boolean, MessageLocDeleteAssistanceDataInputDeleteSvInfoElement[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocDeleteAssistanceDataInput;
        /**
         * Set the 'Delete All' field in the message.
         * @param value_delete_all a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_delete_all(value_delete_all: boolean): boolean;
        /**
         * Set the 'Delete Cell Database Mask' field in the message.
         * @param value_delete_cell_database_mask a #QmiLocDeleteCellDatabase.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_delete_cell_database_mask(value_delete_cell_database_mask: LocDeleteCellDatabase): boolean;
        /**
         * Set the 'Delete Clock Info Mask' field in the message.
         * @param value_delete_clock_info_mask a #QmiLocDeleteClockInfo.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_delete_clock_info_mask(value_delete_clock_info_mask: LocDeleteClockInfo): boolean;
        /**
         * Set the 'Delete GNSS Data Mask' field in the message.
         * @param value_delete_gnss_data_mask a #QmiLocDeleteGnssData.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_delete_gnss_data_mask(value_delete_gnss_data_mask: LocDeleteGnssData): boolean;
        /**
         * Set the 'Delete SV Info' field in the message.
         * @param value_delete_sv_info_ptr array of #QmiMessageLocDeleteAssistanceDataInputDeleteSvInfoElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_delete_sv_info(value_delete_sv_info_ptr: MessageLocDeleteAssistanceDataInputDeleteSvInfoElement[]): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageLocDeleteAssistanceDataInputDeleteSvInfoElement struct.
     */
    class MessageLocDeleteAssistanceDataInputDeleteSvInfoElement {
        static $gtype: GObject.GType<MessageLocDeleteAssistanceDataInputDeleteSvInfoElement>;

        // Fields

        gnss_sv_id: number;
        system: LocSystem;
        delete_sv_info_mask: LocDeleteSvInfo;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageLocDeleteAssistanceDataOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocDeleteAssistanceDataOutput {
        static $gtype: GObject.GType<MessageLocDeleteAssistanceDataOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocDeleteAssistanceDataOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocGetEngineLockOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocGetEngineLockOutput {
        static $gtype: GObject.GType<MessageLocGetEngineLockOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocGetEngineLockOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocGetNmeaTypesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocGetNmeaTypesOutput {
        static $gtype: GObject.GType<MessageLocGetNmeaTypesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocGetNmeaTypesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocGetOperationModeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocGetOperationModeOutput {
        static $gtype: GObject.GType<MessageLocGetOperationModeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocGetOperationModeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocGetPredictedOrbitsDataSourceOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocGetPredictedOrbitsDataSourceOutput {
        static $gtype: GObject.GType<MessageLocGetPredictedOrbitsDataSourceOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocGetPredictedOrbitsDataSourceOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocGetServerInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageLocGetServerInput {
        static $gtype: GObject.GType<MessageLocGetServerInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageLocGetServerInput;

        // Methods

        /**
         * Get the 'Server Address Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_server_address_type(): [boolean, LocServerAddressType | null];
        /**
         * Get the 'Server Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_server_type(): [boolean, LocServerType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocGetServerInput;
        /**
         * Set the 'Server Address Type' field in the message.
         * @param value_server_address_type a #QmiLocServerAddressType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_server_address_type(value_server_address_type: LocServerAddressType): boolean;
        /**
         * Set the 'Server Type' field in the message.
         * @param value_server_type a #QmiLocServerType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_server_type(value_server_type: LocServerType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocGetServerOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocGetServerOutput {
        static $gtype: GObject.GType<MessageLocGetServerOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocGetServerOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocInjectPredictedOrbitsDataInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageLocInjectPredictedOrbitsDataInput {
        static $gtype: GObject.GType<MessageLocInjectPredictedOrbitsDataInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageLocInjectPredictedOrbitsDataInput;

        // Methods

        /**
         * Get the 'Format Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_format_type(): [boolean, LocPredictedOrbitsDataFormat | null];
        /**
         * Get the 'Part Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_part_data(): [boolean, Uint8Array | null];
        /**
         * Get the 'Part Number' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_part_number(): [boolean, number];
        /**
         * Get the 'Total Parts' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_total_parts(): [boolean, number];
        /**
         * Get the 'Total Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_total_size(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocInjectPredictedOrbitsDataInput;
        /**
         * Set the 'Format Type' field in the message.
         * @param value_format_type a #QmiLocPredictedOrbitsDataFormat.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_format_type(value_format_type: LocPredictedOrbitsDataFormat): boolean;
        /**
         * Set the 'Part Data' field in the message.
         * @param value_part_data a #GArray of #guint8 elements. A new reference to @value_part_data will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_part_data(value_part_data: Uint8Array | string): boolean;
        /**
         * Set the 'Part Number' field in the message.
         * @param value_part_number a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_part_number(value_part_number: number): boolean;
        /**
         * Set the 'Total Parts' field in the message.
         * @param value_total_parts a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_total_parts(value_total_parts: number): boolean;
        /**
         * Set the 'Total Size' field in the message.
         * @param value_total_size a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_total_size(value_total_size: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocInjectPredictedOrbitsDataOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocInjectPredictedOrbitsDataOutput {
        static $gtype: GObject.GType<MessageLocInjectPredictedOrbitsDataOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocInjectPredictedOrbitsDataOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocInjectXtraDataInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageLocInjectXtraDataInput {
        static $gtype: GObject.GType<MessageLocInjectXtraDataInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageLocInjectXtraDataInput;

        // Methods

        /**
         * Get the 'Part Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_part_data(): [boolean, Uint8Array | null];
        /**
         * Get the 'Part Number' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_part_number(): [boolean, number];
        /**
         * Get the 'Total Parts' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_total_parts(): [boolean, number];
        /**
         * Get the 'Total Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_total_size(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocInjectXtraDataInput;
        /**
         * Set the 'Part Data' field in the message.
         * @param value_part_data a #GArray of #guint8 elements. A new reference to @value_part_data will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_part_data(value_part_data: Uint8Array | string): boolean;
        /**
         * Set the 'Part Number' field in the message.
         * @param value_part_number a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_part_number(value_part_number: number): boolean;
        /**
         * Set the 'Total Parts' field in the message.
         * @param value_total_parts a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_total_parts(value_total_parts: number): boolean;
        /**
         * Set the 'Total Size' field in the message.
         * @param value_total_size a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_total_size(value_total_size: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocInjectXtraDataOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocInjectXtraDataOutput {
        static $gtype: GObject.GType<MessageLocInjectXtraDataOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocInjectXtraDataOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocRegisterEventsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageLocRegisterEventsInput {
        static $gtype: GObject.GType<MessageLocRegisterEventsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageLocRegisterEventsInput;

        // Methods

        /**
         * Get the 'Event Registration Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_event_registration_mask(): [boolean, LocEventRegistrationFlag | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocRegisterEventsInput;
        /**
         * Set the 'Event Registration Mask' field in the message.
         * @param value_event_registration_mask a #QmiLocEventRegistrationFlag.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_event_registration_mask(value_event_registration_mask: LocEventRegistrationFlag): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocRegisterEventsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocRegisterEventsOutput {
        static $gtype: GObject.GType<MessageLocRegisterEventsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocRegisterEventsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocSetEngineLockInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageLocSetEngineLockInput {
        static $gtype: GObject.GType<MessageLocSetEngineLockInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageLocSetEngineLockInput;

        // Methods

        /**
         * Get the 'Lock Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lock_type(): [boolean, LocLockType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocSetEngineLockInput;
        /**
         * Set the 'Lock Type' field in the message.
         * @param value_lock_type a #QmiLocLockType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lock_type(value_lock_type: LocLockType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocSetEngineLockOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocSetEngineLockOutput {
        static $gtype: GObject.GType<MessageLocSetEngineLockOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocSetEngineLockOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocSetNmeaTypesInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageLocSetNmeaTypesInput {
        static $gtype: GObject.GType<MessageLocSetNmeaTypesInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageLocSetNmeaTypesInput;

        // Methods

        /**
         * Get the 'NMEA Types' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nmea_types(): [boolean, LocNmeaType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocSetNmeaTypesInput;
        /**
         * Set the 'NMEA Types' field in the message.
         * @param value_nmea_types a #QmiLocNmeaType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nmea_types(value_nmea_types: LocNmeaType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocSetNmeaTypesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocSetNmeaTypesOutput {
        static $gtype: GObject.GType<MessageLocSetNmeaTypesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocSetNmeaTypesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocSetOperationModeInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageLocSetOperationModeInput {
        static $gtype: GObject.GType<MessageLocSetOperationModeInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageLocSetOperationModeInput;

        // Methods

        /**
         * Get the 'Operation Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_operation_mode(): [boolean, LocOperationMode | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocSetOperationModeInput;
        /**
         * Set the 'Operation Mode' field in the message.
         * @param value_operation_mode a #QmiLocOperationMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_operation_mode(value_operation_mode: LocOperationMode): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocSetOperationModeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocSetOperationModeOutput {
        static $gtype: GObject.GType<MessageLocSetOperationModeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocSetOperationModeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocSetServerInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageLocSetServerInput {
        static $gtype: GObject.GType<MessageLocSetServerInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageLocSetServerInput;

        // Methods

        /**
         * Get the 'IPv4' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv4(): [boolean, number, number];
        /**
         * Get the 'IPv6' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6(): [boolean, number[] | null, number];
        /**
         * Get the 'Server Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_server_type(): [boolean, LocServerType | null];
        /**
         * Get the 'URL' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_url(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocSetServerInput;
        /**
         * Set the 'IPv4' field in the message.
         * @param value_ipv4_ipv4_address a #guint32.
         * @param value_ipv4_ipv4_port a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ipv4(value_ipv4_ipv4_address: number, value_ipv4_ipv4_port: number): boolean;
        /**
         * Set the 'IPv6' field in the message.
         * @param value_ipv6_ipv6_address a #GArray of #guint16 elements. A new reference to @value_ipv6_ipv6_address will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @param value_ipv6_ipv6_port a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ipv6(value_ipv6_ipv6_address: number[], value_ipv6_ipv6_port: number): boolean;
        /**
         * Set the 'Server Type' field in the message.
         * @param value_server_type a #QmiLocServerType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_server_type(value_server_type: LocServerType): boolean;
        /**
         * Set the 'URL' field in the message.
         * @param value_url a constant string with a maximum length of 256 characters.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_url(value_url: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocSetServerOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocSetServerOutput {
        static $gtype: GObject.GType<MessageLocSetServerOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocSetServerOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocStartInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageLocStartInput {
        static $gtype: GObject.GType<MessageLocStartInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageLocStartInput;

        // Methods

        /**
         * Get the 'Fix Recurrence Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_fix_recurrence_type(): [boolean, LocFixRecurrenceType | null];
        /**
         * Get the 'Intermediate Report State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_intermediate_report_state(): [boolean, LocIntermediateReportState | null];
        /**
         * Get the 'Minimum Interval between Position Reports' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_minimum_interval_between_position_reports(): [boolean, number];
        /**
         * Get the 'Session ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session_id(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocStartInput;
        /**
         * Set the 'Fix Recurrence Type' field in the message.
         * @param value_fix_recurrence_type a #QmiLocFixRecurrenceType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_fix_recurrence_type(value_fix_recurrence_type: LocFixRecurrenceType): boolean;
        /**
         * Set the 'Intermediate Report State' field in the message.
         * @param value_intermediate_report_state a #QmiLocIntermediateReportState.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_intermediate_report_state(value_intermediate_report_state: LocIntermediateReportState): boolean;
        /**
         * Set the 'Minimum Interval between Position Reports' field in the message.
         * @param value_minimum_interval_between_position_reports a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_minimum_interval_between_position_reports(value_minimum_interval_between_position_reports: number): boolean;
        /**
         * Set the 'Session ID' field in the message.
         * @param value_session_id a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session_id(value_session_id: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocStartOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocStartOutput {
        static $gtype: GObject.GType<MessageLocStartOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocStartOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocStopInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageLocStopInput {
        static $gtype: GObject.GType<MessageLocStopInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageLocStopInput;

        // Methods

        /**
         * Get the 'Session ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session_id(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocStopInput;
        /**
         * Set the 'Session ID' field in the message.
         * @param value_session_id a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session_id(value_session_id: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageLocStopOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageLocStopOutput {
        static $gtype: GObject.GType<MessageLocStopOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageLocStopOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasAttachDetachInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasAttachDetachInput {
        static $gtype: GObject.GType<MessageNasAttachDetachInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasAttachDetachInput;

        // Methods

        /**
         * Get the 'Action' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_action(): [boolean, NasPsAttachAction | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasAttachDetachInput;
        /**
         * Set the 'Action' field in the message.
         * @param value_action a #QmiNasPsAttachAction.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_action(value_action: NasPsAttachAction): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasAttachDetachOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasAttachDetachOutput {
        static $gtype: GObject.GType<MessageNasAttachDetachOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasAttachDetachOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasConfigSignalInfoInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasConfigSignalInfoInput {
        static $gtype: GObject.GType<MessageNasConfigSignalInfoInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasConfigSignalInfoInput;

        // Methods

        /**
         * Get the 'ECIO Threshold' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ecio_threshold(): [boolean, number[] | null];
        /**
         * Get the 'IO Threshold' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_io_threshold(): [boolean, number[] | null];
        /**
         * Get the 'LTE Report' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_report(): [boolean, number, number];
        /**
         * Get the 'LTE SNR Threshold' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_snr_threshold(): [boolean, number[] | null];
        /**
         * Get the 'RSCP Threshold' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rscp_threshold(): [boolean, Uint8Array | null];
        /**
         * Get the 'RSRP Threshold' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rsrp_threshold(): [boolean, number[] | null];
        /**
         * Get the 'RSRQ Threshold' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rsrq_threshold(): [boolean, Uint8Array | null];
        /**
         * Get the 'RSSI Threshold' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rssi_threshold(): [boolean, Uint8Array | null];
        /**
         * Get the 'SINR Threshold' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sinr_threshold(): [boolean, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasConfigSignalInfoInput;
        /**
         * Set the 'ECIO Threshold' field in the message.
         * @param value_ecio_threshold a #GArray of #gint16 elements. A new reference to @value_ecio_threshold will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ecio_threshold(value_ecio_threshold: number[]): boolean;
        /**
         * Set the 'IO Threshold' field in the message.
         * @param value_io_threshold a #GArray of #gint32 elements. A new reference to @value_io_threshold will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_io_threshold(value_io_threshold: number[]): boolean;
        /**
         * Set the 'LTE Report' field in the message.
         * @param value_lte_report_rate a #guint8.
         * @param value_lte_report_average_period a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_report(value_lte_report_rate: number, value_lte_report_average_period: number): boolean;
        /**
         * Set the 'LTE SNR Threshold' field in the message.
         * @param value_lte_snr_threshold a #GArray of #gint16 elements. A new reference to @value_lte_snr_threshold will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_snr_threshold(value_lte_snr_threshold: number[]): boolean;
        /**
         * Set the 'RSCP Threshold' field in the message.
         * @param value_rscp_threshold a #GArray of #gint8 elements. A new reference to @value_rscp_threshold will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_rscp_threshold(value_rscp_threshold: Uint8Array | string): boolean;
        /**
         * Set the 'RSRP Threshold' field in the message.
         * @param value_rsrp_threshold a #GArray of #gint16 elements. A new reference to @value_rsrp_threshold will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_rsrp_threshold(value_rsrp_threshold: number[]): boolean;
        /**
         * Set the 'RSRQ Threshold' field in the message.
         * @param value_rsrq_threshold a #GArray of #gint8 elements. A new reference to @value_rsrq_threshold will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_rsrq_threshold(value_rsrq_threshold: Uint8Array | string): boolean;
        /**
         * Set the 'RSSI Threshold' field in the message.
         * @param value_rssi_threshold a #GArray of #gint8 elements. A new reference to @value_rssi_threshold will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_rssi_threshold(value_rssi_threshold: Uint8Array | string): boolean;
        /**
         * Set the 'SINR Threshold' field in the message.
         * @param value_sinr_threshold a #GArray of #guint8 elements. A new reference to @value_sinr_threshold will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_sinr_threshold(value_sinr_threshold: Uint8Array | string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasConfigSignalInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasConfigSignalInfoOutput {
        static $gtype: GObject.GType<MessageNasConfigSignalInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasConfigSignalInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasConfigSignalInfoV2Input structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasConfigSignalInfoV2Input {
        static $gtype: GObject.GType<MessageNasConfigSignalInfoV2Input>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasConfigSignalInfoV2Input;

        // Methods

        /**
         * Get the 'CDMA ECIO Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_ecio_delta(): [boolean, number];
        /**
         * Get the 'CDMA ECIO Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_ecio_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'CDMA RSSI Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_rssi_delta(): [boolean, number];
        /**
         * Get the 'CDMA RSSI Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_rssi_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'GSM RSSI Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_rssi_delta(): [boolean, number];
        /**
         * Get the 'GSM RSSI Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_rssi_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'HDR ECIO Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_ecio_delta(): [boolean, number];
        /**
         * Get the 'HDR ECIO Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_ecio_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'HDR IO Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_io_delta(): [boolean, number];
        /**
         * Get the 'HDR IO Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_io_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'HDR RSSI Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_rssi_delta(): [boolean, number];
        /**
         * Get the 'HDR RSSI Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_rssi_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'HDR SINR Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_sinr_delta(): [boolean, number];
        /**
         * Get the 'HDR SINR Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_sinr_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'LTE Report' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_report(): [boolean, number, number];
        /**
         * Get the 'LTE RSRP Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_rsrp_delta(): [boolean, number];
        /**
         * Get the 'LTE RSRP Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_rsrp_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'LTE RSRQ Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_rsrq_delta(): [boolean, number];
        /**
         * Get the 'LTE RSRQ Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_rsrq_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'LTE RSSI Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_rssi_delta(): [boolean, number];
        /**
         * Get the 'LTE RSSI Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_rssi_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'LTE SNR Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_snr_delta(): [boolean, number];
        /**
         * Get the 'LTE SNR Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_snr_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'NR5G Report' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_report(): [boolean, number, number];
        /**
         * Get the 'NR5G RSRP Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_rsrp_delta(): [boolean, number];
        /**
         * Get the 'NR5G RSRP Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_rsrp_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'NR5G RSRQ Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_rsrq_delta(): [boolean, number];
        /**
         * Get the 'NR5G RSRQ Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_rsrq_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'NR5G SNR Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_snr_delta(): [boolean, number];
        /**
         * Get the 'NR5G SNR Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_snr_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'WCDMA ECIO Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_ecio_delta(): [boolean, number];
        /**
         * Get the 'WCDMA ECIO Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_ecio_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'WCDMA RSCP Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_rscp_delta(): [boolean, number];
        /**
         * Get the 'WCDMA RSCP Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_rscp_threshold_list(): [boolean, number[] | null];
        /**
         * Get the 'WCDMA RSSI Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_rssi_delta(): [boolean, number];
        /**
         * Get the 'WCDMA RSSI Threshold List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_rssi_threshold_list(): [boolean, number[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasConfigSignalInfoV2Input;
        /**
         * Set the 'CDMA ECIO Delta' field in the message.
         * @param value_cdma_ecio_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_cdma_ecio_delta(value_cdma_ecio_delta: number): boolean;
        /**
         * Set the 'CDMA ECIO Threshold List' field in the message.
         * @param value_cdma_ecio_threshold_list a #GArray of #gint16 elements. A new reference to @value_cdma_ecio_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_cdma_ecio_threshold_list(value_cdma_ecio_threshold_list: number[]): boolean;
        /**
         * Set the 'CDMA RSSI Delta' field in the message.
         * @param value_cdma_rssi_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_cdma_rssi_delta(value_cdma_rssi_delta: number): boolean;
        /**
         * Set the 'CDMA RSSI Threshold List' field in the message.
         * @param value_cdma_rssi_threshold_list a #GArray of #gint16 elements. A new reference to @value_cdma_rssi_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_cdma_rssi_threshold_list(value_cdma_rssi_threshold_list: number[]): boolean;
        /**
         * Set the 'GSM RSSI Delta' field in the message.
         * @param value_gsm_rssi_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_gsm_rssi_delta(value_gsm_rssi_delta: number): boolean;
        /**
         * Set the 'GSM RSSI Threshold List' field in the message.
         * @param value_gsm_rssi_threshold_list a #GArray of #gint16 elements. A new reference to @value_gsm_rssi_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_gsm_rssi_threshold_list(value_gsm_rssi_threshold_list: number[]): boolean;
        /**
         * Set the 'HDR ECIO Delta' field in the message.
         * @param value_hdr_ecio_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_hdr_ecio_delta(value_hdr_ecio_delta: number): boolean;
        /**
         * Set the 'HDR ECIO Threshold List' field in the message.
         * @param value_hdr_ecio_threshold_list a #GArray of #gint16 elements. A new reference to @value_hdr_ecio_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_hdr_ecio_threshold_list(value_hdr_ecio_threshold_list: number[]): boolean;
        /**
         * Set the 'HDR IO Delta' field in the message.
         * @param value_hdr_io_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_hdr_io_delta(value_hdr_io_delta: number): boolean;
        /**
         * Set the 'HDR IO Threshold List' field in the message.
         * @param value_hdr_io_threshold_list a #GArray of #gint16 elements. A new reference to @value_hdr_io_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_hdr_io_threshold_list(value_hdr_io_threshold_list: number[]): boolean;
        /**
         * Set the 'HDR RSSI Delta' field in the message.
         * @param value_hdr_rssi_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_hdr_rssi_delta(value_hdr_rssi_delta: number): boolean;
        /**
         * Set the 'HDR RSSI Threshold List' field in the message.
         * @param value_hdr_rssi_threshold_list a #GArray of #gint16 elements. A new reference to @value_hdr_rssi_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_hdr_rssi_threshold_list(value_hdr_rssi_threshold_list: number[]): boolean;
        /**
         * Set the 'HDR SINR Delta' field in the message.
         * @param value_hdr_sinr_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_hdr_sinr_delta(value_hdr_sinr_delta: number): boolean;
        /**
         * Set the 'HDR SINR Threshold List' field in the message.
         * @param value_hdr_sinr_threshold_list a #GArray of #gint16 elements. A new reference to @value_hdr_sinr_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_hdr_sinr_threshold_list(value_hdr_sinr_threshold_list: number[]): boolean;
        /**
         * Set the 'LTE Report' field in the message.
         * @param value_lte_report_rate a #guint8.
         * @param value_lte_report_average_period a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_report(value_lte_report_rate: number, value_lte_report_average_period: number): boolean;
        /**
         * Set the 'LTE RSRP Delta' field in the message.
         * @param value_lte_rsrp_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_rsrp_delta(value_lte_rsrp_delta: number): boolean;
        /**
         * Set the 'LTE RSRP Threshold List' field in the message.
         * @param value_lte_rsrp_threshold_list a #GArray of #gint16 elements. A new reference to @value_lte_rsrp_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_rsrp_threshold_list(value_lte_rsrp_threshold_list: number[]): boolean;
        /**
         * Set the 'LTE RSRQ Delta' field in the message.
         * @param value_lte_rsrq_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_rsrq_delta(value_lte_rsrq_delta: number): boolean;
        /**
         * Set the 'LTE RSRQ Threshold List' field in the message.
         * @param value_lte_rsrq_threshold_list a #GArray of #gint16 elements. A new reference to @value_lte_rsrq_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_rsrq_threshold_list(value_lte_rsrq_threshold_list: number[]): boolean;
        /**
         * Set the 'LTE RSSI Delta' field in the message.
         * @param value_lte_rssi_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_rssi_delta(value_lte_rssi_delta: number): boolean;
        /**
         * Set the 'LTE RSSI Threshold List' field in the message.
         * @param value_lte_rssi_threshold_list a #GArray of #gint16 elements. A new reference to @value_lte_rssi_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_rssi_threshold_list(value_lte_rssi_threshold_list: number[]): boolean;
        /**
         * Set the 'LTE SNR Delta' field in the message.
         * @param value_lte_snr_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_snr_delta(value_lte_snr_delta: number): boolean;
        /**
         * Set the 'LTE SNR Threshold List' field in the message.
         * @param value_lte_snr_threshold_list a #GArray of #gint16 elements. A new reference to @value_lte_snr_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_snr_threshold_list(value_lte_snr_threshold_list: number[]): boolean;
        /**
         * Set the 'NR5G Report' field in the message.
         * @param value_nr5g_report_rate a #guint8.
         * @param value_nr5g_report_average_period a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nr5g_report(value_nr5g_report_rate: number, value_nr5g_report_average_period: number): boolean;
        /**
         * Set the 'NR5G RSRP Delta' field in the message.
         * @param value_nr5g_rsrp_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nr5g_rsrp_delta(value_nr5g_rsrp_delta: number): boolean;
        /**
         * Set the 'NR5G RSRP Threshold List' field in the message.
         * @param value_nr5g_rsrp_threshold_list a #GArray of #gint16 elements. A new reference to @value_nr5g_rsrp_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nr5g_rsrp_threshold_list(value_nr5g_rsrp_threshold_list: number[]): boolean;
        /**
         * Set the 'NR5G RSRQ Delta' field in the message.
         * @param value_nr5g_rsrq_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nr5g_rsrq_delta(value_nr5g_rsrq_delta: number): boolean;
        /**
         * Set the 'NR5G RSRQ Threshold List' field in the message.
         * @param value_nr5g_rsrq_threshold_list a #GArray of #gint16 elements. A new reference to @value_nr5g_rsrq_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nr5g_rsrq_threshold_list(value_nr5g_rsrq_threshold_list: number[]): boolean;
        /**
         * Set the 'NR5G SNR Delta' field in the message.
         * @param value_nr5g_snr_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nr5g_snr_delta(value_nr5g_snr_delta: number): boolean;
        /**
         * Set the 'NR5G SNR Threshold List' field in the message.
         * @param value_nr5g_snr_threshold_list a #GArray of #gint16 elements. A new reference to @value_nr5g_snr_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nr5g_snr_threshold_list(value_nr5g_snr_threshold_list: number[]): boolean;
        /**
         * Set the 'WCDMA ECIO Delta' field in the message.
         * @param value_wcdma_ecio_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_wcdma_ecio_delta(value_wcdma_ecio_delta: number): boolean;
        /**
         * Set the 'WCDMA ECIO Threshold List' field in the message.
         * @param value_wcdma_ecio_threshold_list a #GArray of #gint16 elements. A new reference to @value_wcdma_ecio_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_wcdma_ecio_threshold_list(value_wcdma_ecio_threshold_list: number[]): boolean;
        /**
         * Set the 'WCDMA RSCP Delta' field in the message.
         * @param value_wcdma_rscp_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_wcdma_rscp_delta(value_wcdma_rscp_delta: number): boolean;
        /**
         * Set the 'WCDMA RSCP Threshold List' field in the message.
         * @param value_wcdma_rscp_threshold_list a #GArray of #gint16 elements. A new reference to @value_wcdma_rscp_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_wcdma_rscp_threshold_list(value_wcdma_rscp_threshold_list: number[]): boolean;
        /**
         * Set the 'WCDMA RSSI Delta' field in the message.
         * @param value_wcdma_rssi_delta a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_wcdma_rssi_delta(value_wcdma_rssi_delta: number): boolean;
        /**
         * Set the 'WCDMA RSSI Threshold List' field in the message.
         * @param value_wcdma_rssi_threshold_list a #GArray of #gint16 elements. A new reference to @value_wcdma_rssi_threshold_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_wcdma_rssi_threshold_list(value_wcdma_rssi_threshold_list: number[]): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasConfigSignalInfoV2Output structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasConfigSignalInfoV2Output {
        static $gtype: GObject.GType<MessageNasConfigSignalInfoV2Output>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasConfigSignalInfoV2Output;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasForceNetworkSearchOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasForceNetworkSearchOutput {
        static $gtype: GObject.GType<MessageNasForceNetworkSearchOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasForceNetworkSearchOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasGetCdmaPositionInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetCdmaPositionInfoOutput {
        static $gtype: GObject.GType<MessageNasGetCdmaPositionInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'CDMA Position Info' field from `self`.
         *
         * Version of qmi_message_nas_get_cdma_position_info_output_get_cdma_position_info() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_position_info(): [
            boolean,
            number,
            MessageNasGetCdmaPositionInfoOutputCdmaPositionInfoBasestationsBasestation[] | null,
        ];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetCdmaPositionInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageNasGetCdmaPositionInfoOutputCdmaPositionInfoBasestationsBasestation struct.
     */
    class MessageNasGetCdmaPositionInfoOutputCdmaPositionInfoBasestationsBasestation {
        static $gtype: GObject.GType<MessageNasGetCdmaPositionInfoOutputCdmaPositionInfoBasestationsBasestation>;

        // Fields

        pilot_type: NasCdmaPilotType;
        system_id: number;
        network_id: number;
        base_station_id: number;
        pilot_pn: number;
        pilot_strength: number;
        latitude: number;
        longitude: number;
        gps_time_in_milliseconds: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageNasGetCellLocationInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetCellLocationInfoOutput {
        static $gtype: GObject.GType<MessageNasGetCellLocationInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'CDMA Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_info(): [boolean, number, number, number, number, number, number];
        get_compat_context(): any | null;
        /**
         * Get the 'GERAN Info v2' field from `self`.
         *
         * Version of qmi_message_nas_get_cell_location_info_output_get_geran_info_v2() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_geran_info_v2(): [
            boolean,
            number,
            Uint8Array | null,
            number,
            number,
            number,
            number,
            number,
            MessageNasGetCellLocationInfoOutputGeranInfoV2CellElement[] | null,
        ];
        /**
         * Get the 'Interfrequency LTE Info' field from `self`.
         *
         * Version of qmi_message_nas_get_cell_location_info_output_get_interfrequency_lte_info() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_interfrequency_lte_info(): [
            boolean,
            boolean,
            MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementGir[] | null,
        ];
        /**
         * Get the 'Intrafrequency LTE Info v2' field from `self`.
         *
         * Version of qmi_message_nas_get_cell_location_info_output_get_intrafrequency_lte_info_v2() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_intrafrequency_lte_info_v2(): [
            boolean,
            boolean,
            Uint8Array | null,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            MessageNasGetCellLocationInfoOutputIntrafrequencyLteInfoV2CellElement[] | null,
        ];
        /**
         * Get the 'LTE Info Neighboring GSM' field from `self`.
         *
         * Version of qmi_message_nas_get_cell_location_info_output_get_lte_info_neighboring_gsm() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_info_neighboring_gsm(): [
            boolean,
            boolean,
            MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementGir[] | null,
        ];
        /**
         * Get the 'LTE Info Neighboring WCDMA' field from `self`.
         *
         * Version of qmi_message_nas_get_cell_location_info_output_get_lte_info_neighboring_wcdma() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_info_neighboring_wcdma(): [
            boolean,
            boolean,
            MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementGir[] | null,
        ];
        /**
         * Get the 'LTE Info Timing Advance' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_info_timing_advance(): [boolean, number];
        /**
         * Get the 'NR5G ARFCN' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_arfcn(): [boolean, number];
        /**
         * Get the 'NR5G Cell Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_cell_information(): [
            boolean,
            Uint8Array | null,
            Uint8Array | null,
            number,
            number,
            number,
            number,
            number,
        ];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'UMTS Cell ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_cell_id(): [boolean, number];
        /**
         * Get the 'UMTS Info Neighboring LTE' field from `self`.
         *
         * Version of qmi_message_nas_get_cell_location_info_output_get_umts_info_neighboring_lte() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_info_neighboring_lte(): [
            boolean,
            NasWcdmaRrcState | null,
            MessageNasGetCellLocationInfoOutputUmtsInfoNeighboringLteFrequencyElement[] | null,
        ];
        /**
         * Get the 'UMTS Info v2' field from `self`.
         *
         * Version of qmi_message_nas_get_cell_location_info_output_get_umts_info_v2() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_info_v2(): [
            boolean,
            number,
            Uint8Array | null,
            number,
            number,
            number,
            number,
            number,
            MessageNasGetCellLocationInfoOutputUmtsInfoV2CellElement[] | null,
            MessageNasGetCellLocationInfoOutputUmtsInfoV2NeighboringGeranElement[] | null,
        ];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetCellLocationInfoOutput;
        set_compat_context(compat_context?: any | null): void;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageNasGetCellLocationInfoOutputGeranInfoV2CellElement struct.
     */
    class MessageNasGetCellLocationInfoOutputGeranInfoV2CellElement {
        static $gtype: GObject.GType<MessageNasGetCellLocationInfoOutputGeranInfoV2CellElement>;

        // Fields

        cell_id: number;
        plmn: any[];
        lac: number;
        geran_absolute_rf_channel_number: number;
        base_station_identity_code: number;
        rx_level: number;

        // Constructors

        constructor(
            properties?: Partial<{
                cell_id: number;
                plmn: any[];
                lac: number;
                geran_absolute_rf_channel_number: number;
                base_station_identity_code: number;
                rx_level: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementCellElement struct.
     */
    class MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementCellElement {
        static $gtype: GObject.GType<MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementCellElement>;

        // Fields

        physical_cell_id: number;
        rsrq: number;
        rsrp: number;
        rssi: number;
        cell_selection_rx_level: number;

        // Constructors

        constructor(
            properties?: Partial<{
                physical_cell_id: number;
                rsrq: number;
                rsrp: number;
                rssi: number;
                cell_selection_rx_level: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementGir struct.
     *
     * This type is a version of #QmiMessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElement, using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    class MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementGir {
        static $gtype: GObject.GType<MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementGir>;

        // Fields

        eutra_absolute_rf_channel_number: number;
        cell_selection_rx_level_low_threshold: number;
        cell_selection_rx_level_high_threshold: number;
        cell_reselection_priority: number;
        cell: MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementCellElement[];

        // Constructors

        constructor(
            properties?: Partial<{
                eutra_absolute_rf_channel_number: number;
                cell_selection_rx_level_low_threshold: number;
                cell_selection_rx_level_high_threshold: number;
                cell_reselection_priority: number;
                cell: MessageNasGetCellLocationInfoOutputInterfrequencyLteInfoFrequencyElementCellElement[];
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetCellLocationInfoOutputIntrafrequencyLteInfoV2CellElement struct.
     */
    class MessageNasGetCellLocationInfoOutputIntrafrequencyLteInfoV2CellElement {
        static $gtype: GObject.GType<MessageNasGetCellLocationInfoOutputIntrafrequencyLteInfoV2CellElement>;

        // Fields

        physical_cell_id: number;
        rsrq: number;
        rsrp: number;
        rssi: number;
        cell_selection_rx_level: number;

        // Constructors

        constructor(
            properties?: Partial<{
                physical_cell_id: number;
                rsrq: number;
                rsrp: number;
                rssi: number;
                cell_selection_rx_level: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementCellElement struct.
     */
    class MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementCellElement {
        static $gtype: GObject.GType<MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementCellElement>;

        // Fields

        geran_absolute_rf_channel_number: number;
        band_is_1900: boolean;
        cell_id_valid: boolean;
        base_station_identity_code: number;
        rssi: number;
        cell_selection_rx_level: number;

        // Constructors

        constructor(
            properties?: Partial<{
                geran_absolute_rf_channel_number: number;
                band_is_1900: boolean;
                cell_id_valid: boolean;
                base_station_identity_code: number;
                rssi: number;
                cell_selection_rx_level: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementGir struct.
     *
     * This type is a version of #QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElement, using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    class MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementGir {
        static $gtype: GObject.GType<MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementGir>;

        // Fields

        cell_reselection_priority: number;
        cell_reselection_high_threshold: number;
        cell_reselection_low_threshold: number;
        ncc_permitted: number;
        cell: MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementCellElement[];

        // Constructors

        constructor(
            properties?: Partial<{
                cell_reselection_priority: number;
                cell_reselection_high_threshold: number;
                cell_reselection_low_threshold: number;
                ncc_permitted: number;
                cell: MessageNasGetCellLocationInfoOutputLteInfoNeighboringGsmFrequencyElementCellElement[];
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementCellElement struct.
     */
    class MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementCellElement {
        static $gtype: GObject.GType<MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementCellElement>;

        // Fields

        primary_scrambling_code: number;
        cpich_rscp: number;
        cpich_ecno: number;
        cell_selection_rx_level: number;

        // Constructors

        constructor(
            properties?: Partial<{
                primary_scrambling_code: number;
                cpich_rscp: number;
                cpich_ecno: number;
                cell_selection_rx_level: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementGir struct.
     *
     * This type is a version of #QmiMessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElement, using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    class MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementGir {
        static $gtype: GObject.GType<MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementGir>;

        // Fields

        utra_absolute_rf_channel_number: number;
        cell_reselection_priority: number;
        cell_reselection_high_threshold: number;
        cell_reselection_low_threshold: number;
        cell: MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementCellElement[];

        // Constructors

        constructor(
            properties?: Partial<{
                utra_absolute_rf_channel_number: number;
                cell_reselection_priority: number;
                cell_reselection_high_threshold: number;
                cell_reselection_low_threshold: number;
                cell: MessageNasGetCellLocationInfoOutputLteInfoNeighboringWcdmaFrequencyElementCellElement[];
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetCellLocationInfoOutputUmtsInfoNeighboringLteFrequencyElement struct.
     */
    class MessageNasGetCellLocationInfoOutputUmtsInfoNeighboringLteFrequencyElement {
        static $gtype: GObject.GType<MessageNasGetCellLocationInfoOutputUmtsInfoNeighboringLteFrequencyElement>;

        // Fields

        eutra_absolute_rf_channel_number: number;
        physical_cell_id: number;
        rsrp: number;
        rsrq: number;
        cell_selection_rx_level: number;
        is_tdd: boolean;

        // Constructors

        constructor(
            properties?: Partial<{
                eutra_absolute_rf_channel_number: number;
                physical_cell_id: number;
                rsrp: number;
                rsrq: number;
                cell_selection_rx_level: number;
                is_tdd: boolean;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetCellLocationInfoOutputUmtsInfoV2CellElement struct.
     */
    class MessageNasGetCellLocationInfoOutputUmtsInfoV2CellElement {
        static $gtype: GObject.GType<MessageNasGetCellLocationInfoOutputUmtsInfoV2CellElement>;

        // Fields

        utra_absolute_rf_channel_number: number;
        primary_scrambling_code: number;
        rscp: number;
        ecio: number;

        // Constructors

        constructor(
            properties?: Partial<{
                utra_absolute_rf_channel_number: number;
                primary_scrambling_code: number;
                rscp: number;
                ecio: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetCellLocationInfoOutputUmtsInfoV2NeighboringGeranElement struct.
     */
    class MessageNasGetCellLocationInfoOutputUmtsInfoV2NeighboringGeranElement {
        static $gtype: GObject.GType<MessageNasGetCellLocationInfoOutputUmtsInfoV2NeighboringGeranElement>;

        // Fields

        geran_absolute_rf_channel_number: number;
        network_color_code: number;
        base_station_color_code: number;
        rssi: number;

        // Constructors

        constructor(
            properties?: Partial<{
                geran_absolute_rf_channel_number: number;
                network_color_code: number;
                base_station_color_code: number;
                rssi: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageNasGetDrxOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetDrxOutput {
        static $gtype: GObject.GType<MessageNasGetDrxOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, NasDrx | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetDrxOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasGetHomeNetworkOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetHomeNetworkOutput {
        static $gtype: GObject.GType<MessageNasGetHomeNetworkOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Home Network' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_home_network(): [boolean, number, number, string];
        /**
         * Get the 'Home Network 3GPP2 Ext' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_home_network_3gpp2_ext(): [
            boolean,
            number,
            number,
            NasNetworkDescriptionDisplay | null,
            NasNetworkDescriptionEncoding | null,
            Uint8Array | null,
        ];
        /**
         * Get the 'Home Network 3GPP MNC' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_home_network_3gpp_mnc(): [boolean, boolean, boolean];
        /**
         * Get the 'Home System ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_home_system_id(): [boolean, number, number];
        /**
         * Get the 'Network Name Source' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_name_source(): [boolean, NasNetworkNameSource | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetHomeNetworkOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasGetLteCphyCaInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetLteCphyCaInfoOutput {
        static $gtype: GObject.GType<MessageNasGetLteCphyCaInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'DL Bandwidth' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_dl_bandwidth(): [boolean, NasDLBandwidth | null];
        /**
         * Get the 'Phy CA Agg PCell Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_phy_ca_agg_pcell_info(): [boolean, number, number, NasDLBandwidth | null, NasActiveBand | null];
        /**
         * Get the 'Phy CA Agg SCell Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_phy_ca_agg_scell_info(): [
            boolean,
            number,
            number,
            NasDLBandwidth | null,
            NasActiveBand | null,
            NasScellState | null,
        ];
        /**
         * Get the 'Phy CA Agg Secondary Cells' field from `self`.
         *
         * Version of qmi_message_nas_get_lte_cphy_ca_info_output_get_phy_ca_agg_secondary_cells() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_phy_ca_agg_secondary_cells(): [boolean, MessageNasGetLteCphyCaInfoOutputPhyCaAggSecondaryCellsSsc[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'SCell index' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_scell_index(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetLteCphyCaInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageNasGetLteCphyCaInfoOutputPhyCaAggSecondaryCellsSsc struct.
     */
    class MessageNasGetLteCphyCaInfoOutputPhyCaAggSecondaryCellsSsc {
        static $gtype: GObject.GType<MessageNasGetLteCphyCaInfoOutputPhyCaAggSecondaryCellsSsc>;

        // Fields

        physical_cell_id: number;
        rx_channel: number;
        dl_bandwidth: NasDLBandwidth;
        lte_band: NasActiveBand;
        state: NasScellState;
        cell_index: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageNasGetOperatorNameOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetOperatorNameOutput {
        static $gtype: GObject.GType<MessageNasGetOperatorNameOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'NITZ Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nitz_information(): [
            boolean,
            NasPlmnEncodingScheme | null,
            NasPlmnNameCountryInitials | null,
            NasPlmnNameSpareBits | null,
            NasPlmnNameSpareBits | null,
            Uint8Array | null,
            Uint8Array | null,
        ];
        /**
         * Get the 'Operator PLMN List' field from `self`.
         *
         * Version of qmi_message_nas_get_operator_name_output_get_operator_plmn_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_operator_plmn_list(): [boolean, MessageNasGetOperatorNameOutputOperatorPlmnListElement[] | null];
        /**
         * Get the 'Operator PLMN Name' field from `self`.
         *
         * Version of qmi_message_nas_get_operator_name_output_get_operator_plmn_name() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_operator_plmn_name(): [boolean, MessageNasGetOperatorNameOutputOperatorPlmnNameElement[] | null];
        /**
         * Get the 'Operator String Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_operator_string_name(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Service Provider Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_service_provider_name(): [boolean, NasNetworkNameDisplayCondition | null, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetOperatorNameOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageNasGetOperatorNameOutputOperatorPlmnListElement struct.
     */
    class MessageNasGetOperatorNameOutputOperatorPlmnListElement {
        static $gtype: GObject.GType<MessageNasGetOperatorNameOutputOperatorPlmnListElement>;

        // Fields

        mcc: string;
        mnc: string;
        lac1: number;
        lac2: number;
        plmn_name_record_identifier: number;

        // Constructors

        constructor(
            properties?: Partial<{
                mcc: string;
                mnc: string;
                lac1: number;
                lac2: number;
                plmn_name_record_identifier: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetOperatorNameOutputOperatorPlmnNameElement struct.
     */
    class MessageNasGetOperatorNameOutputOperatorPlmnNameElement {
        static $gtype: GObject.GType<MessageNasGetOperatorNameOutputOperatorPlmnNameElement>;

        // Fields

        name_encoding: NasPlmnEncodingScheme;
        short_country_initials: NasPlmnNameCountryInitials;
        long_name_spare_bits: NasPlmnNameSpareBits;
        short_name_spare_bits: NasPlmnNameSpareBits;
        long_name: any[];
        short_name: any[];

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageNasGetPlmnNameInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasGetPlmnNameInput {
        static $gtype: GObject.GType<MessageNasGetPlmnNameInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasGetPlmnNameInput;

        // Methods

        /**
         * Get the 'Always Send PLMN Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_always_send_plmn_name(): [boolean, boolean];
        /**
         * Get the 'CSG ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_csg_id(): [boolean, number];
        /**
         * Get the 'MNC PCS Digit Include Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mnc_pcs_digit_include_status(): [boolean, boolean];
        /**
         * Get the 'PLMN' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_plmn(): [boolean, number, number];
        /**
         * Get the 'Radio Access Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_radio_access_technology(): [boolean, NasRadioInterface | null];
        /**
         * Get the 'Send All Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_send_all_information(): [boolean, boolean];
        /**
         * Get the 'Suppress SIM Error' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_suppress_sim_error(): [boolean, boolean];
        /**
         * Get the 'Use Static Table Only' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_use_static_table_only(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetPlmnNameInput;
        /**
         * Set the 'Always Send PLMN Name' field in the message.
         * @param value_always_send_plmn_name a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_always_send_plmn_name(value_always_send_plmn_name: boolean): boolean;
        /**
         * Set the 'CSG ID' field in the message.
         * @param value_csg_id a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_csg_id(value_csg_id: number): boolean;
        /**
         * Set the 'MNC PCS Digit Include Status' field in the message.
         * @param value_mnc_pcs_digit_include_status a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mnc_pcs_digit_include_status(value_mnc_pcs_digit_include_status: boolean): boolean;
        /**
         * Set the 'PLMN' field in the message.
         * @param value_plmn_mcc a #guint16.
         * @param value_plmn_mnc a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_plmn(value_plmn_mcc: number, value_plmn_mnc: number): boolean;
        /**
         * Set the 'Radio Access Technology' field in the message.
         * @param value_radio_access_technology a #QmiNasRadioInterface.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_radio_access_technology(value_radio_access_technology: NasRadioInterface): boolean;
        /**
         * Set the 'Send All Information' field in the message.
         * @param value_send_all_information a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_send_all_information(value_send_all_information: boolean): boolean;
        /**
         * Set the 'Suppress SIM Error' field in the message.
         * @param value_suppress_sim_error a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_suppress_sim_error(value_suppress_sim_error: boolean): boolean;
        /**
         * Set the 'Use Static Table Only' field in the message.
         * @param value_use_static_table_only a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_use_static_table_only(value_use_static_table_only: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasGetPlmnNameOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetPlmnNameOutput {
        static $gtype: GObject.GType<MessageNasGetPlmnNameOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the '3GPP EONS PLMN Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_3gpp_eons_plmn_name(): [
            boolean,
            NasNetworkDescriptionEncoding | null,
            Uint8Array | null,
            NasNetworkDescriptionEncoding | null,
            NasPlmnNameCountryInitials | null,
            NasPlmnNameSpareBits | null,
            Uint8Array | null,
            NasNetworkDescriptionEncoding | null,
            NasPlmnNameCountryInitials | null,
            NasPlmnNameSpareBits | null,
            Uint8Array | null,
        ];
        /**
         * Get the 'Additional Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_information(): [boolean, number[] | null];
        /**
         * Get the 'Display Bit Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_display_bit_information(): [boolean, NasBoolean | null, NasBoolean | null];
        /**
         * Get the 'Network Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_information(): [boolean, NasBoolean | null];
        /**
         * Get the 'Network Name Source' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_name_source(): [boolean, NasNetworkNameSource | null];
        /**
         * Get the 'PLMN Name With Language Id' field from `self`.
         *
         * Version of qmi_message_nas_get_plmn_name_output_get_plmn_name_with_language_id() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_plmn_name_with_language_id(): [boolean, MessageNasGetPlmnNameOutputPlmnNameWithLanguageIdElement[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetPlmnNameOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageNasGetPlmnNameOutputPlmnNameWithLanguageIdElement struct.
     */
    class MessageNasGetPlmnNameOutputPlmnNameWithLanguageIdElement {
        static $gtype: GObject.GType<MessageNasGetPlmnNameOutputPlmnNameWithLanguageIdElement>;

        // Fields

        long_name: any[];
        short_name: any[];
        language_id: NasPlmnLanguageId;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageNasGetPreferredNetworksOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetPreferredNetworksOutput {
        static $gtype: GObject.GType<MessageNasGetPreferredNetworksOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'MNC PCS Digit Include Status' field from `self`.
         *
         * Version of qmi_message_nas_get_preferred_networks_output_get_mnc_pcs_digit_include_status() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mnc_pcs_digit_include_status(): [
            boolean,
            MessageNasGetPreferredNetworksOutputMncPcsDigitIncludeStatusElement[] | null,
        ];
        /**
         * Get the 'Preferred Networks' field from `self`.
         *
         * Version of qmi_message_nas_get_preferred_networks_output_get_preferred_networks() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_preferred_networks(): [boolean, MessageNasGetPreferredNetworksOutputPreferredNetworksElement[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetPreferredNetworksOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageNasGetPreferredNetworksOutputMncPcsDigitIncludeStatusElement struct.
     */
    class MessageNasGetPreferredNetworksOutputMncPcsDigitIncludeStatusElement {
        static $gtype: GObject.GType<MessageNasGetPreferredNetworksOutputMncPcsDigitIncludeStatusElement>;

        // Fields

        mcc: number;
        mnc: number;
        includes_pcs_digit: boolean;

        // Constructors

        constructor(
            properties?: Partial<{
                mcc: number;
                mnc: number;
                includes_pcs_digit: boolean;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetPreferredNetworksOutputPreferredNetworksElement struct.
     */
    class MessageNasGetPreferredNetworksOutputPreferredNetworksElement {
        static $gtype: GObject.GType<MessageNasGetPreferredNetworksOutputPreferredNetworksElement>;

        // Fields

        mcc: number;
        mnc: number;
        radio_access_technology: NasPlmnAccessTechnologyIdentifier;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageNasGetRfBandInformationOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetRfBandInformationOutput {
        static $gtype: GObject.GType<MessageNasGetRfBandInformationOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Bandwidth List' field from `self`.
         *
         * Version of qmi_message_nas_get_rf_band_information_output_get_bandwidth_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_bandwidth_list(): [boolean, MessageNasGetRfBandInformationOutputBandwidthListElement[] | null];
        /**
         * Get the 'Extended List' field from `self`.
         *
         * Version of qmi_message_nas_get_rf_band_information_output_get_extended_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_list(): [boolean, MessageNasGetRfBandInformationOutputExtendedListElement[] | null];
        /**
         * Get the 'List' field from `self`.
         *
         * Version of qmi_message_nas_get_rf_band_information_output_get_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, MessageNasGetRfBandInformationOutputListElement[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetRfBandInformationOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageNasGetRfBandInformationOutputBandwidthListElement struct.
     */
    class MessageNasGetRfBandInformationOutputBandwidthListElement {
        static $gtype: GObject.GType<MessageNasGetRfBandInformationOutputBandwidthListElement>;

        // Fields

        radio_interface: NasRadioInterface;
        bandwidth: NasDLBandwidth;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetRfBandInformationOutputExtendedListElement struct.
     */
    class MessageNasGetRfBandInformationOutputExtendedListElement {
        static $gtype: GObject.GType<MessageNasGetRfBandInformationOutputExtendedListElement>;

        // Fields

        radio_interface: NasRadioInterface;
        active_band_class: NasActiveBand;
        active_channel: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetRfBandInformationOutputListElement struct.
     */
    class MessageNasGetRfBandInformationOutputListElement {
        static $gtype: GObject.GType<MessageNasGetRfBandInformationOutputListElement>;

        // Fields

        radio_interface: NasRadioInterface;
        active_band_class: NasActiveBand;
        active_channel: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageNasGetServingSystemOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetServingSystemOutput {
        static $gtype: GObject.GType<MessageNasGetServingSystemOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Call Barring Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_barring_status(): [boolean, NasCallBarringStatus | null, NasCallBarringStatus | null];
        /**
         * Get the 'CDMA Base Station Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_base_station_info(): [boolean, number, number, number];
        /**
         * Get the 'CDMA P Rev' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_p_rev(): [boolean, number];
        /**
         * Get the 'CDMA System ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_system_id(): [boolean, number, number];
        /**
         * Get the 'CDMA System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_system_info(): [boolean, number, number];
        /**
         * Get the 'CID 3GPP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cid_3gpp(): [boolean, number];
        /**
         * Get the 'Concurrent Service Info 3GPP2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_concurrent_service_info_3gpp2(): [boolean, boolean];
        /**
         * Get the 'Current PLMN' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_plmn(): [boolean, number, number, string];
        /**
         * Get the 'Data Service Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data_service_capability(): [boolean, NasDataCapability[] | null];
        /**
         * Get the 'Daylight Saving Time Adjustment 3GPP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_daylight_saving_time_adjustment_3gpp(): [boolean, number];
        /**
         * Get the 'Default Roaming Indicator' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_default_roaming_indicator(): [boolean, NasRoamingIndicatorStatus | null];
        /**
         * Get the 'Detailed Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_detailed_service_status(): [
            boolean,
            NasServiceStatus | null,
            NasNetworkServiceDomain | null,
            NasServiceStatus | null,
            boolean,
            boolean,
        ];
        /**
         * Get the 'DTM Support' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_dtm_support(): [boolean, boolean];
        /**
         * Get the 'HDR Personality' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_personality(): [boolean, NasHdrPersonality | null];
        /**
         * Get the 'LAC 3GPP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lac_3gpp(): [boolean, number];
        /**
         * Get the 'LTE TAC' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_tac(): [boolean, number];
        /**
         * Get the 'MNC PCS Digit Include Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mnc_pcs_digit_include_status(): [boolean, number, number, boolean];
        /**
         * Get the 'Network Name Source' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_name_source(): [boolean, NasNetworkNameSource | null];
        /**
         * Get the 'PRL Indicator 3GPP2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_prl_indicator_3gpp2(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Roaming Indicator' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roaming_indicator(): [boolean, NasRoamingIndicatorStatus | null];
        /**
         * Get the 'Roaming Indicator List' field from `self`.
         *
         * Version of qmi_message_nas_get_serving_system_output_get_roaming_indicator_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roaming_indicator_list(): [boolean, MessageNasGetServingSystemOutputRoamingIndicatorListElement[] | null];
        /**
         * Get the 'Serving System' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_serving_system(): [
            boolean,
            NasRegistrationState | null,
            NasAttachState | null,
            NasAttachState | null,
            NasNetworkType | null,
            NasRadioInterface[] | null,
        ];
        /**
         * Get the 'Time Zone 3GPP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_time_zone_3gpp(): [boolean, number];
        /**
         * Get the 'Time Zone 3GPP2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_time_zone_3gpp2(): [boolean, number, number, boolean];
        /**
         * Get the 'UMTS Primary Scrambling Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_primary_scrambling_code(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetServingSystemOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageNasGetServingSystemOutputRoamingIndicatorListElement struct.
     */
    class MessageNasGetServingSystemOutputRoamingIndicatorListElement {
        static $gtype: GObject.GType<MessageNasGetServingSystemOutputRoamingIndicatorListElement>;

        // Fields

        radio_interface: NasRadioInterface;
        roaming_indicator: NasRoamingIndicatorStatus;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageNasGetSignalInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetSignalInfoOutput {
        static $gtype: GObject.GType<MessageNasGetSignalInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the '5G Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_5g_signal_strength(): [boolean, number, number];
        /**
         * Get the '5G Signal Strength Extended' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_5g_signal_strength_extended(): [boolean, number];
        /**
         * Get the 'CDMA Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_signal_strength(): [boolean, number, number];
        /**
         * Get the 'GSM Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_signal_strength(): [boolean, number];
        /**
         * Get the 'HDR Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_signal_strength(): [boolean, number, number, NasEvdoSinrLevel | null, number];
        /**
         * Get the 'LTE Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_signal_strength(): [boolean, number, number, number, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'TDMA Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tdma_signal_strength(): [boolean, number];
        /**
         * Get the 'TDMA Signal Strength Extended' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tdma_signal_strength_extended(): [boolean, number, number, number, number];
        /**
         * Get the 'WCDMA RSCP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_rscp(): [boolean, number];
        /**
         * Get the 'WCDMA Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_signal_strength(): [boolean, number, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetSignalInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasGetSignalStrengthInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasGetSignalStrengthInput {
        static $gtype: GObject.GType<MessageNasGetSignalStrengthInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasGetSignalStrengthInput;

        // Methods

        /**
         * Get the 'Request Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_request_mask(): [boolean, NasSignalStrengthRequest | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetSignalStrengthInput;
        /**
         * Set the 'Request Mask' field in the message.
         * @param value_request_mask a #QmiNasSignalStrengthRequest.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_request_mask(value_request_mask: NasSignalStrengthRequest): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasGetSignalStrengthOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetSignalStrengthOutput {
        static $gtype: GObject.GType<MessageNasGetSignalStrengthOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'ECIO List' field from `self`.
         *
         * Version of qmi_message_nas_get_signal_strength_output_get_ecio_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ecio_list(): [boolean, MessageNasGetSignalStrengthOutputEcioListElement[] | null];
        /**
         * Get the 'Error Rate List' field from `self`.
         *
         * Version of qmi_message_nas_get_signal_strength_output_get_error_rate_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_error_rate_list(): [boolean, MessageNasGetSignalStrengthOutputErrorRateListElement[] | null];
        /**
         * Get the 'IO' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_io(): [boolean, number];
        /**
         * Get the 'LTE RSRP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_rsrp(): [boolean, number];
        /**
         * Get the 'LTE SNR' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_snr(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'RSRQ' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rsrq(): [boolean, number, NasRadioInterface | null];
        /**
         * Get the 'RSSI List' field from `self`.
         *
         * Version of qmi_message_nas_get_signal_strength_output_get_rssi_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rssi_list(): [boolean, MessageNasGetSignalStrengthOutputRssiListElement[] | null];
        /**
         * Get the 'Signal Strength' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_signal_strength(): [boolean, number, NasRadioInterface | null];
        /**
         * Get the 'SINR' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sinr(): [boolean, NasEvdoSinrLevel | null];
        /**
         * Get the 'Strength List' field from `self`.
         *
         * Version of qmi_message_nas_get_signal_strength_output_get_strength_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_strength_list(): [boolean, MessageNasGetSignalStrengthOutputStrengthListElement[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetSignalStrengthOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageNasGetSignalStrengthOutputEcioListElement struct.
     */
    class MessageNasGetSignalStrengthOutputEcioListElement {
        static $gtype: GObject.GType<MessageNasGetSignalStrengthOutputEcioListElement>;

        // Fields

        ecio: number;
        radio_interface: NasRadioInterface;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetSignalStrengthOutputErrorRateListElement struct.
     */
    class MessageNasGetSignalStrengthOutputErrorRateListElement {
        static $gtype: GObject.GType<MessageNasGetSignalStrengthOutputErrorRateListElement>;

        // Fields

        rate: number;
        radio_interface: NasRadioInterface;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetSignalStrengthOutputRssiListElement struct.
     */
    class MessageNasGetSignalStrengthOutputRssiListElement {
        static $gtype: GObject.GType<MessageNasGetSignalStrengthOutputRssiListElement>;

        // Fields

        rssi: number;
        radio_interface: NasRadioInterface;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasGetSignalStrengthOutputStrengthListElement struct.
     */
    class MessageNasGetSignalStrengthOutputStrengthListElement {
        static $gtype: GObject.GType<MessageNasGetSignalStrengthOutputStrengthListElement>;

        // Fields

        strength: number;
        radio_interface: NasRadioInterface;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageNasGetSupportedMessagesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetSupportedMessagesOutput {
        static $gtype: GObject.GType<MessageNasGetSupportedMessagesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, Uint8Array | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetSupportedMessagesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasGetSystemInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetSystemInfoOutput {
        static $gtype: GObject.GType<MessageNasGetSystemInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Additional CDMA System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_cdma_system_info(): [boolean, number, number];
        /**
         * Get the 'Additional GSM System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_gsm_system_info(): [boolean, number, NasCellBroadcastCapability | null];
        /**
         * Get the 'Additional HDR System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_hdr_system_info(): [boolean, number];
        /**
         * Get the 'Additional LTE System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_lte_system_info(): [boolean, number];
        /**
         * Get the 'Additional WCDMA System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_wcdma_system_info(): [boolean, number, NasCellBroadcastCapability | null];
        /**
         * Get the 'CDMA Registration Zone ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_registration_zone_id(): [boolean, number];
        /**
         * Get the 'CDMA Resolved MCC' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_resolved_mcc(): [boolean, number];
        /**
         * Get the 'CDMA Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_service_status(): [boolean, NasServiceStatus | null, boolean];
        /**
         * Get the 'CDMA System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_system_info(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            boolean,
            boolean,
            number,
            boolean,
            number,
            boolean,
            boolean,
            boolean,
            number,
            number,
            boolean,
            number,
            number,
            number,
            boolean,
            number,
            boolean,
            string,
            string,
        ];
        /**
         * Get the 'DCNR restriction Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_dcnr_restriction_info(): [boolean, boolean];
        /**
         * Get the 'EUTRA with NR5G availability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_eutra_with_nr5g_availability(): [boolean, boolean];
        /**
         * Get the 'GSM Call Barring Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_call_barring_status(): [boolean, NasCallBarringStatus | null, NasCallBarringStatus | null];
        /**
         * Get the 'GSM Cipher Domain' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_cipher_domain(): [boolean, NasNetworkServiceDomain | null];
        /**
         * Get the 'GSM Routing Area Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_routing_area_code(): [boolean, number];
        /**
         * Get the 'GSM Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_service_status(): [boolean, NasServiceStatus | null, NasServiceStatus | null, boolean];
        /**
         * Get the 'GSM System Info v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_system_info_v2(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            number,
            boolean,
            number,
            boolean,
            NasNetworkServiceDomain | null,
            NasRejectCause | null,
            boolean,
            string,
            string,
            boolean,
            boolean,
            boolean,
            boolean,
        ];
        /**
         * Get the 'HDR Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_service_status(): [boolean, NasServiceStatus | null, boolean];
        /**
         * Get the 'HDR System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_system_info(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            boolean,
            boolean,
            NasHdrPersonality | null,
            boolean,
            NasHdrProtocolRevision | null,
            boolean,
            string,
        ];
        /**
         * Get the 'IMS Voice Support' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ims_voice_support(): [boolean, boolean];
        /**
         * Get the 'LTE Cell Access Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_cell_access_status(): [boolean, NasLteCellAccessStatus | null];
        /**
         * Get the 'LTE eMBMS Coverage Info Support' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_embms_coverage_info_support(): [boolean, boolean];
        /**
         * Get the 'LTE eMBMS Coverage Info Trace ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_embms_coverage_info_trace_id(): [boolean, number];
        /**
         * Get the 'LTE Registration Domain' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_registration_domain(): [boolean, NasLteRegistrationDomain | null];
        /**
         * Get the 'LTE Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_service_status(): [boolean, NasServiceStatus | null, NasServiceStatus | null, boolean];
        /**
         * Get the 'LTE System Info v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_system_info_v2(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            number,
            boolean,
            number,
            boolean,
            NasNetworkServiceDomain | null,
            NasRejectCause | null,
            boolean,
            string,
            string,
            boolean,
            number,
        ];
        /**
         * Get the 'LTE Voice Domain' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_voice_domain(): [boolean, NasLteVoiceDomain | null];
        /**
         * Get the 'LTE Voice Support' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_voice_support(): [boolean, boolean];
        /**
         * Get the 'Network Selection Registration Restriction' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_selection_registration_restriction(): [boolean, NasNetworkSelectionRegistrationRestriction | null];
        /**
         * Get the 'NR5G Service Status Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_service_status_info(): [boolean, NasServiceStatus | null, NasServiceStatus | null, boolean];
        /**
         * Get the 'NR5G System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_system_info(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            number,
            boolean,
            number,
            boolean,
            NasNetworkServiceDomain | null,
            number,
            boolean,
            string,
            string,
            boolean,
            number,
        ];
        /**
         * Get the 'NR5G Tracking Area Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_tracking_area_code(): [boolean, Uint8Array | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'SIM Reject Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sim_reject_info(): [boolean, NasSimRejectState | null];
        /**
         * Get the 'TD SCDMA Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_td_scdma_service_status(): [boolean, NasServiceStatus | null, NasServiceStatus | null, boolean];
        /**
         * Get the 'TD SCDMA System Info v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_td_scdma_system_info_v2(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            number,
            boolean,
            number,
            boolean,
            NasNetworkServiceDomain | null,
            NasRejectCause | null,
            boolean,
            string,
            string,
            boolean,
            NasWcdmaHsService | null,
            boolean,
            NasWcdmaHsService | null,
            boolean,
            number,
            boolean,
            NasCellBroadcastCapability | null,
            boolean,
            NasCallBarringStatus | null,
            boolean,
            NasCallBarringStatus | null,
            boolean,
            NasNetworkServiceDomain | null,
        ];
        /**
         * Get the 'WCDMA Call Barring Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_call_barring_status(): [boolean, NasCallBarringStatus | null, NasCallBarringStatus | null];
        /**
         * Get the 'WCDMA Cipher Domain' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_cipher_domain(): [boolean, NasNetworkServiceDomain | null];
        /**
         * Get the 'WCDMA Routing Area Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_routing_area_code(): [boolean, number];
        /**
         * Get the 'WCDMA Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_service_status(): [boolean, NasServiceStatus | null, NasServiceStatus | null, boolean];
        /**
         * Get the 'WCDMA System Info v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_wcdma_system_info_v2(): [
            boolean,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasNetworkServiceDomain | null,
            boolean,
            NasRoamingStatus | null,
            boolean,
            boolean,
            boolean,
            number,
            boolean,
            number,
            boolean,
            NasNetworkServiceDomain | null,
            NasRejectCause | null,
            boolean,
            string,
            string,
            boolean,
            NasWcdmaHsService | null,
            boolean,
            NasWcdmaHsService | null,
            boolean,
            number,
        ];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetSystemInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasGetSystemSelectionPreferenceOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetSystemSelectionPreferenceOutput {
        static $gtype: GObject.GType<MessageNasGetSystemSelectionPreferenceOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Acquisition Order Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_acquisition_order_preference(): [boolean, NasRadioInterface[] | null];
        /**
         * Get the 'Band Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_band_preference(): [boolean, NasBandPreference | null];
        /**
         * Get the 'CDMA PRL Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_prl_preference(): [boolean, NasCdmaPrlPreference | null];
        /**
         * Get the 'Disabled Modes' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_disabled_modes(): [boolean, NasRatModePreference | null];
        /**
         * Get the 'Emergency mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_emergency_mode(): [boolean, boolean];
        /**
         * Get the 'Extended LTE Band Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_lte_band_preference(): [boolean, number, number, number, number];
        /**
         * Get the 'GSM WCDMA Acquisition Order Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_wcdma_acquisition_order_preference(): [boolean, NasGsmWcdmaAcquisitionOrderPreference | null];
        /**
         * Get the 'LTE Band Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_band_preference(): [boolean, NasLteBandPreference | null];
        /**
         * Get the 'Manual Network Selection' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_manual_network_selection(): [boolean, number, number, boolean];
        /**
         * Get the 'Mode Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mode_preference(): [boolean, NasRatModePreference | null];
        /**
         * Get the 'Network Selection Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_selection_preference(): [boolean, NasNetworkSelectionPreference | null];
        /**
         * Get the 'Network Selection Registration Restriction' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_selection_registration_restriction(): [boolean, NasNetworkSelectionRegistrationRestriction | null];
        /**
         * Get the 'NR5G NSA Band Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_nsa_band_preference(): [boolean, number, number, number, number, number, number, number, number];
        /**
         * Get the 'NR5G SA Band Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_sa_band_preference(): [boolean, number, number, number, number, number, number, number, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Roaming Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roaming_preference(): [boolean, NasRoamingPreference | null];
        /**
         * Get the 'Service Domain Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_service_domain_preference(): [boolean, NasServiceDomainPreference | null];
        /**
         * Get the 'TD SCDMA Band Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_td_scdma_band_preference(): [boolean, NasTdScdmaBandPreference | null];
        /**
         * Get the 'Usage Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_usage_preference(): [boolean, NasUsagePreference | null];
        /**
         * Get the 'Voice Domain Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_voice_domain_preference(): [boolean, NasVoiceDomainPreference | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetSystemSelectionPreferenceOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasGetTechnologyPreferenceOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetTechnologyPreferenceOutput {
        static $gtype: GObject.GType<MessageNasGetTechnologyPreferenceOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Active' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_active(): [boolean, NasRadioTechnologyPreference | null, NasPreferenceDuration | null];
        /**
         * Get the 'Persistent' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_persistent(): [boolean, NasRadioTechnologyPreference | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetTechnologyPreferenceOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasGetTxRxInfoInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasGetTxRxInfoInput {
        static $gtype: GObject.GType<MessageNasGetTxRxInfoInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasGetTxRxInfoInput;

        // Methods

        /**
         * Get the 'Radio Interface' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_radio_interface(): [boolean, NasRadioInterface | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetTxRxInfoInput;
        /**
         * Set the 'Radio Interface' field in the message.
         * @param value_radio_interface a #QmiNasRadioInterface.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_radio_interface(value_radio_interface: NasRadioInterface): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasGetTxRxInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasGetTxRxInfoOutput {
        static $gtype: GObject.GType<MessageNasGetTxRxInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Rx Chain 0 Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_chain_0_info(): [boolean, boolean, number, number, number, number, number];
        /**
         * Get the 'Rx Chain 1 Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_chain_1_info(): [boolean, boolean, number, number, number, number, number];
        /**
         * Get the 'Rx Chain 2 Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_chain_2_info(): [boolean, boolean, number, number, number, number, number];
        /**
         * Get the 'Rx Chain 3 Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_chain_3_info(): [boolean, boolean, number, number, number, number, number];
        /**
         * Get the 'Tx Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tx_info(): [boolean, boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasGetTxRxInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasInitiateNetworkRegisterInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasInitiateNetworkRegisterInput {
        static $gtype: GObject.GType<MessageNasInitiateNetworkRegisterInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasInitiateNetworkRegisterInput;

        // Methods

        /**
         * Get the 'Action' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_action(): [boolean, NasNetworkRegisterType | null];
        /**
         * Get the 'Change Duration' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_change_duration(): [boolean, NasChangeDuration | null];
        /**
         * Get the 'Manual Registration Info 3GPP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_manual_registration_info_3gpp(): [boolean, number, number, NasRadioInterface | null];
        /**
         * Get the 'MNC PCS Digit Include Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mnc_pcs_digit_include_status(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasInitiateNetworkRegisterInput;
        /**
         * Set the 'Action' field in the message.
         * @param value_action a #QmiNasNetworkRegisterType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_action(value_action: NasNetworkRegisterType): boolean;
        /**
         * Set the 'Change Duration' field in the message.
         * @param value_change_duration a #QmiNasChangeDuration.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_change_duration(value_change_duration: NasChangeDuration): boolean;
        /**
         * Set the 'Manual Registration Info 3GPP' field in the message.
         * @param value_manual_registration_info_3gpp_mcc a #guint16.
         * @param value_manual_registration_info_3gpp_mnc a #guint16.
         * @param value_manual_registration_info_3gpp_radio_interface a #QmiNasRadioInterface.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_manual_registration_info_3gpp(
            value_manual_registration_info_3gpp_mcc: number,
            value_manual_registration_info_3gpp_mnc: number,
            value_manual_registration_info_3gpp_radio_interface: NasRadioInterface,
        ): boolean;
        /**
         * Set the 'MNC PCS Digit Include Status' field in the message.
         * @param value_mnc_pcs_digit_include_status a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mnc_pcs_digit_include_status(value_mnc_pcs_digit_include_status: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasInitiateNetworkRegisterOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasInitiateNetworkRegisterOutput {
        static $gtype: GObject.GType<MessageNasInitiateNetworkRegisterOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasInitiateNetworkRegisterOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasNetworkScanInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasNetworkScanInput {
        static $gtype: GObject.GType<MessageNasNetworkScanInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasNetworkScanInput;

        // Methods

        /**
         * Get the 'Network Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_type(): [boolean, NasNetworkScanType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasNetworkScanInput;
        /**
         * Set the 'Network Type' field in the message.
         * @param value_network_type a #QmiNasNetworkScanType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_network_type(value_network_type: NasNetworkScanType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasNetworkScanOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasNetworkScanOutput {
        static $gtype: GObject.GType<MessageNasNetworkScanOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'MNC PCS Digit Include Status' field from `self`.
         *
         * Version of qmi_message_nas_network_scan_output_get_mnc_pcs_digit_include_status() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mnc_pcs_digit_include_status(): [
            boolean,
            MessageNasNetworkScanOutputMncPcsDigitIncludeStatusElement[] | null,
        ];
        /**
         * Get the 'Network Information' field from `self`.
         *
         * Version of qmi_message_nas_network_scan_output_get_network_information() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_information(): [boolean, MessageNasNetworkScanOutputNetworkInformationElement[] | null];
        /**
         * Get the 'Network Scan Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_scan_result(): [boolean, NasNetworkScanResult | null];
        /**
         * Get the 'Radio Access Technology' field from `self`.
         *
         * Version of qmi_message_nas_network_scan_output_get_radio_access_technology() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_radio_access_technology(): [boolean, MessageNasNetworkScanOutputRadioAccessTechnologyElement[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasNetworkScanOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageNasNetworkScanOutputMncPcsDigitIncludeStatusElement struct.
     */
    class MessageNasNetworkScanOutputMncPcsDigitIncludeStatusElement {
        static $gtype: GObject.GType<MessageNasNetworkScanOutputMncPcsDigitIncludeStatusElement>;

        // Fields

        mcc: number;
        mnc: number;
        includes_pcs_digit: boolean;

        // Constructors

        constructor(
            properties?: Partial<{
                mcc: number;
                mnc: number;
                includes_pcs_digit: boolean;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasNetworkScanOutputNetworkInformationElement struct.
     */
    class MessageNasNetworkScanOutputNetworkInformationElement {
        static $gtype: GObject.GType<MessageNasNetworkScanOutputNetworkInformationElement>;

        // Fields

        mcc: number;
        mnc: number;
        network_status: NasNetworkStatus;
        description: string;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasNetworkScanOutputRadioAccessTechnologyElement struct.
     */
    class MessageNasNetworkScanOutputRadioAccessTechnologyElement {
        static $gtype: GObject.GType<MessageNasNetworkScanOutputRadioAccessTechnologyElement>;

        // Fields

        mcc: number;
        mnc: number;
        radio_interface: NasRadioInterface;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageNasRegisterIndicationsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasRegisterIndicationsInput {
        static $gtype: GObject.GType<MessageNasRegisterIndicationsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasRegisterIndicationsInput;

        // Methods

        /**
         * Get the 'Current PLMN Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_plmn_name(): [boolean, boolean];
        /**
         * Get the 'DDTM Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ddtm_events(): [boolean, boolean];
        /**
         * Get the 'Dual Standby Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_dual_standby_preference(): [boolean, boolean];
        /**
         * Get the 'eMBMS Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_embms_status(): [boolean, boolean];
        /**
         * Get the 'Error Rate' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_error_rate(): [boolean, boolean];
        /**
         * Get the 'HDR New UATI Assigned' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_new_uati_assigned(): [boolean, boolean];
        /**
         * Get the 'HDR Session Closed' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hdr_session_closed(): [boolean, boolean];
        /**
         * Get the 'Managed Roaming' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_managed_roaming(): [boolean, boolean];
        /**
         * Get the 'Network Reject Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_reject_information(): [boolean, boolean, boolean];
        /**
         * Get the 'Network Time' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_time(): [boolean, boolean];
        /**
         * Get the 'RF Band Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rf_band_information(): [boolean, boolean];
        /**
         * Get the 'Serving System Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_serving_system_events(): [boolean, boolean];
        /**
         * Get the 'Signal Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_signal_info(): [boolean, boolean];
        /**
         * Get the 'Subscription Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_subscription_info(): [boolean, boolean];
        /**
         * Get the 'System Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_system_info(): [boolean, boolean];
        /**
         * Get the 'System Selection Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_system_selection_preference(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasRegisterIndicationsInput;
        /**
         * Set the 'Current PLMN Name' field in the message.
         * @param value_current_plmn_name a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_current_plmn_name(value_current_plmn_name: boolean): boolean;
        /**
         * Set the 'DDTM Events' field in the message.
         * @param value_ddtm_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ddtm_events(value_ddtm_events: boolean): boolean;
        /**
         * Set the 'Dual Standby Preference' field in the message.
         * @param value_dual_standby_preference a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_dual_standby_preference(value_dual_standby_preference: boolean): boolean;
        /**
         * Set the 'eMBMS Status' field in the message.
         * @param value_embms_status a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_embms_status(value_embms_status: boolean): boolean;
        /**
         * Set the 'Error Rate' field in the message.
         * @param value_error_rate a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_error_rate(value_error_rate: boolean): boolean;
        /**
         * Set the 'HDR New UATI Assigned' field in the message.
         * @param value_hdr_new_uati_assigned a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_hdr_new_uati_assigned(value_hdr_new_uati_assigned: boolean): boolean;
        /**
         * Set the 'HDR Session Closed' field in the message.
         * @param value_hdr_session_closed a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_hdr_session_closed(value_hdr_session_closed: boolean): boolean;
        /**
         * Set the 'Managed Roaming' field in the message.
         * @param value_managed_roaming a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_managed_roaming(value_managed_roaming: boolean): boolean;
        /**
         * Set the 'Network Reject Information' field in the message.
         * @param value_network_reject_information_enable_network_reject_indications a #gboolean.
         * @param value_network_reject_information_supress_system_info_indications a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_network_reject_information(
            value_network_reject_information_enable_network_reject_indications: boolean,
            value_network_reject_information_supress_system_info_indications: boolean,
        ): boolean;
        /**
         * Set the 'Network Time' field in the message.
         * @param value_network_time a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_network_time(value_network_time: boolean): boolean;
        /**
         * Set the 'RF Band Information' field in the message.
         * @param value_rf_band_information a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_rf_band_information(value_rf_band_information: boolean): boolean;
        /**
         * Set the 'Serving System Events' field in the message.
         * @param value_serving_system_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_serving_system_events(value_serving_system_events: boolean): boolean;
        /**
         * Set the 'Signal Info' field in the message.
         * @param value_signal_info a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_signal_info(value_signal_info: boolean): boolean;
        /**
         * Set the 'Subscription Info' field in the message.
         * @param value_subscription_info a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_subscription_info(value_subscription_info: boolean): boolean;
        /**
         * Set the 'System Info' field in the message.
         * @param value_system_info a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_system_info(value_system_info: boolean): boolean;
        /**
         * Set the 'System Selection Preference' field in the message.
         * @param value_system_selection_preference a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_system_selection_preference(value_system_selection_preference: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasRegisterIndicationsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasRegisterIndicationsOutput {
        static $gtype: GObject.GType<MessageNasRegisterIndicationsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasRegisterIndicationsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasResetOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasResetOutput {
        static $gtype: GObject.GType<MessageNasResetOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasResetOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasSetEventReportInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasSetEventReportInput {
        static $gtype: GObject.GType<MessageNasSetEventReportInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasSetEventReportInput;

        // Methods

        /**
         * Get the 'ECIO Indicator' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ecio_indicator(): [boolean, boolean, number];
        /**
         * Get the 'ECIO Threshold' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ecio_threshold(): [boolean, boolean, number[] | null];
        /**
         * Get the 'Error Rate Indicator' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_error_rate_indicator(): [boolean, boolean];
        /**
         * Get the 'IO Indicator' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_io_indicator(): [boolean, boolean, number];
        /**
         * Get the 'LTE RSRP Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_rsrp_delta(): [boolean, boolean, number];
        /**
         * Get the 'LTE SNR Delta' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_snr_delta(): [boolean, boolean, number];
        /**
         * Get the 'Registration Reject Reason' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_registration_reject_reason(): [boolean, boolean];
        /**
         * Get the 'RF Band Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rf_band_information(): [boolean, boolean];
        /**
         * Get the 'RSSI Indicator' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rssi_indicator(): [boolean, boolean, number];
        /**
         * Get the 'Signal Strength Indicator' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_signal_strength_indicator(): [boolean, boolean, Uint8Array | null];
        /**
         * Get the 'SINR Indicator' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sinr_indicator(): [boolean, boolean, number];
        /**
         * Get the 'SINR Threshold' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sinr_threshold(): [boolean, boolean, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasSetEventReportInput;
        /**
         * Set the 'ECIO Indicator' field in the message.
         * @param value_ecio_indicator_report a #gboolean.
         * @param value_ecio_indicator_ecio_delta a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ecio_indicator(value_ecio_indicator_report: boolean, value_ecio_indicator_ecio_delta: number): boolean;
        /**
         * Set the 'ECIO Threshold' field in the message.
         * @param value_ecio_threshold_report a #gboolean.
         * @param value_ecio_threshold_thresholds a #GArray of #gint16 elements. A new reference to @value_ecio_threshold_thresholds will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ecio_threshold(value_ecio_threshold_report: boolean, value_ecio_threshold_thresholds: number[]): boolean;
        /**
         * Set the 'Error Rate Indicator' field in the message.
         * @param value_error_rate_indicator a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_error_rate_indicator(value_error_rate_indicator: boolean): boolean;
        /**
         * Set the 'IO Indicator' field in the message.
         * @param value_io_indicator_report a #gboolean.
         * @param value_io_indicator_io_delta a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_io_indicator(value_io_indicator_report: boolean, value_io_indicator_io_delta: number): boolean;
        /**
         * Set the 'LTE RSRP Delta' field in the message.
         * @param value_lte_rsrp_delta_report a #gboolean.
         * @param value_lte_rsrp_delta_rsrp_delta a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_rsrp_delta(value_lte_rsrp_delta_report: boolean, value_lte_rsrp_delta_rsrp_delta: number): boolean;
        /**
         * Set the 'LTE SNR Delta' field in the message.
         * @param value_lte_snr_delta_report a #gboolean.
         * @param value_lte_snr_delta_snr_delta a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_snr_delta(value_lte_snr_delta_report: boolean, value_lte_snr_delta_snr_delta: number): boolean;
        /**
         * Set the 'Registration Reject Reason' field in the message.
         * @param value_registration_reject_reason a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_registration_reject_reason(value_registration_reject_reason: boolean): boolean;
        /**
         * Set the 'RF Band Information' field in the message.
         * @param value_rf_band_information a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_rf_band_information(value_rf_band_information: boolean): boolean;
        /**
         * Set the 'RSSI Indicator' field in the message.
         * @param value_rssi_indicator_report a #gboolean.
         * @param value_rssi_indicator_rssi_delta a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_rssi_indicator(value_rssi_indicator_report: boolean, value_rssi_indicator_rssi_delta: number): boolean;
        /**
         * Set the 'Signal Strength Indicator' field in the message.
         * @param value_signal_strength_indicator_report a #gboolean.
         * @param value_signal_strength_indicator_thresholds a #GArray of #gint8 elements. A new reference to @value_signal_strength_indicator_thresholds will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_signal_strength_indicator(
            value_signal_strength_indicator_report: boolean,
            value_signal_strength_indicator_thresholds: Uint8Array | string,
        ): boolean;
        /**
         * Set the 'SINR Indicator' field in the message.
         * @param value_sinr_indicator_report a #gboolean.
         * @param value_sinr_indicator_sinr_delta a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_sinr_indicator(value_sinr_indicator_report: boolean, value_sinr_indicator_sinr_delta: number): boolean;
        /**
         * Set the 'SINR Threshold' field in the message.
         * @param value_sinr_threshold_report a #gboolean.
         * @param value_sinr_threshold_thresholds a #GArray of #guint8 elements. A new reference to @value_sinr_threshold_thresholds will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_sinr_threshold(
            value_sinr_threshold_report: boolean,
            value_sinr_threshold_thresholds: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasSetEventReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasSetEventReportOutput {
        static $gtype: GObject.GType<MessageNasSetEventReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasSetEventReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasSetPreferredNetworksInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasSetPreferredNetworksInput {
        static $gtype: GObject.GType<MessageNasSetPreferredNetworksInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasSetPreferredNetworksInput;

        // Methods

        /**
         * Get the 'Clear Previous Preferred Networks' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_clear_previous_preferred_networks(): [boolean, boolean];
        /**
         * Get the 'MNC PCS Digit Include Status' field from `self`.
         *
         * Version of qmi_message_nas_set_preferred_networks_input_get_mnc_pcs_digit_include_status() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mnc_pcs_digit_include_status(): [
            boolean,
            MessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement[] | null,
        ];
        /**
         * Get the 'Preferred Networks' field from `self`.
         *
         * Version of qmi_message_nas_set_preferred_networks_input_get_preferred_networks() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_preferred_networks(): [boolean, MessageNasSetPreferredNetworksInputPreferredNetworksElement[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasSetPreferredNetworksInput;
        /**
         * Set the 'Clear Previous Preferred Networks' field in the message.
         * @param value_clear_previous_preferred_networks a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_clear_previous_preferred_networks(value_clear_previous_preferred_networks: boolean): boolean;
        /**
         * Set the 'MNC PCS Digit Include Status' field in the message.
         * @param value_mnc_pcs_digit_include_status_ptr array of #QmiMessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mnc_pcs_digit_include_status(
            value_mnc_pcs_digit_include_status_ptr: MessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement[],
        ): boolean;
        /**
         * Set the 'Preferred Networks' field in the message.
         * @param value_preferred_networks_ptr array of #QmiMessageNasSetPreferredNetworksInputPreferredNetworksElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_preferred_networks(
            value_preferred_networks_ptr: MessageNasSetPreferredNetworksInputPreferredNetworksElement[],
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement struct.
     */
    class MessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement {
        static $gtype: GObject.GType<MessageNasSetPreferredNetworksInputMncPcsDigitIncludeStatusElement>;

        // Fields

        mcc: number;
        mnc: number;
        includes_pcs_digit: boolean;

        // Constructors

        constructor(
            properties?: Partial<{
                mcc: number;
                mnc: number;
                includes_pcs_digit: boolean;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageNasSetPreferredNetworksInputPreferredNetworksElement struct.
     */
    class MessageNasSetPreferredNetworksInputPreferredNetworksElement {
        static $gtype: GObject.GType<MessageNasSetPreferredNetworksInputPreferredNetworksElement>;

        // Fields

        mcc: number;
        mnc: number;
        radio_access_technology: NasPlmnAccessTechnologyIdentifier;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageNasSetPreferredNetworksOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasSetPreferredNetworksOutput {
        static $gtype: GObject.GType<MessageNasSetPreferredNetworksOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasSetPreferredNetworksOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasSetSystemSelectionPreferenceInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasSetSystemSelectionPreferenceInput {
        static $gtype: GObject.GType<MessageNasSetSystemSelectionPreferenceInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasSetSystemSelectionPreferenceInput;

        // Methods

        /**
         * Get the 'Acquisition Order Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_acquisition_order_preference(): [boolean, NasRadioInterface[] | null];
        /**
         * Get the 'Band Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_band_preference(): [boolean, NasBandPreference | null];
        /**
         * Get the 'CDMA PRL Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_prl_preference(): [boolean, NasCdmaPrlPreference | null];
        /**
         * Get the 'Change Duration' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_change_duration(): [boolean, NasChangeDuration | null];
        /**
         * Get the 'Emergency mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_emergency_mode(): [boolean, boolean];
        /**
         * Get the 'Extended LTE Band Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_lte_band_preference(): [boolean, number, number, number, number];
        /**
         * Get the 'GSM WCDMA Acquisition Order Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_wcdma_acquisition_order_preference(): [boolean, NasGsmWcdmaAcquisitionOrderPreference | null];
        /**
         * Get the 'LTE Band Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_band_preference(): [boolean, NasLteBandPreference | null];
        /**
         * Get the 'MNC PCS Digit Include Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mnc_pcs_digit_include_status(): [boolean, boolean];
        /**
         * Get the 'Mode Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mode_preference(): [boolean, NasRatModePreference | null];
        /**
         * Get the 'Network Selection Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_selection_preference(): [boolean, NasNetworkSelectionPreference | null, number, number];
        /**
         * Get the 'Network Selection Registration Restriction' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_selection_registration_restriction(): [boolean, NasNetworkSelectionRegistrationRestriction | null];
        /**
         * Get the 'NR5G NSA Band Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_nsa_band_preference(): [boolean, number, number, number, number, number, number, number, number];
        /**
         * Get the 'NR5G SA Band Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nr5g_sa_band_preference(): [boolean, number, number, number, number, number, number, number, number];
        /**
         * Get the 'Roaming Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roaming_preference(): [boolean, NasRoamingPreference | null];
        /**
         * Get the 'Service Domain Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_service_domain_preference(): [boolean, NasServiceDomainPreference | null];
        /**
         * Get the 'TD SCDMA Band Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_td_scdma_band_preference(): [boolean, NasTdScdmaBandPreference | null];
        /**
         * Get the 'Usage Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_usage_preference(): [boolean, NasUsagePreference | null];
        /**
         * Get the 'Voice Domain Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_voice_domain_preference(): [boolean, NasVoiceDomainPreference | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasSetSystemSelectionPreferenceInput;
        /**
         * Set the 'Acquisition Order Preference' field in the message.
         * @param value_acquisition_order_preference a #GArray of #QmiNasRadioInterface elements. A new reference to @value_acquisition_order_preference will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_acquisition_order_preference(value_acquisition_order_preference: NasRadioInterface[]): boolean;
        /**
         * Set the 'Band Preference' field in the message.
         * @param value_band_preference a #QmiNasBandPreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_band_preference(value_band_preference: NasBandPreference): boolean;
        /**
         * Set the 'CDMA PRL Preference' field in the message.
         * @param value_cdma_prl_preference a #QmiNasCdmaPrlPreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_cdma_prl_preference(value_cdma_prl_preference: NasCdmaPrlPreference): boolean;
        /**
         * Set the 'Change Duration' field in the message.
         * @param value_change_duration a #QmiNasChangeDuration.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_change_duration(value_change_duration: NasChangeDuration): boolean;
        /**
         * Set the 'Emergency mode' field in the message.
         * @param value_emergency_mode a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_emergency_mode(value_emergency_mode: boolean): boolean;
        /**
         * Set the 'Extended LTE Band Preference' field in the message.
         * @param value_extended_lte_band_preference_mask_low a #guint64.
         * @param value_extended_lte_band_preference_mask_mid_low a #guint64.
         * @param value_extended_lte_band_preference_mask_mid_high a #guint64.
         * @param value_extended_lte_band_preference_mask_high a #guint64.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_extended_lte_band_preference(
            value_extended_lte_band_preference_mask_low: number,
            value_extended_lte_band_preference_mask_mid_low: number,
            value_extended_lte_band_preference_mask_mid_high: number,
            value_extended_lte_band_preference_mask_high: number,
        ): boolean;
        /**
         * Set the 'GSM WCDMA Acquisition Order Preference' field in the message.
         * @param value_gsm_wcdma_acquisition_order_preference a #QmiNasGsmWcdmaAcquisitionOrderPreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_gsm_wcdma_acquisition_order_preference(
            value_gsm_wcdma_acquisition_order_preference: NasGsmWcdmaAcquisitionOrderPreference,
        ): boolean;
        /**
         * Set the 'LTE Band Preference' field in the message.
         * @param value_lte_band_preference a #QmiNasLteBandPreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_band_preference(value_lte_band_preference: NasLteBandPreference): boolean;
        /**
         * Set the 'MNC PCS Digit Include Status' field in the message.
         * @param value_mnc_pcs_digit_include_status a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mnc_pcs_digit_include_status(value_mnc_pcs_digit_include_status: boolean): boolean;
        /**
         * Set the 'Mode Preference' field in the message.
         * @param value_mode_preference a #QmiNasRatModePreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mode_preference(value_mode_preference: NasRatModePreference): boolean;
        /**
         * Set the 'Network Selection Preference' field in the message.
         * @param value_network_selection_preference_mode a #QmiNasNetworkSelectionPreference.
         * @param value_network_selection_preference_mcc a #guint16.
         * @param value_network_selection_preference_mnc a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_network_selection_preference(
            value_network_selection_preference_mode: NasNetworkSelectionPreference,
            value_network_selection_preference_mcc: number,
            value_network_selection_preference_mnc: number,
        ): boolean;
        /**
         * Set the 'Network Selection Registration Restriction' field in the message.
         * @param value_network_selection_registration_restriction a #QmiNasNetworkSelectionRegistrationRestriction.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_network_selection_registration_restriction(
            value_network_selection_registration_restriction: NasNetworkSelectionRegistrationRestriction,
        ): boolean;
        /**
         * Set the 'NR5G NSA Band Preference' field in the message.
         * @param value_nr5g_nsa_band_preference_mask_0 a #guint64.
         * @param value_nr5g_nsa_band_preference_mask_1 a #guint64.
         * @param value_nr5g_nsa_band_preference_mask_2 a #guint64.
         * @param value_nr5g_nsa_band_preference_mask_3 a #guint64.
         * @param value_nr5g_nsa_band_preference_mask_4 a #guint64.
         * @param value_nr5g_nsa_band_preference_mask_5 a #guint64.
         * @param value_nr5g_nsa_band_preference_mask_6 a #guint64.
         * @param value_nr5g_nsa_band_preference_mask_7 a #guint64.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nr5g_nsa_band_preference(
            value_nr5g_nsa_band_preference_mask_0: number,
            value_nr5g_nsa_band_preference_mask_1: number,
            value_nr5g_nsa_band_preference_mask_2: number,
            value_nr5g_nsa_band_preference_mask_3: number,
            value_nr5g_nsa_band_preference_mask_4: number,
            value_nr5g_nsa_band_preference_mask_5: number,
            value_nr5g_nsa_band_preference_mask_6: number,
            value_nr5g_nsa_band_preference_mask_7: number,
        ): boolean;
        /**
         * Set the 'NR5G SA Band Preference' field in the message.
         * @param value_nr5g_sa_band_preference_mask_0 a #guint64.
         * @param value_nr5g_sa_band_preference_mask_1 a #guint64.
         * @param value_nr5g_sa_band_preference_mask_2 a #guint64.
         * @param value_nr5g_sa_band_preference_mask_3 a #guint64.
         * @param value_nr5g_sa_band_preference_mask_4 a #guint64.
         * @param value_nr5g_sa_band_preference_mask_5 a #guint64.
         * @param value_nr5g_sa_band_preference_mask_6 a #guint64.
         * @param value_nr5g_sa_band_preference_mask_7 a #guint64.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nr5g_sa_band_preference(
            value_nr5g_sa_band_preference_mask_0: number,
            value_nr5g_sa_band_preference_mask_1: number,
            value_nr5g_sa_band_preference_mask_2: number,
            value_nr5g_sa_band_preference_mask_3: number,
            value_nr5g_sa_band_preference_mask_4: number,
            value_nr5g_sa_band_preference_mask_5: number,
            value_nr5g_sa_band_preference_mask_6: number,
            value_nr5g_sa_band_preference_mask_7: number,
        ): boolean;
        /**
         * Set the 'Roaming Preference' field in the message.
         * @param value_roaming_preference a #QmiNasRoamingPreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_roaming_preference(value_roaming_preference: NasRoamingPreference): boolean;
        /**
         * Set the 'Service Domain Preference' field in the message.
         * @param value_service_domain_preference a #QmiNasServiceDomainPreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_service_domain_preference(value_service_domain_preference: NasServiceDomainPreference): boolean;
        /**
         * Set the 'TD SCDMA Band Preference' field in the message.
         * @param value_td_scdma_band_preference a #QmiNasTdScdmaBandPreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_td_scdma_band_preference(value_td_scdma_band_preference: NasTdScdmaBandPreference): boolean;
        /**
         * Set the 'Usage Preference' field in the message.
         * @param value_usage_preference a #QmiNasUsagePreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_usage_preference(value_usage_preference: NasUsagePreference): boolean;
        /**
         * Set the 'Voice Domain Preference' field in the message.
         * @param value_voice_domain_preference a #QmiNasVoiceDomainPreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_voice_domain_preference(value_voice_domain_preference: NasVoiceDomainPreference): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasSetSystemSelectionPreferenceOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasSetSystemSelectionPreferenceOutput {
        static $gtype: GObject.GType<MessageNasSetSystemSelectionPreferenceOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasSetSystemSelectionPreferenceOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasSetTechnologyPreferenceInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageNasSetTechnologyPreferenceInput {
        static $gtype: GObject.GType<MessageNasSetTechnologyPreferenceInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageNasSetTechnologyPreferenceInput;

        // Methods

        /**
         * Get the 'Current' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current(): [boolean, NasRadioTechnologyPreference | null, NasPreferenceDuration | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasSetTechnologyPreferenceInput;
        /**
         * Set the 'Current' field in the message.
         * @param value_current_technology_preference a #QmiNasRadioTechnologyPreference.
         * @param value_current_technology_preference_duration a #QmiNasPreferenceDuration.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_current(
            value_current_technology_preference: NasRadioTechnologyPreference,
            value_current_technology_preference_duration: NasPreferenceDuration,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasSetTechnologyPreferenceOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasSetTechnologyPreferenceOutput {
        static $gtype: GObject.GType<MessageNasSetTechnologyPreferenceOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasSetTechnologyPreferenceOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageNasSwiGetStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageNasSwiGetStatusOutput {
        static $gtype: GObject.GType<MessageNasSwiGetStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Common Info v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_common_info_v2(): [
            boolean,
            number,
            NasSwiModemMode | null,
            NasSwiSystemMode | null,
            NasSwiImsRegState | null,
            NasSwiPsState | null,
        ];
        /**
         * Get the 'LTE Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_info(): [
            boolean,
            NasActiveBand | null,
            NasDLBandwidth | null,
            number,
            number,
            NasSwiEmmState | null,
            number,
            NasSwiEmmConnectionState | null,
        ];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageNasSwiGetStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageOmaCancelSessionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageOmaCancelSessionOutput {
        static $gtype: GObject.GType<MessageOmaCancelSessionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageOmaCancelSessionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageOmaGetFeatureSettingOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageOmaGetFeatureSettingOutput {
        static $gtype: GObject.GType<MessageOmaGetFeatureSettingOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Device Provisioning Service Update Config' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_device_provisioning_service_update_config(): [boolean, boolean];
        /**
         * Get the 'HFA Feature Config' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hfa_feature_config(): [boolean, boolean];
        /**
         * Get the 'HFA Feature Done State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hfa_feature_done_state(): [boolean, OmaHfaFeatureDoneState | null];
        /**
         * Get the 'PRL Update Service Config' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_prl_update_service_config(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageOmaGetFeatureSettingOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageOmaGetSessionInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageOmaGetSessionInfoOutput {
        static $gtype: GObject.GType<MessageOmaGetSessionInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Network Initiated Alert' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_initiated_alert(): [boolean, OmaSessionType | null, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Retry Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_retry_info(): [boolean, number, number, number];
        /**
         * Get the 'Session Failed Reason' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session_failed_reason(): [boolean, OmaSessionFailedReason | null];
        /**
         * Get the 'Session Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session_info(): [boolean, OmaSessionState | null, OmaSessionType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageOmaGetSessionInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageOmaResetOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageOmaResetOutput {
        static $gtype: GObject.GType<MessageOmaResetOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageOmaResetOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageOmaSendSelectionInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageOmaSendSelectionInput {
        static $gtype: GObject.GType<MessageOmaSendSelectionInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageOmaSendSelectionInput;

        // Methods

        /**
         * Get the 'Network Initiated Alert Selection' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_initiated_alert_selection(): [boolean, boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageOmaSendSelectionInput;
        /**
         * Set the 'Network Initiated Alert Selection' field in the message.
         * @param value_network_initiated_alert_selection_control_point_selection_accept a #gboolean.
         * @param value_network_initiated_alert_selection_session_id a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_network_initiated_alert_selection(
            value_network_initiated_alert_selection_control_point_selection_accept: boolean,
            value_network_initiated_alert_selection_session_id: number,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageOmaSendSelectionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageOmaSendSelectionOutput {
        static $gtype: GObject.GType<MessageOmaSendSelectionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageOmaSendSelectionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageOmaSetEventReportInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageOmaSetEventReportInput {
        static $gtype: GObject.GType<MessageOmaSetEventReportInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageOmaSetEventReportInput;

        // Methods

        /**
         * Get the 'Network Initiated Alert Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_initiated_alert_reporting(): [boolean, boolean];
        /**
         * Get the 'Session State Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session_state_reporting(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageOmaSetEventReportInput;
        /**
         * Set the 'Network Initiated Alert Reporting' field in the message.
         * @param value_network_initiated_alert_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_network_initiated_alert_reporting(value_network_initiated_alert_reporting: boolean): boolean;
        /**
         * Set the 'Session State Reporting' field in the message.
         * @param value_session_state_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session_state_reporting(value_session_state_reporting: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageOmaSetEventReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageOmaSetEventReportOutput {
        static $gtype: GObject.GType<MessageOmaSetEventReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageOmaSetEventReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageOmaSetFeatureSettingInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageOmaSetFeatureSettingInput {
        static $gtype: GObject.GType<MessageOmaSetFeatureSettingInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageOmaSetFeatureSettingInput;

        // Methods

        /**
         * Get the 'Device Provisioning Service Update Config' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_device_provisioning_service_update_config(): [boolean, boolean];
        /**
         * Get the 'HFA Feature Config' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hfa_feature_config(): [boolean, boolean];
        /**
         * Get the 'PRL Update Service Config' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_prl_update_service_config(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageOmaSetFeatureSettingInput;
        /**
         * Set the 'Device Provisioning Service Update Config' field in the message.
         * @param value_device_provisioning_service_update_config a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_device_provisioning_service_update_config(
            value_device_provisioning_service_update_config: boolean,
        ): boolean;
        /**
         * Set the 'HFA Feature Config' field in the message.
         * @param value_hfa_feature_config a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_hfa_feature_config(value_hfa_feature_config: boolean): boolean;
        /**
         * Set the 'PRL Update Service Config' field in the message.
         * @param value_prl_update_service_config a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_prl_update_service_config(value_prl_update_service_config: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageOmaSetFeatureSettingOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageOmaSetFeatureSettingOutput {
        static $gtype: GObject.GType<MessageOmaSetFeatureSettingOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageOmaSetFeatureSettingOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageOmaStartSessionInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageOmaStartSessionInput {
        static $gtype: GObject.GType<MessageOmaStartSessionInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageOmaStartSessionInput;

        // Methods

        /**
         * Get the 'Session Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session_type(): [boolean, OmaSessionType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageOmaStartSessionInput;
        /**
         * Set the 'Session Type' field in the message.
         * @param value_session_type a #QmiOmaSessionType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session_type(value_session_type: OmaSessionType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageOmaStartSessionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageOmaStartSessionOutput {
        static $gtype: GObject.GType<MessageOmaStartSessionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageOmaStartSessionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePbmGetAllCapabilitiesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePbmGetAllCapabilitiesOutput {
        static $gtype: GObject.GType<MessagePbmGetAllCapabilitiesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Additional Number Alpha String Capability' field from `self`.
         *
         * Version of qmi_message_pbm_get_all_capabilities_output_get_additional_number_alpha_string_capability() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_number_alpha_string_capability(): [
            boolean,
            MessagePbmGetAllCapabilitiesOutputAdditionalNumberAlphaStringCapabilityElement[] | null,
        ];
        /**
         * Get the 'Additional Number Capability' field from `self`.
         *
         * Version of qmi_message_pbm_get_all_capabilities_output_get_additional_number_capability() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_number_capability(): [
            boolean,
            MessagePbmGetAllCapabilitiesOutputAdditionalNumberCapabilityElement[] | null,
        ];
        /**
         * Get the 'Capability Basic Information' field from `self`.
         *
         * Version of qmi_message_pbm_get_all_capabilities_output_get_capability_basic_information() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_capability_basic_information(): [
            boolean,
            MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementGir[] | null,
        ];
        /**
         * Get the 'Email Capability' field from `self`.
         *
         * Version of qmi_message_pbm_get_all_capabilities_output_get_email_capability() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_email_capability(): [boolean, MessagePbmGetAllCapabilitiesOutputEmailCapabilityElement[] | null];
        /**
         * Get the 'Group Capability' field from `self`.
         *
         * Version of qmi_message_pbm_get_all_capabilities_output_get_group_capability() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_group_capability(): [boolean, MessagePbmGetAllCapabilitiesOutputGroupCapabilityElement[] | null];
        /**
         * Get the 'Grouping Information Alpha String Capability' field from `self`.
         *
         * Version of qmi_message_pbm_get_all_capabilities_output_get_grouping_information_alpha_string_capability() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_grouping_information_alpha_string_capability(): [
            boolean,
            MessagePbmGetAllCapabilitiesOutputGroupingInformationAlphaStringCapabilityElement[] | null,
        ];
        /**
         * Get the 'Hidden Records Capability' field from `self`.
         *
         * Version of qmi_message_pbm_get_all_capabilities_output_get_hidden_records_capability() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hidden_records_capability(): [
            boolean,
            MessagePbmGetAllCapabilitiesOutputHiddenRecordsCapabilityElement[] | null,
        ];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Second Name Capability' field from `self`.
         *
         * Version of qmi_message_pbm_get_all_capabilities_output_get_second_name_capability() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_second_name_capability(): [boolean, MessagePbmGetAllCapabilitiesOutputSecondNameCapabilityElement[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePbmGetAllCapabilitiesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessagePbmGetAllCapabilitiesOutputAdditionalNumberAlphaStringCapabilityElement struct.
     */
    class MessagePbmGetAllCapabilitiesOutputAdditionalNumberAlphaStringCapabilityElement {
        static $gtype: GObject.GType<MessagePbmGetAllCapabilitiesOutputAdditionalNumberAlphaStringCapabilityElement>;

        // Fields

        session_type: PbmSessionType;
        maximum_records: number;
        used_records: number;
        maximum_string_length: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessagePbmGetAllCapabilitiesOutputAdditionalNumberCapabilityElement struct.
     */
    class MessagePbmGetAllCapabilitiesOutputAdditionalNumberCapabilityElement {
        static $gtype: GObject.GType<MessagePbmGetAllCapabilitiesOutputAdditionalNumberCapabilityElement>;

        // Fields

        session_type: PbmSessionType;
        maximum_additional_numbers: number;
        maximum_additional_number_length: number;
        maximum_additional_number_tag_length: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementGir struct.
     *
     * This type is a version of #QmiMessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElement, using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    class MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementGir {
        static $gtype: GObject.GType<MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementGir>;

        // Fields

        session_type: PbmSessionType;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementPhonebooksElement struct.
     */
    class MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementPhonebooksElement {
        static $gtype: GObject.GType<MessagePbmGetAllCapabilitiesOutputCapabilityBasicInformationElementPhonebooksElement>;

        // Fields

        phonebook_type: PbmPhonebookType;
        used_records: number;
        maximum_records: number;
        maximum_number_length: number;
        maximum_name_length: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessagePbmGetAllCapabilitiesOutputEmailCapabilityElement struct.
     */
    class MessagePbmGetAllCapabilitiesOutputEmailCapabilityElement {
        static $gtype: GObject.GType<MessagePbmGetAllCapabilitiesOutputEmailCapabilityElement>;

        // Fields

        session_type: PbmSessionType;
        maximum_emails: number;
        maximum_email_address_length: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessagePbmGetAllCapabilitiesOutputGroupCapabilityElement struct.
     */
    class MessagePbmGetAllCapabilitiesOutputGroupCapabilityElement {
        static $gtype: GObject.GType<MessagePbmGetAllCapabilitiesOutputGroupCapabilityElement>;

        // Fields

        session_type: PbmSessionType;
        maximum_groups: number;
        maximum_group_tag_length: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessagePbmGetAllCapabilitiesOutputGroupingInformationAlphaStringCapabilityElement struct.
     */
    class MessagePbmGetAllCapabilitiesOutputGroupingInformationAlphaStringCapabilityElement {
        static $gtype: GObject.GType<MessagePbmGetAllCapabilitiesOutputGroupingInformationAlphaStringCapabilityElement>;

        // Fields

        session_type: PbmSessionType;
        maximum_records: number;
        used_records: number;
        maximum_string_length: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessagePbmGetAllCapabilitiesOutputHiddenRecordsCapabilityElement struct.
     */
    class MessagePbmGetAllCapabilitiesOutputHiddenRecordsCapabilityElement {
        static $gtype: GObject.GType<MessagePbmGetAllCapabilitiesOutputHiddenRecordsCapabilityElement>;

        // Fields

        session_type: PbmSessionType;
        supported: boolean;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessagePbmGetAllCapabilitiesOutputSecondNameCapabilityElement struct.
     */
    class MessagePbmGetAllCapabilitiesOutputSecondNameCapabilityElement {
        static $gtype: GObject.GType<MessagePbmGetAllCapabilitiesOutputSecondNameCapabilityElement>;

        // Fields

        session_type: PbmSessionType;
        maximum_second_name_length: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessagePbmGetCapabilitiesInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePbmGetCapabilitiesInput {
        static $gtype: GObject.GType<MessagePbmGetCapabilitiesInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePbmGetCapabilitiesInput;

        // Methods

        /**
         * Get the 'Phonebook Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_phonebook_information(): [boolean, PbmSessionType | null, PbmPhonebookType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePbmGetCapabilitiesInput;
        /**
         * Set the 'Phonebook Information' field in the message.
         * @param value_phonebook_information_session_type a #QmiPbmSessionType.
         * @param value_phonebook_information_phonebook_type a #QmiPbmPhonebookType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_phonebook_information(
            value_phonebook_information_session_type: PbmSessionType,
            value_phonebook_information_phonebook_type: PbmPhonebookType,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePbmGetCapabilitiesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePbmGetCapabilitiesOutput {
        static $gtype: GObject.GType<MessagePbmGetCapabilitiesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Additional Number Alpha String Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_number_alpha_string_capability(): [boolean, number, number, number];
        /**
         * Get the 'Additional Number Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_number_capability(): [boolean, number, number, number];
        /**
         * Get the 'Capability Basic Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_capability_basic_information(): [
            boolean,
            PbmSessionType | null,
            PbmPhonebookType | null,
            number,
            number,
            number,
            number,
        ];
        /**
         * Get the 'Email Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_email_capability(): [boolean, number, number];
        /**
         * Get the 'Group Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_group_capability(): [boolean, number, number];
        /**
         * Get the 'Grouping Information Alpha String Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_grouping_information_alpha_string_capability(): [boolean, number, number, number];
        /**
         * Get the 'Hidden Records Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_hidden_records_capability(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Second Name Capability' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_second_name_capability(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePbmGetCapabilitiesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePbmIndicationRegisterInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePbmIndicationRegisterInput {
        static $gtype: GObject.GType<MessagePbmIndicationRegisterInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePbmIndicationRegisterInput;

        // Methods

        /**
         * Get the 'Event Registration Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_event_registration_mask(): [boolean, PbmEventRegistrationFlag | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePbmIndicationRegisterInput;
        /**
         * Set the 'Event Registration Mask' field in the message.
         * @param value_event_registration_mask a #QmiPbmEventRegistrationFlag.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_event_registration_mask(value_event_registration_mask: PbmEventRegistrationFlag): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePbmIndicationRegisterOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePbmIndicationRegisterOutput {
        static $gtype: GObject.GType<MessagePbmIndicationRegisterOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Event Registration Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_event_registration_mask(): [boolean, PbmEventRegistrationFlag | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePbmIndicationRegisterOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcActivateConfigInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdcActivateConfigInput {
        static $gtype: GObject.GType<MessagePdcActivateConfigInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdcActivateConfigInput;

        // Methods

        /**
         * Get the 'Config Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_config_type(): [boolean, PdcConfigurationType | null];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcActivateConfigInput;
        /**
         * Set the 'Config Type' field in the message.
         * @param value_config_type a #QmiPdcConfigurationType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_config_type(value_config_type: PdcConfigurationType): boolean;
        /**
         * Set the 'Token' field in the message.
         * @param value_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_token(value_token: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcActivateConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcActivateConfigOutput {
        static $gtype: GObject.GType<MessagePdcActivateConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcActivateConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcConfigChangeInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdcConfigChangeInput {
        static $gtype: GObject.GType<MessagePdcConfigChangeInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdcConfigChangeInput;

        // Methods

        /**
         * Get the 'Type With Id v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_type_with_id_v2(): [boolean, PdcConfigurationType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcConfigChangeInput;
        /**
         * Set the 'Type With Id v2' field in the message.
         * @param value_type_with_id_v2_config_type a #QmiPdcConfigurationType.
         * @param value_type_with_id_v2_id a #GArray of #guint8 elements. A new reference to @value_type_with_id_v2_id will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_type_with_id_v2(
            value_type_with_id_v2_config_type: PdcConfigurationType,
            value_type_with_id_v2_id: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcConfigChangeOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcConfigChangeOutput {
        static $gtype: GObject.GType<MessagePdcConfigChangeOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Type With Id v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_type_with_id_v2(): [boolean, PdcConfigurationType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcConfigChangeOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcDeactivateConfigInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdcDeactivateConfigInput {
        static $gtype: GObject.GType<MessagePdcDeactivateConfigInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdcDeactivateConfigInput;

        // Methods

        /**
         * Get the 'Config Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_config_type(): [boolean, PdcConfigurationType | null];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcDeactivateConfigInput;
        /**
         * Set the 'Config Type' field in the message.
         * @param value_config_type a #QmiPdcConfigurationType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_config_type(value_config_type: PdcConfigurationType): boolean;
        /**
         * Set the 'Token' field in the message.
         * @param value_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_token(value_token: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcDeactivateConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcDeactivateConfigOutput {
        static $gtype: GObject.GType<MessagePdcDeactivateConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcDeactivateConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcDeleteConfigInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdcDeleteConfigInput {
        static $gtype: GObject.GType<MessagePdcDeleteConfigInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdcDeleteConfigInput;

        // Methods

        /**
         * Get the 'Config Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_config_type(): [boolean, PdcConfigurationType | null];
        /**
         * Get the 'Id' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_id(): [boolean, Uint8Array | null];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcDeleteConfigInput;
        /**
         * Set the 'Config Type' field in the message.
         * @param value_config_type a #QmiPdcConfigurationType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_config_type(value_config_type: PdcConfigurationType): boolean;
        /**
         * Set the 'Id' field in the message.
         * @param value_id a #GArray of #guint8 elements. A new reference to @value_id will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_id(value_id: Uint8Array | string): boolean;
        /**
         * Set the 'Token' field in the message.
         * @param value_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_token(value_token: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcDeleteConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcDeleteConfigOutput {
        static $gtype: GObject.GType<MessagePdcDeleteConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcDeleteConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcGetConfigInfoInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdcGetConfigInfoInput {
        static $gtype: GObject.GType<MessagePdcGetConfigInfoInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdcGetConfigInfoInput;

        // Methods

        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Get the 'Type With Id v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_type_with_id_v2(): [boolean, PdcConfigurationType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcGetConfigInfoInput;
        /**
         * Set the 'Token' field in the message.
         * @param value_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_token(value_token: number): boolean;
        /**
         * Set the 'Type With Id v2' field in the message.
         * @param value_type_with_id_v2_config_type a #QmiPdcConfigurationType.
         * @param value_type_with_id_v2_id a #GArray of #guint8 elements. A new reference to @value_type_with_id_v2_id will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_type_with_id_v2(
            value_type_with_id_v2_config_type: PdcConfigurationType,
            value_type_with_id_v2_id: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcGetConfigInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcGetConfigInfoOutput {
        static $gtype: GObject.GType<MessagePdcGetConfigInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcGetConfigInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcGetConfigLimitsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdcGetConfigLimitsInput {
        static $gtype: GObject.GType<MessagePdcGetConfigLimitsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdcGetConfigLimitsInput;

        // Methods

        /**
         * Get the 'Config Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_config_type(): [boolean, PdcConfigurationType | null];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcGetConfigLimitsInput;
        /**
         * Set the 'Config Type' field in the message.
         * @param value_config_type a #QmiPdcConfigurationType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_config_type(value_config_type: PdcConfigurationType): boolean;
        /**
         * Set the 'Token' field in the message.
         * @param value_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_token(value_token: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcGetConfigLimitsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcGetConfigLimitsOutput {
        static $gtype: GObject.GType<MessagePdcGetConfigLimitsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Current Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_size(): [boolean, number];
        /**
         * Get the 'Maximum Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_maximum_size(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcGetConfigLimitsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcGetDefaultConfigInfoInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdcGetDefaultConfigInfoInput {
        static $gtype: GObject.GType<MessagePdcGetDefaultConfigInfoInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdcGetDefaultConfigInfoInput;

        // Methods

        /**
         * Get the 'Config Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_config_type(): [boolean, PdcConfigurationType | null];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcGetDefaultConfigInfoInput;
        /**
         * Set the 'Config Type' field in the message.
         * @param value_config_type a #QmiPdcConfigurationType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_config_type(value_config_type: PdcConfigurationType): boolean;
        /**
         * Set the 'Token' field in the message.
         * @param value_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_token(value_token: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcGetDefaultConfigInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcGetDefaultConfigInfoOutput {
        static $gtype: GObject.GType<MessagePdcGetDefaultConfigInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Description' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_description(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Get the 'Total Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_total_size(): [boolean, number];
        /**
         * Get the 'Version' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_version(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcGetDefaultConfigInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcGetSelectedConfigInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdcGetSelectedConfigInput {
        static $gtype: GObject.GType<MessagePdcGetSelectedConfigInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdcGetSelectedConfigInput;

        // Methods

        /**
         * Get the 'Config Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_config_type(): [boolean, PdcConfigurationType | null];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcGetSelectedConfigInput;
        /**
         * Set the 'Config Type' field in the message.
         * @param value_config_type a #QmiPdcConfigurationType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_config_type(value_config_type: PdcConfigurationType): boolean;
        /**
         * Set the 'Token' field in the message.
         * @param value_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_token(value_token: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcGetSelectedConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcGetSelectedConfigOutput {
        static $gtype: GObject.GType<MessagePdcGetSelectedConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcGetSelectedConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcListConfigsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdcListConfigsInput {
        static $gtype: GObject.GType<MessagePdcListConfigsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdcListConfigsInput;

        // Methods

        /**
         * Get the 'Config Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_config_type(): [boolean, PdcConfigurationType | null];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcListConfigsInput;
        /**
         * Set the 'Config Type' field in the message.
         * @param value_config_type a #QmiPdcConfigurationType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_config_type(value_config_type: PdcConfigurationType): boolean;
        /**
         * Set the 'Token' field in the message.
         * @param value_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_token(value_token: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcListConfigsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcListConfigsOutput {
        static $gtype: GObject.GType<MessagePdcListConfigsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcListConfigsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcLoadConfigInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdcLoadConfigInput {
        static $gtype: GObject.GType<MessagePdcLoadConfigInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdcLoadConfigInput;

        // Methods

        /**
         * Get the 'Config Chunk' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_config_chunk(): [boolean, PdcConfigurationType | null, Uint8Array | null, number, Uint8Array | null];
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcLoadConfigInput;
        /**
         * Set the 'Config Chunk' field in the message.
         * @param value_config_chunk_type a #QmiPdcConfigurationType.
         * @param value_config_chunk_id a #GArray of #guint8 elements. A new reference to @value_config_chunk_id will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @param value_config_chunk_total_size a #guint32.
         * @param value_config_chunk_chunk a #GArray of #guint8 elements. A new reference to @value_config_chunk_chunk will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_config_chunk(
            value_config_chunk_type: PdcConfigurationType,
            value_config_chunk_id: Uint8Array | string,
            value_config_chunk_total_size: number,
            value_config_chunk_chunk: Uint8Array | string,
        ): boolean;
        /**
         * Set the 'Token' field in the message.
         * @param value_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_token(value_token: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcLoadConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcLoadConfigOutput {
        static $gtype: GObject.GType<MessagePdcLoadConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcLoadConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcRegisterInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdcRegisterInput {
        static $gtype: GObject.GType<MessagePdcRegisterInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdcRegisterInput;

        // Methods

        /**
         * Get the 'Enable Refresh' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_enable_refresh(): [boolean, boolean];
        /**
         * Get the 'Enable Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_enable_reporting(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcRegisterInput;
        /**
         * Set the 'Enable Refresh' field in the message.
         * @param value_enable_refresh a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_enable_refresh(value_enable_refresh: boolean): boolean;
        /**
         * Set the 'Enable Reporting' field in the message.
         * @param value_enable_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_enable_reporting(value_enable_reporting: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcRegisterOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcRegisterOutput {
        static $gtype: GObject.GType<MessagePdcRegisterOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcRegisterOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcResetOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcResetOutput {
        static $gtype: GObject.GType<MessagePdcResetOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcResetOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcSetSelectedConfigInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdcSetSelectedConfigInput {
        static $gtype: GObject.GType<MessagePdcSetSelectedConfigInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdcSetSelectedConfigInput;

        // Methods

        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Get the 'Type With Id v2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_type_with_id_v2(): [boolean, PdcConfigurationType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcSetSelectedConfigInput;
        /**
         * Set the 'Token' field in the message.
         * @param value_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_token(value_token: number): boolean;
        /**
         * Set the 'Type With Id v2' field in the message.
         * @param value_type_with_id_v2_config_type a #QmiPdcConfigurationType.
         * @param value_type_with_id_v2_id a #GArray of #guint8 elements. A new reference to @value_type_with_id_v2_id will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_type_with_id_v2(
            value_type_with_id_v2_config_type: PdcConfigurationType,
            value_type_with_id_v2_id: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdcSetSelectedConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdcSetSelectedConfigOutput {
        static $gtype: GObject.GType<MessagePdcSetSelectedConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_token(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdcSetSelectedConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsGetAgpsConfigInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdsGetAgpsConfigInput {
        static $gtype: GObject.GType<MessagePdsGetAgpsConfigInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdsGetAgpsConfigInput;

        // Methods

        /**
         * Get the 'Network Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_mode(): [boolean, PdsNetworkMode | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsGetAgpsConfigInput;
        /**
         * Set the 'Network Mode' field in the message.
         * @param value_network_mode a #QmiPdsNetworkMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_network_mode(value_network_mode: PdsNetworkMode): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsGetAgpsConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdsGetAgpsConfigOutput {
        static $gtype: GObject.GType<MessagePdsGetAgpsConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Location Server Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_location_server_address(): [boolean, number, number];
        /**
         * Get the 'Location Server URL' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_location_server_url(): [boolean, Uint8Array | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsGetAgpsConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsGetAutoTrackingStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdsGetAutoTrackingStateOutput {
        static $gtype: GObject.GType<MessagePdsGetAutoTrackingStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_state(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsGetAutoTrackingStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsGetDefaultTrackingSessionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdsGetDefaultTrackingSessionOutput {
        static $gtype: GObject.GType<MessagePdsGetDefaultTrackingSessionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, PdsOperatingMode | null, number, number, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsGetDefaultTrackingSessionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsGetGpsServiceStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdsGetGpsServiceStateOutput {
        static $gtype: GObject.GType<MessagePdsGetGpsServiceStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_state(): [boolean, boolean, PdsTrackingSessionState | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsGetGpsServiceStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsResetOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdsResetOutput {
        static $gtype: GObject.GType<MessagePdsResetOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsResetOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsSetAgpsConfigInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdsSetAgpsConfigInput {
        static $gtype: GObject.GType<MessagePdsSetAgpsConfigInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdsSetAgpsConfigInput;

        // Methods

        /**
         * Get the 'Location Server Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_location_server_address(): [boolean, number, number];
        /**
         * Get the 'Location Server URL' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_location_server_url(): [boolean, Uint8Array | null];
        /**
         * Get the 'Network Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_mode(): [boolean, PdsNetworkMode | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsSetAgpsConfigInput;
        /**
         * Set the 'Location Server Address' field in the message.
         * @param value_location_server_address_ip a #guint32.
         * @param value_location_server_address_port a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_location_server_address(
            value_location_server_address_ip: number,
            value_location_server_address_port: number,
        ): boolean;
        /**
         * Set the 'Location Server URL' field in the message.
         * @param value_location_server_url a #GArray of #guint8 elements. A new reference to @value_location_server_url will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_location_server_url(value_location_server_url: Uint8Array | string): boolean;
        /**
         * Set the 'Network Mode' field in the message.
         * @param value_network_mode a #QmiPdsNetworkMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_network_mode(value_network_mode: PdsNetworkMode): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsSetAgpsConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdsSetAgpsConfigOutput {
        static $gtype: GObject.GType<MessagePdsSetAgpsConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsSetAgpsConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsSetAutoTrackingStateInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdsSetAutoTrackingStateInput {
        static $gtype: GObject.GType<MessagePdsSetAutoTrackingStateInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdsSetAutoTrackingStateInput;

        // Methods

        /**
         * Get the 'State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_state(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsSetAutoTrackingStateInput;
        /**
         * Set the 'State' field in the message.
         * @param value_state_auto_tracking_state a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_state(value_state_auto_tracking_state: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsSetAutoTrackingStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdsSetAutoTrackingStateOutput {
        static $gtype: GObject.GType<MessagePdsSetAutoTrackingStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsSetAutoTrackingStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsSetDefaultTrackingSessionInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdsSetDefaultTrackingSessionInput {
        static $gtype: GObject.GType<MessagePdsSetDefaultTrackingSessionInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdsSetDefaultTrackingSessionInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, PdsOperatingMode | null, number, number, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsSetDefaultTrackingSessionInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_session_operation a #QmiPdsOperatingMode.
         * @param value_info_position_data_timeout a #guint8.
         * @param value_info_interval a #guint32.
         * @param value_info_accuracy_threshold a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(
            value_info_session_operation: PdsOperatingMode,
            value_info_position_data_timeout: number,
            value_info_interval: number,
            value_info_accuracy_threshold: number,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsSetDefaultTrackingSessionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdsSetDefaultTrackingSessionOutput {
        static $gtype: GObject.GType<MessagePdsSetDefaultTrackingSessionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsSetDefaultTrackingSessionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsSetEventReportInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdsSetEventReportInput {
        static $gtype: GObject.GType<MessagePdsSetEventReportInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdsSetEventReportInput;

        // Methods

        /**
         * Get the 'Accelerometer Data Streaming Ready Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_accelerometer_data_streaming_ready_reporting(): [boolean, boolean];
        /**
         * Get the 'Extended External XTRA Data Request Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_external_xtra_data_request_reporting(): [boolean, boolean];
        /**
         * Get the 'Extended NMEA Position Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_nmea_position_reporting(): [boolean, boolean];
        /**
         * Get the 'External Time Injection Request Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_external_time_injection_request_reporting(): [boolean, boolean];
        /**
         * Get the 'External WIFI Position Request Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_external_wifi_position_request_reporting(): [boolean, boolean];
        /**
         * Get the 'External XTRA Data Request Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_external_xtra_data_request_reporting(): [boolean, boolean];
        /**
         * Get the 'Gyro Data Streaming Ready Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gyro_data_streaming_ready_reporting(): [boolean, boolean];
        /**
         * Get the 'Heading Uncertainty Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_heading_uncertainty_reporting(): [boolean, boolean];
        /**
         * Get the 'NMEA Debug Strings Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nmea_debug_strings_reporting(): [boolean, boolean];
        /**
         * Get the 'NMEA Position Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nmea_position_reporting(): [boolean, boolean];
        /**
         * Get the 'Parsed Position Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_parsed_position_reporting(): [boolean, boolean];
        /**
         * Get the 'PDS Comm Event Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pds_comm_event_reporting(): [boolean, boolean];
        /**
         * Get the 'Position Reliability Indicator Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_position_reliability_indicator_reporting(): [boolean, boolean];
        /**
         * Get the 'Satellite Information Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_satellite_information_reporting(): [boolean, boolean];
        /**
         * Get the 'Sensor Data Usage Indicator Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sensor_data_usage_indicator_reporting(): [boolean, boolean];
        /**
         * Get the 'SUPL Network Initiated Prompt Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_supl_network_initiated_prompt_reporting(): [boolean, boolean];
        /**
         * Get the 'Time Source Information Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_time_source_information_reporting(): [boolean, boolean];
        /**
         * Get the 'Time Sync Request Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_time_sync_request_reporting(): [boolean, boolean];
        /**
         * Get the 'UMTS CP Network Initiated Prompt Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_cp_network_initiated_prompt_reporting(): [boolean, boolean];
        /**
         * Get the 'VX Network Initiated Request Reporting' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_vx_network_initiated_request_reporting(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsSetEventReportInput;
        /**
         * Set the 'Accelerometer Data Streaming Ready Reporting' field in the message.
         * @param value_accelerometer_data_streaming_ready_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_accelerometer_data_streaming_ready_reporting(
            value_accelerometer_data_streaming_ready_reporting: boolean,
        ): boolean;
        /**
         * Set the 'Extended External XTRA Data Request Reporting' field in the message.
         * @param value_extended_external_xtra_data_request_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_extended_external_xtra_data_request_reporting(
            value_extended_external_xtra_data_request_reporting: boolean,
        ): boolean;
        /**
         * Set the 'Extended NMEA Position Reporting' field in the message.
         * @param value_extended_nmea_position_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_extended_nmea_position_reporting(value_extended_nmea_position_reporting: boolean): boolean;
        /**
         * Set the 'External Time Injection Request Reporting' field in the message.
         * @param value_external_time_injection_request_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_external_time_injection_request_reporting(
            value_external_time_injection_request_reporting: boolean,
        ): boolean;
        /**
         * Set the 'External WIFI Position Request Reporting' field in the message.
         * @param value_external_wifi_position_request_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_external_wifi_position_request_reporting(value_external_wifi_position_request_reporting: boolean): boolean;
        /**
         * Set the 'External XTRA Data Request Reporting' field in the message.
         * @param value_external_xtra_data_request_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_external_xtra_data_request_reporting(value_external_xtra_data_request_reporting: boolean): boolean;
        /**
         * Set the 'Gyro Data Streaming Ready Reporting' field in the message.
         * @param value_gyro_data_streaming_ready_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_gyro_data_streaming_ready_reporting(value_gyro_data_streaming_ready_reporting: boolean): boolean;
        /**
         * Set the 'Heading Uncertainty Reporting' field in the message.
         * @param value_heading_uncertainty_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_heading_uncertainty_reporting(value_heading_uncertainty_reporting: boolean): boolean;
        /**
         * Set the 'NMEA Debug Strings Reporting' field in the message.
         * @param value_nmea_debug_strings_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nmea_debug_strings_reporting(value_nmea_debug_strings_reporting: boolean): boolean;
        /**
         * Set the 'NMEA Position Reporting' field in the message.
         * @param value_nmea_position_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nmea_position_reporting(value_nmea_position_reporting: boolean): boolean;
        /**
         * Set the 'Parsed Position Reporting' field in the message.
         * @param value_parsed_position_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_parsed_position_reporting(value_parsed_position_reporting: boolean): boolean;
        /**
         * Set the 'PDS Comm Event Reporting' field in the message.
         * @param value_pds_comm_event_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pds_comm_event_reporting(value_pds_comm_event_reporting: boolean): boolean;
        /**
         * Set the 'Position Reliability Indicator Reporting' field in the message.
         * @param value_position_reliability_indicator_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_position_reliability_indicator_reporting(value_position_reliability_indicator_reporting: boolean): boolean;
        /**
         * Set the 'Satellite Information Reporting' field in the message.
         * @param value_satellite_information_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_satellite_information_reporting(value_satellite_information_reporting: boolean): boolean;
        /**
         * Set the 'Sensor Data Usage Indicator Reporting' field in the message.
         * @param value_sensor_data_usage_indicator_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_sensor_data_usage_indicator_reporting(value_sensor_data_usage_indicator_reporting: boolean): boolean;
        /**
         * Set the 'SUPL Network Initiated Prompt Reporting' field in the message.
         * @param value_supl_network_initiated_prompt_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_supl_network_initiated_prompt_reporting(value_supl_network_initiated_prompt_reporting: boolean): boolean;
        /**
         * Set the 'Time Source Information Reporting' field in the message.
         * @param value_time_source_information_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_time_source_information_reporting(value_time_source_information_reporting: boolean): boolean;
        /**
         * Set the 'Time Sync Request Reporting' field in the message.
         * @param value_time_sync_request_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_time_sync_request_reporting(value_time_sync_request_reporting: boolean): boolean;
        /**
         * Set the 'UMTS CP Network Initiated Prompt Reporting' field in the message.
         * @param value_umts_cp_network_initiated_prompt_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_umts_cp_network_initiated_prompt_reporting(
            value_umts_cp_network_initiated_prompt_reporting: boolean,
        ): boolean;
        /**
         * Set the 'VX Network Initiated Request Reporting' field in the message.
         * @param value_vx_network_initiated_request_reporting a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_vx_network_initiated_request_reporting(value_vx_network_initiated_request_reporting: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsSetEventReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdsSetEventReportOutput {
        static $gtype: GObject.GType<MessagePdsSetEventReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsSetEventReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsSetGpsServiceStateInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessagePdsSetGpsServiceStateInput {
        static $gtype: GObject.GType<MessagePdsSetGpsServiceStateInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessagePdsSetGpsServiceStateInput;

        // Methods

        /**
         * Get the 'State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_state(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsSetGpsServiceStateInput;
        /**
         * Set the 'State' field in the message.
         * @param value_state_gps_service_state a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_state(value_state_gps_service_state: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessagePdsSetGpsServiceStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessagePdsSetGpsServiceStateOutput {
        static $gtype: GObject.GType<MessagePdsSetGpsServiceStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessagePdsSetGpsServiceStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageQosGetFlowStatusInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageQosGetFlowStatusInput {
        static $gtype: GObject.GType<MessageQosGetFlowStatusInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageQosGetFlowStatusInput;

        // Methods

        /**
         * Get the 'Qos Id' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_qos_id(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageQosGetFlowStatusInput;
        /**
         * Set the 'Qos Id' field in the message.
         * @param value_qos_id a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_qos_id(value_qos_id: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageQosGetFlowStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageQosGetFlowStatusOutput {
        static $gtype: GObject.GType<MessageQosGetFlowStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Value' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_value(): [boolean, QosStatus | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageQosGetFlowStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageQosGetNetworkStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageQosGetNetworkStatusOutput {
        static $gtype: GObject.GType<MessageQosGetNetworkStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'QoS Supported' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_qos_supported(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageQosGetNetworkStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageQosResetOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageQosResetOutput {
        static $gtype: GObject.GType<MessageQosResetOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageQosResetOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageQosSwiReadDataStatsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageQosSwiReadDataStatsInput {
        static $gtype: GObject.GType<MessageQosSwiReadDataStatsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageQosSwiReadDataStatsInput;

        // Methods

        /**
         * Get the 'Apn Id' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_id(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageQosSwiReadDataStatsInput;
        /**
         * Set the 'Apn Id' field in the message.
         * @param value_apn_id a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn_id(value_apn_id: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageQosSwiReadDataStatsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageQosSwiReadDataStatsOutput {
        static $gtype: GObject.GType<MessageQosSwiReadDataStatsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Apn' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn(): [boolean, number, number, number, number, number, number, number];
        /**
         * Get the 'Flow' field from `self`.
         *
         * Version of qmi_message_qos_swi_read_data_stats_output_get_flow() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_flow(): [boolean, MessageQosSwiReadDataStatsOutputFlowElement[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageQosSwiReadDataStatsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageQosSwiReadDataStatsOutputFlowElement struct.
     */
    class MessageQosSwiReadDataStatsOutputFlowElement {
        static $gtype: GObject.GType<MessageQosSwiReadDataStatsOutputFlowElement>;

        // Fields

        bearer_id: number;
        tx_packets: number;
        tx_packets_dropped: number;
        tx_bytes: number;
        tx_bytes_dropped: number;

        // Constructors

        constructor(
            properties?: Partial<{
                bearer_id: number;
                tx_packets: number;
                tx_packets_dropped: number;
                tx_bytes: number;
                tx_bytes_dropped: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageSarRfGetStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageSarRfGetStateOutput {
        static $gtype: GObject.GType<MessageSarRfGetStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_state(): [boolean, SarRfState | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageSarRfGetStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageSarRfSetStateInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageSarRfSetStateInput {
        static $gtype: GObject.GType<MessageSarRfSetStateInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageSarRfSetStateInput;

        // Methods

        /**
         * Get the 'State' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_state(): [boolean, SarRfState | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageSarRfSetStateInput;
        /**
         * Set the 'State' field in the message.
         * @param value_state a #QmiSarRfState.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_state(value_state: SarRfState): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageSarRfSetStateOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageSarRfSetStateOutput {
        static $gtype: GObject.GType<MessageSarRfSetStateOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageSarRfSetStateOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageSscControlInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageSscControlInput {
        static $gtype: GObject.GType<MessageSscControlInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageSscControlInput;

        // Methods

        /**
         * Get the 'Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data(): [boolean, Uint8Array | null];
        /**
         * Get the 'Report Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_report_type(): [boolean, SscReportType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageSscControlInput;
        /**
         * Set the 'Data' field in the message.
         * @param value_data a #GArray of #guint8 elements. A new reference to @value_data will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_data(value_data: Uint8Array | string): boolean;
        /**
         * Set the 'Report Type' field in the message.
         * @param value_report_type a #QmiSscReportType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_report_type(value_report_type: SscReportType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageSscControlOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageSscControlOutput {
        static $gtype: GObject.GType<MessageSscControlOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Client ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_client_id(): [boolean, number];
        /**
         * Get the 'Response' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageSscControlOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimChangePinInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimChangePinInput {
        static $gtype: GObject.GType<MessageUimChangePinInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimChangePinInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, UimPinId | null, string, string];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the 'Session' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session(): [boolean, UimSessionType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimChangePinInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_pin_id a #QmiUimPinId.
         * @param value_info_old_pin a constant string.
         * @param value_info_new_pin a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(value_info_pin_id: UimPinId, value_info_old_pin: string, value_info_new_pin: string): boolean;
        /**
         * Set the 'Response In Indication Token' field in the message.
         * @param value_response_in_indication_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_response_in_indication_token(value_response_in_indication_token: number): boolean;
        /**
         * Set the 'Session' field in the message.
         * @param value_session_session_type a #QmiUimSessionType.
         * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to @value_session_application_identifier will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session(
            value_session_session_type: UimSessionType,
            value_session_application_identifier: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimChangePinOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimChangePinOutput {
        static $gtype: GObject.GType<MessageUimChangePinOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Card Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_card_result(): [boolean, number, number];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Retries Remaining' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_retries_remaining(): [boolean, number, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimChangePinOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimChangeProvisioningSessionInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimChangeProvisioningSessionInput {
        static $gtype: GObject.GType<MessageUimChangeProvisioningSessionInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimChangeProvisioningSessionInput;

        // Methods

        /**
         * Get the 'Application Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_application_information(): [boolean, number, Uint8Array | null];
        /**
         * Get the 'Session Change' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session_change(): [boolean, UimSessionType | null, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimChangeProvisioningSessionInput;
        /**
         * Set the 'Application Information' field in the message.
         * @param value_application_information_slot a #guint8.
         * @param value_application_information_application_identifier a #GArray of #guint8 elements. A new reference to @value_application_information_application_identifier will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_application_information(
            value_application_information_slot: number,
            value_application_information_application_identifier: Uint8Array | string,
        ): boolean;
        /**
         * Set the 'Session Change' field in the message.
         * @param value_session_change_session_type a #QmiUimSessionType.
         * @param value_session_change_activate a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session_change(
            value_session_change_session_type: UimSessionType,
            value_session_change_activate: boolean,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimChangeProvisioningSessionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimChangeProvisioningSessionOutput {
        static $gtype: GObject.GType<MessageUimChangeProvisioningSessionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimChangeProvisioningSessionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimDepersonalizationInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimDepersonalizationInput {
        static $gtype: GObject.GType<MessageUimDepersonalizationInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimDepersonalizationInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [
            boolean,
            UimCardApplicationPersonalizationFeature | null,
            UimDepersonalizationOperation | null,
            string,
        ];
        /**
         * Get the 'Slot' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_slot(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimDepersonalizationInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_feature a #QmiUimCardApplicationPersonalizationFeature.
         * @param value_info_operation a #QmiUimDepersonalizationOperation.
         * @param value_info_control_key a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(
            value_info_feature: UimCardApplicationPersonalizationFeature,
            value_info_operation: UimDepersonalizationOperation,
            value_info_control_key: string,
        ): boolean;
        /**
         * Set the 'Slot' field in the message.
         * @param value_slot a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_slot(value_slot: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimDepersonalizationOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimDepersonalizationOutput {
        static $gtype: GObject.GType<MessageUimDepersonalizationOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Retries Remaining' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_retries_remaining(): [boolean, number, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimDepersonalizationOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimGetCardStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimGetCardStatusOutput {
        static $gtype: GObject.GType<MessageUimGetCardStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Card Status' field from `self`.
         *
         * Version of qmi_message_uim_get_card_status_output_get_card_status() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_card_status(): [
            boolean,
            number,
            number,
            number,
            number,
            MessageUimGetCardStatusOutputCardStatusCardsElementGir[] | null,
        ];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimGetCardStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageUimGetCardStatusOutputCardStatusCardsElementApplicationsElementV2 struct.
     */
    class MessageUimGetCardStatusOutputCardStatusCardsElementApplicationsElementV2 {
        static $gtype: GObject.GType<MessageUimGetCardStatusOutputCardStatusCardsElementApplicationsElementV2>;

        // Fields

        type: UimCardApplicationType;
        state: UimCardApplicationState;
        personalization_state: UimCardApplicationPersonalizationState;
        personalization_feature: UimCardApplicationPersonalizationFeatureStatus;
        personalization_retries: number;
        personalization_unblock_retries: number;
        application_identifier_value: any[];
        upin_replaces_pin1: boolean;
        pin1_state: UimPinState;
        pin1_retries: number;
        puk1_retries: number;
        pin2_state: UimPinState;
        pin2_retries: number;
        puk2_retries: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageUimGetCardStatusOutputCardStatusCardsElementGir struct.
     *
     * This type is a version of #QmiMessageUimGetCardStatusOutputCardStatusCardsElement, using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    class MessageUimGetCardStatusOutputCardStatusCardsElementGir {
        static $gtype: GObject.GType<MessageUimGetCardStatusOutputCardStatusCardsElementGir>;

        // Fields

        card_state: UimCardState;
        upin_state: UimPinState;
        upin_retries: number;
        upuk_retries: number;
        error_code: UimCardError;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageUimGetConfigurationInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimGetConfigurationInput {
        static $gtype: GObject.GType<MessageUimGetConfigurationInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimGetConfigurationInput;

        // Methods

        /**
         * Get the 'Configuration Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_configuration_mask(): [boolean, UimConfiguration | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimGetConfigurationInput;
        /**
         * Set the 'Configuration Mask' field in the message.
         * @param value_configuration_mask a #QmiUimConfiguration.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_configuration_mask(value_configuration_mask: UimConfiguration): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimGetConfigurationOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimGetConfigurationOutput {
        static $gtype: GObject.GType<MessageUimGetConfigurationOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Automatic Selection' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_automatic_selection(): [boolean, boolean];
        get_compat_context(): any | null;
        /**
         * Get the 'Halt Subscription' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_halt_subscription(): [boolean, boolean];
        /**
         * Get the 'Personalization Status' field from `self`.
         *
         * Version of qmi_message_uim_get_configuration_output_get_personalization_status() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_personalization_status(): [boolean, MessageUimGetConfigurationOutputPersonalizationStatusElement[] | null];
        /**
         * Get the 'Personalization Status Other' field from `self`.
         *
         * Version of qmi_message_uim_get_configuration_output_get_personalization_status_other() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_personalization_status_other(): [
            boolean,
            MessageUimGetConfigurationOutputPersonalizationStatusOtherElementGir[] | null,
        ];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimGetConfigurationOutput;
        set_compat_context(compat_context?: any | null): void;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageUimGetConfigurationOutputPersonalizationStatusElement struct.
     */
    class MessageUimGetConfigurationOutputPersonalizationStatusElement {
        static $gtype: GObject.GType<MessageUimGetConfigurationOutputPersonalizationStatusElement>;

        // Fields

        feature: UimCardApplicationPersonalizationFeature;
        verify_left: number;
        unblock_left: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageUimGetConfigurationOutputPersonalizationStatusOtherElementGir struct.
     *
     * This type is a version of #QmiMessageUimGetConfigurationOutputPersonalizationStatusOtherElement, using arrays of pointers to
     * structs instead of arrays of structs, for easier binding in other languages.
     */
    class MessageUimGetConfigurationOutputPersonalizationStatusOtherElementGir {
        static $gtype: GObject.GType<MessageUimGetConfigurationOutputPersonalizationStatusOtherElementGir>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageUimGetConfigurationOutputPersonalizationStatusOtherElementSlotElement struct.
     */
    class MessageUimGetConfigurationOutputPersonalizationStatusOtherElementSlotElement {
        static $gtype: GObject.GType<MessageUimGetConfigurationOutputPersonalizationStatusOtherElementSlotElement>;

        // Fields

        feature: UimCardApplicationPersonalizationFeature;
        verify_left: number;
        unblock_left: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageUimGetFileAttributesInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimGetFileAttributesInput {
        static $gtype: GObject.GType<MessageUimGetFileAttributesInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimGetFileAttributesInput;

        // Methods

        /**
         * Get the 'File' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_file(): [boolean, number, Uint8Array | null];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the 'Session' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session(): [boolean, UimSessionType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimGetFileAttributesInput;
        /**
         * Set the 'File' field in the message.
         * @param value_file_file_id a #guint16.
         * @param value_file_file_path a #GArray of #guint8 elements. A new reference to @value_file_file_path will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_file(value_file_file_id: number, value_file_file_path: Uint8Array | string): boolean;
        /**
         * Set the 'Response In Indication Token' field in the message.
         * @param value_response_in_indication_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_response_in_indication_token(value_response_in_indication_token: number): boolean;
        /**
         * Set the 'Session' field in the message.
         * @param value_session_session_type a #QmiUimSessionType.
         * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to @value_session_application_identifier will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session(
            value_session_session_type: UimSessionType,
            value_session_application_identifier: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimGetFileAttributesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimGetFileAttributesOutput {
        static $gtype: GObject.GType<MessageUimGetFileAttributesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Card result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_card_result(): [boolean, number, number];
        /**
         * Get the 'File Attributes' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_file_attributes(): [
            boolean,
            number,
            number,
            UimFileType | null,
            number,
            number,
            UimSecurityAttributeLogic | null,
            UimSecurityAttribute | null,
            UimSecurityAttributeLogic | null,
            UimSecurityAttribute | null,
            UimSecurityAttributeLogic | null,
            UimSecurityAttribute | null,
            UimSecurityAttributeLogic | null,
            UimSecurityAttribute | null,
            UimSecurityAttributeLogic | null,
            UimSecurityAttribute | null,
            Uint8Array | null,
        ];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimGetFileAttributesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimGetSlotStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimGetSlotStatusOutput {
        static $gtype: GObject.GType<MessageUimGetSlotStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        get_compat_context(): any | null;
        /**
         * Get the 'Physical Slot Information' field from `self`.
         *
         * Version of qmi_message_uim_get_slot_status_output_get_physical_slot_information() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_physical_slot_information(): [boolean, PhysicalSlotInformationSlot[] | null];
        /**
         * Get the 'Physical Slot Status' field from `self`.
         *
         * Version of qmi_message_uim_get_slot_status_output_get_physical_slot_status() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_physical_slot_status(): [boolean, PhysicalSlotStatusSlot[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Slot EID' field from `self`.
         *
         * Version of qmi_message_uim_get_slot_status_output_get_slot_eid() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_slot_eid(): [boolean, SlotEidElement[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimGetSlotStatusOutput;
        set_compat_context(compat_context?: any | null): void;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimGetSupportedMessagesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimGetSupportedMessagesOutput {
        static $gtype: GObject.GType<MessageUimGetSupportedMessagesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, Uint8Array | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimGetSupportedMessagesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimPowerOffSimInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimPowerOffSimInput {
        static $gtype: GObject.GType<MessageUimPowerOffSimInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimPowerOffSimInput;

        // Methods

        /**
         * Get the 'Slot' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_slot(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimPowerOffSimInput;
        /**
         * Set the 'Slot' field in the message.
         * @param value_slot a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_slot(value_slot: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimPowerOffSimOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimPowerOffSimOutput {
        static $gtype: GObject.GType<MessageUimPowerOffSimOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimPowerOffSimOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimPowerOnSimInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimPowerOnSimInput {
        static $gtype: GObject.GType<MessageUimPowerOnSimInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimPowerOnSimInput;

        // Methods

        /**
         * Get the 'Slot' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_slot(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimPowerOnSimInput;
        /**
         * Set the 'Slot' field in the message.
         * @param value_slot a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_slot(value_slot: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimPowerOnSimOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimPowerOnSimOutput {
        static $gtype: GObject.GType<MessageUimPowerOnSimOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimPowerOnSimOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimReadRecordInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimReadRecordInput {
        static $gtype: GObject.GType<MessageUimReadRecordInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimReadRecordInput;

        // Methods

        /**
         * Get the 'File' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_file(): [boolean, number, Uint8Array | null];
        /**
         * Get the 'Last Record' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_last_record(): [boolean, number];
        /**
         * Get the 'Record' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_record(): [boolean, number, number];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the 'Session' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session(): [boolean, UimSessionType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimReadRecordInput;
        /**
         * Set the 'File' field in the message.
         * @param value_file_file_id a #guint16.
         * @param value_file_file_path a #GArray of #guint8 elements. A new reference to @value_file_file_path will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_file(value_file_file_id: number, value_file_file_path: Uint8Array | string): boolean;
        /**
         * Set the 'Last Record' field in the message.
         * @param value_last_record a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_last_record(value_last_record: number): boolean;
        /**
         * Set the 'Record' field in the message.
         * @param value_record_record_number a #guint16.
         * @param value_record_record_length a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_record(value_record_record_number: number, value_record_record_length: number): boolean;
        /**
         * Set the 'Response In Indication Token' field in the message.
         * @param value_response_in_indication_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_response_in_indication_token(value_response_in_indication_token: number): boolean;
        /**
         * Set the 'Session' field in the message.
         * @param value_session_session_type a #QmiUimSessionType.
         * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to @value_session_application_identifier will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session(
            value_session_session_type: UimSessionType,
            value_session_application_identifier: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimReadRecordOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimReadRecordOutput {
        static $gtype: GObject.GType<MessageUimReadRecordOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Additional Read Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_additional_read_result(): [boolean, Uint8Array | null];
        /**
         * Get the 'Card result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_card_result(): [boolean, number, number];
        /**
         * Get the 'Read Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_read_result(): [boolean, Uint8Array | null];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimReadRecordOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimReadTransparentInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimReadTransparentInput {
        static $gtype: GObject.GType<MessageUimReadTransparentInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimReadTransparentInput;

        // Methods

        /**
         * Get the 'Encrypt Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_encrypt_data(): [boolean, boolean];
        /**
         * Get the 'File' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_file(): [boolean, number, Uint8Array | null];
        /**
         * Get the 'Read Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_read_information(): [boolean, number, number];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the 'Session' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session(): [boolean, UimSessionType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimReadTransparentInput;
        /**
         * Set the 'Encrypt Data' field in the message.
         * @param value_encrypt_data a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_encrypt_data(value_encrypt_data: boolean): boolean;
        /**
         * Set the 'File' field in the message.
         * @param value_file_file_id a #guint16.
         * @param value_file_file_path a #GArray of #guint8 elements. A new reference to @value_file_file_path will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_file(value_file_file_id: number, value_file_file_path: Uint8Array | string): boolean;
        /**
         * Set the 'Read Information' field in the message.
         * @param value_read_information_offset a #guint16.
         * @param value_read_information_length a #guint16.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_read_information(value_read_information_offset: number, value_read_information_length: number): boolean;
        /**
         * Set the 'Response In Indication Token' field in the message.
         * @param value_response_in_indication_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_response_in_indication_token(value_response_in_indication_token: number): boolean;
        /**
         * Set the 'Session' field in the message.
         * @param value_session_session_type a #QmiUimSessionType.
         * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to @value_session_application_identifier will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session(
            value_session_session_type: UimSessionType,
            value_session_application_identifier: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimReadTransparentOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimReadTransparentOutput {
        static $gtype: GObject.GType<MessageUimReadTransparentOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Card result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_card_result(): [boolean, number, number];
        /**
         * Get the 'Encrypted Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_encrypted_data(): [boolean, boolean];
        /**
         * Get the 'Read result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_read_result(): [boolean, Uint8Array | null];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimReadTransparentOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimRefreshCompleteInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimRefreshCompleteInput {
        static $gtype: GObject.GType<MessageUimRefreshCompleteInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimRefreshCompleteInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, boolean];
        /**
         * Get the 'Session' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session(): [boolean, UimSessionType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimRefreshCompleteInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_refresh_success a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(value_info_refresh_success: boolean): boolean;
        /**
         * Set the 'Session' field in the message.
         * @param value_session_session_type a #QmiUimSessionType.
         * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to @value_session_application_identifier will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session(
            value_session_session_type: UimSessionType,
            value_session_application_identifier: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimRefreshCompleteOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimRefreshCompleteOutput {
        static $gtype: GObject.GType<MessageUimRefreshCompleteOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimRefreshCompleteOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimRefreshRegisterAllInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimRefreshRegisterAllInput {
        static $gtype: GObject.GType<MessageUimRefreshRegisterAllInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimRefreshRegisterAllInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, boolean];
        /**
         * Get the 'Session' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session(): [boolean, UimSessionType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimRefreshRegisterAllInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_register_flag a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(value_info_register_flag: boolean): boolean;
        /**
         * Set the 'Session' field in the message.
         * @param value_session_session_type a #QmiUimSessionType.
         * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to @value_session_application_identifier will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session(
            value_session_session_type: UimSessionType,
            value_session_application_identifier: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimRefreshRegisterAllOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimRefreshRegisterAllOutput {
        static $gtype: GObject.GType<MessageUimRefreshRegisterAllOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimRefreshRegisterAllOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimRefreshRegisterInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimRefreshRegisterInput {
        static $gtype: GObject.GType<MessageUimRefreshRegisterInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimRefreshRegisterInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         *
         * Version of qmi_message_uim_refresh_register_input_get_info() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, boolean, boolean, MessageUimRefreshRegisterInputInfoFilesElement[] | null];
        /**
         * Get the 'Session' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session(): [boolean, UimSessionType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimRefreshRegisterInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_register_flag a #gboolean.
         * @param value_info_vote_for_init a #gboolean.
         * @param value_info_files_ptr array of #QmiMessageUimRefreshRegisterInputInfoFilesElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(
            value_info_register_flag: boolean,
            value_info_vote_for_init: boolean,
            value_info_files_ptr: MessageUimRefreshRegisterInputInfoFilesElement[],
        ): boolean;
        /**
         * Set the 'Session' field in the message.
         * @param value_session_session_type a #QmiUimSessionType.
         * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to @value_session_application_identifier will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session(
            value_session_session_type: UimSessionType,
            value_session_application_identifier: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageUimRefreshRegisterInputInfoFilesElement struct.
     */
    class MessageUimRefreshRegisterInputInfoFilesElement {
        static $gtype: GObject.GType<MessageUimRefreshRegisterInputInfoFilesElement>;

        // Fields

        file_id: number;
        path: any[];

        // Constructors

        constructor(
            properties?: Partial<{
                file_id: number;
                path: any[];
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageUimRefreshRegisterOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimRefreshRegisterOutput {
        static $gtype: GObject.GType<MessageUimRefreshRegisterOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimRefreshRegisterOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimRegisterEventsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimRegisterEventsInput {
        static $gtype: GObject.GType<MessageUimRegisterEventsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimRegisterEventsInput;

        // Methods

        /**
         * Get the 'Event Registration Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_event_registration_mask(): [boolean, UimEventRegistrationFlag | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimRegisterEventsInput;
        /**
         * Set the 'Event Registration Mask' field in the message.
         * @param value_event_registration_mask a #QmiUimEventRegistrationFlag.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_event_registration_mask(value_event_registration_mask: UimEventRegistrationFlag): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimRegisterEventsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimRegisterEventsOutput {
        static $gtype: GObject.GType<MessageUimRegisterEventsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Event Registration Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_event_registration_mask(): [boolean, UimEventRegistrationFlag | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimRegisterEventsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimRemoteUnlockInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimRemoteUnlockInput {
        static $gtype: GObject.GType<MessageUimRemoteUnlockInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimRemoteUnlockInput;

        // Methods

        /**
         * Get the 'SimLock Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_simlock_data(): [boolean, Uint8Array | null];
        /**
         * Get the 'SimLock Extended Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_simlock_extended_data(): [boolean, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimRemoteUnlockInput;
        /**
         * Set the 'SimLock Data' field in the message.
         * @param value_simlock_data a #GArray of #guint8 elements. A new reference to @value_simlock_data will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_simlock_data(value_simlock_data: Uint8Array | string): boolean;
        /**
         * Set the 'SimLock Extended Data' field in the message.
         * @param value_simlock_extended_data a #GArray of #guint8 elements. A new reference to @value_simlock_extended_data will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_simlock_extended_data(value_simlock_extended_data: Uint8Array | string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimRemoteUnlockOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimRemoteUnlockOutput {
        static $gtype: GObject.GType<MessageUimRemoteUnlockOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimRemoteUnlockOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimResetOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimResetOutput {
        static $gtype: GObject.GType<MessageUimResetOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimResetOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimSetPinProtectionInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimSetPinProtectionInput {
        static $gtype: GObject.GType<MessageUimSetPinProtectionInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimSetPinProtectionInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, UimPinId | null, boolean, string];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the 'Session' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session(): [boolean, UimSessionType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimSetPinProtectionInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_pin_id a #QmiUimPinId.
         * @param value_info_pin_enabled a #gboolean.
         * @param value_info_pin_value a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(value_info_pin_id: UimPinId, value_info_pin_enabled: boolean, value_info_pin_value: string): boolean;
        /**
         * Set the 'Response In Indication Token' field in the message.
         * @param value_response_in_indication_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_response_in_indication_token(value_response_in_indication_token: number): boolean;
        /**
         * Set the 'Session' field in the message.
         * @param value_session_session_type a #QmiUimSessionType.
         * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to @value_session_application_identifier will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session(
            value_session_session_type: UimSessionType,
            value_session_application_identifier: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimSetPinProtectionOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimSetPinProtectionOutput {
        static $gtype: GObject.GType<MessageUimSetPinProtectionOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Retries Remaining' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_retries_remaining(): [boolean, number, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimSetPinProtectionOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimSwitchSlotInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimSwitchSlotInput {
        static $gtype: GObject.GType<MessageUimSwitchSlotInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimSwitchSlotInput;

        // Methods

        /**
         * Get the 'Logical Slot' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_logical_slot(): [boolean, number];
        /**
         * Get the 'Physical Slot' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_physical_slot(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimSwitchSlotInput;
        /**
         * Set the 'Logical Slot' field in the message.
         * @param value_logical_slot a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_logical_slot(value_logical_slot: number): boolean;
        /**
         * Set the 'Physical Slot' field in the message.
         * @param value_physical_slot a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_physical_slot(value_physical_slot: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimSwitchSlotOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimSwitchSlotOutput {
        static $gtype: GObject.GType<MessageUimSwitchSlotOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimSwitchSlotOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimUnblockPinInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimUnblockPinInput {
        static $gtype: GObject.GType<MessageUimUnblockPinInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimUnblockPinInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, UimPinId | null, string, string];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the 'Session' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session(): [boolean, UimSessionType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimUnblockPinInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_pin_id a #QmiUimPinId.
         * @param value_info_puk a constant string.
         * @param value_info_new_pin a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(value_info_pin_id: UimPinId, value_info_puk: string, value_info_new_pin: string): boolean;
        /**
         * Set the 'Response In Indication Token' field in the message.
         * @param value_response_in_indication_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_response_in_indication_token(value_response_in_indication_token: number): boolean;
        /**
         * Set the 'Session' field in the message.
         * @param value_session_session_type a #QmiUimSessionType.
         * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to @value_session_application_identifier will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session(
            value_session_session_type: UimSessionType,
            value_session_application_identifier: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimUnblockPinOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimUnblockPinOutput {
        static $gtype: GObject.GType<MessageUimUnblockPinOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Card Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_card_result(): [boolean, number, number];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Retries Remaining' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_retries_remaining(): [boolean, number, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimUnblockPinOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimVerifyPinInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageUimVerifyPinInput {
        static $gtype: GObject.GType<MessageUimVerifyPinInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageUimVerifyPinInput;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, UimPinId | null, string];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the 'Session' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_session(): [boolean, UimSessionType | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimVerifyPinInput;
        /**
         * Set the 'Info' field in the message.
         * @param value_info_pin_id a #QmiUimPinId.
         * @param value_info_pin_value a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_info(value_info_pin_id: UimPinId, value_info_pin_value: string): boolean;
        /**
         * Set the 'Response In Indication Token' field in the message.
         * @param value_response_in_indication_token a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_response_in_indication_token(value_response_in_indication_token: number): boolean;
        /**
         * Set the 'Session' field in the message.
         * @param value_session_session_type a #QmiUimSessionType.
         * @param value_session_application_identifier a #GArray of #guint8 elements. A new reference to @value_session_application_identifier will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_session(
            value_session_session_type: UimSessionType,
            value_session_application_identifier: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageUimVerifyPinOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageUimVerifyPinOutput {
        static $gtype: GObject.GType<MessageUimVerifyPinOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Card Result' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_card_result(): [boolean, number, number];
        /**
         * Get the 'Response In Indication Token' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_response_in_indication_token(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Retries Remaining' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_retries_remaining(): [boolean, number, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageUimVerifyPinOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceAnswerCallInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceAnswerCallInput {
        static $gtype: GObject.GType<MessageVoiceAnswerCallInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceAnswerCallInput;

        // Methods

        /**
         * Get the 'Call ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_id(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceAnswerCallInput;
        /**
         * Set the 'Call ID' field in the message.
         * @param value_call_id a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_call_id(value_call_id: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceAnswerCallOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceAnswerCallOutput {
        static $gtype: GObject.GType<MessageVoiceAnswerCallOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Call ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_id(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceAnswerCallOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceAnswerUssdInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceAnswerUssdInput {
        static $gtype: GObject.GType<MessageVoiceAnswerUssdInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceAnswerUssdInput;

        // Methods

        /**
         * Get the 'USS Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uss_data(): [boolean, VoiceUssDataCodingScheme | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceAnswerUssdInput;
        /**
         * Set the 'USS Data' field in the message.
         * @param value_uss_data_data_coding_scheme a #QmiVoiceUssDataCodingScheme.
         * @param value_uss_data_data a #GArray of #guint8 elements. A new reference to @value_uss_data_data will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_uss_data(
            value_uss_data_data_coding_scheme: VoiceUssDataCodingScheme,
            value_uss_data_data: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceAnswerUssdOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceAnswerUssdOutput {
        static $gtype: GObject.GType<MessageVoiceAnswerUssdOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceAnswerUssdOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceBurstDtmfInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceBurstDtmfInput {
        static $gtype: GObject.GType<MessageVoiceBurstDtmfInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceBurstDtmfInput;

        // Methods

        /**
         * Get the 'Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data(): [boolean, number, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceBurstDtmfInput;
        /**
         * Set the 'Data' field in the message.
         * @param value_data_call_id a #guint8.
         * @param value_data_digit_buffer a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_data(value_data_call_id: number, value_data_digit_buffer: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceBurstDtmfOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceBurstDtmfOutput {
        static $gtype: GObject.GType<MessageVoiceBurstDtmfOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Call ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_id(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceBurstDtmfOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceCancelUssdOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceCancelUssdOutput {
        static $gtype: GObject.GType<MessageVoiceCancelUssdOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceCancelUssdOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceDialCallInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceDialCallInput {
        static $gtype: GObject.GType<MessageVoiceDialCallInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceDialCallInput;

        // Methods

        /**
         * Get the 'Calling Number' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_calling_number(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceDialCallInput;
        /**
         * Set the 'Calling Number' field in the message.
         * @param value_calling_number a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_calling_number(value_calling_number: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceDialCallOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceDialCallOutput {
        static $gtype: GObject.GType<MessageVoiceDialCallOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Call ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_id(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceDialCallOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceEndCallInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceEndCallInput {
        static $gtype: GObject.GType<MessageVoiceEndCallInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceEndCallInput;

        // Methods

        /**
         * Get the 'Call ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_id(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceEndCallInput;
        /**
         * Set the 'Call ID' field in the message.
         * @param value_call_id a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_call_id(value_call_id: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceEndCallOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceEndCallOutput {
        static $gtype: GObject.GType<MessageVoiceEndCallOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Call ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_id(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceEndCallOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceGetAllCallInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceGetAllCallInfoOutput {
        static $gtype: GObject.GType<MessageVoiceGetAllCallInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Call Information' field from `self`.
         *
         * Version of qmi_message_voice_get_all_call_info_output_get_call_information() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_information(): [boolean, MessageVoiceGetAllCallInfoOutputCallInformationCall[] | null];
        /**
         * Get the 'Remote Party Number' field from `self`.
         *
         * Version of qmi_message_voice_get_all_call_info_output_get_remote_party_number() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_remote_party_number(): [boolean, MessageVoiceGetAllCallInfoOutputRemotePartyNumberCall[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceGetAllCallInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageVoiceGetAllCallInfoOutputCallInformationCall struct.
     */
    class MessageVoiceGetAllCallInfoOutputCallInformationCall {
        static $gtype: GObject.GType<MessageVoiceGetAllCallInfoOutputCallInformationCall>;

        // Fields

        id: number;
        state: VoiceCallState;
        type: VoiceCallType;
        direction: VoiceCallDirection;
        mode: VoiceCallMode;
        multipart_indicator: boolean;
        als: VoiceAls;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiMessageVoiceGetAllCallInfoOutputRemotePartyNumberCall struct.
     */
    class MessageVoiceGetAllCallInfoOutputRemotePartyNumberCall {
        static $gtype: GObject.GType<MessageVoiceGetAllCallInfoOutputRemotePartyNumberCall>;

        // Fields

        id: number;
        presentation_indicator: VoicePresentation;
        type: string;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageVoiceGetCallWaitingInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceGetCallWaitingInput {
        static $gtype: GObject.GType<MessageVoiceGetCallWaitingInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceGetCallWaitingInput;

        // Methods

        /**
         * Get the 'Service Class' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_service_class(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceGetCallWaitingInput;
        /**
         * Set the 'Service Class' field in the message.
         * @param value_service_class a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_service_class(value_service_class: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceGetCallWaitingOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceGetCallWaitingOutput {
        static $gtype: GObject.GType<MessageVoiceGetCallWaitingOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Service Class' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_service_class(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceGetCallWaitingOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceGetConfigInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceGetConfigInput {
        static $gtype: GObject.GType<MessageVoiceGetConfigInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceGetConfigInput;

        // Methods

        /**
         * Get the 'Air Timer' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_air_timer(): [boolean, boolean];
        /**
         * Get the 'AMR Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_amr_status(): [boolean, boolean];
        /**
         * Get the 'Auto Answer' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_auto_answer(): [boolean, boolean];
        /**
         * Get the 'NAM Index' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_nam_index(): [boolean, boolean];
        /**
         * Get the 'Preferred Voice Privacy' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_preferred_voice_privacy(): [boolean, boolean];
        /**
         * Get the 'Preferred Voice Service Option' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_preferred_voice_service_option(): [boolean, boolean];
        /**
         * Get the 'Roam Timer' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roam_timer(): [boolean, boolean];
        /**
         * Get the 'TTY Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tty_mode(): [boolean, boolean];
        /**
         * Get the 'Voice Domain Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_voice_domain_preference(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceGetConfigInput;
        /**
         * Set the 'Air Timer' field in the message.
         * @param value_air_timer a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_air_timer(value_air_timer: boolean): boolean;
        /**
         * Set the 'AMR Status' field in the message.
         * @param value_amr_status a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_amr_status(value_amr_status: boolean): boolean;
        /**
         * Set the 'Auto Answer' field in the message.
         * @param value_auto_answer a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_auto_answer(value_auto_answer: boolean): boolean;
        /**
         * Set the 'NAM Index' field in the message.
         * @param value_nam_index a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_nam_index(value_nam_index: boolean): boolean;
        /**
         * Set the 'Preferred Voice Privacy' field in the message.
         * @param value_preferred_voice_privacy a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_preferred_voice_privacy(value_preferred_voice_privacy: boolean): boolean;
        /**
         * Set the 'Preferred Voice Service Option' field in the message.
         * @param value_preferred_voice_service_option a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_preferred_voice_service_option(value_preferred_voice_service_option: boolean): boolean;
        /**
         * Set the 'Roam Timer' field in the message.
         * @param value_roam_timer a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_roam_timer(value_roam_timer: boolean): boolean;
        /**
         * Set the 'TTY Mode' field in the message.
         * @param value_tty_mode a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_tty_mode(value_tty_mode: boolean): boolean;
        /**
         * Set the 'Voice Domain Preference' field in the message.
         * @param value_voice_domain_preference a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_voice_domain_preference(value_voice_domain_preference: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceGetConfigOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceGetConfigOutput {
        static $gtype: GObject.GType<MessageVoiceGetConfigOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Air Timer Count' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_air_timer_count(): [boolean, number, number];
        /**
         * Get the 'Auto Answer Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_auto_answer_status(): [boolean, boolean];
        /**
         * Get the 'Current AMR Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_amr_status(): [boolean, boolean, VoiceWcdmaAmrStatus | null];
        /**
         * Get the 'Current Preferred Voice SO' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_preferred_voice_so(): [
            boolean,
            number,
            boolean,
            VoiceServiceOption | null,
            VoiceServiceOption | null,
            VoiceServiceOption | null,
        ];
        /**
         * Get the 'Current TTY Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_tty_mode(): [boolean, VoiceTtyMode | null];
        /**
         * Get the 'Current Voice Domain Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_voice_domain_preference(): [boolean, VoiceDomain | null];
        /**
         * Get the 'Current Voice Privacy Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_voice_privacy_preference(): [boolean, VoicePrivacy | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Roam Timer Count' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roam_timer_count(): [boolean, number, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceGetConfigOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceGetSupportedMessagesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceGetSupportedMessagesOutput {
        static $gtype: GObject.GType<MessageVoiceGetSupportedMessagesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, Uint8Array | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceGetSupportedMessagesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceIndicationRegisterInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceIndicationRegisterInput {
        static $gtype: GObject.GType<MessageVoiceIndicationRegisterInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceIndicationRegisterInput;

        // Methods

        /**
         * Get the 'AOC Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_aoc_events(): [boolean, boolean];
        /**
         * Get the 'Call Notification Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_notification_events(): [boolean, boolean];
        /**
         * Get the 'Conference Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_conference_events(): [boolean, boolean];
        /**
         * Get the 'DTMF Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_dtmf_events(): [boolean, boolean];
        /**
         * Get the 'Extended Burst Type International Information Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_burst_type_international_information_events(): [boolean, boolean];
        /**
         * Get the 'Handover Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_handover_events(): [boolean, boolean];
        /**
         * Get the 'Modification Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_modification_events(): [boolean, boolean];
        /**
         * Get the 'MT Page Miss Information Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mt_page_miss_information_events(): [boolean, boolean];
        /**
         * Get the 'Speech Codec Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_speech_codec_events(): [boolean, boolean];
        /**
         * Get the 'Supplementary Service Notification Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_supplementary_service_notification_events(): [boolean, boolean];
        /**
         * Get the 'USSD Notification Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ussd_notification_events(): [boolean, boolean];
        /**
         * Get the 'UUS Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uus_events(): [boolean, boolean];
        /**
         * Get the 'Voice Privacy Events' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_voice_privacy_events(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceIndicationRegisterInput;
        /**
         * Set the 'AOC Events' field in the message.
         * @param value_aoc_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_aoc_events(value_aoc_events: boolean): boolean;
        /**
         * Set the 'Call Notification Events' field in the message.
         * @param value_call_notification_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_call_notification_events(value_call_notification_events: boolean): boolean;
        /**
         * Set the 'Conference Events' field in the message.
         * @param value_conference_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_conference_events(value_conference_events: boolean): boolean;
        /**
         * Set the 'DTMF Events' field in the message.
         * @param value_dtmf_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_dtmf_events(value_dtmf_events: boolean): boolean;
        /**
         * Set the 'Extended Burst Type International Information Events' field in the message.
         * @param value_extended_burst_type_international_information_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_extended_burst_type_international_information_events(
            value_extended_burst_type_international_information_events: boolean,
        ): boolean;
        /**
         * Set the 'Handover Events' field in the message.
         * @param value_handover_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_handover_events(value_handover_events: boolean): boolean;
        /**
         * Set the 'Modification Events' field in the message.
         * @param value_modification_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_modification_events(value_modification_events: boolean): boolean;
        /**
         * Set the 'MT Page Miss Information Events' field in the message.
         * @param value_mt_page_miss_information_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mt_page_miss_information_events(value_mt_page_miss_information_events: boolean): boolean;
        /**
         * Set the 'Speech Codec Events' field in the message.
         * @param value_speech_codec_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_speech_codec_events(value_speech_codec_events: boolean): boolean;
        /**
         * Set the 'Supplementary Service Notification Events' field in the message.
         * @param value_supplementary_service_notification_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_supplementary_service_notification_events(
            value_supplementary_service_notification_events: boolean,
        ): boolean;
        /**
         * Set the 'USSD Notification Events' field in the message.
         * @param value_ussd_notification_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ussd_notification_events(value_ussd_notification_events: boolean): boolean;
        /**
         * Set the 'UUS Events' field in the message.
         * @param value_uus_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_uus_events(value_uus_events: boolean): boolean;
        /**
         * Set the 'Voice Privacy Events' field in the message.
         * @param value_voice_privacy_events a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_voice_privacy_events(value_voice_privacy_events: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceIndicationRegisterOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceIndicationRegisterOutput {
        static $gtype: GObject.GType<MessageVoiceIndicationRegisterOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceIndicationRegisterOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceManageCallsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceManageCallsInput {
        static $gtype: GObject.GType<MessageVoiceManageCallsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceManageCallsInput;

        // Methods

        /**
         * Get the 'Call ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_id(): [boolean, number];
        /**
         * Get the 'Service Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_service_type(): [boolean, VoiceSupplementaryServiceType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceManageCallsInput;
        /**
         * Set the 'Call ID' field in the message.
         * @param value_call_id a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_call_id(value_call_id: number): boolean;
        /**
         * Set the 'Service Type' field in the message.
         * @param value_service_type a #QmiVoiceSupplementaryServiceType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_service_type(value_service_type: VoiceSupplementaryServiceType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceManageCallsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceManageCallsOutput {
        static $gtype: GObject.GType<MessageVoiceManageCallsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceManageCallsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceOriginateUssdInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceOriginateUssdInput {
        static $gtype: GObject.GType<MessageVoiceOriginateUssdInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceOriginateUssdInput;

        // Methods

        /**
         * Get the 'USS Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uss_data(): [boolean, VoiceUssDataCodingScheme | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceOriginateUssdInput;
        /**
         * Set the 'USS Data' field in the message.
         * @param value_uss_data_data_coding_scheme a #QmiVoiceUssDataCodingScheme.
         * @param value_uss_data_data a #GArray of #guint8 elements. A new reference to @value_uss_data_data will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_uss_data(
            value_uss_data_data_coding_scheme: VoiceUssDataCodingScheme,
            value_uss_data_data: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceOriginateUssdNoWaitInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceOriginateUssdNoWaitInput {
        static $gtype: GObject.GType<MessageVoiceOriginateUssdNoWaitInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceOriginateUssdNoWaitInput;

        // Methods

        /**
         * Get the 'USS Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uss_data(): [boolean, VoiceUssDataCodingScheme | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceOriginateUssdNoWaitInput;
        /**
         * Set the 'USS Data' field in the message.
         * @param value_uss_data_data_coding_scheme a #QmiVoiceUssDataCodingScheme.
         * @param value_uss_data_data a #GArray of #guint8 elements. A new reference to @value_uss_data_data will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_uss_data(
            value_uss_data_data_coding_scheme: VoiceUssDataCodingScheme,
            value_uss_data_data: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceOriginateUssdNoWaitOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceOriginateUssdNoWaitOutput {
        static $gtype: GObject.GType<MessageVoiceOriginateUssdNoWaitOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceOriginateUssdNoWaitOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceOriginateUssdOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceOriginateUssdOutput {
        static $gtype: GObject.GType<MessageVoiceOriginateUssdOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Alpha Identifier' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_alpha_identifier(): [boolean, VoiceAlphaDataCodingScheme | null, Uint8Array | null];
        /**
         * Get the 'Call Control Result Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_control_result_type(): [boolean, VoiceCallControlResultType | null];
        /**
         * Get the 'Call Control Supplementary Service Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_control_supplementary_service_type(): [boolean, VoiceCallControlSupplementaryServiceType | null];
        /**
         * Get the 'Call ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_id(): [boolean, number];
        /**
         * Get the 'Failure Cause' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_failure_cause(): [boolean, VoiceCallEndReason | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'USS Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uss_data(): [boolean, VoiceUssDataCodingScheme | null, Uint8Array | null];
        /**
         * Get the 'USS Data UTF16' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uss_data_utf16(): [boolean, number[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceOriginateUssdOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceSetSupplementaryServiceInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceSetSupplementaryServiceInput {
        static $gtype: GObject.GType<MessageVoiceSetSupplementaryServiceInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceSetSupplementaryServiceInput;

        // Methods

        /**
         * Get the 'Supplementary Service Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_supplementary_service_information(): [
            boolean,
            VoiceSupplementaryServiceAction | null,
            VoiceSupplementaryServiceReason | null,
        ];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceSetSupplementaryServiceInput;
        /**
         * Set the 'Supplementary Service Information' field in the message.
         * @param value_supplementary_service_information_supplementary_service_action a #QmiVoiceSupplementaryServiceAction.
         * @param value_supplementary_service_information_supplementary_service_reason a #QmiVoiceSupplementaryServiceReason.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_supplementary_service_information(
            value_supplementary_service_information_supplementary_service_action: VoiceSupplementaryServiceAction,
            value_supplementary_service_information_supplementary_service_reason: VoiceSupplementaryServiceReason,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceSetSupplementaryServiceOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceSetSupplementaryServiceOutput {
        static $gtype: GObject.GType<MessageVoiceSetSupplementaryServiceOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Service Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_service_status(): [boolean, boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceSetSupplementaryServiceOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceStartContinuousDtmfInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceStartContinuousDtmfInput {
        static $gtype: GObject.GType<MessageVoiceStartContinuousDtmfInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceStartContinuousDtmfInput;

        // Methods

        /**
         * Get the 'Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data(): [boolean, number, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceStartContinuousDtmfInput;
        /**
         * Set the 'Data' field in the message.
         * @param value_data_call_id a #guint8.
         * @param value_data_digit a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_data(value_data_call_id: number, value_data_digit: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceStartContinuousDtmfOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceStartContinuousDtmfOutput {
        static $gtype: GObject.GType<MessageVoiceStartContinuousDtmfOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Call ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_id(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceStartContinuousDtmfOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceStopContinuousDtmfInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageVoiceStopContinuousDtmfInput {
        static $gtype: GObject.GType<MessageVoiceStopContinuousDtmfInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageVoiceStopContinuousDtmfInput;

        // Methods

        /**
         * Get the 'Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceStopContinuousDtmfInput;
        /**
         * Set the 'Data' field in the message.
         * @param value_data_call_id a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_data(value_data_call_id: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageVoiceStopContinuousDtmfOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageVoiceStopContinuousDtmfOutput {
        static $gtype: GObject.GType<MessageVoiceStopContinuousDtmfOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Call ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_id(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageVoiceStopContinuousDtmfOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdaGetDataFormatInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdaGetDataFormatInput {
        static $gtype: GObject.GType<MessageWdaGetDataFormatInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdaGetDataFormatInput;

        // Methods

        /**
         * Get the 'Endpoint Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_endpoint_info(): [boolean, DataEndpointType | null, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdaGetDataFormatInput;
        /**
         * Set the 'Endpoint Info' field in the message.
         * @param value_endpoint_info_endpoint_type a #QmiDataEndpointType.
         * @param value_endpoint_info_interface_number a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_endpoint_info(
            value_endpoint_info_endpoint_type: DataEndpointType,
            value_endpoint_info_interface_number: number,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdaGetDataFormatOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdaGetDataFormatOutput {
        static $gtype: GObject.GType<MessageWdaGetDataFormatOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Downlink Data Aggregation Max Datagrams' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_downlink_data_aggregation_max_datagrams(): [boolean, number];
        /**
         * Get the 'Downlink Data Aggregation Max Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_downlink_data_aggregation_max_size(): [boolean, number];
        /**
         * Get the 'Downlink Data Aggregation Protocol' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_downlink_data_aggregation_protocol(): [boolean, WdaDataAggregationProtocol | null];
        /**
         * Get the 'Download Minimum Padding' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_download_minimum_padding(): [boolean, number];
        /**
         * Get the 'Flow Control' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_flow_control(): [boolean, number];
        /**
         * Get the 'Link Layer Protocol' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_link_layer_protocol(): [boolean, WdaLinkLayerProtocol | null];
        /**
         * Get the 'NDP Signature' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ndp_signature(): [boolean, number];
        /**
         * Get the 'QoS Format' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_qos_format(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Uplink Data Aggregation Max Datagrams' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uplink_data_aggregation_max_datagrams(): [boolean, number];
        /**
         * Get the 'Uplink Data Aggregation Max Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uplink_data_aggregation_max_size(): [boolean, number];
        /**
         * Get the 'Uplink Data Aggregation Protocol' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uplink_data_aggregation_protocol(): [boolean, WdaDataAggregationProtocol | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdaGetDataFormatOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdaGetSupportedMessagesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdaGetSupportedMessagesOutput {
        static $gtype: GObject.GType<MessageWdaGetSupportedMessagesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, Uint8Array | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdaGetSupportedMessagesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdaSetDataFormatInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdaSetDataFormatInput {
        static $gtype: GObject.GType<MessageWdaSetDataFormatInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdaSetDataFormatInput;

        // Methods

        /**
         * Get the 'Downlink Data Aggregation Max Datagrams' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_downlink_data_aggregation_max_datagrams(): [boolean, number];
        /**
         * Get the 'Downlink Data Aggregation Max Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_downlink_data_aggregation_max_size(): [boolean, number];
        /**
         * Get the 'Downlink Data Aggregation Protocol' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_downlink_data_aggregation_protocol(): [boolean, WdaDataAggregationProtocol | null];
        /**
         * Get the 'Endpoint Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_endpoint_info(): [boolean, DataEndpointType | null, number];
        /**
         * Get the 'Link Layer Protocol' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_link_layer_protocol(): [boolean, WdaLinkLayerProtocol | null];
        /**
         * Get the 'NDP Signature' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ndp_signature(): [boolean, number];
        /**
         * Get the 'QoS Format' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_qos_format(): [boolean, boolean];
        /**
         * Get the 'Uplink Data Aggregation Max Datagrams' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uplink_data_aggregation_max_datagrams(): [boolean, number];
        /**
         * Get the 'Uplink Data Aggregation Max Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uplink_data_aggregation_max_size(): [boolean, number];
        /**
         * Get the 'Uplink Data Aggregation Protocol' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uplink_data_aggregation_protocol(): [boolean, WdaDataAggregationProtocol | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdaSetDataFormatInput;
        /**
         * Set the 'Downlink Data Aggregation Max Datagrams' field in the message.
         * @param value_downlink_data_aggregation_max_datagrams a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_downlink_data_aggregation_max_datagrams(value_downlink_data_aggregation_max_datagrams: number): boolean;
        /**
         * Set the 'Downlink Data Aggregation Max Size' field in the message.
         * @param value_downlink_data_aggregation_max_size a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_downlink_data_aggregation_max_size(value_downlink_data_aggregation_max_size: number): boolean;
        /**
         * Set the 'Downlink Data Aggregation Protocol' field in the message.
         * @param value_downlink_data_aggregation_protocol a #QmiWdaDataAggregationProtocol.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_downlink_data_aggregation_protocol(
            value_downlink_data_aggregation_protocol: WdaDataAggregationProtocol,
        ): boolean;
        /**
         * Set the 'Endpoint Info' field in the message.
         * @param value_endpoint_info_endpoint_type a #QmiDataEndpointType.
         * @param value_endpoint_info_interface_number a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_endpoint_info(
            value_endpoint_info_endpoint_type: DataEndpointType,
            value_endpoint_info_interface_number: number,
        ): boolean;
        /**
         * Set the 'Link Layer Protocol' field in the message.
         * @param value_link_layer_protocol a #QmiWdaLinkLayerProtocol.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_link_layer_protocol(value_link_layer_protocol: WdaLinkLayerProtocol): boolean;
        /**
         * Set the 'NDP Signature' field in the message.
         * @param value_ndp_signature a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ndp_signature(value_ndp_signature: number): boolean;
        /**
         * Set the 'QoS Format' field in the message.
         * @param value_qos_format a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_qos_format(value_qos_format: boolean): boolean;
        /**
         * Set the 'Uplink Data Aggregation Max Datagrams' field in the message.
         * @param value_uplink_data_aggregation_max_datagrams a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_uplink_data_aggregation_max_datagrams(value_uplink_data_aggregation_max_datagrams: number): boolean;
        /**
         * Set the 'Uplink Data Aggregation Max Size' field in the message.
         * @param value_uplink_data_aggregation_max_size a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_uplink_data_aggregation_max_size(value_uplink_data_aggregation_max_size: number): boolean;
        /**
         * Set the 'Uplink Data Aggregation Protocol' field in the message.
         * @param value_uplink_data_aggregation_protocol a #QmiWdaDataAggregationProtocol.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_uplink_data_aggregation_protocol(
            value_uplink_data_aggregation_protocol: WdaDataAggregationProtocol,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdaSetDataFormatOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdaSetDataFormatOutput {
        static $gtype: GObject.GType<MessageWdaSetDataFormatOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Downlink Data Aggregation Max Datagrams' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_downlink_data_aggregation_max_datagrams(): [boolean, number];
        /**
         * Get the 'Downlink Data Aggregation Max Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_downlink_data_aggregation_max_size(): [boolean, number];
        /**
         * Get the 'Downlink Data Aggregation Protocol' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_downlink_data_aggregation_protocol(): [boolean, WdaDataAggregationProtocol | null];
        /**
         * Get the 'Download Minimum Padding' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_download_minimum_padding(): [boolean, number];
        /**
         * Get the 'Flow Control' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_flow_control(): [boolean, number];
        /**
         * Get the 'Link Layer Protocol' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_link_layer_protocol(): [boolean, WdaLinkLayerProtocol | null];
        /**
         * Get the 'NDP Signature' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ndp_signature(): [boolean, number];
        /**
         * Get the 'QoS Format' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_qos_format(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Uplink Data Aggregation Max Datagrams' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uplink_data_aggregation_max_datagrams(): [boolean, number];
        /**
         * Get the 'Uplink Data Aggregation Max Size' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uplink_data_aggregation_max_size(): [boolean, number];
        /**
         * Get the 'Uplink Data Aggregation Protocol' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uplink_data_aggregation_protocol(): [boolean, WdaDataAggregationProtocol | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdaSetDataFormatOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsBindDataPortInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsBindDataPortInput {
        static $gtype: GObject.GType<MessageWdsBindDataPortInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsBindDataPortInput;

        // Methods

        /**
         * Get the 'Data Port' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data_port(): [boolean, SioPort | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsBindDataPortInput;
        /**
         * Set the 'Data Port' field in the message.
         * @param value_data_port a #QmiSioPort.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_data_port(value_data_port: SioPort): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsBindDataPortOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsBindDataPortOutput {
        static $gtype: GObject.GType<MessageWdsBindDataPortOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsBindDataPortOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsBindMuxDataPortInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsBindMuxDataPortInput {
        static $gtype: GObject.GType<MessageWdsBindMuxDataPortInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsBindMuxDataPortInput;

        // Methods

        /**
         * Get the 'Client Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_client_type(): [boolean, WdsClientType | null];
        /**
         * Get the 'Endpoint Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_endpoint_info(): [boolean, DataEndpointType | null, number];
        /**
         * Get the 'Mux ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mux_id(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsBindMuxDataPortInput;
        /**
         * Set the 'Client Type' field in the message.
         * @param value_client_type a #QmiWdsClientType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_client_type(value_client_type: WdsClientType): boolean;
        /**
         * Set the 'Endpoint Info' field in the message.
         * @param value_endpoint_info_endpoint_type a #QmiDataEndpointType.
         * @param value_endpoint_info_interface_number a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_endpoint_info(
            value_endpoint_info_endpoint_type: DataEndpointType,
            value_endpoint_info_interface_number: number,
        ): boolean;
        /**
         * Set the 'Mux ID' field in the message.
         * @param value_mux_id a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mux_id(value_mux_id: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsBindMuxDataPortOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsBindMuxDataPortOutput {
        static $gtype: GObject.GType<MessageWdsBindMuxDataPortOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsBindMuxDataPortOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsConfigureProfileEventListInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsConfigureProfileEventListInput {
        static $gtype: GObject.GType<MessageWdsConfigureProfileEventListInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsConfigureProfileEventListInput;

        // Methods

        /**
         * Get the 'Register' field from `self`.
         *
         * Version of qmi_message_wds_configure_profile_event_list_input_get_register() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_register(): [boolean, MessageWdsConfigureProfileEventListInputRegisterElement[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsConfigureProfileEventListInput;
        /**
         * Set the 'Register' field in the message.
         * @param value_register_ptr array of #QmiMessageWdsConfigureProfileEventListInputRegisterElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_register(value_register_ptr: MessageWdsConfigureProfileEventListInputRegisterElement[]): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageWdsConfigureProfileEventListInputRegisterElement struct.
     */
    class MessageWdsConfigureProfileEventListInputRegisterElement {
        static $gtype: GObject.GType<MessageWdsConfigureProfileEventListInputRegisterElement>;

        // Fields

        profile_type: WdsProfileType;
        profile_index: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageWdsConfigureProfileEventListOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsConfigureProfileEventListOutput {
        static $gtype: GObject.GType<MessageWdsConfigureProfileEventListOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsConfigureProfileEventListOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsCreateProfileInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsCreateProfileInput {
        static $gtype: GObject.GType<MessageWdsCreateProfileInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsCreateProfileInput;

        // Methods

        /**
         * Get the 'APN Disabled Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_disabled_flag(): [boolean, boolean];
        /**
         * Get the 'APN Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_name(): [boolean, string];
        /**
         * Get the 'APN Type Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_type_mask(): [boolean, WdsApnTypeMask | null];
        /**
         * Get the 'Authentication' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_authentication(): [boolean, WdsAuthentication | null];
        /**
         * Get the 'GPRS Minimum QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gprs_minimum_qos(): [boolean, number, number, number, number, number];
        /**
         * Get the 'GPRS Requested QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gprs_requested_qos(): [boolean, number, number, number, number, number];
        /**
         * Get the 'IMCN Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_imcn_flag(): [boolean, boolean];
        /**
         * Get the 'IPv4 Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv4_address_preference(): [boolean, number];
        /**
         * Get the 'IPv6 Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_address_preference(): [boolean, number[] | null];
        /**
         * Get the 'IPv6 Primary DNS Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_primary_dns_address_preference(): [boolean, number[] | null];
        /**
         * Get the 'IPv6 Secondary DNS Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_secondary_dns_address_preference(): [boolean, number[] | null];
        /**
         * Get the 'LTE QoS Parameters' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_qos_parameters(): [boolean, WdsQosClassIdentifier | null, number, number, number, number];
        /**
         * Get the 'Password' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_password(): [boolean, string];
        /**
         * Get the 'PCSCF Address Using DHCP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pcscf_address_using_dhcp(): [boolean, boolean];
        /**
         * Get the 'PCSCF Address Using PCO' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pcscf_address_using_pco(): [boolean, boolean];
        /**
         * Get the 'PDP Context Number' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_number(): [boolean, number];
        /**
         * Get the 'PDP Context Primary ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_primary_id(): [boolean, number];
        /**
         * Get the 'PDP Context Secondary Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_secondary_flag(): [boolean, boolean];
        /**
         * Get the 'PDP Data Compression Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_data_compression_type(): [boolean, WdsPdpDataCompressionType | null];
        /**
         * Get the 'PDP Header Compression Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_header_compression_type(): [boolean, WdsPdpHeaderCompressionType | null];
        /**
         * Get the 'PDP Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_type(): [boolean, WdsPdpType | null];
        /**
         * Get the 'Primary IPv4 DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_primary_ipv4_dns_address(): [boolean, number];
        /**
         * Get the 'Profile Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_name(): [boolean, string];
        /**
         * Get the 'Profile Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_type(): [boolean, WdsProfileType | null];
        /**
         * Get the 'Roaming Disallowed Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roaming_disallowed_flag(): [boolean, boolean];
        /**
         * Get the 'Secondary IPv4 DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_secondary_ipv4_dns_address(): [boolean, number];
        /**
         * Get the 'UMTS Minimum QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_minimum_qos(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
        ];
        /**
         * Get the 'UMTS Minimum QoS With Signaling Indication Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_minimum_qos_with_signaling_indication_flag(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
            number,
        ];
        /**
         * Get the 'UMTS Requested QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_requested_qos(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
        ];
        /**
         * Get the 'UMTS Requested QoS With Signaling Indication Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_requested_qos_with_signaling_indication_flag(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
            number,
        ];
        /**
         * Get the 'Username' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_username(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsCreateProfileInput;
        /**
         * Set the 'APN Disabled Flag' field in the message.
         * @param value_apn_disabled_flag a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn_disabled_flag(value_apn_disabled_flag: boolean): boolean;
        /**
         * Set the 'APN Name' field in the message.
         * @param value_apn_name a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn_name(value_apn_name: string): boolean;
        /**
         * Set the 'APN Type Mask' field in the message.
         * @param value_apn_type_mask a #QmiWdsApnTypeMask.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn_type_mask(value_apn_type_mask: WdsApnTypeMask): boolean;
        /**
         * Set the 'Authentication' field in the message.
         * @param value_authentication a #QmiWdsAuthentication.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_authentication(value_authentication: WdsAuthentication): boolean;
        /**
         * Set the 'GPRS Minimum QoS' field in the message.
         * @param value_gprs_minimum_qos_precedence_class a #guint32.
         * @param value_gprs_minimum_qos_delay_class a #guint32.
         * @param value_gprs_minimum_qos_reliability_class a #guint32.
         * @param value_gprs_minimum_qos_peak_throughput_class a #guint32.
         * @param value_gprs_minimum_qos_mean_throughput_class a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_gprs_minimum_qos(
            value_gprs_minimum_qos_precedence_class: number,
            value_gprs_minimum_qos_delay_class: number,
            value_gprs_minimum_qos_reliability_class: number,
            value_gprs_minimum_qos_peak_throughput_class: number,
            value_gprs_minimum_qos_mean_throughput_class: number,
        ): boolean;
        /**
         * Set the 'GPRS Requested QoS' field in the message.
         * @param value_gprs_requested_qos_precedence_class a #guint32.
         * @param value_gprs_requested_qos_delay_class a #guint32.
         * @param value_gprs_requested_qos_reliability_class a #guint32.
         * @param value_gprs_requested_qos_peak_throughput_class a #guint32.
         * @param value_gprs_requested_qos_mean_throughput_class a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_gprs_requested_qos(
            value_gprs_requested_qos_precedence_class: number,
            value_gprs_requested_qos_delay_class: number,
            value_gprs_requested_qos_reliability_class: number,
            value_gprs_requested_qos_peak_throughput_class: number,
            value_gprs_requested_qos_mean_throughput_class: number,
        ): boolean;
        /**
         * Set the 'IMCN Flag' field in the message.
         * @param value_imcn_flag a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_imcn_flag(value_imcn_flag: boolean): boolean;
        /**
         * Set the 'IPv4 Address Preference' field in the message.
         * @param value_ipv4_address_preference a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ipv4_address_preference(value_ipv4_address_preference: number): boolean;
        /**
         * Set the 'IPv6 Address Preference' field in the message.
         * @param value_ipv6_address_preference_address a #GArray of #guint16 elements. A new reference to @value_ipv6_address_preference_address will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ipv6_address_preference(value_ipv6_address_preference_address: number[]): boolean;
        /**
         * Set the 'IPv6 Primary DNS Address Preference' field in the message.
         * @param value_ipv6_primary_dns_address_preference a #GArray of #guint16 elements. A new reference to @value_ipv6_primary_dns_address_preference will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ipv6_primary_dns_address_preference(value_ipv6_primary_dns_address_preference: number[]): boolean;
        /**
         * Set the 'IPv6 Secondary DNS Address Preference' field in the message.
         * @param value_ipv6_secondary_dns_address_preference a #GArray of #guint16 elements. A new reference to @value_ipv6_secondary_dns_address_preference will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ipv6_secondary_dns_address_preference(value_ipv6_secondary_dns_address_preference: number[]): boolean;
        /**
         * Set the 'LTE QoS Parameters' field in the message.
         * @param value_lte_qos_parameters_qos_class_identifier a #QmiWdsQosClassIdentifier.
         * @param value_lte_qos_parameters_guaranteed_downlink_bitrate a #guint32.
         * @param value_lte_qos_parameters_max_downlink_bitrate a #guint32.
         * @param value_lte_qos_parameters_guaranteed_uplink_bitrate a #guint32.
         * @param value_lte_qos_parameters_max_uplink_bitrate a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_qos_parameters(
            value_lte_qos_parameters_qos_class_identifier: WdsQosClassIdentifier,
            value_lte_qos_parameters_guaranteed_downlink_bitrate: number,
            value_lte_qos_parameters_max_downlink_bitrate: number,
            value_lte_qos_parameters_guaranteed_uplink_bitrate: number,
            value_lte_qos_parameters_max_uplink_bitrate: number,
        ): boolean;
        /**
         * Set the 'Password' field in the message.
         * @param value_password a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_password(value_password: string): boolean;
        /**
         * Set the 'PCSCF Address Using DHCP' field in the message.
         * @param value_pcscf_address_using_dhcp a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pcscf_address_using_dhcp(value_pcscf_address_using_dhcp: boolean): boolean;
        /**
         * Set the 'PCSCF Address Using PCO' field in the message.
         * @param value_pcscf_address_using_pco a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pcscf_address_using_pco(value_pcscf_address_using_pco: boolean): boolean;
        /**
         * Set the 'PDP Context Number' field in the message.
         * @param value_pdp_context_number a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_context_number(value_pdp_context_number: number): boolean;
        /**
         * Set the 'PDP Context Primary ID' field in the message.
         * @param value_pdp_context_primary_id a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_context_primary_id(value_pdp_context_primary_id: number): boolean;
        /**
         * Set the 'PDP Context Secondary Flag' field in the message.
         * @param value_pdp_context_secondary_flag a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_context_secondary_flag(value_pdp_context_secondary_flag: boolean): boolean;
        /**
         * Set the 'PDP Data Compression Type' field in the message.
         * @param value_pdp_data_compression_type a #QmiWdsPdpDataCompressionType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_data_compression_type(value_pdp_data_compression_type: WdsPdpDataCompressionType): boolean;
        /**
         * Set the 'PDP Header Compression Type' field in the message.
         * @param value_pdp_header_compression_type a #QmiWdsPdpHeaderCompressionType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_header_compression_type(value_pdp_header_compression_type: WdsPdpHeaderCompressionType): boolean;
        /**
         * Set the 'PDP Type' field in the message.
         * @param value_pdp_type a #QmiWdsPdpType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_type(value_pdp_type: WdsPdpType): boolean;
        /**
         * Set the 'Primary IPv4 DNS Address' field in the message.
         * @param value_primary_ipv4_dns_address a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_primary_ipv4_dns_address(value_primary_ipv4_dns_address: number): boolean;
        /**
         * Set the 'Profile Name' field in the message.
         * @param value_profile_name a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_name(value_profile_name: string): boolean;
        /**
         * Set the 'Profile Type' field in the message.
         * @param value_profile_type a #QmiWdsProfileType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_type(value_profile_type: WdsProfileType): boolean;
        /**
         * Set the 'Roaming Disallowed Flag' field in the message.
         * @param value_roaming_disallowed_flag a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_roaming_disallowed_flag(value_roaming_disallowed_flag: boolean): boolean;
        /**
         * Set the 'Secondary IPv4 DNS Address' field in the message.
         * @param value_secondary_ipv4_dns_address a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_secondary_ipv4_dns_address(value_secondary_ipv4_dns_address: number): boolean;
        /**
         * Set the 'UMTS Minimum QoS' field in the message.
         * @param value_umts_minimum_qos_traffic_class a #QmiWdsTrafficClass.
         * @param value_umts_minimum_qos_max_uplink_bitrate a #guint32.
         * @param value_umts_minimum_qos_max_downlink_bitrate a #guint32.
         * @param value_umts_minimum_qos_guaranteed_uplink_bitrate a #guint32.
         * @param value_umts_minimum_qos_guaranteed_downlink_bitrate a #guint32.
         * @param value_umts_minimum_qos_qos_delivery_order a #QmiWdsDeliveryOrder.
         * @param value_umts_minimum_qos_maximum_sdu_size a #guint32.
         * @param value_umts_minimum_qos_sdu_error_ratio a #QmiWdsSduErrorRatio.
         * @param value_umts_minimum_qos_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
         * @param value_umts_minimum_qos_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
         * @param value_umts_minimum_qos_transfer_delay a #guint32.
         * @param value_umts_minimum_qos_traffic_handling_priority a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_umts_minimum_qos(
            value_umts_minimum_qos_traffic_class: WdsTrafficClass,
            value_umts_minimum_qos_max_uplink_bitrate: number,
            value_umts_minimum_qos_max_downlink_bitrate: number,
            value_umts_minimum_qos_guaranteed_uplink_bitrate: number,
            value_umts_minimum_qos_guaranteed_downlink_bitrate: number,
            value_umts_minimum_qos_qos_delivery_order: WdsDeliveryOrder,
            value_umts_minimum_qos_maximum_sdu_size: number,
            value_umts_minimum_qos_sdu_error_ratio: WdsSduErrorRatio,
            value_umts_minimum_qos_residual_bit_error_ratio: WdsSduResidualBitErrorRatio,
            value_umts_minimum_qos_delivery_erroneous_sdu: WdsSduErroneousDelivery,
            value_umts_minimum_qos_transfer_delay: number,
            value_umts_minimum_qos_traffic_handling_priority: number,
        ): boolean;
        /**
         * Set the 'UMTS Minimum QoS With Signaling Indication Flag' field in the message.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_traffic_class a #QmiWdsTrafficClass.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_max_uplink_bitrate a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_max_downlink_bitrate a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_qos_delivery_order a #QmiWdsDeliveryOrder.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_maximum_sdu_size a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_sdu_error_ratio a #QmiWdsSduErrorRatio.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_transfer_delay a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_traffic_handling_priority a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_signaling_indication a #gint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_umts_minimum_qos_with_signaling_indication_flag(
            value_umts_minimum_qos_with_signaling_indication_flag_traffic_class: WdsTrafficClass,
            value_umts_minimum_qos_with_signaling_indication_flag_max_uplink_bitrate: number,
            value_umts_minimum_qos_with_signaling_indication_flag_max_downlink_bitrate: number,
            value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate: number,
            value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate: number,
            value_umts_minimum_qos_with_signaling_indication_flag_qos_delivery_order: WdsDeliveryOrder,
            value_umts_minimum_qos_with_signaling_indication_flag_maximum_sdu_size: number,
            value_umts_minimum_qos_with_signaling_indication_flag_sdu_error_ratio: WdsSduErrorRatio,
            value_umts_minimum_qos_with_signaling_indication_flag_residual_bit_error_ratio: WdsSduResidualBitErrorRatio,
            value_umts_minimum_qos_with_signaling_indication_flag_delivery_erroneous_sdu: WdsSduErroneousDelivery,
            value_umts_minimum_qos_with_signaling_indication_flag_transfer_delay: number,
            value_umts_minimum_qos_with_signaling_indication_flag_traffic_handling_priority: number,
            value_umts_minimum_qos_with_signaling_indication_flag_signaling_indication: number,
        ): boolean;
        /**
         * Set the 'UMTS Requested QoS' field in the message.
         * @param value_umts_requested_qos_traffic_class a #QmiWdsTrafficClass.
         * @param value_umts_requested_qos_max_uplink_bitrate a #guint32.
         * @param value_umts_requested_qos_max_downlink_bitrate a #guint32.
         * @param value_umts_requested_qos_guaranteed_uplink_bitrate a #guint32.
         * @param value_umts_requested_qos_guaranteed_downlink_bitrate a #guint32.
         * @param value_umts_requested_qos_qos_delivery_order a #QmiWdsDeliveryOrder.
         * @param value_umts_requested_qos_maximum_sdu_size a #guint32.
         * @param value_umts_requested_qos_sdu_error_ratio a #QmiWdsSduErrorRatio.
         * @param value_umts_requested_qos_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
         * @param value_umts_requested_qos_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
         * @param value_umts_requested_qos_transfer_delay a #guint32.
         * @param value_umts_requested_qos_traffic_handling_priority a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_umts_requested_qos(
            value_umts_requested_qos_traffic_class: WdsTrafficClass,
            value_umts_requested_qos_max_uplink_bitrate: number,
            value_umts_requested_qos_max_downlink_bitrate: number,
            value_umts_requested_qos_guaranteed_uplink_bitrate: number,
            value_umts_requested_qos_guaranteed_downlink_bitrate: number,
            value_umts_requested_qos_qos_delivery_order: WdsDeliveryOrder,
            value_umts_requested_qos_maximum_sdu_size: number,
            value_umts_requested_qos_sdu_error_ratio: WdsSduErrorRatio,
            value_umts_requested_qos_residual_bit_error_ratio: WdsSduResidualBitErrorRatio,
            value_umts_requested_qos_delivery_erroneous_sdu: WdsSduErroneousDelivery,
            value_umts_requested_qos_transfer_delay: number,
            value_umts_requested_qos_traffic_handling_priority: number,
        ): boolean;
        /**
         * Set the 'UMTS Requested QoS With Signaling Indication Flag' field in the message.
         * @param value_umts_requested_qos_with_signaling_indication_flag_traffic_class a #QmiWdsTrafficClass.
         * @param value_umts_requested_qos_with_signaling_indication_flag_max_uplink_bitrate a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_max_downlink_bitrate a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_qos_delivery_order a #QmiWdsDeliveryOrder.
         * @param value_umts_requested_qos_with_signaling_indication_flag_maximum_sdu_size a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_sdu_error_ratio a #QmiWdsSduErrorRatio.
         * @param value_umts_requested_qos_with_signaling_indication_flag_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
         * @param value_umts_requested_qos_with_signaling_indication_flag_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
         * @param value_umts_requested_qos_with_signaling_indication_flag_transfer_delay a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_traffic_handling_priority a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_signaling_indication a #gint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_umts_requested_qos_with_signaling_indication_flag(
            value_umts_requested_qos_with_signaling_indication_flag_traffic_class: WdsTrafficClass,
            value_umts_requested_qos_with_signaling_indication_flag_max_uplink_bitrate: number,
            value_umts_requested_qos_with_signaling_indication_flag_max_downlink_bitrate: number,
            value_umts_requested_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate: number,
            value_umts_requested_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate: number,
            value_umts_requested_qos_with_signaling_indication_flag_qos_delivery_order: WdsDeliveryOrder,
            value_umts_requested_qos_with_signaling_indication_flag_maximum_sdu_size: number,
            value_umts_requested_qos_with_signaling_indication_flag_sdu_error_ratio: WdsSduErrorRatio,
            value_umts_requested_qos_with_signaling_indication_flag_residual_bit_error_ratio: WdsSduResidualBitErrorRatio,
            value_umts_requested_qos_with_signaling_indication_flag_delivery_erroneous_sdu: WdsSduErroneousDelivery,
            value_umts_requested_qos_with_signaling_indication_flag_transfer_delay: number,
            value_umts_requested_qos_with_signaling_indication_flag_traffic_handling_priority: number,
            value_umts_requested_qos_with_signaling_indication_flag_signaling_indication: number,
        ): boolean;
        /**
         * Set the 'Username' field in the message.
         * @param value_username a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_username(value_username: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsCreateProfileOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsCreateProfileOutput {
        static $gtype: GObject.GType<MessageWdsCreateProfileOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Extended Error Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_error_code(): [boolean, WdsDsProfileError | null];
        /**
         * Get the 'Profile Identifier' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_identifier(): [boolean, WdsProfileType | null, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsCreateProfileOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsDeleteProfileInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsDeleteProfileInput {
        static $gtype: GObject.GType<MessageWdsDeleteProfileInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsDeleteProfileInput;

        // Methods

        /**
         * Get the 'Profile Identifier' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_identifier(): [boolean, WdsProfileType | null, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsDeleteProfileInput;
        /**
         * Set the 'Profile Identifier' field in the message.
         * @param value_profile_identifier_profile_type a #QmiWdsProfileType.
         * @param value_profile_identifier_profile_index a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_identifier(
            value_profile_identifier_profile_type: WdsProfileType,
            value_profile_identifier_profile_index: number,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsDeleteProfileOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsDeleteProfileOutput {
        static $gtype: GObject.GType<MessageWdsDeleteProfileOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Extended Error Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_error_code(): [boolean, WdsDsProfileError | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsDeleteProfileOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetAutoconnectSettingsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetAutoconnectSettingsOutput {
        static $gtype: GObject.GType<MessageWdsGetAutoconnectSettingsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Roaming' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roaming(): [boolean, WdsAutoconnectSettingRoaming | null];
        /**
         * Get the 'Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_status(): [boolean, WdsAutoconnectSetting | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetAutoconnectSettingsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetChannelRatesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetChannelRatesOutput {
        static $gtype: GObject.GType<MessageWdsGetChannelRatesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Channel Rates' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_channel_rates(): [boolean, number, number, number, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetChannelRatesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetCurrentDataBearerTechnologyOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetCurrentDataBearerTechnologyOutput {
        static $gtype: GObject.GType<MessageWdsGetCurrentDataBearerTechnologyOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Current' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current(): [boolean, WdsNetworkType | null, number, number];
        /**
         * Get the 'Last' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_last(): [boolean, WdsNetworkType | null, number, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetCurrentDataBearerTechnologyOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetCurrentSettingsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsGetCurrentSettingsInput {
        static $gtype: GObject.GType<MessageWdsGetCurrentSettingsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsGetCurrentSettingsInput;

        // Methods

        /**
         * Get the 'Requested Settings' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_requested_settings(): [boolean, WdsRequestedSettings | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetCurrentSettingsInput;
        /**
         * Set the 'Requested Settings' field in the message.
         * @param value_requested_settings a #QmiWdsRequestedSettings.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_requested_settings(value_requested_settings: WdsRequestedSettings): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetCurrentSettingsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetCurrentSettingsOutput {
        static $gtype: GObject.GType<MessageWdsGetCurrentSettingsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'APN Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_name(): [boolean, string];
        /**
         * Get the 'Authentication' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_authentication(): [boolean, WdsAuthentication | null];
        /**
         * Get the 'Domain Name List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_domain_name_list(): [boolean, string[] | null];
        /**
         * Get the 'Extended Technology Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_technology_preference(): [boolean, WdsExtendedTechnologyPreference | null];
        /**
         * Get the 'GPRS Granted QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gprs_granted_qos(): [boolean, number, number, number, number, number];
        /**
         * Get the 'IMCN Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_imcn_flag(): [boolean, number];
        /**
         * Get the 'IP Family' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ip_family(): [boolean, WdsIpFamily | null];
        /**
         * Get the 'IPv4 Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv4_address(): [boolean, number];
        /**
         * Get the 'IPv4 Gateway Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv4_gateway_address(): [boolean, number];
        /**
         * Get the 'IPv4 Gateway Subnet Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv4_gateway_subnet_mask(): [boolean, number];
        /**
         * Get the 'IPv6 Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_address(): [boolean, number[] | null, number];
        /**
         * Get the 'IPv6 Gateway Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_gateway_address(): [boolean, number[] | null, number];
        /**
         * Get the 'IPv6 Primary DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_primary_dns_address(): [boolean, number[] | null];
        /**
         * Get the 'IPv6 Secondary DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_secondary_dns_address(): [boolean, number[] | null];
        /**
         * Get the 'MTU' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mtu(): [boolean, number];
        /**
         * Get the 'Operator Reserved PCO' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_operator_reserved_pco(): [boolean, number, number, boolean, Uint8Array | null, number];
        /**
         * Get the 'PCSCF Address Using PCO' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pcscf_address_using_pco(): [boolean, number];
        /**
         * Get the 'PCSCF Domain Name List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pcscf_domain_name_list(): [boolean, string[] | null];
        /**
         * Get the 'PCSCF Server Address List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pcscf_server_address_list(): [boolean, number[] | null];
        /**
         * Get the 'PDP Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_type(): [boolean, WdsPdpType | null];
        /**
         * Get the 'Primary IPv4 DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_primary_ipv4_dns_address(): [boolean, number];
        /**
         * Get the 'Profile ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_id(): [boolean, WdsProfileType | null, number];
        /**
         * Get the 'Profile Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_name(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Secondary IPv4 DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_secondary_ipv4_dns_address(): [boolean, number];
        /**
         * Get the 'UMTS Granted QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_granted_qos(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
        ];
        /**
         * Get the 'Username' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_username(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetCurrentSettingsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetDataBearerTechnologyOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetDataBearerTechnologyOutput {
        static $gtype: GObject.GType<MessageWdsGetDataBearerTechnologyOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Current' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current(): [boolean, WdsDataBearerTechnology | null];
        /**
         * Get the 'Last' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_last(): [boolean, WdsDataBearerTechnology | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetDataBearerTechnologyOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetDefaultProfileNumberInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsGetDefaultProfileNumberInput {
        static $gtype: GObject.GType<MessageWdsGetDefaultProfileNumberInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsGetDefaultProfileNumberInput;

        // Methods

        /**
         * Get the 'Profile Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_type(): [boolean, WdsProfileType | null, WdsProfileFamily | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetDefaultProfileNumberInput;
        /**
         * Set the 'Profile Type' field in the message.
         * @param value_profile_type_type a #QmiWdsProfileType.
         * @param value_profile_type_family a #QmiWdsProfileFamily.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_type(value_profile_type_type: WdsProfileType, value_profile_type_family: WdsProfileFamily): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetDefaultProfileNumberOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetDefaultProfileNumberOutput {
        static $gtype: GObject.GType<MessageWdsGetDefaultProfileNumberOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Extended Error Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_error_code(): [boolean, WdsDsProfileError | null];
        /**
         * Get the 'Index' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_index(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetDefaultProfileNumberOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetDefaultSettingsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsGetDefaultSettingsInput {
        static $gtype: GObject.GType<MessageWdsGetDefaultSettingsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsGetDefaultSettingsInput;

        // Methods

        /**
         * Get the 'Profile Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_type(): [boolean, WdsProfileType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetDefaultSettingsInput;
        /**
         * Set the 'Profile Type' field in the message.
         * @param value_profile_type a #QmiWdsProfileType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_type(value_profile_type: WdsProfileType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetDefaultSettingsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetDefaultSettingsOutput {
        static $gtype: GObject.GType<MessageWdsGetDefaultSettingsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'APN Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_name(): [boolean, string];
        /**
         * Get the 'Authentication' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_authentication(): [boolean, WdsAuthentication | null];
        /**
         * Get the 'Extended Error Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_error_code(): [boolean, WdsDsProfileError | null];
        /**
         * Get the 'GPRS Minimum QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gprs_minimum_qos(): [boolean, number, number, number, number, number];
        /**
         * Get the 'GPRS Requested QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gprs_requested_qos(): [boolean, number, number, number, number, number];
        /**
         * Get the 'IMCN Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_imcn_flag(): [boolean, boolean];
        /**
         * Get the 'IPv4 Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv4_address_preference(): [boolean, number];
        /**
         * Get the 'IPv6 Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_address_preference(): [boolean, number[] | null];
        /**
         * Get the 'IPv6 Primary DNS Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_primary_dns_address_preference(): [boolean, number[] | null];
        /**
         * Get the 'IPv6 Secondary DNS Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_secondary_dns_address_preference(): [boolean, number[] | null];
        /**
         * Get the 'LTE QoS Parameters' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_qos_parameters(): [boolean, WdsQosClassIdentifier | null, number, number, number, number];
        /**
         * Get the 'Password' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_password(): [boolean, string];
        /**
         * Get the 'PCSCF Address Using DHCP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pcscf_address_using_dhcp(): [boolean, boolean];
        /**
         * Get the 'PCSCF Address Using PCO' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pcscf_address_using_pco(): [boolean, boolean];
        /**
         * Get the 'PDP Context Number' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_number(): [boolean, number];
        /**
         * Get the 'PDP Context Primary ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_primary_id(): [boolean, number];
        /**
         * Get the 'PDP Context Secondary Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_secondary_flag(): [boolean, boolean];
        /**
         * Get the 'PDP Data Compression Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_data_compression_type(): [boolean, WdsPdpDataCompressionType | null];
        /**
         * Get the 'PDP Header Compression Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_header_compression_type(): [boolean, WdsPdpHeaderCompressionType | null];
        /**
         * Get the 'PDP Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_type(): [boolean, WdsPdpType | null];
        /**
         * Get the 'Primary IPv4 DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_primary_ipv4_dns_address(): [boolean, number];
        /**
         * Get the 'Profile Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_name(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Secondary IPv4 DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_secondary_ipv4_dns_address(): [boolean, number];
        /**
         * Get the 'UMTS Minimum QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_minimum_qos(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
        ];
        /**
         * Get the 'UMTS Minimum QoS With Signaling Indication Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_minimum_qos_with_signaling_indication_flag(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
            number,
        ];
        /**
         * Get the 'UMTS Requested QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_requested_qos(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
        ];
        /**
         * Get the 'UMTS Requested QoS With Signaling Indication Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_requested_qos_with_signaling_indication_flag(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
            number,
        ];
        /**
         * Get the 'Username' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_username(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetDefaultSettingsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetDormancyStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetDormancyStatusOutput {
        static $gtype: GObject.GType<MessageWdsGetDormancyStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Dormancy Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_dormancy_status(): [boolean, WdsDormancyStatus | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetDormancyStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetLteAttachParametersOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetLteAttachParametersOutput {
        static $gtype: GObject.GType<MessageWdsGetLteAttachParametersOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'APN' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn(): [boolean, string];
        /**
         * Get the 'IP Support Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ip_support_type(): [boolean, WdsIpSupportType | null];
        /**
         * Get the 'OTA Attach Performed' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ota_attach_performed(): [boolean, boolean];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetLteAttachParametersOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetLteAttachPdnListOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetLteAttachPdnListOutput {
        static $gtype: GObject.GType<MessageWdsGetLteAttachPdnListOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Current List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_list(): [boolean, number[] | null];
        /**
         * Get the 'Pending List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pending_list(): [boolean, number[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetLteAttachPdnListOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetMaxLteAttachPdnNumberOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetMaxLteAttachPdnNumberOutput {
        static $gtype: GObject.GType<MessageWdsGetMaxLteAttachPdnNumberOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetMaxLteAttachPdnNumberOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetPacketServiceStatusOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetPacketServiceStatusOutput {
        static $gtype: GObject.GType<MessageWdsGetPacketServiceStatusOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Connection Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_connection_status(): [boolean, WdsConnectionStatus | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetPacketServiceStatusOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetPacketStatisticsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsGetPacketStatisticsInput {
        static $gtype: GObject.GType<MessageWdsGetPacketStatisticsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsGetPacketStatisticsInput;

        // Methods

        /**
         * Get the 'Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mask(): [boolean, WdsPacketStatisticsMaskFlag | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetPacketStatisticsInput;
        /**
         * Set the 'Mask' field in the message.
         * @param value_mask a #QmiWdsPacketStatisticsMaskFlag.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mask(value_mask: WdsPacketStatisticsMaskFlag): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetPacketStatisticsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetPacketStatisticsOutput {
        static $gtype: GObject.GType<MessageWdsGetPacketStatisticsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Last Call Rx Bytes Ok' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_last_call_rx_bytes_ok(): [boolean, number];
        /**
         * Get the 'Last Call Tx Bytes Ok' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_last_call_tx_bytes_ok(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Rx Bytes Ok' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_bytes_ok(): [boolean, number];
        /**
         * Get the 'Rx Overflows' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_overflows(): [boolean, number];
        /**
         * Get the 'Rx Packets Dropped' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_packets_dropped(): [boolean, number];
        /**
         * Get the 'Rx Packets Error' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_packets_error(): [boolean, number];
        /**
         * Get the 'Rx Packets Ok' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_rx_packets_ok(): [boolean, number];
        /**
         * Get the 'Tx Bytes Ok' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tx_bytes_ok(): [boolean, number];
        /**
         * Get the 'Tx Overflows' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tx_overflows(): [boolean, number];
        /**
         * Get the 'Tx Packets Dropped' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tx_packets_dropped(): [boolean, number];
        /**
         * Get the 'Tx Packets Error' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tx_packets_error(): [boolean, number];
        /**
         * Get the 'Tx Packets Ok' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_tx_packets_ok(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetPacketStatisticsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetPdnThrottleInfoInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsGetPdnThrottleInfoInput {
        static $gtype: GObject.GType<MessageWdsGetPdnThrottleInfoInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsGetPdnThrottleInfoInput;

        // Methods

        /**
         * Get the 'Network Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_network_type(): [boolean, WdsDataSystemNetworkType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetPdnThrottleInfoInput;
        /**
         * Set the 'Network Type' field in the message.
         * @param value_network_type a #QmiWdsDataSystemNetworkType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_network_type(value_network_type: WdsDataSystemNetworkType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetPdnThrottleInfoOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetPdnThrottleInfoOutput {
        static $gtype: GObject.GType<MessageWdsGetPdnThrottleInfoOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Info' field from `self`.
         *
         * Version of qmi_message_wds_get_pdn_throttle_info_output_get_info() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_info(): [boolean, MessageWdsGetPdnThrottleInfoOutputInfoElement[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetPdnThrottleInfoOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageWdsGetPdnThrottleInfoOutputInfoElement struct.
     */
    class MessageWdsGetPdnThrottleInfoOutputInfoElement {
        static $gtype: GObject.GType<MessageWdsGetPdnThrottleInfoOutputInfoElement>;

        // Fields

        ipv4_throttled: boolean;
        ipv6_throttled: boolean;
        ipv4_throttle_time_left_ms: number;
        ipv6_throttle_time_left_ms: number;
        apn: string;

        // Constructors

        constructor(
            properties?: Partial<{
                ipv4_throttled: boolean;
                ipv6_throttled: boolean;
                ipv4_throttle_time_left_ms: number;
                ipv6_throttle_time_left_ms: number;
                apn: string;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageWdsGetProfileListInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsGetProfileListInput {
        static $gtype: GObject.GType<MessageWdsGetProfileListInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsGetProfileListInput;

        // Methods

        /**
         * Get the 'Profile Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_type(): [boolean, WdsProfileType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetProfileListInput;
        /**
         * Set the 'Profile Type' field in the message.
         * @param value_profile_type a #QmiWdsProfileType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_type(value_profile_type: WdsProfileType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetProfileListOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetProfileListOutput {
        static $gtype: GObject.GType<MessageWdsGetProfileListOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Extended Error Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_error_code(): [boolean, WdsDsProfileError | null];
        /**
         * Get the 'Profile List' field from `self`.
         *
         * Version of qmi_message_wds_get_profile_list_output_get_profile_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_list(): [boolean, MessageWdsGetProfileListOutputProfileListProfile[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetProfileListOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageWdsGetProfileListOutputProfileListProfile struct.
     */
    class MessageWdsGetProfileListOutputProfileListProfile {
        static $gtype: GObject.GType<MessageWdsGetProfileListOutputProfileListProfile>;

        // Fields

        profile_type: WdsProfileType;
        profile_index: number;
        profile_name: string;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageWdsGetProfileSettingsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsGetProfileSettingsInput {
        static $gtype: GObject.GType<MessageWdsGetProfileSettingsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsGetProfileSettingsInput;

        // Methods

        /**
         * Get the 'Profile ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_id(): [boolean, WdsProfileType | null, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetProfileSettingsInput;
        /**
         * Set the 'Profile ID' field in the message.
         * @param value_profile_id_profile_type a #QmiWdsProfileType.
         * @param value_profile_id_profile_index a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_id(value_profile_id_profile_type: WdsProfileType, value_profile_id_profile_index: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetProfileSettingsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetProfileSettingsOutput {
        static $gtype: GObject.GType<MessageWdsGetProfileSettingsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'APN Disabled Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_disabled_flag(): [boolean, boolean];
        /**
         * Get the 'APN Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_name(): [boolean, string];
        /**
         * Get the 'APN Type Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_type_mask(): [boolean, WdsApnTypeMask | null];
        /**
         * Get the 'Authentication' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_authentication(): [boolean, WdsAuthentication | null];
        /**
         * Get the 'Extended Error Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_error_code(): [boolean, WdsDsProfileError | null];
        /**
         * Get the 'GPRS Minimum QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gprs_minimum_qos(): [boolean, number, number, number, number, number];
        /**
         * Get the 'GPRS Requested QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gprs_requested_qos(): [boolean, number, number, number, number, number];
        /**
         * Get the 'IMCN Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_imcn_flag(): [boolean, boolean];
        /**
         * Get the 'IPv4 Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv4_address_preference(): [boolean, number];
        /**
         * Get the 'IPv6 Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_address_preference(): [boolean, number[] | null];
        /**
         * Get the 'IPv6 Primary DNS Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_primary_dns_address_preference(): [boolean, number[] | null];
        /**
         * Get the 'IPv6 Secondary DNS Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_secondary_dns_address_preference(): [boolean, number[] | null];
        /**
         * Get the 'LTE QoS Parameters' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_qos_parameters(): [boolean, WdsQosClassIdentifier | null, number, number, number, number];
        /**
         * Get the 'Password' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_password(): [boolean, string];
        /**
         * Get the 'PCSCF Address Using DHCP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pcscf_address_using_dhcp(): [boolean, boolean];
        /**
         * Get the 'PCSCF Address Using PCO' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pcscf_address_using_pco(): [boolean, boolean];
        /**
         * Get the 'PDP Context Number' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_number(): [boolean, number];
        /**
         * Get the 'PDP Context Primary ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_primary_id(): [boolean, number];
        /**
         * Get the 'PDP Context Secondary Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_secondary_flag(): [boolean, boolean];
        /**
         * Get the 'PDP Data Compression Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_data_compression_type(): [boolean, WdsPdpDataCompressionType | null];
        /**
         * Get the 'PDP Header Compression Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_header_compression_type(): [boolean, WdsPdpHeaderCompressionType | null];
        /**
         * Get the 'PDP Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_type(): [boolean, WdsPdpType | null];
        /**
         * Get the 'Primary IPv4 DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_primary_ipv4_dns_address(): [boolean, number];
        /**
         * Get the 'Profile Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_name(): [boolean, string];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Roaming Disallowed Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roaming_disallowed_flag(): [boolean, boolean];
        /**
         * Get the 'Secondary IPv4 DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_secondary_ipv4_dns_address(): [boolean, number];
        /**
         * Get the 'UMTS Minimum QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_minimum_qos(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
        ];
        /**
         * Get the 'UMTS Minimum QoS With Signaling Indication Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_minimum_qos_with_signaling_indication_flag(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
            number,
        ];
        /**
         * Get the 'UMTS Requested QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_requested_qos(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
        ];
        /**
         * Get the 'UMTS Requested QoS With Signaling Indication Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_requested_qos_with_signaling_indication_flag(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
            number,
        ];
        /**
         * Get the 'Username' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_username(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetProfileSettingsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGetSupportedMessagesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGetSupportedMessagesOutput {
        static $gtype: GObject.GType<MessageWdsGetSupportedMessagesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, Uint8Array | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGetSupportedMessagesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGoActiveOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGoActiveOutput {
        static $gtype: GObject.GType<MessageWdsGoActiveOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGoActiveOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsGoDormantOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsGoDormantOutput {
        static $gtype: GObject.GType<MessageWdsGoDormantOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsGoDormantOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsIndicationRegisterInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsIndicationRegisterInput {
        static $gtype: GObject.GType<MessageWdsIndicationRegisterInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsIndicationRegisterInput;

        // Methods

        /**
         * Get the 'Report Extended IP Configuration Change' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_report_extended_ip_configuration_change(): [boolean, boolean];
        /**
         * Get the 'Report Profile Changes' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_report_profile_changes(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsIndicationRegisterInput;
        /**
         * Set the 'Report Extended IP Configuration Change' field in the message.
         * @param value_report_extended_ip_configuration_change a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_report_extended_ip_configuration_change(value_report_extended_ip_configuration_change: boolean): boolean;
        /**
         * Set the 'Report Profile Changes' field in the message.
         * @param value_report_profile_changes a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_report_profile_changes(value_report_profile_changes: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsIndicationRegisterOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsIndicationRegisterOutput {
        static $gtype: GObject.GType<MessageWdsIndicationRegisterOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsIndicationRegisterOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsModifyProfileInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsModifyProfileInput {
        static $gtype: GObject.GType<MessageWdsModifyProfileInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsModifyProfileInput;

        // Methods

        /**
         * Get the 'APN Disabled Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_disabled_flag(): [boolean, boolean];
        /**
         * Get the 'APN Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_name(): [boolean, string];
        /**
         * Get the 'APN Type Mask' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_type_mask(): [boolean, WdsApnTypeMask | null];
        /**
         * Get the 'Authentication' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_authentication(): [boolean, WdsAuthentication | null];
        /**
         * Get the 'GPRS Minimum QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gprs_minimum_qos(): [boolean, number, number, number, number, number];
        /**
         * Get the 'GPRS Requested QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gprs_requested_qos(): [boolean, number, number, number, number, number];
        /**
         * Get the 'IMCN Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_imcn_flag(): [boolean, boolean];
        /**
         * Get the 'IPv4 Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv4_address_preference(): [boolean, number];
        /**
         * Get the 'IPv6 Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_address_preference(): [boolean, number[] | null];
        /**
         * Get the 'IPv6 Primary DNS Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_primary_dns_address_preference(): [boolean, number[] | null];
        /**
         * Get the 'IPv6 Secondary DNS Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv6_secondary_dns_address_preference(): [boolean, number[] | null];
        /**
         * Get the 'LTE QoS Parameters' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_lte_qos_parameters(): [boolean, WdsQosClassIdentifier | null, number, number, number, number];
        /**
         * Get the 'Password' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_password(): [boolean, string];
        /**
         * Get the 'PCSCF Address Using DHCP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pcscf_address_using_dhcp(): [boolean, boolean];
        /**
         * Get the 'PCSCF Address Using PCO' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pcscf_address_using_pco(): [boolean, boolean];
        /**
         * Get the 'PDP Context Number' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_number(): [boolean, number];
        /**
         * Get the 'PDP Context Primary ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_primary_id(): [boolean, number];
        /**
         * Get the 'PDP Context Secondary Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_secondary_flag(): [boolean, boolean];
        /**
         * Get the 'PDP Data Compression Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_data_compression_type(): [boolean, WdsPdpDataCompressionType | null];
        /**
         * Get the 'PDP Header Compression Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_header_compression_type(): [boolean, WdsPdpHeaderCompressionType | null];
        /**
         * Get the 'PDP Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_type(): [boolean, WdsPdpType | null];
        /**
         * Get the 'Primary IPv4 DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_primary_ipv4_dns_address(): [boolean, number];
        /**
         * Get the 'Profile Identifier' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_identifier(): [boolean, WdsProfileType | null, number];
        /**
         * Get the 'Profile Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_name(): [boolean, string];
        /**
         * Get the 'Roaming Disallowed Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roaming_disallowed_flag(): [boolean, boolean];
        /**
         * Get the 'Secondary IPv4 DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_secondary_ipv4_dns_address(): [boolean, number];
        /**
         * Get the 'UMTS Minimum QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_minimum_qos(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
        ];
        /**
         * Get the 'UMTS Minimum QoS With Signaling Indication Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_minimum_qos_with_signaling_indication_flag(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
            number,
        ];
        /**
         * Get the 'UMTS Requested QoS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_requested_qos(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
        ];
        /**
         * Get the 'UMTS Requested QoS With Signaling Indication Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_umts_requested_qos_with_signaling_indication_flag(): [
            boolean,
            WdsTrafficClass | null,
            number,
            number,
            number,
            number,
            WdsDeliveryOrder | null,
            number,
            WdsSduErrorRatio | null,
            WdsSduResidualBitErrorRatio | null,
            WdsSduErroneousDelivery | null,
            number,
            number,
            number,
        ];
        /**
         * Get the 'Username' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_username(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsModifyProfileInput;
        /**
         * Set the 'APN Disabled Flag' field in the message.
         * @param value_apn_disabled_flag a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn_disabled_flag(value_apn_disabled_flag: boolean): boolean;
        /**
         * Set the 'APN Name' field in the message.
         * @param value_apn_name a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn_name(value_apn_name: string): boolean;
        /**
         * Set the 'APN Type Mask' field in the message.
         * @param value_apn_type_mask a #QmiWdsApnTypeMask.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn_type_mask(value_apn_type_mask: WdsApnTypeMask): boolean;
        /**
         * Set the 'Authentication' field in the message.
         * @param value_authentication a #QmiWdsAuthentication.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_authentication(value_authentication: WdsAuthentication): boolean;
        /**
         * Set the 'GPRS Minimum QoS' field in the message.
         * @param value_gprs_minimum_qos_precedence_class a #guint32.
         * @param value_gprs_minimum_qos_delay_class a #guint32.
         * @param value_gprs_minimum_qos_reliability_class a #guint32.
         * @param value_gprs_minimum_qos_peak_throughput_class a #guint32.
         * @param value_gprs_minimum_qos_mean_throughput_class a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_gprs_minimum_qos(
            value_gprs_minimum_qos_precedence_class: number,
            value_gprs_minimum_qos_delay_class: number,
            value_gprs_minimum_qos_reliability_class: number,
            value_gprs_minimum_qos_peak_throughput_class: number,
            value_gprs_minimum_qos_mean_throughput_class: number,
        ): boolean;
        /**
         * Set the 'GPRS Requested QoS' field in the message.
         * @param value_gprs_requested_qos_precedence_class a #guint32.
         * @param value_gprs_requested_qos_delay_class a #guint32.
         * @param value_gprs_requested_qos_reliability_class a #guint32.
         * @param value_gprs_requested_qos_peak_throughput_class a #guint32.
         * @param value_gprs_requested_qos_mean_throughput_class a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_gprs_requested_qos(
            value_gprs_requested_qos_precedence_class: number,
            value_gprs_requested_qos_delay_class: number,
            value_gprs_requested_qos_reliability_class: number,
            value_gprs_requested_qos_peak_throughput_class: number,
            value_gprs_requested_qos_mean_throughput_class: number,
        ): boolean;
        /**
         * Set the 'IMCN Flag' field in the message.
         * @param value_imcn_flag a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_imcn_flag(value_imcn_flag: boolean): boolean;
        /**
         * Set the 'IPv4 Address Preference' field in the message.
         * @param value_ipv4_address_preference a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ipv4_address_preference(value_ipv4_address_preference: number): boolean;
        /**
         * Set the 'IPv6 Address Preference' field in the message.
         * @param value_ipv6_address_preference_address a #GArray of #guint16 elements. A new reference to @value_ipv6_address_preference_address will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ipv6_address_preference(value_ipv6_address_preference_address: number[]): boolean;
        /**
         * Set the 'IPv6 Primary DNS Address Preference' field in the message.
         * @param value_ipv6_primary_dns_address_preference a #GArray of #guint16 elements. A new reference to @value_ipv6_primary_dns_address_preference will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ipv6_primary_dns_address_preference(value_ipv6_primary_dns_address_preference: number[]): boolean;
        /**
         * Set the 'IPv6 Secondary DNS Address Preference' field in the message.
         * @param value_ipv6_secondary_dns_address_preference a #GArray of #guint16 elements. A new reference to @value_ipv6_secondary_dns_address_preference will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ipv6_secondary_dns_address_preference(value_ipv6_secondary_dns_address_preference: number[]): boolean;
        /**
         * Set the 'LTE QoS Parameters' field in the message.
         * @param value_lte_qos_parameters_qos_class_identifier a #QmiWdsQosClassIdentifier.
         * @param value_lte_qos_parameters_guaranteed_downlink_bitrate a #guint32.
         * @param value_lte_qos_parameters_max_downlink_bitrate a #guint32.
         * @param value_lte_qos_parameters_guaranteed_uplink_bitrate a #guint32.
         * @param value_lte_qos_parameters_max_uplink_bitrate a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_lte_qos_parameters(
            value_lte_qos_parameters_qos_class_identifier: WdsQosClassIdentifier,
            value_lte_qos_parameters_guaranteed_downlink_bitrate: number,
            value_lte_qos_parameters_max_downlink_bitrate: number,
            value_lte_qos_parameters_guaranteed_uplink_bitrate: number,
            value_lte_qos_parameters_max_uplink_bitrate: number,
        ): boolean;
        /**
         * Set the 'Password' field in the message.
         * @param value_password a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_password(value_password: string): boolean;
        /**
         * Set the 'PCSCF Address Using DHCP' field in the message.
         * @param value_pcscf_address_using_dhcp a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pcscf_address_using_dhcp(value_pcscf_address_using_dhcp: boolean): boolean;
        /**
         * Set the 'PCSCF Address Using PCO' field in the message.
         * @param value_pcscf_address_using_pco a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pcscf_address_using_pco(value_pcscf_address_using_pco: boolean): boolean;
        /**
         * Set the 'PDP Context Number' field in the message.
         * @param value_pdp_context_number a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_context_number(value_pdp_context_number: number): boolean;
        /**
         * Set the 'PDP Context Primary ID' field in the message.
         * @param value_pdp_context_primary_id a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_context_primary_id(value_pdp_context_primary_id: number): boolean;
        /**
         * Set the 'PDP Context Secondary Flag' field in the message.
         * @param value_pdp_context_secondary_flag a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_context_secondary_flag(value_pdp_context_secondary_flag: boolean): boolean;
        /**
         * Set the 'PDP Data Compression Type' field in the message.
         * @param value_pdp_data_compression_type a #QmiWdsPdpDataCompressionType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_data_compression_type(value_pdp_data_compression_type: WdsPdpDataCompressionType): boolean;
        /**
         * Set the 'PDP Header Compression Type' field in the message.
         * @param value_pdp_header_compression_type a #QmiWdsPdpHeaderCompressionType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_header_compression_type(value_pdp_header_compression_type: WdsPdpHeaderCompressionType): boolean;
        /**
         * Set the 'PDP Type' field in the message.
         * @param value_pdp_type a #QmiWdsPdpType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_type(value_pdp_type: WdsPdpType): boolean;
        /**
         * Set the 'Primary IPv4 DNS Address' field in the message.
         * @param value_primary_ipv4_dns_address a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_primary_ipv4_dns_address(value_primary_ipv4_dns_address: number): boolean;
        /**
         * Set the 'Profile Identifier' field in the message.
         * @param value_profile_identifier_profile_type a #QmiWdsProfileType.
         * @param value_profile_identifier_profile_index a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_identifier(
            value_profile_identifier_profile_type: WdsProfileType,
            value_profile_identifier_profile_index: number,
        ): boolean;
        /**
         * Set the 'Profile Name' field in the message.
         * @param value_profile_name a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_name(value_profile_name: string): boolean;
        /**
         * Set the 'Roaming Disallowed Flag' field in the message.
         * @param value_roaming_disallowed_flag a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_roaming_disallowed_flag(value_roaming_disallowed_flag: boolean): boolean;
        /**
         * Set the 'Secondary IPv4 DNS Address' field in the message.
         * @param value_secondary_ipv4_dns_address a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_secondary_ipv4_dns_address(value_secondary_ipv4_dns_address: number): boolean;
        /**
         * Set the 'UMTS Minimum QoS' field in the message.
         * @param value_umts_minimum_qos_traffic_class a #QmiWdsTrafficClass.
         * @param value_umts_minimum_qos_max_uplink_bitrate a #guint32.
         * @param value_umts_minimum_qos_max_downlink_bitrate a #guint32.
         * @param value_umts_minimum_qos_guaranteed_uplink_bitrate a #guint32.
         * @param value_umts_minimum_qos_guaranteed_downlink_bitrate a #guint32.
         * @param value_umts_minimum_qos_qos_delivery_order a #QmiWdsDeliveryOrder.
         * @param value_umts_minimum_qos_maximum_sdu_size a #guint32.
         * @param value_umts_minimum_qos_sdu_error_ratio a #QmiWdsSduErrorRatio.
         * @param value_umts_minimum_qos_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
         * @param value_umts_minimum_qos_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
         * @param value_umts_minimum_qos_transfer_delay a #guint32.
         * @param value_umts_minimum_qos_traffic_handling_priority a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_umts_minimum_qos(
            value_umts_minimum_qos_traffic_class: WdsTrafficClass,
            value_umts_minimum_qos_max_uplink_bitrate: number,
            value_umts_minimum_qos_max_downlink_bitrate: number,
            value_umts_minimum_qos_guaranteed_uplink_bitrate: number,
            value_umts_minimum_qos_guaranteed_downlink_bitrate: number,
            value_umts_minimum_qos_qos_delivery_order: WdsDeliveryOrder,
            value_umts_minimum_qos_maximum_sdu_size: number,
            value_umts_minimum_qos_sdu_error_ratio: WdsSduErrorRatio,
            value_umts_minimum_qos_residual_bit_error_ratio: WdsSduResidualBitErrorRatio,
            value_umts_minimum_qos_delivery_erroneous_sdu: WdsSduErroneousDelivery,
            value_umts_minimum_qos_transfer_delay: number,
            value_umts_minimum_qos_traffic_handling_priority: number,
        ): boolean;
        /**
         * Set the 'UMTS Minimum QoS With Signaling Indication Flag' field in the message.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_traffic_class a #QmiWdsTrafficClass.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_max_uplink_bitrate a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_max_downlink_bitrate a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_qos_delivery_order a #QmiWdsDeliveryOrder.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_maximum_sdu_size a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_sdu_error_ratio a #QmiWdsSduErrorRatio.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_transfer_delay a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_traffic_handling_priority a #guint32.
         * @param value_umts_minimum_qos_with_signaling_indication_flag_signaling_indication a #gint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_umts_minimum_qos_with_signaling_indication_flag(
            value_umts_minimum_qos_with_signaling_indication_flag_traffic_class: WdsTrafficClass,
            value_umts_minimum_qos_with_signaling_indication_flag_max_uplink_bitrate: number,
            value_umts_minimum_qos_with_signaling_indication_flag_max_downlink_bitrate: number,
            value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate: number,
            value_umts_minimum_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate: number,
            value_umts_minimum_qos_with_signaling_indication_flag_qos_delivery_order: WdsDeliveryOrder,
            value_umts_minimum_qos_with_signaling_indication_flag_maximum_sdu_size: number,
            value_umts_minimum_qos_with_signaling_indication_flag_sdu_error_ratio: WdsSduErrorRatio,
            value_umts_minimum_qos_with_signaling_indication_flag_residual_bit_error_ratio: WdsSduResidualBitErrorRatio,
            value_umts_minimum_qos_with_signaling_indication_flag_delivery_erroneous_sdu: WdsSduErroneousDelivery,
            value_umts_minimum_qos_with_signaling_indication_flag_transfer_delay: number,
            value_umts_minimum_qos_with_signaling_indication_flag_traffic_handling_priority: number,
            value_umts_minimum_qos_with_signaling_indication_flag_signaling_indication: number,
        ): boolean;
        /**
         * Set the 'UMTS Requested QoS' field in the message.
         * @param value_umts_requested_qos_traffic_class a #QmiWdsTrafficClass.
         * @param value_umts_requested_qos_max_uplink_bitrate a #guint32.
         * @param value_umts_requested_qos_max_downlink_bitrate a #guint32.
         * @param value_umts_requested_qos_guaranteed_uplink_bitrate a #guint32.
         * @param value_umts_requested_qos_guaranteed_downlink_bitrate a #guint32.
         * @param value_umts_requested_qos_qos_delivery_order a #QmiWdsDeliveryOrder.
         * @param value_umts_requested_qos_maximum_sdu_size a #guint32.
         * @param value_umts_requested_qos_sdu_error_ratio a #QmiWdsSduErrorRatio.
         * @param value_umts_requested_qos_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
         * @param value_umts_requested_qos_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
         * @param value_umts_requested_qos_transfer_delay a #guint32.
         * @param value_umts_requested_qos_traffic_handling_priority a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_umts_requested_qos(
            value_umts_requested_qos_traffic_class: WdsTrafficClass,
            value_umts_requested_qos_max_uplink_bitrate: number,
            value_umts_requested_qos_max_downlink_bitrate: number,
            value_umts_requested_qos_guaranteed_uplink_bitrate: number,
            value_umts_requested_qos_guaranteed_downlink_bitrate: number,
            value_umts_requested_qos_qos_delivery_order: WdsDeliveryOrder,
            value_umts_requested_qos_maximum_sdu_size: number,
            value_umts_requested_qos_sdu_error_ratio: WdsSduErrorRatio,
            value_umts_requested_qos_residual_bit_error_ratio: WdsSduResidualBitErrorRatio,
            value_umts_requested_qos_delivery_erroneous_sdu: WdsSduErroneousDelivery,
            value_umts_requested_qos_transfer_delay: number,
            value_umts_requested_qos_traffic_handling_priority: number,
        ): boolean;
        /**
         * Set the 'UMTS Requested QoS With Signaling Indication Flag' field in the message.
         * @param value_umts_requested_qos_with_signaling_indication_flag_traffic_class a #QmiWdsTrafficClass.
         * @param value_umts_requested_qos_with_signaling_indication_flag_max_uplink_bitrate a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_max_downlink_bitrate a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_qos_delivery_order a #QmiWdsDeliveryOrder.
         * @param value_umts_requested_qos_with_signaling_indication_flag_maximum_sdu_size a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_sdu_error_ratio a #QmiWdsSduErrorRatio.
         * @param value_umts_requested_qos_with_signaling_indication_flag_residual_bit_error_ratio a #QmiWdsSduResidualBitErrorRatio.
         * @param value_umts_requested_qos_with_signaling_indication_flag_delivery_erroneous_sdu a #QmiWdsSduErroneousDelivery.
         * @param value_umts_requested_qos_with_signaling_indication_flag_transfer_delay a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_traffic_handling_priority a #guint32.
         * @param value_umts_requested_qos_with_signaling_indication_flag_signaling_indication a #gint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_umts_requested_qos_with_signaling_indication_flag(
            value_umts_requested_qos_with_signaling_indication_flag_traffic_class: WdsTrafficClass,
            value_umts_requested_qos_with_signaling_indication_flag_max_uplink_bitrate: number,
            value_umts_requested_qos_with_signaling_indication_flag_max_downlink_bitrate: number,
            value_umts_requested_qos_with_signaling_indication_flag_guaranteed_uplink_bitrate: number,
            value_umts_requested_qos_with_signaling_indication_flag_guaranteed_downlink_bitrate: number,
            value_umts_requested_qos_with_signaling_indication_flag_qos_delivery_order: WdsDeliveryOrder,
            value_umts_requested_qos_with_signaling_indication_flag_maximum_sdu_size: number,
            value_umts_requested_qos_with_signaling_indication_flag_sdu_error_ratio: WdsSduErrorRatio,
            value_umts_requested_qos_with_signaling_indication_flag_residual_bit_error_ratio: WdsSduResidualBitErrorRatio,
            value_umts_requested_qos_with_signaling_indication_flag_delivery_erroneous_sdu: WdsSduErroneousDelivery,
            value_umts_requested_qos_with_signaling_indication_flag_transfer_delay: number,
            value_umts_requested_qos_with_signaling_indication_flag_traffic_handling_priority: number,
            value_umts_requested_qos_with_signaling_indication_flag_signaling_indication: number,
        ): boolean;
        /**
         * Set the 'Username' field in the message.
         * @param value_username a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_username(value_username: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsModifyProfileOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsModifyProfileOutput {
        static $gtype: GObject.GType<MessageWdsModifyProfileOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Extended Error Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_error_code(): [boolean, WdsDsProfileError | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsModifyProfileOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsResetOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsResetOutput {
        static $gtype: GObject.GType<MessageWdsResetOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsResetOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsSetAutoconnectSettingsInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsSetAutoconnectSettingsInput {
        static $gtype: GObject.GType<MessageWdsSetAutoconnectSettingsInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsSetAutoconnectSettingsInput;

        // Methods

        /**
         * Get the 'Roaming' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roaming(): [boolean, WdsAutoconnectSettingRoaming | null];
        /**
         * Get the 'Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_status(): [boolean, WdsAutoconnectSetting | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsSetAutoconnectSettingsInput;
        /**
         * Set the 'Roaming' field in the message.
         * @param value_roaming a #QmiWdsAutoconnectSettingRoaming.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_roaming(value_roaming: WdsAutoconnectSettingRoaming): boolean;
        /**
         * Set the 'Status' field in the message.
         * @param value_status a #QmiWdsAutoconnectSetting.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_status(value_status: WdsAutoconnectSetting): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsSetAutoconnectSettingsOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsSetAutoconnectSettingsOutput {
        static $gtype: GObject.GType<MessageWdsSetAutoconnectSettingsOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsSetAutoconnectSettingsOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsSetDefaultProfileNumberInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsSetDefaultProfileNumberInput {
        static $gtype: GObject.GType<MessageWdsSetDefaultProfileNumberInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsSetDefaultProfileNumberInput;

        // Methods

        /**
         * Get the 'Profile Identifier' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_identifier(): [boolean, WdsProfileType | null, WdsProfileFamily | null, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsSetDefaultProfileNumberInput;
        /**
         * Set the 'Profile Identifier' field in the message.
         * @param value_profile_identifier_type a #QmiWdsProfileType.
         * @param value_profile_identifier_family a #QmiWdsProfileFamily.
         * @param value_profile_identifier_index a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_identifier(
            value_profile_identifier_type: WdsProfileType,
            value_profile_identifier_family: WdsProfileFamily,
            value_profile_identifier_index: number,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsSetDefaultProfileNumberOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsSetDefaultProfileNumberOutput {
        static $gtype: GObject.GType<MessageWdsSetDefaultProfileNumberOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Extended Error Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_error_code(): [boolean, WdsDsProfileError | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsSetDefaultProfileNumberOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsSetEventReportInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsSetEventReportInput {
        static $gtype: GObject.GType<MessageWdsSetEventReportInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsSetEventReportInput;

        // Methods

        /**
         * Get the 'Channel Rate' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_channel_rate(): [boolean, boolean];
        /**
         * Get the 'Current Data Bearer Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_current_data_bearer_technology(): [boolean, boolean];
        /**
         * Get the 'Data Bearer Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data_bearer_technology(): [boolean, boolean];
        /**
         * Get the 'Data Call Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data_call_status(): [boolean, boolean];
        /**
         * Get the 'Data Systems' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_data_systems(): [boolean, boolean];
        /**
         * Get the 'Dormancy Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_dormancy_status(): [boolean, boolean];
        /**
         * Get the 'EVDO PM Change' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_evdo_pm_change(): [boolean, boolean];
        /**
         * Get the 'Extended Data Bearer Technology' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_data_bearer_technology(): [boolean, boolean];
        /**
         * Get the 'Limited Data System Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_limited_data_system_status(): [boolean, boolean];
        /**
         * Get the 'MIP Status' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_mip_status(): [boolean, number];
        /**
         * Get the 'PDN Filter Removals' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdn_filter_removals(): [boolean, boolean];
        /**
         * Get the 'Preferred Data System' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_preferred_data_system(): [boolean, boolean];
        /**
         * Get the 'Transfer Statistics' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_transfer_statistics(): [boolean, number, WdsSetEventReportTransferStatistics | null];
        /**
         * Get the 'Uplink Flow Control' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_uplink_flow_control(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsSetEventReportInput;
        /**
         * Set the 'Channel Rate' field in the message.
         * @param value_channel_rate a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_channel_rate(value_channel_rate: boolean): boolean;
        /**
         * Set the 'Current Data Bearer Technology' field in the message.
         * @param value_current_data_bearer_technology a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_current_data_bearer_technology(value_current_data_bearer_technology: boolean): boolean;
        /**
         * Set the 'Data Bearer Technology' field in the message.
         * @param value_data_bearer_technology a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_data_bearer_technology(value_data_bearer_technology: boolean): boolean;
        /**
         * Set the 'Data Call Status' field in the message.
         * @param value_data_call_status a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_data_call_status(value_data_call_status: boolean): boolean;
        /**
         * Set the 'Data Systems' field in the message.
         * @param value_data_systems a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_data_systems(value_data_systems: boolean): boolean;
        /**
         * Set the 'Dormancy Status' field in the message.
         * @param value_dormancy_status a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_dormancy_status(value_dormancy_status: boolean): boolean;
        /**
         * Set the 'EVDO PM Change' field in the message.
         * @param value_evdo_pm_change a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_evdo_pm_change(value_evdo_pm_change: boolean): boolean;
        /**
         * Set the 'Extended Data Bearer Technology' field in the message.
         * @param value_extended_data_bearer_technology a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_extended_data_bearer_technology(value_extended_data_bearer_technology: boolean): boolean;
        /**
         * Set the 'Limited Data System Status' field in the message.
         * @param value_limited_data_system_status a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_limited_data_system_status(value_limited_data_system_status: boolean): boolean;
        /**
         * Set the 'MIP Status' field in the message.
         * @param value_mip_status a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_mip_status(value_mip_status: number): boolean;
        /**
         * Set the 'PDN Filter Removals' field in the message.
         * @param value_pdn_filter_removals a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdn_filter_removals(value_pdn_filter_removals: boolean): boolean;
        /**
         * Set the 'Preferred Data System' field in the message.
         * @param value_preferred_data_system a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_preferred_data_system(value_preferred_data_system: boolean): boolean;
        /**
         * Set the 'Transfer Statistics' field in the message.
         * @param value_transfer_statistics_interval_seconds a #guint8.
         * @param value_transfer_statistics_indicators a #QmiWdsSetEventReportTransferStatistics.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_transfer_statistics(
            value_transfer_statistics_interval_seconds: number,
            value_transfer_statistics_indicators: WdsSetEventReportTransferStatistics,
        ): boolean;
        /**
         * Set the 'Uplink Flow Control' field in the message.
         * @param value_uplink_flow_control a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_uplink_flow_control(value_uplink_flow_control: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsSetEventReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsSetEventReportOutput {
        static $gtype: GObject.GType<MessageWdsSetEventReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsSetEventReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsSetIpFamilyInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsSetIpFamilyInput {
        static $gtype: GObject.GType<MessageWdsSetIpFamilyInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsSetIpFamilyInput;

        // Methods

        /**
         * Get the 'Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_preference(): [boolean, WdsIpFamily | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsSetIpFamilyInput;
        /**
         * Set the 'Preference' field in the message.
         * @param value_preference a #QmiWdsIpFamily.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_preference(value_preference: WdsIpFamily): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsSetIpFamilyOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsSetIpFamilyOutput {
        static $gtype: GObject.GType<MessageWdsSetIpFamilyOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsSetIpFamilyOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsSetLteAttachPdnListInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsSetLteAttachPdnListInput {
        static $gtype: GObject.GType<MessageWdsSetLteAttachPdnListInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsSetLteAttachPdnListInput;

        // Methods

        /**
         * Get the 'Action' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_action(): [boolean, WdsAttachPdnListAction | null];
        /**
         * Get the 'List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, number[] | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsSetLteAttachPdnListInput;
        /**
         * Set the 'Action' field in the message.
         * @param value_action a #QmiWdsAttachPdnListAction.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_action(value_action: WdsAttachPdnListAction): boolean;
        /**
         * Set the 'List' field in the message.
         * @param value_list a #GArray of #guint16 elements. A new reference to @value_list will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_list(value_list: number[]): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsSetLteAttachPdnListOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsSetLteAttachPdnListOutput {
        static $gtype: GObject.GType<MessageWdsSetLteAttachPdnListOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsSetLteAttachPdnListOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsStartNetworkInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsStartNetworkInput {
        static $gtype: GObject.GType<MessageWdsStartNetworkInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsStartNetworkInput;

        // Methods

        /**
         * Get the 'APN' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn(): [boolean, string];
        /**
         * Get the 'Authentication Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_authentication_preference(): [boolean, WdsAuthentication | null];
        /**
         * Get the 'Call Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_type(): [boolean, WdsCallType | null];
        /**
         * Get the 'Enable Autoconnect' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_enable_autoconnect(): [boolean, boolean];
        /**
         * Get the 'Extended Technology Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_extended_technology_preference(): [boolean, WdsExtendedTechnologyPreference | null];
        /**
         * Get the 'IP Family Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ip_family_preference(): [boolean, WdsIpFamily | null];
        /**
         * Get the 'IPv4 Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv4_address_preference(): [boolean, number];
        /**
         * Get the 'Password' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_password(): [boolean, string];
        /**
         * Get the 'Primary DNS Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_primary_dns_address_preference(): [boolean, number];
        /**
         * Get the 'Primary NBNS Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_primary_nbns_address_preference(): [boolean, number];
        /**
         * Get the 'Profile Index 3GPP' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_index_3gpp(): [boolean, number];
        /**
         * Get the 'Profile Index 3GPP2' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_index_3gpp2(): [boolean, number];
        /**
         * Get the 'Secondary DNS Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_secondary_dns_address_preference(): [boolean, number];
        /**
         * Get the 'Secondary NBNS Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_secondary_nbns_address_preference(): [boolean, number];
        /**
         * Get the 'Technology Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_technology_preference(): [boolean, WdsTechnologyPreference | null];
        /**
         * Get the 'Username' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_username(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsStartNetworkInput;
        /**
         * Set the 'APN' field in the message.
         * @param value_apn a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn(value_apn: string): boolean;
        /**
         * Set the 'Authentication Preference' field in the message.
         * @param value_authentication_preference a #QmiWdsAuthentication.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_authentication_preference(value_authentication_preference: WdsAuthentication): boolean;
        /**
         * Set the 'Call Type' field in the message.
         * @param value_call_type a #QmiWdsCallType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_call_type(value_call_type: WdsCallType): boolean;
        /**
         * Set the 'Enable Autoconnect' field in the message.
         * @param value_enable_autoconnect a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_enable_autoconnect(value_enable_autoconnect: boolean): boolean;
        /**
         * Set the 'Extended Technology Preference' field in the message.
         * @param value_extended_technology_preference a #QmiWdsExtendedTechnologyPreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_extended_technology_preference(
            value_extended_technology_preference: WdsExtendedTechnologyPreference,
        ): boolean;
        /**
         * Set the 'IP Family Preference' field in the message.
         * @param value_ip_family_preference a #QmiWdsIpFamily.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ip_family_preference(value_ip_family_preference: WdsIpFamily): boolean;
        /**
         * Set the 'IPv4 Address Preference' field in the message.
         * @param value_ipv4_address_preference a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ipv4_address_preference(value_ipv4_address_preference: number): boolean;
        /**
         * Set the 'Password' field in the message.
         * @param value_password a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_password(value_password: string): boolean;
        /**
         * Set the 'Primary DNS Address Preference' field in the message.
         * @param value_primary_dns_address_preference a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_primary_dns_address_preference(value_primary_dns_address_preference: number): boolean;
        /**
         * Set the 'Primary NBNS Address Preference' field in the message.
         * @param value_primary_nbns_address_preference a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_primary_nbns_address_preference(value_primary_nbns_address_preference: number): boolean;
        /**
         * Set the 'Profile Index 3GPP' field in the message.
         * @param value_profile_index_3gpp a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_index_3gpp(value_profile_index_3gpp: number): boolean;
        /**
         * Set the 'Profile Index 3GPP2' field in the message.
         * @param value_profile_index_3gpp2 a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_index_3gpp2(value_profile_index_3gpp2: number): boolean;
        /**
         * Set the 'Secondary DNS Address Preference' field in the message.
         * @param value_secondary_dns_address_preference a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_secondary_dns_address_preference(value_secondary_dns_address_preference: number): boolean;
        /**
         * Set the 'Secondary NBNS Address Preference' field in the message.
         * @param value_secondary_nbns_address_preference a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_secondary_nbns_address_preference(value_secondary_nbns_address_preference: number): boolean;
        /**
         * Set the 'Technology Preference' field in the message.
         * @param value_technology_preference a #QmiWdsTechnologyPreference.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_technology_preference(value_technology_preference: WdsTechnologyPreference): boolean;
        /**
         * Set the 'Username' field in the message.
         * @param value_username a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_username(value_username: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsStartNetworkOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsStartNetworkOutput {
        static $gtype: GObject.GType<MessageWdsStartNetworkOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Call End Reason' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_call_end_reason(): [boolean, WdsCallEndReason | null];
        /**
         * Get the 'Packet Data Handle' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_packet_data_handle(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Verbose Call End Reason' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_verbose_call_end_reason(): [boolean, WdsVerboseCallEndReasonType | null, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsStartNetworkOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsStopNetworkInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsStopNetworkInput {
        static $gtype: GObject.GType<MessageWdsStopNetworkInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsStopNetworkInput;

        // Methods

        /**
         * Get the 'Disable Autoconnect' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_disable_autoconnect(): [boolean, boolean];
        /**
         * Get the 'Packet Data Handle' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_packet_data_handle(): [boolean, number];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsStopNetworkInput;
        /**
         * Set the 'Disable Autoconnect' field in the message.
         * @param value_disable_autoconnect a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_disable_autoconnect(value_disable_autoconnect: boolean): boolean;
        /**
         * Set the 'Packet Data Handle' field in the message.
         * @param value_packet_data_handle a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_packet_data_handle(value_packet_data_handle: number): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsStopNetworkOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsStopNetworkOutput {
        static $gtype: GObject.GType<MessageWdsStopNetworkOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsStopNetworkOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsSwiCreateProfileIndexedInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWdsSwiCreateProfileIndexedInput {
        static $gtype: GObject.GType<MessageWdsSwiCreateProfileIndexedInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWdsSwiCreateProfileIndexedInput;

        // Methods

        /**
         * Get the 'APN Disabled Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_disabled_flag(): [boolean, boolean];
        /**
         * Get the 'APN Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_apn_name(): [boolean, string];
        /**
         * Get the 'Authentication' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_authentication(): [boolean, WdsAuthentication | null];
        /**
         * Get the 'IPv4 Address Preference' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_ipv4_address_preference(): [boolean, number];
        /**
         * Get the 'Password' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_password(): [boolean, string];
        /**
         * Get the 'PDP Context Number' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_context_number(): [boolean, number];
        /**
         * Get the 'PDP Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_pdp_type(): [boolean, WdsPdpType | null];
        /**
         * Get the 'Primary IPv4 DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_primary_ipv4_dns_address(): [boolean, number];
        /**
         * Get the 'Profile Identifier' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_identifier(): [boolean, WdsProfileType | null, number];
        /**
         * Get the 'Profile Name' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_name(): [boolean, string];
        /**
         * Get the 'Roaming Disallowed Flag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_roaming_disallowed_flag(): [boolean, boolean];
        /**
         * Get the 'Secondary IPv4 DNS Address' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_secondary_ipv4_dns_address(): [boolean, number];
        /**
         * Get the 'Username' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_username(): [boolean, string];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsSwiCreateProfileIndexedInput;
        /**
         * Set the 'APN Disabled Flag' field in the message.
         * @param value_apn_disabled_flag a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn_disabled_flag(value_apn_disabled_flag: boolean): boolean;
        /**
         * Set the 'APN Name' field in the message.
         * @param value_apn_name a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_apn_name(value_apn_name: string): boolean;
        /**
         * Set the 'Authentication' field in the message.
         * @param value_authentication a #QmiWdsAuthentication.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_authentication(value_authentication: WdsAuthentication): boolean;
        /**
         * Set the 'IPv4 Address Preference' field in the message.
         * @param value_ipv4_address_preference a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_ipv4_address_preference(value_ipv4_address_preference: number): boolean;
        /**
         * Set the 'Password' field in the message.
         * @param value_password a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_password(value_password: string): boolean;
        /**
         * Set the 'PDP Context Number' field in the message.
         * @param value_pdp_context_number a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_context_number(value_pdp_context_number: number): boolean;
        /**
         * Set the 'PDP Type' field in the message.
         * @param value_pdp_type a #QmiWdsPdpType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_pdp_type(value_pdp_type: WdsPdpType): boolean;
        /**
         * Set the 'Primary IPv4 DNS Address' field in the message.
         * @param value_primary_ipv4_dns_address a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_primary_ipv4_dns_address(value_primary_ipv4_dns_address: number): boolean;
        /**
         * Set the 'Profile Identifier' field in the message.
         * @param value_profile_identifier_profile_type a #QmiWdsProfileType.
         * @param value_profile_identifier_profile_index a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_identifier(
            value_profile_identifier_profile_type: WdsProfileType,
            value_profile_identifier_profile_index: number,
        ): boolean;
        /**
         * Set the 'Profile Name' field in the message.
         * @param value_profile_name a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_profile_name(value_profile_name: string): boolean;
        /**
         * Set the 'Roaming Disallowed Flag' field in the message.
         * @param value_roaming_disallowed_flag a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_roaming_disallowed_flag(value_roaming_disallowed_flag: boolean): boolean;
        /**
         * Set the 'Secondary IPv4 DNS Address' field in the message.
         * @param value_secondary_ipv4_dns_address a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_secondary_ipv4_dns_address(value_secondary_ipv4_dns_address: number): boolean;
        /**
         * Set the 'Username' field in the message.
         * @param value_username a constant string.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_username(value_username: string): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWdsSwiCreateProfileIndexedOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWdsSwiCreateProfileIndexedOutput {
        static $gtype: GObject.GType<MessageWdsSwiCreateProfileIndexedOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Profile Identifier' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_profile_identifier(): [boolean, WdsProfileType | null, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWdsSwiCreateProfileIndexedOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsDeleteInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWmsDeleteInput {
        static $gtype: GObject.GType<MessageWmsDeleteInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWmsDeleteInput;

        // Methods

        /**
         * Get the 'Memory Index' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_memory_index(): [boolean, number];
        /**
         * Get the 'Memory Storage' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_memory_storage(): [boolean, WmsStorageType | null];
        /**
         * Get the 'Message Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_mode(): [boolean, WmsMessageMode | null];
        /**
         * Get the 'Message Tag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_tag(): [boolean, WmsMessageTagType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsDeleteInput;
        /**
         * Set the 'Memory Index' field in the message.
         * @param value_memory_index a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_memory_index(value_memory_index: number): boolean;
        /**
         * Set the 'Memory Storage' field in the message.
         * @param value_memory_storage a #QmiWmsStorageType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_memory_storage(value_memory_storage: WmsStorageType): boolean;
        /**
         * Set the 'Message Mode' field in the message.
         * @param value_message_mode a #QmiWmsMessageMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_message_mode(value_message_mode: WmsMessageMode): boolean;
        /**
         * Set the 'Message Tag' field in the message.
         * @param value_message_tag a #QmiWmsMessageTagType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_message_tag(value_message_tag: WmsMessageTagType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsDeleteOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsDeleteOutput {
        static $gtype: GObject.GType<MessageWmsDeleteOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsDeleteOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsGetMessageProtocolOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsGetMessageProtocolOutput {
        static $gtype: GObject.GType<MessageWmsGetMessageProtocolOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Message Protocol' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_protocol(): [boolean, WmsMessageProtocol | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsGetMessageProtocolOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsGetRoutesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsGetRoutesOutput {
        static $gtype: GObject.GType<MessageWmsGetRoutesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Get the 'Route List' field from `self`.
         *
         * Version of qmi_message_wms_get_routes_output_get_route_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_route_list(): [boolean, MessageWmsGetRoutesOutputRouteListElement[] | null];
        /**
         * Get the 'Transfer Status Report' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_transfer_status_report(): [boolean, WmsTransferIndication | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsGetRoutesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageWmsGetRoutesOutputRouteListElement struct.
     */
    class MessageWmsGetRoutesOutputRouteListElement {
        static $gtype: GObject.GType<MessageWmsGetRoutesOutputRouteListElement>;

        // Fields

        message_type: WmsMessageType;
        message_class: WmsMessageClass;
        storage: WmsStorageType;
        receipt_action: WmsReceiptAction;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageWmsGetSupportedMessagesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsGetSupportedMessagesOutput {
        static $gtype: GObject.GType<MessageWmsGetSupportedMessagesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'List' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_list(): [boolean, Uint8Array | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsGetSupportedMessagesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsListMessagesInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWmsListMessagesInput {
        static $gtype: GObject.GType<MessageWmsListMessagesInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWmsListMessagesInput;

        // Methods

        /**
         * Get the 'Message Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_mode(): [boolean, WmsMessageMode | null];
        /**
         * Get the 'Message Tag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_tag(): [boolean, WmsMessageTagType | null];
        /**
         * Get the 'Storage Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_storage_type(): [boolean, WmsStorageType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsListMessagesInput;
        /**
         * Set the 'Message Mode' field in the message.
         * @param value_message_mode a #QmiWmsMessageMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_message_mode(value_message_mode: WmsMessageMode): boolean;
        /**
         * Set the 'Message Tag' field in the message.
         * @param value_message_tag a #QmiWmsMessageTagType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_message_tag(value_message_tag: WmsMessageTagType): boolean;
        /**
         * Set the 'Storage Type' field in the message.
         * @param value_storage_type a #QmiWmsStorageType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_storage_type(value_storage_type: WmsStorageType): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsListMessagesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsListMessagesOutput {
        static $gtype: GObject.GType<MessageWmsListMessagesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Message List' field from `self`.
         *
         * Version of qmi_message_wms_list_messages_output_get_message_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_list(): [boolean, MessageWmsListMessagesOutputMessageListElement[] | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsListMessagesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageWmsListMessagesOutputMessageListElement struct.
     */
    class MessageWmsListMessagesOutputMessageListElement {
        static $gtype: GObject.GType<MessageWmsListMessagesOutputMessageListElement>;

        // Fields

        memory_index: number;
        message_tag: WmsMessageTagType;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageWmsModifyTagInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWmsModifyTagInput {
        static $gtype: GObject.GType<MessageWmsModifyTagInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWmsModifyTagInput;

        // Methods

        /**
         * Get the 'Message Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_mode(): [boolean, WmsMessageMode | null];
        /**
         * Get the 'Message Tag' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_tag(): [boolean, WmsStorageType | null, number, WmsMessageTagType | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsModifyTagInput;
        /**
         * Set the 'Message Mode' field in the message.
         * @param value_message_mode a #QmiWmsMessageMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_message_mode(value_message_mode: WmsMessageMode): boolean;
        /**
         * Set the 'Message Tag' field in the message.
         * @param value_message_tag_storage_type a #QmiWmsStorageType.
         * @param value_message_tag_memory_index a #guint32.
         * @param value_message_tag_message_tag a #QmiWmsMessageTagType.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_message_tag(
            value_message_tag_storage_type: WmsStorageType,
            value_message_tag_memory_index: number,
            value_message_tag_message_tag: WmsMessageTagType,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsModifyTagOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsModifyTagOutput {
        static $gtype: GObject.GType<MessageWmsModifyTagOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsModifyTagOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsRawReadInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWmsRawReadInput {
        static $gtype: GObject.GType<MessageWmsRawReadInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWmsRawReadInput;

        // Methods

        /**
         * Get the 'Message Memory Storage ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_memory_storage_id(): [boolean, WmsStorageType | null, number];
        /**
         * Get the 'Message Mode' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_mode(): [boolean, WmsMessageMode | null];
        /**
         * Get the 'SMS on IMS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sms_on_ims(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsRawReadInput;
        /**
         * Set the 'Message Memory Storage ID' field in the message.
         * @param value_message_memory_storage_id_storage_type a #QmiWmsStorageType.
         * @param value_message_memory_storage_id_memory_index a #guint32.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_message_memory_storage_id(
            value_message_memory_storage_id_storage_type: WmsStorageType,
            value_message_memory_storage_id_memory_index: number,
        ): boolean;
        /**
         * Set the 'Message Mode' field in the message.
         * @param value_message_mode a #QmiWmsMessageMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_message_mode(value_message_mode: WmsMessageMode): boolean;
        /**
         * Set the 'SMS on IMS' field in the message.
         * @param value_sms_on_ims a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_sms_on_ims(value_sms_on_ims: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsRawReadOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsRawReadOutput {
        static $gtype: GObject.GType<MessageWmsRawReadOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Raw Message Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_raw_message_data(): [boolean, WmsMessageTagType | null, WmsMessageFormat | null, Uint8Array | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsRawReadOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsRawSendInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWmsRawSendInput {
        static $gtype: GObject.GType<MessageWmsRawSendInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWmsRawSendInput;

        // Methods

        /**
         * Get the 'CDMA Follow On DC' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_follow_on_dc(): [boolean, boolean];
        /**
         * Get the 'CDMA Force On DC' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_force_on_dc(): [boolean, boolean, WmsCdmaServiceOption | null];
        /**
         * Get the 'GSM WCDMA Link Timer' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_wcdma_link_timer(): [boolean, number];
        /**
         * Get the 'Raw Message Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_raw_message_data(): [boolean, WmsMessageFormat | null, Uint8Array | null];
        /**
         * Get the 'SMS on IMS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sms_on_ims(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsRawSendInput;
        /**
         * Set the 'CDMA Follow On DC' field in the message.
         * @param value_cdma_follow_on_dc_follow a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_cdma_follow_on_dc(value_cdma_follow_on_dc_follow: boolean): boolean;
        /**
         * Set the 'CDMA Force On DC' field in the message.
         * @param value_cdma_force_on_dc_force a #gboolean.
         * @param value_cdma_force_on_dc_service_option a #QmiWmsCdmaServiceOption.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_cdma_force_on_dc(
            value_cdma_force_on_dc_force: boolean,
            value_cdma_force_on_dc_service_option: WmsCdmaServiceOption,
        ): boolean;
        /**
         * Set the 'GSM WCDMA Link Timer' field in the message.
         * @param value_gsm_wcdma_link_timer a #guint8.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_gsm_wcdma_link_timer(value_gsm_wcdma_link_timer: number): boolean;
        /**
         * Set the 'Raw Message Data' field in the message.
         * @param value_raw_message_data_format a #QmiWmsMessageFormat.
         * @param value_raw_message_data_raw_data a #GArray of #guint8 elements. A new reference to @value_raw_message_data_raw_data will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_raw_message_data(
            value_raw_message_data_format: WmsMessageFormat,
            value_raw_message_data_raw_data: Uint8Array | string,
        ): boolean;
        /**
         * Set the 'SMS on IMS' field in the message.
         * @param value_sms_on_ims a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_sms_on_ims(value_sms_on_ims: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsRawSendOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsRawSendOutput {
        static $gtype: GObject.GType<MessageWmsRawSendOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'CDMA Cause Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_cause_code(): [boolean, WmsCdmaCauseCode | null];
        /**
         * Get the 'CDMA Error Class' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_error_class(): [boolean, WmsCdmaErrorClass | null];
        /**
         * Get the 'GSM WCDMA Cause Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_wcdma_cause_info(): [boolean, WmsGsmUmtsRpCause | null, WmsGsmUmtsTpCause | null];
        /**
         * Get the 'Message Delivery Failure Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_delivery_failure_type(): [boolean, WmsMessageDeliveryFailureType | null];
        /**
         * Get the 'Message ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_id(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsRawSendOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsRawWriteInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWmsRawWriteInput {
        static $gtype: GObject.GType<MessageWmsRawWriteInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWmsRawWriteInput;

        // Methods

        /**
         * Get the 'Raw Message Data' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_raw_message_data(): [boolean, WmsStorageType | null, WmsMessageFormat | null, Uint8Array | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsRawWriteInput;
        /**
         * Set the 'Raw Message Data' field in the message.
         * @param value_raw_message_data_storage_type a #QmiWmsStorageType.
         * @param value_raw_message_data_format a #QmiWmsMessageFormat.
         * @param value_raw_message_data_raw_data a #GArray of #guint8 elements. A new reference to @value_raw_message_data_raw_data will be taken, so the caller must make sure the array was created with the correct #GDestroyNotify as clear function for each element in the array.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_raw_message_data(
            value_raw_message_data_storage_type: WmsStorageType,
            value_raw_message_data_format: WmsMessageFormat,
            value_raw_message_data_raw_data: Uint8Array | string,
        ): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsRawWriteOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsRawWriteOutput {
        static $gtype: GObject.GType<MessageWmsRawWriteOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Memory Index' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_memory_index(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsRawWriteOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsResetOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsResetOutput {
        static $gtype: GObject.GType<MessageWmsResetOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsResetOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsSendAckInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWmsSendAckInput {
        static $gtype: GObject.GType<MessageWmsSendAckInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWmsSendAckInput;

        // Methods

        /**
         * Get the '3GPP2 Failure Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_3gpp2_failure_information(): [boolean, WmsCdmaErrorClass | null, WmsCdmaCauseCode | null];
        /**
         * Get the '3GPP Failure Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_3gpp_failure_information(): [boolean, WmsGsmUmtsRpCause | null, WmsGsmUmtsTpCause | null];
        /**
         * Get the 'Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_information(): [boolean, number, WmsMessageProtocol | null, boolean];
        /**
         * Get the 'SMS on IMS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sms_on_ims(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsSendAckInput;
        /**
         * Set the '3GPP2 Failure Information' field in the message.
         * @param value_3gpp2_failure_information_error_class a #QmiWmsCdmaErrorClass.
         * @param value_3gpp2_failure_information_cause_code a #QmiWmsCdmaCauseCode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_3gpp2_failure_information(
            value_3gpp2_failure_information_error_class: WmsCdmaErrorClass,
            value_3gpp2_failure_information_cause_code: WmsCdmaCauseCode,
        ): boolean;
        /**
         * Set the '3GPP Failure Information' field in the message.
         * @param value_3gpp_failure_information_rp_cause a #QmiWmsGsmUmtsRpCause.
         * @param value_3gpp_failure_information_tp_cause a #QmiWmsGsmUmtsTpCause.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_3gpp_failure_information(
            value_3gpp_failure_information_rp_cause: WmsGsmUmtsRpCause,
            value_3gpp_failure_information_tp_cause: WmsGsmUmtsTpCause,
        ): boolean;
        /**
         * Set the 'Information' field in the message.
         * @param value_information_transaction_id a #guint32.
         * @param value_information_message_protocol a #QmiWmsMessageProtocol.
         * @param value_information_success a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_information(
            value_information_transaction_id: number,
            value_information_message_protocol: WmsMessageProtocol,
            value_information_success: boolean,
        ): boolean;
        /**
         * Set the 'SMS on IMS' field in the message.
         * @param value_sms_on_ims a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_sms_on_ims(value_sms_on_ims: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsSendAckOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsSendAckOutput {
        static $gtype: GObject.GType<MessageWmsSendAckOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'Failure Cause' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_failure_cause(): [boolean, WmsAckFailureCause | null];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsSendAckOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsSendFromMemoryStorageInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWmsSendFromMemoryStorageInput {
        static $gtype: GObject.GType<MessageWmsSendFromMemoryStorageInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWmsSendFromMemoryStorageInput;

        // Methods

        /**
         * Get the 'Information' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_information(): [boolean, WmsStorageType | null, number, WmsMessageMode | null];
        /**
         * Get the 'SMS on IMS' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_sms_on_ims(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsSendFromMemoryStorageInput;
        /**
         * Set the 'Information' field in the message.
         * @param value_information_storage_type a #QmiWmsStorageType.
         * @param value_information_memory_index a #guint32.
         * @param value_information_message_mode a #QmiWmsMessageMode.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_information(
            value_information_storage_type: WmsStorageType,
            value_information_memory_index: number,
            value_information_message_mode: WmsMessageMode,
        ): boolean;
        /**
         * Set the 'SMS on IMS' field in the message.
         * @param value_sms_on_ims a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_sms_on_ims(value_sms_on_ims: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsSendFromMemoryStorageOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsSendFromMemoryStorageOutput {
        static $gtype: GObject.GType<MessageWmsSendFromMemoryStorageOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the 'CDMA Cause Code' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_cause_code(): [boolean, WmsCdmaCauseCode | null];
        /**
         * Get the 'CDMA Error Class' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_cdma_error_class(): [boolean, WmsCdmaErrorClass | null];
        /**
         * Get the 'GSM WCDMA Cause Info' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_gsm_wcdma_cause_info(): [boolean, WmsGsmUmtsRpCause | null, WmsGsmUmtsTpCause | null];
        /**
         * Get the 'Message Delivery Failure Type' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_delivery_failure_type(): [boolean, WmsMessageDeliveryFailureType | null];
        /**
         * Get the 'Message ID' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_message_id(): [boolean, number];
        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsSendFromMemoryStorageOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsSetEventReportInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWmsSetEventReportInput {
        static $gtype: GObject.GType<MessageWmsSetEventReportInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWmsSetEventReportInput;

        // Methods

        /**
         * Get the 'New MT Message Indicator' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_new_mt_message_indicator(): [boolean, boolean];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsSetEventReportInput;
        /**
         * Set the 'New MT Message Indicator' field in the message.
         * @param value_new_mt_message_indicator_report a #gboolean.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_new_mt_message_indicator(value_new_mt_message_indicator_report: boolean): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsSetEventReportOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsSetEventReportOutput {
        static $gtype: GObject.GType<MessageWmsSetEventReportOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsSetEventReportOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * The #QmiMessageWmsSetRoutesInput structure contains private data and should only be accessed
     * using the provided API.
     */
    class MessageWmsSetRoutesInput {
        static $gtype: GObject.GType<MessageWmsSetRoutesInput>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        static ['new'](): MessageWmsSetRoutesInput;

        // Methods

        /**
         * Get the 'Route List' field from `self`.
         *
         * Version of qmi_message_wms_set_routes_input_get_route_list() using arrays of pointers to
         * structs instead of arrays of structs, for easier binding in other languages.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_route_list(): [boolean, MessageWmsSetRoutesInputRouteListElement[] | null];
        /**
         * Get the 'Transfer Status Report' field from `self`.
         * @returns %TRUE if the field is found, %FALSE otherwise.
         */
        get_transfer_status_report(): [boolean, WmsTransferIndication | null];
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsSetRoutesInput;
        /**
         * Set the 'Route List' field in the message.
         * @param value_route_list_ptr array of #QmiMessageWmsSetRoutesInputRouteListElement elements. The contents of the given array will be copied, the #GPtrArray will not increase its reference count.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_route_list(value_route_list_ptr: MessageWmsSetRoutesInputRouteListElement[]): boolean;
        /**
         * Set the 'Transfer Status Report' field in the message.
         * @param value_transfer_status_report a #QmiWmsTransferIndication.
         * @returns %TRUE if @value was successfully set, %FALSE otherwise.
         */
        set_transfer_status_report(value_transfer_status_report: WmsTransferIndication): boolean;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiMessageWmsSetRoutesInputRouteListElement struct.
     */
    class MessageWmsSetRoutesInputRouteListElement {
        static $gtype: GObject.GType<MessageWmsSetRoutesInputRouteListElement>;

        // Fields

        message_type: WmsMessageType;
        message_class: WmsMessageClass;
        storage: WmsStorageType;
        receipt_action: WmsReceiptAction;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The #QmiMessageWmsSetRoutesOutput structure contains private data and should only be accessed
     * using the provided API.
     */
    abstract class MessageWmsSetRoutesOutput {
        static $gtype: GObject.GType<MessageWmsSetRoutesOutput>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Get the result of the QMI operation.
         * @returns %TRUE if the QMI operation succeeded, %FALSE if @error is set.
         */
        get_result(): boolean;
        /**
         * Atomically increments the reference count of `self` by one.
         * @returns the new reference to @self.
         */
        ref(): MessageWmsSetRoutesOutput;
        /**
         * Atomically decrements the reference count of `self` by one.
         * If the reference count drops to 0, `self` is completely disposed.
         */
        unref(): void;
    }

    /**
     * A QmiPhysicalSlotInformationSlot struct.
     */
    class PhysicalSlotInformationSlot {
        static $gtype: GObject.GType<PhysicalSlotInformationSlot>;

        // Fields

        card_protocol: UimCardProtocol;
        valid_applications: number;
        atr_value: any[];
        is_euicc: boolean;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiPhysicalSlotStatusSlot struct.
     */
    class PhysicalSlotStatusSlot {
        static $gtype: GObject.GType<PhysicalSlotStatusSlot>;

        // Fields

        physical_card_status: UimPhysicalCardState;
        physical_slot_status: UimSlotState;
        logical_slot: number;
        iccid: any[];

        // Constructors

        _init(...args: any[]): void;
    }

    type ProxyClass = typeof Proxy;
    abstract class ProxyPrivate {
        static $gtype: GObject.GType<ProxyPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A QmiSlotEidElement struct.
     */
    class SlotEidElement {
        static $gtype: GObject.GType<SlotEidElement>;

        // Fields

        eid: any[];

        // Constructors

        constructor(
            properties?: Partial<{
                eid: any[];
            }>,
        );
        _init(...args: any[]): void;
    }

    type Message = GLib.ByteArray;
    /**
     * Name of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
     */
    const __name__: string;
    /**
     * Version of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
     */
    const __version__: string;
}

export default Qmi;

// END
