
/*
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in `ts-for-gir` or create a bug report on https://github.com/gjsify/ts-for-gir
 */

import './gcr-4-ambient.d.ts';
import './gcr-4-import.d.ts';
/**
 * Gcr-4
 */

import type Gio from '@girs/gio-2.0';
import type GObject from '@girs/gobject-2.0';
import type GLib from '@girs/glib-2.0';
import type Gck from '@girs/gck-2';

/**
 * The status of a built certificate chain. Will be set to
 * %GCR_CERTIFICATE_CHAIN_UNKNOWN for certificate chains that have not been
 * built.
 */
export enum CertificateChainStatus {
    /**
     * The certificate chain's status is unknown.
     * When a chain is not yet built it has this status. If a chain is modified after
     * being built, it has this status.
     */
    UNKNOWN,
    /**
     * A full chain could not be loaded. The
     * chain does not end with a self-signed certificate, a trusted anchor, or a
     * pinned certificate.
     */
    INCOMPLETE,
    /**
     * The certificate chain contains a revoked
     * or otherwise explicitly distrusted certificate. The entire chain should
     * be distrusted.
     */
    DISTRUSTED,
    /**
     * The chain ends with a self-signed
     * certificate. No trust anchor was found.
     */
    SELFSIGNED,
    /**
     * The chain represents a pinned certificate. A
     * pinned certificate is an exception which trusts a given certificate
     * explicitly for a purpose and communication with a certain peer.
     */
    PINNED,
    /**
     * The chain ends with an anchored
     * certificate. The anchored certificate is not necessarily self-signed.
     */
    ANCHORED,
}
/**
 * The format of a certificate request. Currently only PKCS#10 is supported.
 */
export enum CertificateRequestFormat {
    /**
     * certificate request is in PKCS#10 format
     */
    CERTIFICATE_REQUEST_PKCS10,
}
/**
 * Values responding to error codes for parsing and serializing data.
 */
export enum DataError {
    /**
     * Failed to parse or serialize the data
     */
    FAILURE,
    /**
     * The data was unrecognized or unsupported
     */
    UNRECOGNIZED,
    /**
     * The operation was cancelled
     */
    CANCELLED,
    /**
     * The data was encrypted or locked and could not be unlocked.
     */
    LOCKED,
}
/**
 * The various format identifiers.
 */
export enum DataFormat {
    /**
     * Represents all the formats, when enabling or disabling
     */
    ALL,
    /**
     * Not a valid format
     */
    INVALID,
    /**
     * DER encoded private key
     */
    DER_PRIVATE_KEY,
    /**
     * DER encoded RSA private key
     */
    DER_PRIVATE_KEY_RSA,
    /**
     * DER encoded DSA private key
     */
    DER_PRIVATE_KEY_DSA,
    /**
     * DER encoded EC private key
     */
    DER_PRIVATE_KEY_EC,
    /**
     * DER encoded SubjectPublicKeyInfo
     */
    DER_SUBJECT_PUBLIC_KEY,
    /**
     * DER encoded X.509 certificate
     */
    DER_CERTIFICATE_X509,
    /**
     * DER encoded PKCS#7 container file which can contain certificates
     */
    DER_PKCS7,
    /**
     * DER encoded PKCS#8 file which can contain a key
     */
    DER_PKCS8,
    /**
     * Unencrypted DER encoded PKCS#8 file which can contain a key
     */
    DER_PKCS8_PLAIN,
    /**
     * Encrypted DER encoded PKCS#8 file which can contain a key
     */
    DER_PKCS8_ENCRYPTED,
    /**
     * DER encoded PKCS#10 certificate request file
     */
    DER_PKCS10,
    /**
     * DER encoded SPKAC as generated by HTML5 keygen element
     */
    DER_SPKAC,
    /**
     * OpenSSL style SPKAC data
     */
    BASE64_SPKAC,
    /**
     * DER encoded PKCS#12 file which can contain certificates and/or keys
     */
    DER_PKCS12,
    /**
     * OpenSSH v1 or v2 public key
     */
    OPENSSH_PUBLIC,
    /**
     * OpenPGP key packet(s)
     */
    OPENPGP_PACKET,
    /**
     * OpenPGP public or private key armor encoded data
     */
    OPENPGP_ARMOR,
    /**
     * An OpenSSL style PEM file with unspecified contents
     */
    PEM,
    /**
     * An OpenSSL style PEM file with a private RSA key
     */
    PEM_PRIVATE_KEY_RSA,
    /**
     * An OpenSSL style PEM file with a private DSA key
     */
    PEM_PRIVATE_KEY_DSA,
    /**
     * An OpenSSL style PEM file with an X.509 certificate
     */
    PEM_CERTIFICATE_X509,
    /**
     * An OpenSSL style PEM file containing PKCS#7
     */
    PEM_PKCS7,
    /**
     * Unencrypted OpenSSL style PEM file containing PKCS#8
     */
    PEM_PKCS8_PLAIN,
    /**
     * Encrypted OpenSSL style PEM file containing PKCS#8
     */
    PEM_PKCS8_ENCRYPTED,
    /**
     * An OpenSSL style PEM file containing PKCS#12
     */
    PEM_PKCS12,
    /**
     * An OpenSSL style PEM file with a private key
     */
    PEM_PRIVATE_KEY,
    /**
     * An OpenSSL style PEM file containing PKCS#10
     */
    PEM_PKCS10,
    /**
     * An OpenSSL style PEM file with a private EC key
     */
    PEM_PRIVATE_KEY_EC,
    /**
     * An OpenSSL style PEM file containing a SubjectPublicKeyInfo
     */
    PEM_PUBLIC_KEY,
}
/**
 * Various replies returned by [method`Prompt`.confirm] and friends.
 */
export enum PromptReply {
    /**
     * the prompt was cancelled
     */
    CANCEL,
    /**
     * the user replied with 'ok'
     */
    CONTINUE,
}
/**
 * No error returned by the #GcrSystemPrompt is suitable for display or
 * to the user.
 * 
 * If the system prompter can only show one prompt at a time, and there is
 * already a prompt being displayed, and the timeout waiting to open the
 * prompt expires, then %GCR_SYSTEM_PROMPT_IN_PROGRESS is returned.
 */
export enum SystemPromptError {
    /**
     * another prompt is already in progress
     */
    SYSTEM_PROMPT_IN_PROGRESS,
}
/**
 * The mode for the system prompter. Most system prompters can only show
 * one prompt at a time and would use the %GCR_SYSTEM_PROMPTER_SINGLE mode.
 */
export enum SystemPrompterMode {
    /**
     * only one prompt shown at a time
     */
    SINGLE,
    /**
     * more than one prompt shown at a time
     */
    MULTIPLE,
}
/**
 * Flags to be used with the gcr_certificate_chain_build() operation.
 * @bitfield 
 */
export enum CertificateChainFlags {
    /**
     * no flags
     */
    NONE,
    /**
     * If this flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11.
     */
    NO_LOOKUPS,
}
export enum CertificateSectionFlags {
    NONE,
    IMPORTANT,
}
/**
 * The major version number of the Gcr library.
 */
export const MAJOR_VERSION: number
/**
 * The micro version number of the Gcr library.
 */
export const MICRO_VERSION: number
/**
 * The minor version number of the Gcr library.
 */
export const MINOR_VERSION: number
/**
 * The purpose used to verify the client certificate in a TLS connection.
 */
export const PURPOSE_CLIENT_AUTH: string | null
/**
 * The purpose used to verify certificate used for the signature on signed code.
 */
export const PURPOSE_CODE_SIGNING: string | null
/**
 * The purpose used to verify certificates that are used in email communication
 * such as S/MIME.
 */
export const PURPOSE_EMAIL: string | null
/**
 * The purpose used to verify the server certificate in a TLS connection. This
 * is the most common purpose in use.
 */
export const PURPOSE_SERVER_AUTH: string | null
/**
 * The current secret exchange protocol. Key agreement is done using DH with the
 * 1536 bit IKE parameter group. Keys are derived using SHA256 with HKDF. The
 * transport encryption is done with 128 bit AES.
 */
export const SECRET_EXCHANGE_PROTOCOL_1: string | null
export const UNLOCK_OPTION_ALWAYS: string | null
export const UNLOCK_OPTION_IDLE: string | null
export const UNLOCK_OPTION_SESSION: string | null
export const UNLOCK_OPTION_TIMEOUT: string | null
export function data_error_get_domain(): GLib.Quark
/**
 * Create a key fingerprint for a certificate, public key or private key.
 * Note that this is not a fingerprint of certificate data, which you would
 * use gcr_certificate_get_fingerprint() for.
 * @param attrs attributes for key or certificate
 * @param checksum_type the type of fingerprint to create
 * @returns the          fingerprint or %NULL if the input was invalid.
 */
export function fingerprint_from_attributes(attrs: Gck.Attributes, checksum_type: GLib.ChecksumType): Uint8Array | null
/**
 * Create a key fingerprint for a DER encoded subjectPublicKeyInfo. The
 * fingerprint is created so that it will be identical for a key and its
 * corresponding certificate.
 * 
 * Note that in the case of certificates this is not a fingerprint of the
 * actual certificate data, but rather of the public key contained in a
 * certificate.
 * @param key_info DER encoded subjectPublicKeyInfo structure
 * @param checksum_type the type of fingerprint to create
 * @returns the          fingerprint or %NULL if the input was invalid.
 */
export function fingerprint_from_subject_public_key_info(key_info: Uint8Array, checksum_type: GLib.ChecksumType): Uint8Array | null
/**
 * Create a set of importers which can import this parsed item.
 * The parsed item is represented by the state of the GcrParser at the
 * time of calling this method.
 * @param parsed a parser with a parsed item to import
 * @returns a list of importers          which can import the parsed item, which should be freed with          g_object_unref(), or %NULL if no types of importers can be created
 */
export function importer_create_for_parsed(parsed: Parsed): Importer[]
/**
 * Queues an additional item to be imported in all compattible importers
 * in the set. The parsed item is represented by the state of the #GcrParser
 * at the time of calling this method.
 * 
 * If the parsed item is incompatible with an importer, then that the item
 * will not be queued on that importer.
 * @param importers a set of importers
 * @param parsed a parsed item
 * @returns a new set of importers          that queued the item.
 */
export function importer_queue_and_filter_for_parsed(importers: Importer[], parsed: Parsed): Importer[]
/**
 * Register an importer to handle parsed items that match the given attributes.
 * @param importer_type the GType of the importer being registered
 * @param attrs the attributes that this importer is compatible with
 */
export function importer_register(importer_type: GObject.GType, attrs: Gck.Attributes): void
/**
 * Register built-in PKCS#11 and GnuPG importers.
 */
export function importer_register_well_known(): void
/**
 * Disconnect the mock prompter
 */
export function mock_prompter_disconnect(): void
/**
 * Queue an expected response on the mock prompter.
 * 
 * Expects any prompt, and closes the prompt when it gets it.
 */
export function mock_prompter_expect_close(): void
/**
 * Queue an expected response on the mock prompter.
 * 
 * Expects a confirmation prompt, and then cancels that prompt.
 */
export function mock_prompter_expect_confirm_cancel(): void
/**
 * Queue an expected response on the mock prompter.
 * 
 * Expects a password prompt, and then cancels that prompt.
 */
export function mock_prompter_expect_password_cancel(): void
/**
 * Get the delay in milliseconds before the mock prompter completes
 * an expected prompt.
 * @returns the delay
 */
export function mock_prompter_get_delay_msec(): number
/**
 * Check if the mock prompter is expecting a response. This will be %TRUE
 * when one of the <literal>gcr_mock_prompter_expect_xxx<!-- -->()</literal>
 * functions have been used to queue an expected prompt, but that prompt
 * response has not be 'used' yet.
 * @returns whether expecting a prompt
 */
export function mock_prompter_is_expecting(): boolean
/**
 * Check if the mock prompter is showing any prompts.
 * @returns whether prompting
 */
export function mock_prompter_is_prompting(): boolean
/**
 * Set the delay in milliseconds before the mock prompter completes
 * an expected prompt.
 * @param delay_msec prompt response delay in milliseconds
 */
export function mock_prompter_set_delay_msec(delay_msec: number): void
/**
 * Start the mock prompter. This is often used from the
 * <literal>setup<!-- -->()</literal> function of tests.
 * 
 * Starts the mock prompter in an additional thread. Use the returned DBus bus
 * name with gcr_system_prompt_open_for_prompter() to connect to this prompter.
 * @returns the bus name that the mock prompter is listening on
 */
export function mock_prompter_start(): string | null
/**
 * Stop the mock prompter. This is often used from the
 * <literal>teardown<!-- -->()</literal> function of tests.
 */
export function mock_prompter_stop(): void
/**
 * Unreferences a parsed item which was referenced with gcr_parsed_ref()
 * @param parsed a parsed item
 */
export function parsed_unref(parsed: any | null): void
/**
 * Add a #GckModule to the list of PKCS#11 modules that are used by the
 * GCR library.
 * 
 * It is not normally necessary to call this function. The available
 * PKCS#11 modules installed on the system are automatically loaded
 * by the GCR library.
 * @param module a #GckModule
 */
export function pkcs11_add_module(module: Gck.Module): void
/**
 * Initialize a PKCS#11 module and add it to the modules that are
 * used by the GCR library. Note that is an error to initialize the same
 * PKCS#11 module twice.
 * 
 * It is not normally necessary to call this function. The available
 * PKCS#11 modules installed on the system are automatically loaded
 * by the GCR library.
 * @param module_path the full file path of the PKCS#11 module
 * @param unused unused
 * @returns whether the module was sucessfully added.
 */
export function pkcs11_add_module_from_file(module_path: string | null, unused: any | null): boolean
/**
 * List all the PKCS#11 modules that are used by the GCR library.
 * Each module is a [class`Gck`.Module] object.
 * 
 * An empty list of modules will be returned if [func`pkcs1`1_set_modules],
 * or [func`pkcs1`1_initialize] has not yet run.
 * @returns a newly allocated list          of #GckModule objects
 */
export function pkcs11_get_modules(): Gck.Module[]
/**
 * List all the PKCS#11 slots that are used by the GCR library for lookup
 * of trust assertions. Each slot is a [class`Gck`.Slot] object.
 * 
 * This will return an empty list if the [func`pkcs1`1_initialize] function has
 * not yet been called.
 * @returns a list of #GckSlot          objects to use for lookup of trust, or the empty list if not          initialized or no appropriate trust stores could be found.
 */
export function pkcs11_get_trust_lookup_slots(): Gck.Slot[]
/**
 * Get the PKCS#11 URIs that are used to identify which slots to use for
 * lookup trust assertions.
 * @returns the uri which identifies trust storage slot
 */
export function pkcs11_get_trust_lookup_uris(): string[] | null
/**
 * Selects an appropriate PKCS#11 slot to store trust assertions. The slot
 * to use is normally configured automatically by the system.
 * 
 * This will only return a valid result after the [func`pkcs1`1_initialize]
 * method has been called.
 * 
 * When done with the #GckSlot, use g_object_unref() to release it.
 * @returns the #GckSlot to use for trust          assertions, or null if not initialized or no appropriate          trust store could be found.
 */
export function pkcs11_get_trust_store_slot(): Gck.Slot | null
/**
 * Get the PKCS#11 URI that is used to identify which slot to use for
 * storing trust storage.
 * @returns the uri which identifies trust storage slot
 */
export function pkcs11_get_trust_store_uri(): string | null
/**
 * Asynchronously initialize the registered PKCS#11 modules.
 * @param cancellable optional cancellable used to cancel the operation
 * @returns whether the operation was successful or not.
 */
export function pkcs11_initialize(cancellable: Gio.Cancellable | null): boolean
/**
 * Asynchronously initialize the registered PKCS#11 modules.
 * @param cancellable optional cancellable used to cancel the operation
 * @param callback callback which will be called when the operation completes
 */
export function pkcs11_initialize_async<Z = unknown>(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<Z> | null): void

// Overloads of pkcs11_initialize_async

/**
 * Promisified version of {@link pkcs11_initialize_async}
 * 
 * Asynchronously initialize the registered PKCS#11 modules.
 * @param cancellable optional cancellable used to cancel the operation
 * @returns A Promise of: whether the operation was successful or not.
 */
export function pkcs11_initialize_async<Z = unknown>(cancellable: Gio.Cancellable | null): globalThis.Promise<boolean>
/**
 * Complete the asynchronous operation to initialize the registered PKCS#11
 * modules.
 * @param result the asynchronous result
 * @returns whether the operation was successful or not.
 */
export function pkcs11_initialize_finish(result: Gio.AsyncResult): boolean
/**
 * Set the list of PKCS#11 modules that are used by the GCR library.
 * Each module in the list is a [class`Gck`.Module] object.
 * 
 * It is not normally necessary to call this function. The available
 * PKCS#11 modules installed on the system are automatically loaded
 * by the GCR library.
 * @param modules a list of PKCS#11 modules
 */
export function pkcs11_set_modules(modules: Gck.Module[]): void
/**
 * Set the PKCS#11 URIs that are used to identify which slots to use for
 * lookup of trust assertions.
 * 
 * It is not normally necessary to call this function. The relevant
 * PKCS#11 slots are automatically configured by the GCR library.
 * @param pkcs11_uris the uris which identifies trust lookup slots
 */
export function pkcs11_set_trust_lookup_uris(pkcs11_uris: string | null): void
/**
 * Set the PKCS#11 URI that is used to identify which slot to use for
 * storing trust assertions.
 * 
 * It is not normally necessary to call this function. The relevant
 * PKCS#11 slot is automatically configured by the GCR library.
 * @param pkcs11_uri the uri which identifies trust storage slot
 */
export function pkcs11_set_trust_store_uri(pkcs11_uri: string | null): void
/**
 * Add a pinned `certificate` for connections to `peer` for `purpose`. A pinned
 * certificate overrides all other certificate verification and should be
 * used with care.
 * 
 * If the same pinned certificate already exists, then this operation
 * does not add another, and succeeds without error.
 * 
 * This call may block, see gcr_trust_add_pinned_certificate_async() for the
 * non-blocking version.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 * @returns %TRUE if the pinned certificate is recorded successfully
 */
export function trust_add_pinned_certificate(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null): boolean
/**
 * Add a pinned certificate for communication with `peer` for `purpose`. A pinned
 * certificate overrides all other certificate verification and should be used
 * with care.
 * 
 * If the same pinned certificate already exists, then this operation
 * does not add another, and succeeds without error.
 * 
 * When the operation is finished, callback will be called. You can then call
 * [func`Gcr`.trust_add_pinned_certificate_finish] to get the result of the
 * operation.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
export function trust_add_pinned_certificate_async<Z = unknown>(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<Z> | null): void

// Overloads of trust_add_pinned_certificate_async

/**
 * Promisified version of {@link trust_add_pinned_certificate_async}
 * 
 * Add a pinned certificate for communication with `peer` for `purpose`. A pinned
 * certificate overrides all other certificate verification and should be used
 * with care.
 * 
 * If the same pinned certificate already exists, then this operation
 * does not add another, and succeeds without error.
 * 
 * When the operation is finished, callback will be called. You can then call
 * [func`Gcr`.trust_add_pinned_certificate_finish] to get the result of the
 * operation.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 * @returns A Promise of: %TRUE if the pinned certificate is recorded successfully
 */
export function trust_add_pinned_certificate_async<Z = unknown>(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null): globalThis.Promise<boolean>
/**
 * Finishes an asynchronous operation started by
 * gcr_trust_add_pinned_certificate_async().
 * @param result the #GAsyncResult passed to the callback
 * @returns %TRUE if the pinned certificate is recorded successfully
 */
export function trust_add_pinned_certificate_finish(result: Gio.AsyncResult): boolean
/**
 * Check if the `certificate` is a trust anchor for the given `purpose`. A trust
 * anchor is used to verify the signatures on other certificates when verifying
 * a certificate chain. Also known as a trusted certificate authority.
 * 
 * This call may block, see [func`Gcr`.trust_is_certificate_anchored_async] for
 * the non-blocking version.
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param cancellable a #GCancellable
 * @returns %TRUE if the certificate is a trust anchor
 */
export function trust_is_certificate_anchored(certificate: Certificate, purpose: string | null, cancellable: Gio.Cancellable | null): boolean
/**
 * Check if the `certificate` is a trust anchor for the given `purpose`. A trust
 * anchor is used to verify the signatures on other certificates when verifying
 * a certificate chain. Also known as a trusted certificate authority.
 * 
 * When the operation is finished, callback will be called. You can then call
 * gcr_trust_is_certificate_anchored_finish() to get the result of the operation.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
export function trust_is_certificate_anchored_async<Z = unknown>(certificate: Certificate, purpose: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<Z> | null): void

// Overloads of trust_is_certificate_anchored_async

/**
 * Promisified version of {@link trust_is_certificate_anchored_async}
 * 
 * Check if the `certificate` is a trust anchor for the given `purpose`. A trust
 * anchor is used to verify the signatures on other certificates when verifying
 * a certificate chain. Also known as a trusted certificate authority.
 * 
 * When the operation is finished, callback will be called. You can then call
 * gcr_trust_is_certificate_anchored_finish() to get the result of the operation.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param cancellable a #GCancellable
 * @returns A Promise of: %TRUE if the certificate is a trust anchor
 */
export function trust_is_certificate_anchored_async<Z = unknown>(certificate: Certificate, purpose: string | null, cancellable: Gio.Cancellable | null): globalThis.Promise<boolean>
/**
 * Finishes an asynchronous operation started by
 * gcr_trust_is_certificate_anchored_async().
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param result the #GAsyncResult passed to the callback
 * @returns %TRUE if the certificate is a trust anchor
 */
export function trust_is_certificate_anchored_finish(result: Gio.AsyncResult): boolean
/**
 * Checks whether the certificate that can be uniquely identified with the
 * given `serial_nr` and `issuer` is marked as distrusted (for example by the
 * user, or because it's part of a CRL).
 * 
 * Since we can't directly use [iface`Certificate]` to fetch these values, you
 * need to call these with the raw serial number and issuer as provided by the
 * PKCS#11 fields `CKA_SERIAL_NR` and `CKA_ISSUER`.
 * @param serial_nr The serial number of the certificate
 * @param issuer The raw issuer
 * @param cancellable a #GCancellable or %NULL
 * @returns %TRUE if the certificate is marked as distrusted
 */
export function trust_is_certificate_distrusted(serial_nr: Uint8Array, issuer: Uint8Array, cancellable: Gio.Cancellable | null): boolean
/**
 * Asynchronously checks whether the certificate that can be uniquely
 * identified with the given `serial_nr` and `issuer` is marked as distrusted
 * (for example by the user, or because it's part of a CRL).
 * 
 * Since we can't directly use [iface`Certificate]` to fetch these values, you
 * need to call these with the raw serial number and issuer as provided by the
 * PKCS#11 fields `CKA_SERIAL_NR` and `CKA_ISSUER`.
 * 
 * When the operation is finished, `callback` will be called. You can then call
 * [func`trust_is_certificate_distrusted_finish]` to get the result of the
 * operation.
 * @param serial_nr The serial number of the certificate
 * @param issuer The raw issuer
 * @param cancellable a #GCancellable or %NULL
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
export function trust_is_certificate_distrusted_async<Z = unknown>(serial_nr: Uint8Array, issuer: Uint8Array, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<Z> | null): void

// Overloads of trust_is_certificate_distrusted_async

/**
 * Promisified version of {@link trust_is_certificate_distrusted_async}
 * 
 * Asynchronously checks whether the certificate that can be uniquely
 * identified with the given `serial_nr` and `issuer` is marked as distrusted
 * (for example by the user, or because it's part of a CRL).
 * 
 * Since we can't directly use [iface`Certificate]` to fetch these values, you
 * need to call these with the raw serial number and issuer as provided by the
 * PKCS#11 fields `CKA_SERIAL_NR` and `CKA_ISSUER`.
 * 
 * When the operation is finished, `callback` will be called. You can then call
 * [func`trust_is_certificate_distrusted_finish]` to get the result of the
 * operation.
 * @param serial_nr The serial number of the certificate
 * @param issuer The raw issuer
 * @param cancellable a #GCancellable or %NULL
 * @returns A Promise of: %TRUE if the certificate is a trust anchor
 */
export function trust_is_certificate_distrusted_async<Z = unknown>(serial_nr: Uint8Array, issuer: Uint8Array, cancellable: Gio.Cancellable | null): globalThis.Promise<boolean>
/**
 * Finishes an asynchronous operation started by
 * [func`trust_is_certificate_distrusted_async]`.
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param result the #GAsyncResult passed to the callback
 * @returns %TRUE if the certificate is a trust anchor
 */
export function trust_is_certificate_distrusted_finish(result: Gio.AsyncResult): boolean
/**
 * Check if `certificate` is pinned for `purpose` to communicate with `peer`.
 * A pinned certificate overrides all other certificate verification.
 * 
 * This call may block, see gcr_trust_is_certificate_pinned_async() for the
 * non-blocking version.
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param peer the peer for this pinned
 * @param cancellable a #GCancellable
 * @returns %TRUE if the certificate is pinned for the host and purpose
 */
export function trust_is_certificate_pinned(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null): boolean
/**
 * Check if `certificate` is pinned for `purpose` to communicate with `peer`. A
 * pinned certificate overrides all other certificate verification.
 * 
 * When the operation is finished, callback will be called. You can then call
 * [func`Gcr`.trust_is_certificate_pinned_finish] to get the result of the
 * operation.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param peer the peer for this pinned
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
export function trust_is_certificate_pinned_async<Z = unknown>(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<Z> | null): void

// Overloads of trust_is_certificate_pinned_async

/**
 * Promisified version of {@link trust_is_certificate_pinned_async}
 * 
 * Check if `certificate` is pinned for `purpose` to communicate with `peer`. A
 * pinned certificate overrides all other certificate verification.
 * 
 * When the operation is finished, callback will be called. You can then call
 * [func`Gcr`.trust_is_certificate_pinned_finish] to get the result of the
 * operation.
 * @param certificate a #GcrCertificate to check
 * @param purpose the purpose string
 * @param peer the peer for this pinned
 * @param cancellable a #GCancellable
 * @returns A Promise of: %TRUE if the certificate is pinned.
 */
export function trust_is_certificate_pinned_async<Z = unknown>(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null): globalThis.Promise<boolean>
/**
 * Finishes an asynchronous operation started by
 * gcr_trust_is_certificate_pinned_async().
 * 
 * In the case of an error, %FALSE is also returned. Check `error` to detect
 * if an error occurred.
 * @param result the #GAsyncResult passed to the callback
 * @returns %TRUE if the certificate is pinned.
 */
export function trust_is_certificate_pinned_finish(result: Gio.AsyncResult): boolean
/**
 * Remove a pinned certificate for communication with `peer` for `purpose`.
 * 
 * If the same pinned certificate does not exist, or was already removed,
 * then this operation succeeds without error.
 * 
 * This call may block, see gcr_trust_remove_pinned_certificate_async() for the
 * non-blocking version.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 * @returns %TRUE if the pinned certificate no longer exists
 */
export function trust_remove_pinned_certificate(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null): boolean
/**
 * Remove a pinned certificate for communication with `peer` for `purpose`.
 * 
 * If the same pinned certificate does not exist, or was already removed,
 * then this operation succeeds without error.
 * 
 * When the operation is finished, callback will be called. You can then call
 * gcr_trust_remove_pinned_certificate_finish() to get the result of the
 * operation.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 * @param callback a #GAsyncReadyCallback to call when the operation completes
 */
export function trust_remove_pinned_certificate_async<Z = unknown>(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<Z> | null): void

// Overloads of trust_remove_pinned_certificate_async

/**
 * Promisified version of {@link trust_remove_pinned_certificate_async}
 * 
 * Remove a pinned certificate for communication with `peer` for `purpose`.
 * 
 * If the same pinned certificate does not exist, or was already removed,
 * then this operation succeeds without error.
 * 
 * When the operation is finished, callback will be called. You can then call
 * gcr_trust_remove_pinned_certificate_finish() to get the result of the
 * operation.
 * @param certificate a #GcrCertificate
 * @param purpose the purpose string
 * @param peer the peer for this pinned certificate
 * @param cancellable a #GCancellable
 * @returns A Promise of: %TRUE if the pinned certificate no longer exists
 */
export function trust_remove_pinned_certificate_async<Z = unknown>(certificate: Certificate, purpose: string | null, peer: string | null, cancellable: Gio.Cancellable | null): globalThis.Promise<boolean>
/**
 * Finishes an asynchronous operation started by
 * gcr_trust_remove_pinned_certificate_async().
 * @param result the #GAsyncResult passed to the callback
 * @returns %TRUE if the pinned certificate no longer exists
 */
export function trust_remove_pinned_certificate_finish(result: Gio.AsyncResult): boolean
export module Certificate {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface Certificate {

    // Own properties of Gcr-4.Gcr.Certificate

    /**
     * A readable description for this certificate
     */
    readonly description: string | null
    /**
     * The expiry date of the certificate
     */
    readonly expiry_date: GLib.DateTime
    /**
     * Common name part of the certificate issuer
     */
    readonly issuer_name: string | null
    /**
     * A readable label for this certificate.
     */
    readonly label: string | null
    readonly subject_name: string | null

    // Owm methods of Gcr-4.Gcr.Certificate

    /**
     * Get the basic constraints for the certificate if present. If %FALSE is
     * returned then no basic constraints are present and the `is_ca` and
     * `path_len` arguments are not changed.
     * @returns whether basic constraints are present or not
     */
    get_basic_constraints(): [ /* returnType */ boolean, /* is_ca */ boolean, /* path_len */ number ]
    /**
     * Gets the raw DER data for an X.509 certificate.
     * @returns raw DER data of the X.509 certificate
     */
    get_der_data(): Uint8Array
    /**
     * Get the expiry date of this certificate.
     * @returns An expiry date of this certificate.
     */
    get_expiry_date(): GLib.DateTime | null
    /**
     * Calculate the fingerprint for this certificate.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     * @param type the type of algorithm for the fingerprint.
     * @returns the raw binary fingerprint
     */
    get_fingerprint(type: GLib.ChecksumType): Uint8Array | null
    /**
     * Calculate the fingerprint for this certificate, and return it
     * as a hex string.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     * @param type the type of algorithm for the fingerprint.
     * @returns an allocated hex string which contains the fingerprint.
     */
    get_fingerprint_hex(type: GLib.ChecksumType): string | null
    /**
     * Get the list of sections from the certificate that can be shown to the user
     * interface.
     * @returns A #GList of #GcrCertificateSection
     */
    get_interface_elements(): CertificateSection[]
    /**
     * Get the issued date of this certificate.
     * @returns A issued date of this certificate.
     */
    get_issued_date(): GLib.DateTime | null
    /**
     * Get the common name of the issuer of this certificate.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @returns The allocated issuer CN, or %NULL if no issuer CN present.
     */
    get_issuer_cn(): string | null
    /**
     * Get the full issuer DN of the certificate as a (mostly)
     * readable string.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @returns The allocated issuer DN of the certificate.
     */
    get_issuer_dn(): string | null
    /**
     * Get a name to represent the issuer of this certificate.
     * 
     * This will try to lookup the common name, orianizational unit,
     * organization in that order.
     * @returns the allocated issuer name, or %NULL if no issuer name
     */
    get_issuer_name(): string | null
    /**
     * Get a part of the DN of the issuer of this certificate.
     * 
     * Examples of a `part` might be the 'OU' (organizational unit)
     * or the 'CN' (common name). Only the value of that part
     * of the DN is returned.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @param part a DN type string or OID.
     * @returns the allocated part of the issuer DN, or %NULL if no          such part is present
     */
    get_issuer_part(part: string | null): string | null
    /**
     * Get the raw DER data for the issuer DN of the certificate.
     * 
     * The data should be freed by using g_free() when no longer required.
     * @returns allocated memory          containing the raw issuer
     */
    get_issuer_raw(): Uint8Array | null
    /**
     * Get the key size in bits of the public key represented
     * by this certificate.
     * @returns The key size of the certificate.
     */
    get_key_size(): number
    /**
     * Get the raw binary serial number of the certificate.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     * @returns the raw binary serial number.
     */
    get_serial_number(): Uint8Array | null
    /**
     * Get the serial number of the certificate as a hex string.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     * @returns an allocated string containing the serial number as hex.
     */
    get_serial_number_hex(): string | null
    /**
     * Get the common name of the subject of this certificate.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @returns The allocated subject CN, or %NULL if no subject CN present.
     */
    get_subject_cn(): string | null
    /**
     * Get the full subject DN of the certificate as a (mostly)
     * readable string.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @returns The allocated subject DN of the certificate.
     */
    get_subject_dn(): string | null
    /**
     * Get a name to represent the subject of this certificate.
     * 
     * This will try to lookup the common name, orianizational unit,
     * organization in that order.
     * @returns the allocated subject name, or %NULL if no subject name
     */
    get_subject_name(): string | null
    /**
     * Get a part of the DN of the subject of this certificate.
     * 
     * Examples of a `part` might be the 'OU' (organizational unit)
     * or the 'CN' (common name). Only the value of that part
     * of the DN is returned.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     * @param part a DN type string or OID.
     * @returns the allocated part of the subject DN, or %NULL if no          such part is present.
     */
    get_subject_part(part: string | null): string | null
    /**
     * Get the raw DER data for the subject DN of the certificate.
     * 
     * The data should be freed by using g_free() when no longer required.
     * @returns allocated memory          containing the raw subject
     */
    get_subject_raw(): Uint8Array | null
    /**
     * Check if `issuer` could be the issuer of this certificate. This is done by
     * comparing the relevant subject and issuer fields. No signature check is
     * done. Proper verification of certificates must be done via a crypto
     * library.
     * @param issuer a possible issuer #GcrCertificate
     * @returns whether @issuer could be the issuer of the certificate.
     */
    is_issuer(issuer: Certificate): boolean
    /**
     * Implementers of the #GcrCertificate mixin should call this function to notify
     * when the certificate has changed to emit notifications on the various
     * properties.
     */
    mixin_emit_notify(): void

    // Own virtual methods of Gcr-4.Gcr.Certificate

    /**
     * Gets the raw DER data for an X.509 certificate.
     * @virtual 
     * @returns raw DER data of the X.509 certificate
     */
    vfunc_get_der_data(): Uint8Array

    // Class property signals of Gcr-4.Gcr.Certificate

    connect(sigName: "notify::description", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::expiry-date", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::expiry-date", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::expiry-date", ...args: any[]): void
    connect(sigName: "notify::issuer-name", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::issuer-name", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::issuer-name", ...args: any[]): void
    connect(sigName: "notify::label", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::subject-name", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::subject-name", callback: (($obj: Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::subject-name", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An interface that represents an X.509 certificate.
 * 
 * Objects can implement this interface to make a certificate usable with the
 * GCR library.
 * 
 * Various methods are available to parse out relevant bits of the certificate.
 * However no verification of the validity of a certificate is done here. Use
 * your favorite crypto library to do this.
 * 
 * You can use [class`SimpleCertificate]` to simply load a certificate for which
 * you already have the raw certificate data.
 * 
 * The #GcrCertificate interface has several properties that must be implemented.
 * You can use a mixin to implement these properties if desired. See the
 * gcr_certificate_mixin_class_init() and gcr_certificate_mixin_get_property()
 * functions.
 * @interface 
 */
export class Certificate extends GObject.Object {

    // Own properties of Gcr-4.Gcr.Certificate

    static name: string
    static $gtype: GObject.GType<Certificate>

    // Constructors of Gcr-4.Gcr.Certificate

    constructor(config?: Certificate.ConstructorProperties) 
    _init(config?: Certificate.ConstructorProperties): void
}

export module ImportInteraction {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.TlsInteraction.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

export interface ImportInteraction extends Gio.TlsInteraction {

    // Owm methods of Gcr-4.Gcr.ImportInteraction

    /**
     * Supplement attributes before import. This means prompting the user for
     * things like labels and the like. The needed attributes will have been passed
     * to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes. If the user or
     * cancellable cancels the operation the error should be set with %G_IO_ERROR_CANCELLED.
     * @param builder supplemented attributes
     * @param cancellable optional cancellable object
     * @returns %G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED
     */
    supplement(builder: Gck.Builder, cancellable: Gio.Cancellable | null): Gio.TlsInteractionResult
    /**
     * Asynchronously supplement attributes before import. This means prompting the
     * user for things like labels and the like. The needed attributes will have
     * been passed to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes.
     * @param builder supplemented attributes
     * @param cancellable optional cancellable object
     * @param callback called when the operation completes
     */
    supplement_async(builder: Gck.Builder, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<this> | null): void

    // Overloads of supplement_async

    /**
     * Promisified version of {@link supplement_async}
     * 
     * Asynchronously supplement attributes before import. This means prompting the
     * user for things like labels and the like. The needed attributes will have
     * been passed to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes.
     * @param builder supplemented attributes
     * @param cancellable optional cancellable object
     * @returns A Promise of: %G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED
     */
    supplement_async(builder: Gck.Builder, cancellable: Gio.Cancellable | null): globalThis.Promise<Gio.TlsInteractionResult>
    /**
     * Complete operation to asynchronously supplement attributes before import.
     * 
     * If the user or cancellable cancels the operation the error should be set
     * with %G_IO_ERROR_CANCELLED.
     * @param result the asynchronous result
     * @returns %G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED
     */
    supplement_finish(result: Gio.AsyncResult): Gio.TlsInteractionResult
    /**
     * Prepare for supplementing the given attributes before import. This means
     * prompting the user for things like labels and the like. The attributes
     * will contain attributes for values that the importer needs, either empty
     * or prefilled with suggested values.
     * 
     * This method does not prompt the user, but rather just prepares the
     * interaction that these are the attributes that are needed.
     * @param builder attributes to supplement
     */
    supplement_prep(builder: Gck.Builder): void

    // Own virtual methods of Gcr-4.Gcr.ImportInteraction

    /**
     * Supplement attributes before import. This means prompting the user for
     * things like labels and the like. The needed attributes will have been passed
     * to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes. If the user or
     * cancellable cancels the operation the error should be set with %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param builder supplemented attributes
     * @param cancellable optional cancellable object
     * @returns %G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED
     */
    vfunc_supplement(builder: Gck.Builder, cancellable: Gio.Cancellable | null): Gio.TlsInteractionResult
    /**
     * Asynchronously supplement attributes before import. This means prompting the
     * user for things like labels and the like. The needed attributes will have
     * been passed to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes.
     * @virtual 
     * @param builder supplemented attributes
     * @param cancellable optional cancellable object
     * @param callback called when the operation completes
     */
    vfunc_supplement_async(builder: Gck.Builder, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<this> | null): void
    /**
     * Complete operation to asynchronously supplement attributes before import.
     * 
     * If the user or cancellable cancels the operation the error should be set
     * with %G_IO_ERROR_CANCELLED.
     * @virtual 
     * @param result the asynchronous result
     * @returns %G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED
     */
    vfunc_supplement_finish(result: Gio.AsyncResult): Gio.TlsInteractionResult
    /**
     * Prepare for supplementing the given attributes before import. This means
     * prompting the user for things like labels and the like. The attributes
     * will contain attributes for values that the importer needs, either empty
     * or prefilled with suggested values.
     * 
     * This method does not prompt the user, but rather just prepares the
     * interaction that these are the attributes that are needed.
     * @virtual 
     * @param builder attributes to supplement
     */
    vfunc_supplement_prep(builder: Gck.Builder): void

    // Class property signals of Gcr-4.Gcr.ImportInteraction

    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * This is an interface implemented by a caller performing an import. It allows
 * the importer to ask the caller for further information about the import.
 * 
 * It must be implemented on a derived class of [class`Gio`.TlsInteraction]
 * @interface 
 */
export class ImportInteraction extends GObject.Object {

    // Own properties of Gcr-4.Gcr.ImportInteraction

    static name: string
    static $gtype: GObject.GType<ImportInteraction>

    // Constructors of Gcr-4.Gcr.ImportInteraction

    constructor(config?: ImportInteraction.ConstructorProperties) 
    _init(config?: ImportInteraction.ConstructorProperties): void
}

export module Importer {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-4.Gcr.Importer

        /**
         * The interaction for the importer.
         */
        interaction?: Gio.TlsInteraction | null
    }

}

export interface Importer {

    // Own properties of Gcr-4.Gcr.Importer

    /**
     * The interaction for the importer.
     */
    interaction: Gio.TlsInteraction
    /**
     * The label for the importer.
     */
    readonly label: string | null
    /**
     * The URI of the location imported to.
     */
    readonly uri: string | null

    // Owm methods of Gcr-4.Gcr.Importer

    /**
     * Get the interaction used to prompt the user when needed by this
     * importer.
     * @returns the interaction or %NULL
     */
    get_interaction(): Gio.TlsInteraction | null
    /**
     * Import the queued items in the importer. This function returns immediately
     * and completes asynchronously.
     * @param cancellable a #GCancellable, or %NULL
     * @param callback called when the operation completes
     */
    import_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<this> | null): void

    // Overloads of import_async

    /**
     * Promisified version of {@link import_async}
     * 
     * Import the queued items in the importer. This function returns immediately
     * and completes asynchronously.
     * @param cancellable a #GCancellable, or %NULL
     * @returns A Promise of: whether the import succeeded or failed
     */
    import_async(cancellable: Gio.Cancellable | null): globalThis.Promise<boolean>
    /**
     * Complete an asynchronous operation to import queued items.
     * @param result an asynchronous result
     * @returns whether the import succeeded or failed
     */
    import_finish(result: Gio.AsyncResult): boolean
    /**
     * Queues an additional item to be imported. The parsed item is represented
     * by the state of the [class`Parser]` at the time of calling this method.
     * 
     * If the parsed item is incompatible with the importer, then this will
     * fail and the item will not be queued.
     * @param parsed a parsed item to import
     * @returns whether the item was queued or not
     */
    queue_for_parsed(parsed: Parsed): boolean
    /**
     * Set the interaction used to prompt the user when needed by this
     * importer.
     * @param interaction the interaction used by the importer
     */
    set_interaction(interaction: Gio.TlsInteraction): void

    // Own virtual methods of Gcr-4.Gcr.Importer

    /**
     * Import the queued items in the importer. This function returns immediately
     * and completes asynchronously.
     * @virtual 
     * @param cancellable a #GCancellable, or %NULL
     * @param callback called when the operation completes
     */
    vfunc_import_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<this> | null): void
    /**
     * Complete an asynchronous operation to import queued items.
     * @virtual 
     * @param result an asynchronous result
     * @returns whether the import succeeded or failed
     */
    vfunc_import_finish(result: Gio.AsyncResult): boolean
    /**
     * Queues an additional item to be imported. The parsed item is represented
     * by the state of the [class`Parser]` at the time of calling this method.
     * 
     * If the parsed item is incompatible with the importer, then this will
     * fail and the item will not be queued.
     * @virtual 
     * @param parsed a parsed item to import
     * @returns whether the item was queued or not
     */
    vfunc_queue_for_parsed(parsed: Parsed): boolean

    // Class property signals of Gcr-4.Gcr.Importer

    connect(sigName: "notify::interaction", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interaction", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::interaction", ...args: any[]): void
    connect(sigName: "notify::label", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::uri", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::uri", callback: (($obj: Importer, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::uri", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An interface which allows importing of certificates and keys. Each importer
 * is registered with a set of PKCS#11 attributes to match stuff that it can
 * import.
 * 
 * An importer gets passed a [class`Parser]` and accesses the currently parsed
 * item. To create a set of importers that can import the currently parsed
 * item in a parser, use [func`Importer`.create_for_parsed]. The list of
 * importers returned has the parsed item queued for import.
 * 
 * To queue additional items with a importer use
 * [method`Importer`.queue_for_parsed].  In addition you can try and queue an
 * additional item with a set of importers using the
 * [func`Importer`.queue_and_filter_for_parsed].
 * 
 * To start the import, use [method`Importer`.import_async].
 * @interface 
 */
export class Importer extends GObject.Object {

    // Own properties of Gcr-4.Gcr.Importer

    static name: string
    static $gtype: GObject.GType<Importer>

    // Constructors of Gcr-4.Gcr.Importer

    constructor(config?: Importer.ConstructorProperties) 
    _init(config?: Importer.ConstructorProperties): void
    /**
     * Create a set of importers which can import this parsed item.
     * The parsed item is represented by the state of the GcrParser at the
     * time of calling this method.
     * @param parsed a parser with a parsed item to import
     * @returns a list of importers          which can import the parsed item, which should be freed with          g_object_unref(), or %NULL if no types of importers can be created
     */
    static create_for_parsed(parsed: Parsed): Importer[]
    /**
     * Queues an additional item to be imported in all compattible importers
     * in the set. The parsed item is represented by the state of the #GcrParser
     * at the time of calling this method.
     * 
     * If the parsed item is incompatible with an importer, then that the item
     * will not be queued on that importer.
     * @param importers a set of importers
     * @param parsed a parsed item
     * @returns a new set of importers          that queued the item.
     */
    static queue_and_filter_for_parsed(importers: Importer[], parsed: Parsed): Importer[]
    /**
     * Register an importer to handle parsed items that match the given attributes.
     * @param importer_type the GType of the importer being registered
     * @param attrs the attributes that this importer is compatible with
     */
    static register(importer_type: GObject.GType, attrs: Gck.Attributes): void
    /**
     * Register built-in PKCS#11 and GnuPG importers.
     */
    static register_well_known(): void
}

export module Prompt {

    // Signal callback interfaces

    /**
     * Signal callback interface for `prompt-close`
     */
    export interface PromptCloseSignalCallback {
        ($obj: Prompt): void
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-4.Gcr.Prompt

        /**
         * The string handle of the caller's window.
         * 
         * The caller window indicates to the prompt which window is prompting the
         * user. The prompt may choose to ignore this information or use it in whatever
         * way it sees fit.
         * 
         * In X11, this will be a stringified version of the XWindow handle; in
         * Wayland this is the result of an export using the XDG foreign
         * protocol.
         */
        caller_window?: string | null
        /**
         * The label for the cancel button in the prompt.
         */
        cancel_label?: string | null
        /**
         * Whether the additional choice is chosen or not.
         * 
         * The additional choice would have been setup using #GcrPrompt:choice-label.
         */
        choice_chosen?: boolean | null
        /**
         * The label for the additional choice.
         * 
         * If this is a non-%NULL value then an additional boolean choice will be
         * displayed by the prompt allowing the user to select or deselect it.
         * 
         * If %NULL, then no additional choice is displayed.
         * 
         * The initial value of the choice can be set with #GcrPrompt:choice-chosen.
         */
        choice_label?: string | null
        /**
         * The label for the continue button in the prompt.
         */
        continue_label?: string | null
        /**
         * The detailed description of the prompt.
         * 
         * A prompt implementation may choose not to display this detailed description.
         * The prompt message should contain relevant information.
         */
        description?: string | null
        /**
         * The prompt message for the user.
         * 
         * A prompt implementation should always display this message.
         */
        message?: string | null
        /**
         * Whether the prompt will prompt for a new password.
         * 
         * This will cause the prompt implementation to ask the user to confirm the
         * password and/or display other relevant user interface for creating a new
         * password.
         */
        password_new?: boolean | null
        /**
         * The title of the prompt.
         * 
         * A prompt implementation may choose not to display the prompt title. The
         * #GcrPrompt:message should contain relevant information.
         */
        title?: string | null
        /**
         * A prompt warning displayed on the prompt, or %NULL for no warning.
         * 
         * This is a warning like "The password is incorrect." usually displayed to the
         * user about a previous 'unsuccessful' prompt.
         */
        warning?: string | null
    }

}

export interface Prompt {

    // Own properties of Gcr-4.Gcr.Prompt

    /**
     * The string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     * 
     * In X11, this will be a stringified version of the XWindow handle; in
     * Wayland this is the result of an export using the XDG foreign
     * protocol.
     */
    caller_window: string | null
    /**
     * The label for the cancel button in the prompt.
     */
    cancel_label: string | null
    /**
     * Whether the additional choice is chosen or not.
     * 
     * The additional choice would have been setup using #GcrPrompt:choice-label.
     */
    choice_chosen: boolean
    /**
     * The label for the additional choice.
     * 
     * If this is a non-%NULL value then an additional boolean choice will be
     * displayed by the prompt allowing the user to select or deselect it.
     * 
     * If %NULL, then no additional choice is displayed.
     * 
     * The initial value of the choice can be set with #GcrPrompt:choice-chosen.
     */
    choice_label: string | null
    /**
     * The label for the continue button in the prompt.
     */
    continue_label: string | null
    /**
     * The detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * The prompt message should contain relevant information.
     */
    description: string | null
    /**
     * The prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     */
    message: string | null
    /**
     * Whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     */
    password_new: boolean
    /**
     * Indication of the password strength.
     * 
     * Prompts will return a zero value if the password is empty, and a value
     * greater than zero if the password has any characters.
     * 
     * This is only valid after a successful prompt for a password.
     */
    readonly password_strength: number
    /**
     * The title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * #GcrPrompt:message should contain relevant information.
     */
    title: string | null
    /**
     * A prompt warning displayed on the prompt, or %NULL for no warning.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     */
    warning: string | null

    // Owm methods of Gcr-4.Gcr.Prompt

    /**
     * Closes the prompt so that in can no longer be used to prompt. The various
     * prompt methods will return results as if the user dismissed the prompt.
     * 
     * The prompt may also be closed by the implementor of the prompt object.
     * 
     * This emits the [signal`Prompt:`:prompt-close] signal on the prompt object.
     */
    close(): void
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this function to
     * represent the question correctly.
     * 
     * This method will block until the a response is returned from the prompter.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     * @param cancellable optional cancellation object
     * @returns the reply from the prompt
     */
    confirm(cancellable: Gio.Cancellable | null): PromptReply
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this method to
     * represent the question correctly.
     * 
     * This method will return immediately and complete asynchronously.
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    confirm_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<this> | null): void

    // Overloads of confirm_async

    /**
     * Promisified version of {@link confirm_async}
     * 
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this method to
     * represent the question correctly.
     * 
     * This method will return immediately and complete asynchronously.
     * @param cancellable optional cancellation object
     * @returns A Promise of: the reply from the prompt
     */
    confirm_async(cancellable: Gio.Cancellable | null): globalThis.Promise<PromptReply>
    /**
     * Complete an operation to prompt for confirmation.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     * @param result asynchronous result passed to callback
     * @returns the reply from the prompt
     */
    confirm_finish(result: Gio.AsyncResult): PromptReply
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this function to
     * represent the question correctly.
     * 
     * This method will block until the a response is returned from the prompter
     * and will run a main loop similar to a `gtk_dialog_run()`. The application
     * will remain responsive but care must be taken to handle reentrancy issues.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     * @param cancellable optional cancellation object
     * @returns the reply from the prompt
     */
    confirm_run(cancellable: Gio.Cancellable | null): PromptReply
    /**
     * Get the string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     * @returns a newly allocated string containing the string          handle of the window.
     */
    get_caller_window(): string | null
    /**
     * Get the label for the cancel button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
     * from the prompt.
     * @returns a newly allocated string containing the label
     */
    get_cancel_label(): string | null
    /**
     * Get whether the additional choice was chosen or not.
     * 
     * The additional choice would have been setup using
     * gcr_prompt_set_choice_label().
     * @returns whether chosen
     */
    get_choice_chosen(): boolean
    /**
     * Get the label for the additional choice.
     * 
     * This will be %NULL if no additional choice is being displayed.
     * @returns a newly allocated string containing the additional          choice or %NULL
     */
    get_choice_label(): string | null
    /**
     * Get the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
     * from the prompt.
     * @returns a newly allocated string containing the label
     */
    get_continue_label(): string | null
    /**
     * Get the detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * The prompt message should contain relevant information.
     * @returns a newly allocated string containing the detailed          description of the prompt
     */
    get_description(): string | null
    /**
     * Gets the prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     * @returns a newly allocated string containing the detailed          description of the prompt
     */
    get_message(): string | null
    /**
     * Get whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     * @returns whether in new password mode or not
     */
    get_password_new(): boolean
    /**
     * Get indication of the password strength.
     * 
     * Prompts will return a zero value if the password is empty, and a value
     * greater than zero if the password has any characters.
     * 
     * This is only valid after a successful prompt for a password.
     * @returns zero if the password is empty, greater than zero if not
     */
    get_password_strength(): number
    /**
     * Gets the title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * prompt message should contain relevant information.
     * @returns a newly allocated string containing the prompt          title.
     */
    get_title(): string | null
    /**
     * Get a prompt warning displayed on the prompt.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     * 
     * If this string is %NULL then no warning is displayed.
     * @returns a newly allocated string containing the prompt          warning, or %NULL if no warning
     */
    get_warning(): string | null
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will block until the a response is returned from the prompter.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     * @param cancellable optional cancellation object
     * @returns the password owned by the prompt, or %NULL
     */
    password(cancellable: Gio.Cancellable | null): string | null
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will return immediately and complete asynchronously.
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    password_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<this> | null): void

    // Overloads of password_async

    /**
     * Promisified version of {@link password_async}
     * 
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will return immediately and complete asynchronously.
     * @param cancellable optional cancellation object
     * @returns A Promise of: the password owned by the prompt, or %NULL
     */
    password_async(cancellable: Gio.Cancellable | null): globalThis.Promise<string | null>
    /**
     * Complete an operation to prompt for a password.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     * @param result asynchronous result passed to callback
     * @returns the password owned by the prompt, or %NULL
     */
    password_finish(result: Gio.AsyncResult): string | null
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will block until the a response is returned from the prompter
     * and will run a main loop similar to a gtk_dialog_run(). The application
     * will remain responsive but care must be taken to handle reentrancy issues.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     * @param cancellable optional cancellation object
     * @returns the password owned by the prompt, or %NULL
     */
    password_run(cancellable: Gio.Cancellable | null): string | null
    /**
     * Reset the contents and properties of the prompt.
     */
    reset(): void
    /**
     * Set the string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     * @param window_id the window id
     */
    set_caller_window(window_id: string | null): void
    /**
     * Set the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
     * from the prompt.
     * @param cancel_label the label
     */
    set_cancel_label(cancel_label: string | null): void
    /**
     * Set whether the additional choice is chosen or not.
     * 
     * The additional choice should be set up using gcr_prompt_set_choice_label().
     * @param chosen whether chosen
     */
    set_choice_chosen(chosen: boolean): void
    /**
     * Set the label for the additional choice.
     * 
     * If this is a non-%NULL value then an additional boolean choice will be
     * displayed by the prompt allowing the user to select or deselect it.
     * 
     * The initial value of the choice can be set with the
     * gcr_prompt_set_choice_label() method.
     * 
     * If this is %NULL, then no additional choice is being displayed.
     * @param choice_label the additional choice or %NULL
     */
    set_choice_label(choice_label: string | null): void
    /**
     * Set the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
     * from the prompt.
     * @param continue_label the label
     */
    set_continue_label(continue_label: string | null): void
    /**
     * Set the detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * Use gcr_prompt_set_message() to set a general message containing relevant
     * information.
     * @param description the detailed description
     */
    set_description(description: string | null): void
    /**
     * Sets the prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     * @param message the prompt message
     */
    set_message(message: string | null): void
    /**
     * Set whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     * @param new_password whether in new password mode or not
     */
    set_password_new(new_password: boolean): void
    /**
     * Sets the title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * prompt message should contain relevant information.
     * @param title the prompt title
     */
    set_title(title: string | null): void
    /**
     * Set a prompt warning displayed on the prompt.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     * 
     * If this string is %NULL then no warning is displayed.
     * @param warning the warning or %NULL
     */
    set_warning(warning: string | null): void

    // Own virtual methods of Gcr-4.Gcr.Prompt

    vfunc_prompt_close(): void
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this method to
     * represent the question correctly.
     * 
     * This method will return immediately and complete asynchronously.
     * @virtual 
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    vfunc_prompt_confirm_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<this> | null): void
    /**
     * Complete an operation to prompt for confirmation.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     * @virtual 
     * @param result asynchronous result passed to callback
     * @returns the reply from the prompt
     */
    vfunc_prompt_confirm_finish(result: Gio.AsyncResult): PromptReply
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will return immediately and complete asynchronously.
     * @virtual 
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    vfunc_prompt_password_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<this> | null): void
    /**
     * Complete an operation to prompt for a password.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     * @virtual 
     * @param result asynchronous result passed to callback
     * @returns the password owned by the prompt, or %NULL
     */
    vfunc_prompt_password_finish(result: Gio.AsyncResult): string | null

    // Own signals of Gcr-4.Gcr.Prompt

    connect(sigName: "prompt-close", callback: Prompt.PromptCloseSignalCallback): number
    connect_after(sigName: "prompt-close", callback: Prompt.PromptCloseSignalCallback): number
    emit(sigName: "prompt-close", ...args: any[]): void

    // Class property signals of Gcr-4.Gcr.Prompt

    connect(sigName: "notify::caller-window", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::caller-window", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::caller-window", ...args: any[]): void
    connect(sigName: "notify::cancel-label", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cancel-label", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::cancel-label", ...args: any[]): void
    connect(sigName: "notify::choice-chosen", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::choice-chosen", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::choice-chosen", ...args: any[]): void
    connect(sigName: "notify::choice-label", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::choice-label", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::choice-label", ...args: any[]): void
    connect(sigName: "notify::continue-label", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::continue-label", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::continue-label", ...args: any[]): void
    connect(sigName: "notify::description", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::message", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::message", ...args: any[]): void
    connect(sigName: "notify::password-new", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-new", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::password-new", ...args: any[]): void
    connect(sigName: "notify::password-strength", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-strength", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::password-strength", ...args: any[]): void
    connect(sigName: "notify::title", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::title", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::title", ...args: any[]): void
    connect(sigName: "notify::warning", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::warning", callback: (($obj: Prompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::warning", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A prompt displayed to the user. It is an interface with various
 * implementations.
 * 
 * Various properties are set on the prompt, and then the prompt is displayed
 * the various prompt methods like [method`Prompt`.password_run].
 * 
 * A `GcrPrompt` may be used to display multiple related prompts. Most
 * implementions do not hide the window between display of multiple related
 * prompts, and the #GcrPrompt must be closed or destroyed in order to make
 * it go away. This allows the user to see that the prompts are related.
 * 
 * Use `GcrPromptDialog` (part of gcr-ui) to create an in-process GTK+ dialog
 * prompt. Use [class`SystemPrompt]` to create a system prompt in a prompter
 * process.
 * 
 * The prompt implementation will always display the [property`Prompt:`message]
 * property, but may choose not to display the [property`Prompt:`description] or
 * [property`Prompt:`title] properties.
 * @interface 
 */
export class Prompt extends GObject.Object {

    // Own properties of Gcr-4.Gcr.Prompt

    static name: string
    static $gtype: GObject.GType<Prompt>

    // Constructors of Gcr-4.Gcr.Prompt

    constructor(config?: Prompt.ConstructorProperties) 
    _init(config?: Prompt.ConstructorProperties): void
}

export module CertificateChain {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface CertificateChain {

    // Own properties of Gcr-4.Gcr.CertificateChain

    /**
     * The length of the certificate chain.
     */
    readonly length: number

    // Own fields of Gcr-4.Gcr.CertificateChain

    parent: GObject.Object

    // Owm methods of Gcr-4.Gcr.CertificateChain

    /**
     * Add `certificate` to the chain. The order of certificates in the chain are
     * important. The first certificate should be the endpoint certificate, and
     * then come the signers (certificate authorities) each in turn. If a root
     * certificate authority is present, it should come last.
     * 
     * Adding a certificate an already built chain (see
     * gcr_certificate_chain_build()) resets the type of the certificate chain
     * to %GCR_CERTIFICATE_CHAIN_UNKNOWN
     * @param certificate a #GcrCertificate to add to the chain
     */
    add(certificate: Certificate): void
    /**
     * Complete a certificate chain. Once a certificate chain has been built
     * its status can be examined.
     * 
     * This operation will lookup missing certificates in PKCS#11
     * modules and also that each certificate in the chain is the signer of the
     * previous one. If a trust anchor, pinned certificate, or self-signed certificate
     * is found, then the chain is considered built. Any extra certificates are
     * removed from the chain.
     * 
     * It's important to understand that building of a certificate chain does not
     * constitute verifying that chain. This is merely the first step towards
     * trust verification.
     * 
     * The `purpose` is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
     * for which the certificate chain will be used. Trust anchors are looked up
     * for this purpose. This argument is required.
     * 
     * The `peer` is usually the host name of the peer whith which this certificate
     * chain is being used. It is used to look up pinned certificates that have
     * been stored for this peer. If %NULL then no pinned certificates will
     * be considered.
     * 
     * If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11
     * 
     * This call will block, see gcr_certificate_chain_build_async() for the
     * asynchronous version.
     * @param purpose the purpose the certificate chain will be used for
     * @param peer the peer the certificate chain will be used with, or %NULL
     * @param flags chain completion flags
     * @param cancellable a #GCancellable or %NULL
     * @returns whether the operation completed successfully
     */
    build(purpose: string | null, peer: string | null, flags: CertificateChainFlags, cancellable: Gio.Cancellable | null): boolean
    /**
     * Complete a certificate chain. Once a certificate chain has been built
     * its status can be examined.
     * 
     * This will lookup missing certificates in PKCS#11
     * modules and also that each certificate in the chain is the signer of the
     * previous one. If a trust anchor, pinned certificate, or self-signed certificate
     * is found, then the chain is considered built. Any extra certificates are
     * removed from the chain.
     * 
     * It's important to understand that building of a certificate chain does not
     * constitute verifying that chain. This is merely the first step towards
     * trust verification.
     * 
     * The `purpose` is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
     * for which the certificate chain will be used. Trust anchors are looked up
     * for this purpose. This argument is required.
     * 
     * The `peer` is usually the host name of the peer whith which this certificate
     * chain is being used. It is used to look up pinned certificates that have
     * been stored for this peer. If %NULL then no pinned certificates will
     * be considered.
     * 
     * If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * gcr_certificate_chain_build_finish() to get the result of the operation.
     * @param purpose the purpose the certificate chain will be used for
     * @param peer the peer the certificate chain will be used with, or %NULL
     * @param flags chain completion flags
     * @param cancellable a #GCancellable or %NULL
     * @param callback this will be called when the operation completes.
     */
    build_async(purpose: string | null, peer: string | null, flags: CertificateChainFlags, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<this> | null): void

    // Overloads of build_async

    /**
     * Promisified version of {@link build_async}
     * 
     * Complete a certificate chain. Once a certificate chain has been built
     * its status can be examined.
     * 
     * This will lookup missing certificates in PKCS#11
     * modules and also that each certificate in the chain is the signer of the
     * previous one. If a trust anchor, pinned certificate, or self-signed certificate
     * is found, then the chain is considered built. Any extra certificates are
     * removed from the chain.
     * 
     * It's important to understand that building of a certificate chain does not
     * constitute verifying that chain. This is merely the first step towards
     * trust verification.
     * 
     * The `purpose` is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
     * for which the certificate chain will be used. Trust anchors are looked up
     * for this purpose. This argument is required.
     * 
     * The `peer` is usually the host name of the peer whith which this certificate
     * chain is being used. It is used to look up pinned certificates that have
     * been stored for this peer. If %NULL then no pinned certificates will
     * be considered.
     * 
     * If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * gcr_certificate_chain_build_finish() to get the result of the operation.
     * @param purpose the purpose the certificate chain will be used for
     * @param peer the peer the certificate chain will be used with, or %NULL
     * @param flags chain completion flags
     * @param cancellable a #GCancellable or %NULL
     * @returns A Promise of: whether the operation succeeded
     */
    build_async(purpose: string | null, peer: string | null, flags: CertificateChainFlags, cancellable: Gio.Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finishes an asynchronous operation started by
     * gcr_certificate_chain_build_async().
     * @param result the #GAsyncResult passed to the callback
     * @returns whether the operation succeeded
     */
    build_finish(result: Gio.AsyncResult): boolean
    /**
     * If the certificate chain has been built and is of status
     * %GCR_CERTIFICATE_CHAIN_ANCHORED, then this will return the anchor
     * certificate that was found. This is not necessarily a root certificate
     * authority. If an intermediate certificate authority in the chain was
     * found to be anchored, then that certificate will be returned.
     * 
     * If an anchor is returned it does not mean that the certificate chain has
     * been verified, but merely that an anchor has been found.
     * @returns the anchor certificate, or %NULL if not anchored.
     */
    get_anchor(): Certificate
    /**
     * Get a certificate in the chain. It is an error to call this function
     * with an invalid index.
     * @param index index of the certificate to get
     * @returns the certificate
     */
    get_certificate(index: number): Certificate
    /**
     * Get the endpoint certificate in the chain. This is always the first
     * certificate in the chain. The endpoint certificate cannot be anchored.
     * @returns the endpoint certificate, or %NULL if the chain          is empty
     */
    get_endpoint(): Certificate
    /**
     * Get the length of the certificate chain.
     * @returns the length of the certificate chain
     */
    get_length(): number
    /**
     * Get the status of a certificate chain. If the certificate chain has not
     * been built, then the status will be %GCR_CERTIFICATE_CHAIN_UNKNOWN.
     * 
     * A status of %GCR_CERTIFICATE_CHAIN_ANCHORED does not mean that the
     * certificate chain has been verified, but merely that an anchor has been
     * found.
     * @returns the status of the certificate chain.
     */
    get_status(): CertificateChainStatus

    // Class property signals of Gcr-4.Gcr.CertificateChain

    connect(sigName: "notify::length", callback: (($obj: CertificateChain, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::length", callback: (($obj: CertificateChain, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::length", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Represents a chain of certificates, normally used to
 * validate the trust in a certificate. An X.509 certificate chain has one
 * endpoint certificate (the one for which trust is being verified) and then
 * in turn the certificate that issued each previous certificate in the chain.
 * 
 * This functionality is for building of certificate chains not for validating
 * them. Use your favorite crypto library to validate trust in a certificate
 * chain once its built.
 * 
 * The order of certificates in the chain should be first the endpoint
 * certificates and then the signing certificates.
 * 
 * Create a new certificate chain with [ctor`CertificateChain`.new] and then
 * add the certificates with [method`CertificateChain`.add].
 * 
 * You can then use [method`CertificateChain`.build] to build the remainder of
 * the chain. This will lookup missing certificates in PKCS#11 modules and
 * also check that each certificate in the chain is the signer of the previous
 * one. If a trust anchor, pinned certificate, or self-signed certificate is
 * found, then the chain is considered built. Any extra certificates are
 * removed from the chain.
 * 
 * Once the certificate chain has been built, you can access its status
 * through [method`CertificateChain`.get_status]. The status signifies whether
 * the chain is anchored on a trust root, self-signed, incomplete etc. See
 * [enum`CertificateChainStatus]` for information on the various statuses.
 * 
 * It's important to understand that the building of a certificate chain is
 * merely the first step towards verifying trust in a certificate.
 * @class 
 */
export class CertificateChain extends GObject.Object {

    // Own properties of Gcr-4.Gcr.CertificateChain

    static name: string
    static $gtype: GObject.GType<CertificateChain>

    // Constructors of Gcr-4.Gcr.CertificateChain

    constructor(config?: CertificateChain.ConstructorProperties) 
    /**
     * Create a new #GcrCertificateChain.
     * @constructor 
     * @returns a newly allocated certificate chain
     */
    constructor() 
    /**
     * Create a new #GcrCertificateChain.
     * @constructor 
     * @returns a newly allocated certificate chain
     */
    static new(): CertificateChain
    _init(config?: CertificateChain.ConstructorProperties): void
}

export module CertificateField {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-4.Gcr.CertificateField

        label?: string | null
        section?: CertificateSection | null
    }

}

export interface CertificateField {

    // Own properties of Gcr-4.Gcr.CertificateField

    readonly label: string | null
    readonly section: CertificateSection
    readonly value: any

    // Owm methods of Gcr-4.Gcr.CertificateField

    /**
     * Get the display label of the field.
     * @returns the display label of the field
     */
    get_label(): string | null
    /**
     * Get the parent #GcrCertificateSection.
     * @returns the parent #GcrCertificateSection
     */
    get_section(): CertificateSection
    /**
     * Get the value of the field.
     * 
     * The `value` will have been initialized to the `GType` the value should be
     * provided in.
     * @returns %TRUE if the value was set successfully.
     */
    get_value(): [ /* returnType */ boolean, /* value */ any ]
    /**
     * Get the type associated with the value.
     * @returns The `GType` of the value
     */
    get_value_type(): GObject.GType

    // Class property signals of Gcr-4.Gcr.CertificateField

    connect(sigName: "notify::label", callback: (($obj: CertificateField, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: (($obj: CertificateField, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::section", callback: (($obj: CertificateField, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::section", callback: (($obj: CertificateField, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::section", ...args: any[]): void
    connect(sigName: "notify::value", callback: (($obj: CertificateField, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::value", callback: (($obj: CertificateField, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::value", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

export class CertificateField extends GObject.Object {

    // Own properties of Gcr-4.Gcr.CertificateField

    static name: string
    static $gtype: GObject.GType<CertificateField>

    // Constructors of Gcr-4.Gcr.CertificateField

    constructor(config?: CertificateField.ConstructorProperties) 
    _init(config?: CertificateField.ConstructorProperties): void
}

export module CertificateRequest {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-4.Gcr.CertificateRequest

        /**
         * The private key that this certificate request is for.
         */
        private_key?: Gck.Object | null
    }

}

export interface CertificateRequest {

    // Own properties of Gcr-4.Gcr.CertificateRequest

    /**
     * The private key that this certificate request is for.
     */
    readonly private_key: Gck.Object

    // Owm methods of Gcr-4.Gcr.CertificateRequest

    /**
     * Complete and sign a certificate request, so that it can be encoded
     * and sent to a certificate authority.
     * 
     * This call may block as it signs the request using the private key.
     * @param cancellable a cancellation object
     * @returns whether certificate request was successfully completed or not
     */
    complete(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously complete and sign a certificate request, so that it can
     * be encoded and sent to a certificate authority.
     * 
     * This call will return immediately and complete later.
     * @param cancellable a cancellation object
     * @param callback called when the operation completes
     */
    complete_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<this> | null): void

    // Overloads of complete_async

    /**
     * Promisified version of {@link complete_async}
     * 
     * Asynchronously complete and sign a certificate request, so that it can
     * be encoded and sent to a certificate authority.
     * 
     * This call will return immediately and complete later.
     * @param cancellable a cancellation object
     * @returns A Promise of: whether certificate request was successfully completed or not
     */
    complete_async(cancellable: Gio.Cancellable | null): globalThis.Promise<boolean>
    /**
     * Finish an asynchronous operation to complete and sign a certificate
     * request.
     * @param result result of the asynchronous operation
     * @returns whether certificate request was successfully completed or not
     */
    complete_finish(result: Gio.AsyncResult): boolean
    /**
     * Encode the certificate request. It must have been completed with
     * [method`CertificateRequest`.complete] or
     * [method`CertificateRequest`.complete_async].
     * 
     * If `textual` is %FALSE, the output is a DER encoded certificate request.
     * 
     * If `textual` is %TRUE, the output is encoded as text. For PKCS#10 requests
     * this is done using the OpenSSL style PEM encoding.
     * @param textual whether to encode output as text
     * @returns the encoded certificate request
     */
    encode(textual: boolean): Uint8Array
    /**
     * Get the format of this certificate request.
     * @returns the format
     */
    get_format(): CertificateRequestFormat
    /**
     * Get the private key this certificate request is for.
     * @returns the private key,
     */
    get_private_key(): Gck.Object
    /**
     * Set the common name encoded in the certificate request.
     * @param cn common name to set on the request
     */
    set_cn(cn: string | null): void

    // Class property signals of Gcr-4.Gcr.CertificateRequest

    connect(sigName: "notify::private-key", callback: (($obj: CertificateRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::private-key", callback: (($obj: CertificateRequest, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::private-key", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An object that allows creation of certificate requests. A certificate
 * request is sent to a certificate authority to request an X.509 certificate.
 * 
 * Use [func`CertificateRequest`.prepare] to create a blank certificate
 * request for a given private key. Set the common name on the certificate
 * request with [method`CertificateRequest`.set_cn], and then sign the request
 * with [method`CertificateRequest`.complete_async].
 * @class 
 */
export class CertificateRequest extends GObject.Object {

    // Own properties of Gcr-4.Gcr.CertificateRequest

    static name: string
    static $gtype: GObject.GType<CertificateRequest>

    // Constructors of Gcr-4.Gcr.CertificateRequest

    constructor(config?: CertificateRequest.ConstructorProperties) 
    _init(config?: CertificateRequest.ConstructorProperties): void
    /**
     * Check whether [class`CertificateRequest]` is capable of creating a request
     * for the given `private_key`.
     * @param private_key a private key
     * @param cancellable cancellation object
     * @returns whether a request can be created
     */
    static capable(private_key: Gck.Object, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously check whether [class`CertificateRequest]` is capable of
     * creating a request for the given `private_key`.
     * @param private_key a private key
     * @param cancellable cancellation object
     * @param callback will be called when the operation completes
     */
    static capable_async(private_key: Gck.Object, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<CertificateRequest> | null): void
    /**
     * Get the result for asynchronously check whether [class`CertificateRequest]` is
     * capable of creating a request for the given `private_key`.
     * @param result asynchronous result
     * @returns whether a request can be created
     */
    static capable_finish(result: Gio.AsyncResult): boolean
    /**
     * Create a new certificate request, in the given format for the private key.
     * @param format the format for the certificate request
     * @param private_key the private key the the certificate is being requested for
     * @returns a new #GcrCertificate request
     */
    static prepare(format: CertificateRequestFormat, private_key: Gck.Object): CertificateRequest
}

export module CertificateSection {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-4.Gcr.CertificateSection

        label?: string | null
    }

}

export interface CertificateSection {

    // Own properties of Gcr-4.Gcr.CertificateSection

    readonly fields: Gio.ListModel
    readonly label: string | null

    // Owm methods of Gcr-4.Gcr.CertificateSection

    /**
     * Get the list of all the fields in this section.
     * @returns a #GListModel of #GcrCertificateField
     */
    get_fields(): Gio.ListModel
    /**
     * Get the flags.
     * @returns the `GcrCertificateSectionFlags`
     */
    get_flags(): CertificateSectionFlags
    /**
     * Get the displayable label of the section.
     * @returns the displayable label of the section
     */
    get_label(): string | null

    // Class property signals of Gcr-4.Gcr.CertificateSection

    connect(sigName: "notify::fields", callback: (($obj: CertificateSection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::fields", callback: (($obj: CertificateSection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::fields", ...args: any[]): void
    connect(sigName: "notify::label", callback: (($obj: CertificateSection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: (($obj: CertificateSection, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

export class CertificateSection extends GObject.Object {

    // Own properties of Gcr-4.Gcr.CertificateSection

    static name: string
    static $gtype: GObject.GType<CertificateSection>

    // Constructors of Gcr-4.Gcr.CertificateSection

    constructor(config?: CertificateSection.ConstructorProperties) 
    _init(config?: CertificateSection.ConstructorProperties): void
}

export module Parser {

    // Signal callback interfaces

    /**
     * Signal callback interface for `authenticate`
     */
    export interface AuthenticateSignalCallback {
        ($obj: Parser, count: number): boolean
    }

    /**
     * Signal callback interface for `parsed`
     */
    export interface ParsedSignalCallback {
        ($obj: Parser): void
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface Parser {

    // Own properties of Gcr-4.Gcr.Parser

    /**
     * Get the attributes that make up the currently parsed item. This is
     * generally only valid during a [signal`Parser:`:parsed] signal.
     */
    readonly parsed_attributes: Gck.Attributes
    /**
     * The description of the type of the currently parsed item. This is generally
     * only valid during a [signal`Parser:`:parsed] signal.
     */
    readonly parsed_description: string | null
    /**
     * The label of the currently parsed item. This is generally
     * only valid during a [signal`Parser:`:parsed] signal.
     */
    readonly parsed_label: string | null

    // Own fields of Gcr-4.Gcr.Parser

    parent: GObject.Object

    // Owm methods of Gcr-4.Gcr.Parser

    /**
     * Add a password to the set of passwords to try when parsing locked or encrypted
     * items. This is usually called from the [signal`Parser:`:authenticate] signal.
     * @param password a password to try
     */
    add_password(password: string | null): void
    /**
     * Disable parsing of the given format. Use %GCR_FORMAT_ALL to disable all the formats.
     * @param format The format identifier
     */
    format_disable(format: DataFormat): void
    /**
     * Enable parsing of the given format. Use %GCR_FORMAT_ALL to enable all the formats.
     * @param format The format identifier
     */
    format_enable(format: DataFormat): void
    /**
     * Check whether the given format is supported by the parser.
     * @param format The format identifier
     * @returns Whether the format is supported.
     */
    format_supported(format: DataFormat): boolean
    /**
     * Get the filename of the parser item.
     * @returns the filename set on the parser, or %NULL
     */
    get_filename(): string | null
    /**
     * Get the currently parsed item
     * @returns the currently parsed item
     */
    get_parsed(): Parsed
    /**
     * Get the attributes which make up the currently parsed item. This is generally
     * only valid during the [signal`Parser:`:parsed] signal.
     * @returns the attributes for the current item,          which are owned by the parser and should not be freed
     */
    get_parsed_attributes(): Gck.Attributes | null
    /**
     * Get the raw data block that represents this parsed object. This is only
     * valid during the [signal`Parser:`:parsed] signal.
     * @returns the raw data          block of the currently parsed item; the value is owned by the parser          and should not be freed
     */
    get_parsed_block(): Uint8Array | null
    /**
     * Get the raw data block that represents this parsed object. This is only
     * valid during the [signal`Parser:`:parsed] signal.
     * @returns the raw data block of the currently parsed item
     */
    get_parsed_bytes(): GLib.Bytes
    /**
     * Get a description for the type of the currently parsed item. This is generally
     * only valid during the [signal`Parser:`:parsed] signal.
     * @returns the description for the current item; this is owned by          the parser and should not be freed
     */
    get_parsed_description(): string | null
    /**
     * Get the format of the raw data block that represents this parsed object.
     * This corresponds with the data returned from
     * [method`Parser`.get_parsed_block].
     * 
     * This is only valid during the [signal`Parser:`:parsed] signal.
     * @returns the data format of the currently parsed item
     */
    get_parsed_format(): DataFormat
    /**
     * Get the label of the currently parsed item. This is generally only valid
     * during the [signal`Parser:`:parsed] signal.
     * @returns the label of the currently parsed item. The value is          owned by the parser and should not be freed.
     */
    get_parsed_label(): string | null
    /**
     * Parse the data. The [signal`Parser:`:parsed] and
     * [signal`Parser:`:authenticate] signals may fire during the parsing.
     * @param data the data to parse
     * @returns Whether the data was parsed successfully or not.
     */
    parse_bytes(data: GLib.Bytes): boolean
    /**
     * Parse the data. The [signal`Parser:`:parsed] and [signal`Parser:`:authenticate]
     * signals may fire during the parsing.
     * 
     * A copy of the data will be made. Use [method`Parser`.parse_bytes] to avoid
     * this.
     * @param data the data to parse
     * @returns Whether the data was parsed successfully or not.
     */
    parse_data(data: Uint8Array): boolean
    /**
     * Parse items from the data in a #GInputStream. This function may block while
     * reading from the input stream. Use [method`Parser`.parse_stream_async] for
     * a non-blocking variant.
     * 
     * The [signal`Parser:`:parsed] and [signal`Parser:`:authenticate] signals
     * may fire during the parsing.
     * @param input The input stream
     * @param cancellable An optional cancellation object
     * @returns Whether the parsing completed successfully or not.
     */
    parse_stream(input: Gio.InputStream, cancellable: Gio.Cancellable | null): boolean
    /**
     * Parse items from the data in a #GInputStream. This function completes
     * asyncronously and doesn't block.
     * 
     * The [signal`Parser:`:parsed] and [signal`Parser:`:authenticate] signals
     * may fire during the parsing.
     * @param input The input stream
     * @param cancellable An optional cancellation object
     * @param callback Called when the operation result is ready.
     */
    parse_stream_async(input: Gio.InputStream, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<this> | null): void

    // Overloads of parse_stream_async

    /**
     * Promisified version of {@link parse_stream_async}
     * 
     * Parse items from the data in a #GInputStream. This function completes
     * asyncronously and doesn't block.
     * 
     * The [signal`Parser:`:parsed] and [signal`Parser:`:authenticate] signals
     * may fire during the parsing.
     * @param input The input stream
     * @param cancellable An optional cancellation object
     * @returns A Promise of: Whether the parsing completed successfully or not.
     */
    parse_stream_async(input: Gio.InputStream, cancellable: Gio.Cancellable | null): globalThis.Promise<boolean>
    /**
     * Complete an operation to parse a stream.
     * @param result The operation result
     * @returns Whether the parsing completed successfully or not.
     */
    parse_stream_finish(result: Gio.AsyncResult): boolean
    /**
     * Sets the filename of the parser item.
     * @param filename a string of the filename of the parser item
     */
    set_filename(filename: string | null): void

    // Own virtual methods of Gcr-4.Gcr.Parser

    vfunc_authenticate(count: number): boolean
    vfunc_parsed(): void

    // Own signals of Gcr-4.Gcr.Parser

    connect(sigName: "authenticate", callback: Parser.AuthenticateSignalCallback): number
    connect_after(sigName: "authenticate", callback: Parser.AuthenticateSignalCallback): number
    emit(sigName: "authenticate", count: number, ...args: any[]): void
    connect(sigName: "parsed", callback: Parser.ParsedSignalCallback): number
    connect_after(sigName: "parsed", callback: Parser.ParsedSignalCallback): number
    emit(sigName: "parsed", ...args: any[]): void

    // Class property signals of Gcr-4.Gcr.Parser

    connect(sigName: "notify::parsed-attributes", callback: (($obj: Parser, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parsed-attributes", callback: (($obj: Parser, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::parsed-attributes", ...args: any[]): void
    connect(sigName: "notify::parsed-description", callback: (($obj: Parser, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parsed-description", callback: (($obj: Parser, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::parsed-description", ...args: any[]): void
    connect(sigName: "notify::parsed-label", callback: (($obj: Parser, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parsed-label", callback: (($obj: Parser, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::parsed-label", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A parser for parsing various types of files or data.
 * 
 * A `GcrParser` can parse various certificate and key files such as OpenSSL
 * PEM files, DER encoded certifictes, PKCS#8 keys and so on. Each various
 * format is identified by a value in the [enum`DataFormat]` enumeration.
 * 
 * In order to parse data, a new parser is created with gcr_parser_new() and
 * then the [signal`Parser:`:authenticate] and [signal`Parser:`:parsed] signals
 * should be connected to. Data is then fed to the parser via
 * [method`Parser`.parse_data] or [method`Parser`.parse_stream].
 * 
 * During the [signal`Parser:`:parsed] signal the attributes that make up the
 * currently parsed item can be retrieved using the
 * [method`Parser`.get_parsed_attributes] function.
 * @class 
 */
export class Parser extends GObject.Object {

    // Own properties of Gcr-4.Gcr.Parser

    static name: string
    static $gtype: GObject.GType<Parser>

    // Constructors of Gcr-4.Gcr.Parser

    constructor(config?: Parser.ConstructorProperties) 
    /**
     * Create a new #GcrParser
     * @constructor 
     * @returns a newly allocated #GcrParser
     */
    constructor() 
    /**
     * Create a new #GcrParser
     * @constructor 
     * @returns a newly allocated #GcrParser
     */
    static new(): Parser
    _init(config?: Parser.ConstructorProperties): void
}

export module Pkcs11Certificate {

    // Constructor properties interface

    export interface ConstructorProperties extends Certificate.ConstructorProperties, Gck.Object.ConstructorProperties {

        // Own constructor properties of Gcr-4.Gcr.Pkcs11Certificate

        /**
         * Automatically loaded attributes for this certificate.
         */
        attributes?: Gck.Attributes | null
    }

}

export interface Pkcs11Certificate extends Certificate {

    // Own properties of Gcr-4.Gcr.Pkcs11Certificate

    /**
     * Automatically loaded attributes for this certificate.
     */
    readonly attributes: Gck.Attributes

    // Own fields of Gcr-4.Gcr.Pkcs11Certificate

    parent: Gck.Object

    // Owm methods of Gcr-4.Gcr.Pkcs11Certificate

    /**
     * Access the automatically loaded attributes for this certificate.
     * @returns the certificate attributes
     */
    get_attributes(): Gck.Attributes

    // Conflicting methods

    /**
     * Get the data for the specified attribute from the object. For convenience
     * the returned data has a null terminator.
     * 
     * This call may block for an indefinite period.
     * @param attr_type The attribute to get data for.
     * @param cancellable A #GCancellable or %NULL
     * @returns the resulting PKCS#11          attribute data, or %NULL if an error occurred
     */
    get_data(attr_type: number, cancellable: Gio.Cancellable | null): Uint8Array

    // Overloads of get_data

    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     * @returns the data if found,          or %NULL if no such data exists.
     */
    get_data(key: string | null): any | null
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     * @returns the data if found,          or %NULL if no such data exists.
     */
    get_data(key: string | null): any | null

    // Class property signals of Gcr-4.Gcr.Pkcs11Certificate

    connect(sigName: "notify::attributes", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::attributes", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::attributes", ...args: any[]): void
    connect(sigName: "notify::handle", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::handle", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::handle", ...args: any[]): void
    connect(sigName: "notify::module", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::module", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::module", ...args: any[]): void
    connect(sigName: "notify::session", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::session", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::session", ...args: any[]): void
    connect(sigName: "notify::description", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::expiry-date", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::expiry-date", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::expiry-date", ...args: any[]): void
    connect(sigName: "notify::issuer-name", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::issuer-name", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::issuer-name", ...args: any[]): void
    connect(sigName: "notify::label", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::subject-name", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::subject-name", callback: (($obj: Pkcs11Certificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::subject-name", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A certificate loaded from a PKCS#11 storage.
 * It is also a valid [class`Gck`.Object] and can be used as such.
 * 
 * Use gcr_pkcs11_certificate_lookup_issuer() to lookup the issuer of a given
 * certificate in the PKCS#11 store.
 * 
 * Various common PKCS#11 certificate attributes are automatically loaded and
 * are available via gcr_pkcs11_certificate_get_attributes().
 * @class 
 */
export class Pkcs11Certificate extends Gck.Object {

    // Own properties of Gcr-4.Gcr.Pkcs11Certificate

    static name: string
    static $gtype: GObject.GType<Pkcs11Certificate>

    // Constructors of Gcr-4.Gcr.Pkcs11Certificate

    constructor(config?: Pkcs11Certificate.ConstructorProperties) 
    _init(config?: Pkcs11Certificate.ConstructorProperties): void
    /**
     * Lookup a certificate in the PKCS#11 storage by the given URI.
     * 
     * This call may block, see gcr_pkcs11_certificate_new_from_uri_async() for the
     * non-blocking version.
     * 
     * Will return %NULL if no certificate is found. Use `error` to determine
     * if an error occurred.
     * @param pkcs11_uri a A PKCS \#11 URI
     * @param cancellable a #GCancellable
     * @returns a new #GcrCertificate, or %NULL
     */
    static new_from_uri(pkcs11_uri: string | null, cancellable: Gio.Cancellable | null): Certificate | null
    /**
     * Lookup a certificate in the PKCS#11 storage by the given URI.
     * 
     * When the operation is finished, callback will be called. You can then call
     * gcr_pkcs11_certificate_new_from_uri_finish() to get the result of the
     * operation.
     * @param pkcs11_uri a A PKCS \#11 URI
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the operation completes
     */
    static new_from_uri_async(pkcs11_uri: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<Pkcs11Certificate> | null): void
    /**
     * Finishes an asynchronous operation started by
     * gcr_pkcs11_certificate_new_from_uri_async().
     * 
     * Will return %NULL if no certificate is found. Use `error` to determine
     * if an error occurred.
     * @param result the #GAsyncResult passed to the callback
     * @returns a new #GcrCertificate, or %NULL
     */
    static new_from_uri_finish(result: Gio.AsyncResult): Certificate | null
    /**
     * Lookup a the issuer of a `certificate` in the PKCS#11 storage. The
     * lookup is done using the issuer DN of the certificate. No certificate chain
     * verification is done. Use a crypto library to make trust decisions.
     * 
     * This call may block, see gcr_pkcs11_certificate_lookup_issuer() for the
     * non-blocking version.
     * 
     * Will return %NULL if no issuer certificate is found. Use `error` to determine
     * if an error occurred.
     * @param certificate a #GcrCertificate
     * @param cancellable a #GCancellable
     * @returns a new #GcrPkcs11Certificate, or %NULL
     */
    static lookup_issuer(certificate: Certificate, cancellable: Gio.Cancellable | null): Certificate
    /**
     * Lookup a the issuer of a `certificate` in the PKCS#11 storage. The
     * lookup is done using the issuer DN of the certificate. No certificate chain
     * verification is done. Use a crypto library to make trust decisions.
     * 
     * When the operation is finished, callback will be called. You can then call
     * gcr_pkcs11_certificate_lookup_issuer_finish() to get the result of the
     * operation.
     * @param certificate a #GcrCertificate
     * @param cancellable a #GCancellable
     * @param callback a #GAsyncReadyCallback to call when the operation completes
     */
    static lookup_issuer_async(certificate: Certificate, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<Pkcs11Certificate> | null): void
    /**
     * Finishes an asynchronous operation started by
     * gcr_pkcs11_certificate_lookup_issuer_async().
     * 
     * Will return %NULL if no issuer certificate is found. Use `error` to determine
     * if an error occurred.
     * @param result the #GAsyncResult passed to the callback
     * @returns a new #GcrPkcs11Certificate, or %NULL
     */
    static lookup_issuer_finish(result: Gio.AsyncResult): Certificate
}

export module SecretExchange {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-4.Gcr.SecretExchange

        /**
         * The protocol being used for the exchange.
         * 
         * Will be %NULL if no protocol was specified when creating this object,
         * and either [method`SecretExchange`.begin] or [method`SecretExchange`.receive]
         * have not been called successfully.
         */
        protocol?: string | null
    }

}

export interface SecretExchange {

    // Own properties of Gcr-4.Gcr.SecretExchange

    /**
     * The protocol being used for the exchange.
     * 
     * Will be %NULL if no protocol was specified when creating this object,
     * and either [method`SecretExchange`.begin] or [method`SecretExchange`.receive]
     * have not been called successfully.
     */
    readonly protocol: string | null

    // Owm methods of Gcr-4.Gcr.SecretExchange

    /**
     * Begin the secret exchange. The resulting string should be sent to the other
     * side of the exchange. The other side should use [method`SecretExchange`.receive]
     * to process the string.
     * @returns A newly allocated string to be sent to the other     side of the secret exchange
     */
    begin(): string | null
    /**
     * Will return %NULL if no protocol was specified, and either
     * [method`SecretExchange`.begin] or [method`SecretExchange`.receive] have not
     * been called successfully.
     * @returns the protocol or %NULL
     */
    get_protocol(): string | null
    /**
     * Returns the last secret received. If no secret has yet been received this
     * will return %NULL. The string is owned by the #GcrSecretExchange object
     * and will be valid until the next time that gcr_secret_exchange_receive()
     * is called on this object, or the object is destroyed.
     * 
     * Depending on the secret passed into the other side of the secret exchange,
     * the result may be a binary string. It does however have a null terminator,
     * so if you're certain that it is does not contain arbitrary binary data,
     * it can be used as a string.
     * @returns the last secret received
     */
    get_secret(): string[]
    /**
     * Receive a string from the other side of secret exchange. This string will
     * have been created by [method`SecretExchange`.begin] or
     * [method`SecretExchange`.send].
     * 
     * After this call completes successfully the value returned from
     * gcr_secret_exchange_get_secret() will have changed.
     * @param exchange the string received
     * @returns whether the string was successfully parsed and received
     */
    receive(exchange: string | null): boolean
    /**
     * Send a reply to the other side of the secret exchange, optionally sending a
     * secret.
     * 
     * [method`SecretExchange`.receive] must have been successfully called at least
     * once on this object. In other words this object must have received data
     * from the other side of the secret exchange, before we can send a secret.
     * @param secret optionally, a secret to send to the other side
     * @param secret_len length of `secret,` or -1 if null terminated
     * @returns a newly allocated string to be sent to the other     side of the secret exchange
     */
    send(secret: string | null, secret_len: number): string | null

    // Own virtual methods of Gcr-4.Gcr.SecretExchange

    vfunc_derive_transport_key(peer: number, n_peer: number): boolean
    vfunc_generate_exchange_key(scheme: string | null, public_key: number, n_public_key: number): boolean

    // Class property signals of Gcr-4.Gcr.SecretExchange

    connect(sigName: "notify::protocol", callback: (($obj: SecretExchange, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol", callback: (($obj: SecretExchange, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::protocol", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Allows exchange of secrets between two processes on the same system without
 * exposing those secrets to things like loggers, non-pageable memory etc.
 * 
 * This does not protect against active attacks like MITM attacks.
 * 
 * Each side creates a secret exchange object, and one of the sides calls
 * [method`SecretExchange`.begin]. This creates a string, which should be passed
 * to the other side. Each side passes the strings it receives into
 * [method`SecretExchange`.receive].
 * 
 * In order to send a reply (either with or without a secret) use
 * [method`SecretExchange`.send]. A side must have successfully called
 * [method`SecretExchange`.receive] before it can use
 * [method`SecretExchange`.send].
 * 
 * The secret exchange objects can be used for multiple iterations of the
 * conversation, or for just one request/reply. The only limitation being that
 * the initial request cannot contain a secret.
 * 
 * Caveat: Information about the approximate length (rounded up to the nearest
 * 16 bytes) may be leaked. If this is considered inacceptable, do not use
 * [class`SecretExchange]`.
 * @class 
 */
export class SecretExchange extends GObject.Object {

    // Own properties of Gcr-4.Gcr.SecretExchange

    static name: string
    static $gtype: GObject.GType<SecretExchange>

    // Constructors of Gcr-4.Gcr.SecretExchange

    constructor(config?: SecretExchange.ConstructorProperties) 
    /**
     * Create a new secret exchange object.
     * 
     * Specify a protocol of %NULL to allow any protocol. This is especially
     * relevant on the side of the exchange that does not call
     * [method`SecretExchange`.begin], that is the originator. Currently the only
     * protocol supported is %GCR_SECRET_EXCHANGE_PROTOCOL_1.
     * @constructor 
     * @param protocol the exchange protocol to use
     * @returns A new #GcrSecretExchange object
     */
    constructor(protocol: string | null) 
    /**
     * Create a new secret exchange object.
     * 
     * Specify a protocol of %NULL to allow any protocol. This is especially
     * relevant on the side of the exchange that does not call
     * [method`SecretExchange`.begin], that is the originator. Currently the only
     * protocol supported is %GCR_SECRET_EXCHANGE_PROTOCOL_1.
     * @constructor 
     * @param protocol the exchange protocol to use
     * @returns A new #GcrSecretExchange object
     */
    static new(protocol: string | null): SecretExchange
    _init(config?: SecretExchange.ConstructorProperties): void
}

export module SimpleCertificate {

    // Constructor properties interface

    export interface ConstructorProperties extends Certificate.ConstructorProperties, GObject.Object.ConstructorProperties {
    }

}

export interface SimpleCertificate extends Certificate {

    // Own fields of Gcr-4.Gcr.SimpleCertificate

    parent: GObject.Object

    // Class property signals of Gcr-4.Gcr.SimpleCertificate

    connect(sigName: "notify::description", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::expiry-date", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::expiry-date", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::expiry-date", ...args: any[]): void
    connect(sigName: "notify::issuer-name", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::issuer-name", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::issuer-name", ...args: any[]): void
    connect(sigName: "notify::label", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::label", ...args: any[]): void
    connect(sigName: "notify::subject-name", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::subject-name", callback: (($obj: SimpleCertificate, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::subject-name", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * An implementation of [iface`Certificate]` which loads a certificate from DER
 * data already located in memory.
 * 
 * To create an object, use the [ctor`SimpleCertificate`.new] or
 * [ctor`SimpleCertificate`.new_static] functions.
 * @class 
 */
export class SimpleCertificate extends GObject.Object {

    // Own properties of Gcr-4.Gcr.SimpleCertificate

    static name: string
    static $gtype: GObject.GType<SimpleCertificate>

    // Constructors of Gcr-4.Gcr.SimpleCertificate

    constructor(config?: SimpleCertificate.ConstructorProperties) 
    /**
     * Create a new #GcrSimpleCertificate for the raw DER data. The `data` memory is
     * copied so you can dispose of it after this function returns.
     * @constructor 
     * @param data the raw DER certificate data
     * @returns a new #GcrSimpleCertificate
     */
    constructor(data: Uint8Array) 
    /**
     * Create a new #GcrSimpleCertificate for the raw DER data. The `data` memory is
     * copied so you can dispose of it after this function returns.
     * @constructor 
     * @param data the raw DER certificate data
     * @returns a new #GcrSimpleCertificate
     */
    static new(data: Uint8Array): SimpleCertificate
    _init(config?: SimpleCertificate.ConstructorProperties): void
}

export module SshAskpass {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-4.Gcr.SshAskpass

        /**
         * The interaction used to prompt for passwords.
         */
        interaction?: Gio.TlsInteraction | null
    }

}

export interface SshAskpass {

    // Own properties of Gcr-4.Gcr.SshAskpass

    /**
     * The interaction used to prompt for passwords.
     */
    readonly interaction: Gio.TlsInteraction

    // Owm methods of Gcr-4.Gcr.SshAskpass

    /**
     * Get the interaction associated with this object.
     * @returns the interaction
     */
    get_interaction(): Gio.TlsInteraction

    // Class property signals of Gcr-4.Gcr.SshAskpass

    connect(sigName: "notify::interaction", callback: (($obj: SshAskpass, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interaction", callback: (($obj: SshAskpass, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::interaction", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * When used as the setup function while spawning an ssh command like ssh-add
 * or ssh, this allows callbacks for passwords on the provided interaction.
 * @class 
 */
export class SshAskpass extends GObject.Object {

    // Own properties of Gcr-4.Gcr.SshAskpass

    static name: string
    static $gtype: GObject.GType<SshAskpass>

    // Constructors of Gcr-4.Gcr.SshAskpass

    constructor(config?: SshAskpass.ConstructorProperties) 
    /**
     * Create a new GcrSshAskpass object which can be used to spawn an
     * ssh command and prompt for any necessary passwords.
     * 
     * Use the gcr_ssh_askpass_child_setup() function as a callback with
     * g_spawn_sync(), g_spawn_async() or g_spawn_async_with_pipes().
     * @constructor 
     * @param interaction the interaction to use for prompting paswords
     * @returns A new #GcrSshAskpass object
     */
    constructor(interaction: Gio.TlsInteraction) 
    /**
     * Create a new GcrSshAskpass object which can be used to spawn an
     * ssh command and prompt for any necessary passwords.
     * 
     * Use the gcr_ssh_askpass_child_setup() function as a callback with
     * g_spawn_sync(), g_spawn_async() or g_spawn_async_with_pipes().
     * @constructor 
     * @param interaction the interaction to use for prompting paswords
     * @returns A new #GcrSshAskpass object
     */
    static new(interaction: Gio.TlsInteraction): SshAskpass
    _init(config?: SshAskpass.ConstructorProperties): void
    /**
     * Use this function as a callback setup function passed to g_spawn_sync(),
     * g_spawn_async(), g_spawn_async_with_pipes().
     * @param askpass a #GcrSshAskpass object
     */
    static child_setup(askpass: any | null): void
}

export module SystemPrompt {

    // Constructor properties interface

    export interface ConstructorProperties extends Prompt.ConstructorProperties, Gio.AsyncInitable.ConstructorProperties, Gio.Initable.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-4.Gcr.SystemPrompt

        /**
         * The DBus bus name of the prompter to use for prompting, or %NULL
         * for the default prompter.
         */
        bus_name?: string | null
        /**
         * The #GcrSecretExchange to use when transferring passwords. A default
         * secret exchange will be used if this is not set.
         */
        secret_exchange?: SecretExchange | null
        /**
         * The timeout in seconds to wait when opening the prompt.
         */
        timeout_seconds?: number | null
    }

}

export interface SystemPrompt extends Prompt, Gio.AsyncInitable, Gio.Initable {

    // Own properties of Gcr-4.Gcr.SystemPrompt

    /**
     * The DBus bus name of the prompter to use for prompting, or %NULL
     * for the default prompter.
     */
    readonly bus_name: string | null
    /**
     * The #GcrSecretExchange to use when transferring passwords. A default
     * secret exchange will be used if this is not set.
     */
    secret_exchange: SecretExchange
    /**
     * The timeout in seconds to wait when opening the prompt.
     */
    readonly timeout_seconds: number

    // Own fields of Gcr-4.Gcr.SystemPrompt

    parent: GObject.Object

    // Owm methods of Gcr-4.Gcr.SystemPrompt

    /**
     * Close this prompt. After calling this function, no further prompts will
     * succeed on this object. The prompt object is not unreferenced by this
     * function, and you must unreference it once done.
     * 
     * This call may block, use the gcr_system_prompt_close_async() to perform
     * this action indefinitely.
     * 
     * Whether or not this function returns %TRUE, the system prompt object is
     * still closed and may not be further used.
     * @param cancellable an optional cancellation object
     * @returns whether close was cleanly completed
     */
    close(cancellable: Gio.Cancellable | null): boolean

    // Overloads of close

    /**
     * Closes the prompt so that in can no longer be used to prompt. The various
     * prompt methods will return results as if the user dismissed the prompt.
     * 
     * The prompt may also be closed by the implementor of the prompt object.
     * 
     * This emits the [signal`Prompt:`:prompt-close] signal on the prompt object.
     */
    close(): void
    /**
     * Close this prompt asynchronously. After calling this function, no further
     * methods may be called on this object. The prompt object is not unreferenced
     * by this function, and you must unreference it once done.
     * 
     * This call returns immediately and completes asynchronously.
     * @param cancellable an optional cancellation object
     * @param callback called when the operation completes
     */
    close_async(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<this> | null): void

    // Overloads of close_async

    /**
     * Promisified version of {@link close_async}
     * 
     * Close this prompt asynchronously. After calling this function, no further
     * methods may be called on this object. The prompt object is not unreferenced
     * by this function, and you must unreference it once done.
     * 
     * This call returns immediately and completes asynchronously.
     * @param cancellable an optional cancellation object
     * @returns A Promise of: whether close was cleanly completed
     */
    close_async(cancellable: Gio.Cancellable | null): globalThis.Promise<boolean>
    /**
     * Complete operation to close this prompt.
     * 
     * Whether or not this function returns %TRUE, the system prompt object is
     * still closed and may not be further used.
     * @param result asynchronous operation result
     * @returns whether close was cleanly completed
     */
    close_finish(result: Gio.AsyncResult): boolean
    /**
     * Get the current [class`SecretExchange]` used to transfer secrets in this prompt.
     * @returns the secret exchange
     */
    get_secret_exchange(): SecretExchange

    // Class property signals of Gcr-4.Gcr.SystemPrompt

    connect(sigName: "notify::bus-name", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::bus-name", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::bus-name", ...args: any[]): void
    connect(sigName: "notify::secret-exchange", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::secret-exchange", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::secret-exchange", ...args: any[]): void
    connect(sigName: "notify::timeout-seconds", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::timeout-seconds", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::timeout-seconds", ...args: any[]): void
    connect(sigName: "notify::caller-window", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::caller-window", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::caller-window", ...args: any[]): void
    connect(sigName: "notify::cancel-label", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cancel-label", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::cancel-label", ...args: any[]): void
    connect(sigName: "notify::choice-chosen", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::choice-chosen", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::choice-chosen", ...args: any[]): void
    connect(sigName: "notify::choice-label", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::choice-label", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::choice-label", ...args: any[]): void
    connect(sigName: "notify::continue-label", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::continue-label", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::continue-label", ...args: any[]): void
    connect(sigName: "notify::description", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::description", ...args: any[]): void
    connect(sigName: "notify::message", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::message", ...args: any[]): void
    connect(sigName: "notify::password-new", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-new", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::password-new", ...args: any[]): void
    connect(sigName: "notify::password-strength", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-strength", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::password-strength", ...args: any[]): void
    connect(sigName: "notify::title", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::title", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::title", ...args: any[]): void
    connect(sigName: "notify::warning", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::warning", callback: (($obj: SystemPrompt, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::warning", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A [iface`Prompt]` implementation which calls to the system prompter to
 * display prompts in a system modal fashion.
 * 
 * Since the system prompter usually only displays one prompt at a time, you
 * may have to wait for the prompt to be displayed. Use [func`SystemPrompt`.open]
 * or a related function to open a prompt. Since this can take a long time, you
 * should always check that the prompt is still needed after it is opened. A
 * previous prompt may have already provided the information needed and you
 * may no longer need to prompt.
 * 
 * Use [method`SystemPrompt`.close] to close the prompt when you're done with it.
 * @class 
 */
export class SystemPrompt extends GObject.Object {

    // Own properties of Gcr-4.Gcr.SystemPrompt

    static name: string
    static $gtype: GObject.GType<SystemPrompt>

    // Constructors of Gcr-4.Gcr.SystemPrompt

    constructor(config?: SystemPrompt.ConstructorProperties) 
    _init(config?: SystemPrompt.ConstructorProperties): void
    static error_get_domain(): GLib.Quark
    /**
     * Opens a system prompt with the default prompter.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this function will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     * @param timeout_seconds the number of seconds to wait to access the prompt, or -1
     * @param cancellable optional cancellation object
     * @returns the prompt, or %NULL if          prompt could not be opened
     */
    static open(timeout_seconds: number, cancellable: Gio.Cancellable | null): SystemPrompt
    /**
     * Asynchronously open a system prompt with the default system prompter.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this operation will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     * @param timeout_seconds the number of seconds to wait to access the prompt, or -1
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    static open_async(timeout_seconds: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<SystemPrompt> | null): void
    /**
     * Complete an operation to asynchronously open a system prompt.
     * @param result the asynchronous result
     * @returns the prompt, or %NULL if          prompt could not be opened
     */
    static open_finish(result: Gio.AsyncResult): SystemPrompt
    /**
     * Opens a system prompt. If prompter_name is %NULL, then the default
     * system prompter is used.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this function will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     * @param prompter_name the prompter dbus name
     * @param timeout_seconds the number of seconds to wait to access the prompt, or -1
     * @param cancellable optional cancellation object
     * @returns the prompt, or %NULL if          prompt could not be opened
     */
    static open_for_prompter(prompter_name: string | null, timeout_seconds: number, cancellable: Gio.Cancellable | null): SystemPrompt
    /**
     * Opens a system prompt asynchronously. If prompter_name is %NULL, then the
     * default system prompter is used.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this operation will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     * @param prompter_name the prompter D-Bus name
     * @param timeout_seconds the number of seconds to wait to access the prompt, or -1
     * @param cancellable optional cancellation object
     * @param callback called when the operation completes
     */
    static open_for_prompter_async(prompter_name: string | null, timeout_seconds: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback<SystemPrompt> | null): void
}

export module SystemPrompter {

    // Signal callback interfaces

    /**
     * Signal callback interface for `new-prompt`
     */
    export interface NewPromptSignalCallback {
        ($obj: SystemPrompter): Prompt
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of Gcr-4.Gcr.SystemPrompter

        /**
         * The #GType for prompts created by this prompter. This must be a
         * #GcrPrompt implementation.
         */
        prompt_type?: GObject.GType | null
    }

}

export interface SystemPrompter {

    // Own properties of Gcr-4.Gcr.SystemPrompter

    /**
     * The #GType for prompts created by this prompter. This must be a
     * #GcrPrompt implementation.
     */
    readonly prompt_type: GObject.GType
    /**
     * Whether the prompter is prompting or not.
     */
    readonly prompting: boolean

    // Own fields of Gcr-4.Gcr.SystemPrompter

    parent: GObject.Object

    // Owm methods of Gcr-4.Gcr.SystemPrompter

    /**
     * Get the mode for this prompter.
     * 
     * Most system prompters only display one prompt at a time and therefore
     * return %GCR_SYSTEM_PROMPTER_SINGLE.
     * @returns the prompter mode
     */
    get_mode(): SystemPrompterMode
    /**
     * Get the #GType for prompts created by this prompter.
     * 
     * The returned #GType will be a #GcrPrompt implementation.
     * @returns the prompt #GType
     */
    get_prompt_type(): GObject.GType
    /**
     * Get whether prompting or not.
     * @returns whether prompting or not
     */
    get_prompting(): boolean
    /**
     * Register this system prompter on the DBus `connection`.
     * 
     * This makes the prompter available for clients to call. The prompter will
     * remain registered until gcr_system_prompter_unregister() is called, or the
     * prompter is unreferenced.
     * @param connection a DBus connection
     */
    register(connection: Gio.DBusConnection): void
    /**
     * Unregister this system prompter on the DBus `connection`.
     * 
     * The prompter must have previously been registered with gcr_system_prompter_register().
     * 
     * If `wait` is set then this function will wait until all prompts have been closed
     * or cancelled. This is usually only used by tests.
     * @param wait whether to wait for closing prompts
     */
    unregister(wait: boolean): void

    // Own signals of Gcr-4.Gcr.SystemPrompter

    connect(sigName: "new-prompt", callback: SystemPrompter.NewPromptSignalCallback): number
    connect_after(sigName: "new-prompt", callback: SystemPrompter.NewPromptSignalCallback): number
    emit(sigName: "new-prompt", ...args: any[]): void

    // Class property signals of Gcr-4.Gcr.SystemPrompter

    connect(sigName: "notify::prompt-type", callback: (($obj: SystemPrompter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::prompt-type", callback: (($obj: SystemPrompter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::prompt-type", ...args: any[]): void
    connect(sigName: "notify::prompting", callback: (($obj: SystemPrompter, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::prompting", callback: (($obj: SystemPrompter, pspec: GObject.ParamSpec) => void)): number
    emit(sigName: "notify::prompting", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    connect_after(sigName: string, callback: (...args: any[]) => void): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * A prompter used by implementations of system prompts.
 * 
 * This is a D-Bus service which is rarely implemented. Use [class`SystemPrompt]`
 * to display system prompts.
 * 
 * The system prompter service responds to D-Bus requests to create system
 * prompts and creates #GcrPrompt type objects to display those prompts.
 * 
 * Pass the GType of the implementation of [iface`Prompt]` to
 * [ctor`SystemPrompter`.new].
 * @class 
 */
export class SystemPrompter extends GObject.Object {

    // Own properties of Gcr-4.Gcr.SystemPrompter

    static name: string
    static $gtype: GObject.GType<SystemPrompter>

    // Constructors of Gcr-4.Gcr.SystemPrompter

    constructor(config?: SystemPrompter.ConstructorProperties) 
    /**
     * Create a new system prompter service. This prompter won't do anything unless
     * you connect to its signals and show appropriate prompts.
     * 
     * If `prompt_type` is zero, then the new-prompt signal must be handled and
     * return a valid prompt object implementing the #GcrPrompt interface.
     * 
     * If `prompt_type` is non-zero then the #GType must implement the #GcrPrompt
     * interface.
     * @constructor 
     * @param mode the mode for the prompt
     * @param prompt_type the gobject type for prompts created by this prompter
     * @returns a new prompter service
     */
    constructor(mode: SystemPrompterMode, prompt_type: GObject.GType) 
    /**
     * Create a new system prompter service. This prompter won't do anything unless
     * you connect to its signals and show appropriate prompts.
     * 
     * If `prompt_type` is zero, then the new-prompt signal must be handled and
     * return a valid prompt object implementing the #GcrPrompt interface.
     * 
     * If `prompt_type` is non-zero then the #GType must implement the #GcrPrompt
     * interface.
     * @constructor 
     * @param mode the mode for the prompt
     * @param prompt_type the gobject type for prompts created by this prompter
     * @returns a new prompter service
     */
    static new(mode: SystemPrompterMode, prompt_type: GObject.GType): SystemPrompter
    _init(config?: SystemPrompter.ConstructorProperties): void
}

export interface CertificateChainClass {

    // Own fields of Gcr-4.Gcr.CertificateChainClass

    /**
     * The parent class
     * @field 
     */
    parent_class: GObject.ObjectClass
}

/**
 * The class for #GcrCertificateChain.
 * @record 
 */
export abstract class CertificateChainClass {

    // Own properties of Gcr-4.Gcr.CertificateChainClass

    static name: string
}

export interface CertificateChainPrivate {
}

export class CertificateChainPrivate {

    // Own properties of Gcr-4.Gcr.CertificateChainPrivate

    static name: string
}

export interface CertificateFieldClass {

    // Own fields of Gcr-4.Gcr.CertificateFieldClass

    parent_class: GObject.ObjectClass
}

export abstract class CertificateFieldClass {

    // Own properties of Gcr-4.Gcr.CertificateFieldClass

    static name: string
}

export interface CertificateIface {

    // Own fields of Gcr-4.Gcr.CertificateIface

    /**
     * the parent interface type
     * @field 
     */
    parent: GObject.TypeInterface
    get_der_data: (self: Certificate) => Uint8Array
}

/**
 * The interface that implementors of #GcrCertificate must implement.
 * @record 
 */
export abstract class CertificateIface {

    // Own properties of Gcr-4.Gcr.CertificateIface

    static name: string
}

export interface CertificateRequestClass {

    // Own fields of Gcr-4.Gcr.CertificateRequestClass

    parent_class: GObject.ObjectClass
}

export abstract class CertificateRequestClass {

    // Own properties of Gcr-4.Gcr.CertificateRequestClass

    static name: string
}

export interface CertificateSectionClass {

    // Own fields of Gcr-4.Gcr.CertificateSectionClass

    parent_class: GObject.ObjectClass
}

export abstract class CertificateSectionClass {

    // Own properties of Gcr-4.Gcr.CertificateSectionClass

    static name: string
}

export interface ImportInteractionInterface {

    // Own fields of Gcr-4.Gcr.ImportInteractionInterface

    /**
     * parent interface
     * @field 
     */
    parent: GObject.TypeInterface
    supplement_prep: (interaction: ImportInteraction, builder: Gck.Builder) => void
    supplement: (interaction: ImportInteraction, builder: Gck.Builder, cancellable: Gio.Cancellable | null) => Gio.TlsInteractionResult
    supplement_async: (interaction: ImportInteraction, builder: Gck.Builder, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null) => void
    supplement_finish: (interaction: ImportInteraction, result: Gio.AsyncResult) => Gio.TlsInteractionResult
}

/**
 * Interface implemented by implementations of [iface`ImportInteraction]`.
 * @record 
 */
export abstract class ImportInteractionInterface {

    // Own properties of Gcr-4.Gcr.ImportInteractionInterface

    static name: string
}

export interface ImporterInterface {

    // Own fields of Gcr-4.Gcr.ImporterInterface

    /**
     * parent interface
     * @field 
     */
    parent: GObject.TypeInterface
    queue_for_parsed: (importer: Importer, parsed: Parsed) => boolean
    import_async: (importer: Importer, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null) => void
    import_finish: (importer: Importer, result: Gio.AsyncResult) => boolean
}

/**
 * Interface implemented for a #GcrImporter.
 * @record 
 */
export abstract class ImporterInterface {

    // Own properties of Gcr-4.Gcr.ImporterInterface

    static name: string
}

export interface Parsed {

    // Owm methods of Gcr-4.Gcr.Parsed

    /**
     * Get the attributes which make up the parsed item.
     * @returns the attributes for the item; these          are owned by the parsed item and should not be freed
     */
    get_attributes(): Gck.Attributes | null
    /**
     * Get the raw data block for the parsed item.
     * @returns the raw data of the parsed item, or %NULL
     */
    get_bytes(): GLib.Bytes
    /**
     * Get the raw data block for the parsed item.
     * @returns the raw data of          the parsed item, or %NULL
     */
    get_data(): Uint8Array | null
    /**
     * Get the descirption for a parsed item.
     * @returns the description
     */
    get_description(): string | null
    /**
     * Get the filename of the parsed item.
     * @returns the filename of          the parsed item, or %NULL
     */
    get_filename(): string | null
    /**
     * Get the format of the parsed item.
     * @returns the data format of the item
     */
    get_format(): DataFormat
    /**
     * Get the label for the parsed item.
     * @returns the label for the item
     */
    get_label(): string | null
    /**
     * Add a reference to a parsed item. An item may not be shared across threads
     * until it has been referenced at least once.
     * @returns the parsed item
     */
    ref(): Parsed
}

/**
 * A parsed item parsed by a #GcrParser.
 * @record 
 */
export class Parsed {

    // Own properties of Gcr-4.Gcr.Parsed

    static name: string

    // Constructors of Gcr-4.Gcr.Parsed

    /**
     * Unreferences a parsed item which was referenced with gcr_parsed_ref()
     * @param parsed a parsed item
     */
    static unref(parsed: any | null): void
}

export interface ParserClass {

    // Own fields of Gcr-4.Gcr.ParserClass

    /**
     * The parent class
     * @field 
     */
    parent_class: GObject.ObjectClass
    authenticate: (self: Parser, count: number) => boolean
    parsed: (self: Parser) => void
}

/**
 * The class for #GcrParser
 * @record 
 */
export abstract class ParserClass {

    // Own properties of Gcr-4.Gcr.ParserClass

    static name: string
}

export interface ParserPrivate {
}

export class ParserPrivate {

    // Own properties of Gcr-4.Gcr.ParserPrivate

    static name: string
}

export interface Pkcs11CertificateClass {
}

export abstract class Pkcs11CertificateClass {

    // Own properties of Gcr-4.Gcr.Pkcs11CertificateClass

    static name: string
}

export interface Pkcs11CertificatePrivate {
}

export class Pkcs11CertificatePrivate {

    // Own properties of Gcr-4.Gcr.Pkcs11CertificatePrivate

    static name: string
}

export interface PromptInterface {

    // Own fields of Gcr-4.Gcr.PromptInterface

    /**
     * parent interface
     * @field 
     */
    parent_iface: GObject.TypeInterface
    prompt_password_async: (prompt: Prompt, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null) => void
    prompt_password_finish: (prompt: Prompt, result: Gio.AsyncResult) => string | null
    prompt_confirm_async: (prompt: Prompt, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null) => void
    prompt_confirm_finish: (prompt: Prompt, result: Gio.AsyncResult) => PromptReply
    prompt_close: (prompt: Prompt) => void
}

/**
 * The interface for implementing [iface`Prompt]`.
 * @record 
 */
export abstract class PromptInterface {

    // Own properties of Gcr-4.Gcr.PromptInterface

    static name: string
}

export interface SecretExchangeClass {

    // Own fields of Gcr-4.Gcr.SecretExchangeClass

    generate_exchange_key: (exchange: SecretExchange, scheme: string | null, public_key: number, n_public_key: number) => boolean
    derive_transport_key: (exchange: SecretExchange, peer: number, n_peer: number) => boolean
}

export abstract class SecretExchangeClass {

    // Own properties of Gcr-4.Gcr.SecretExchangeClass

    static name: string
}

export interface SecretExchangePrivate {
}

export class SecretExchangePrivate {

    // Own properties of Gcr-4.Gcr.SecretExchangePrivate

    static name: string
}

export interface SimpleCertificateClass {

    // Own fields of Gcr-4.Gcr.SimpleCertificateClass

    parent_class: GObject.ObjectClass
}

export abstract class SimpleCertificateClass {

    // Own properties of Gcr-4.Gcr.SimpleCertificateClass

    static name: string
}

export interface SimpleCertificatePrivate {
}

export class SimpleCertificatePrivate {

    // Own properties of Gcr-4.Gcr.SimpleCertificatePrivate

    static name: string
}

export interface SshAskpassClass {

    // Own fields of Gcr-4.Gcr.SshAskpassClass

    parent_class: GObject.ObjectClass
}

export abstract class SshAskpassClass {

    // Own properties of Gcr-4.Gcr.SshAskpassClass

    static name: string
}

export interface SystemPromptClass {

    // Own fields of Gcr-4.Gcr.SystemPromptClass

    parent_class: GObject.ObjectClass
}

export abstract class SystemPromptClass {

    // Own properties of Gcr-4.Gcr.SystemPromptClass

    static name: string
}

export interface SystemPromptPrivate {
}

export class SystemPromptPrivate {

    // Own properties of Gcr-4.Gcr.SystemPromptPrivate

    static name: string
}

export interface SystemPrompterClass {

    // Own fields of Gcr-4.Gcr.SystemPrompterClass

    /**
     * parent class
     * @field 
     */
    parent_class: GObject.ObjectClass
}

/**
 * The class for #GcrSystemPrompter.
 * @record 
 */
export abstract class SystemPrompterClass {

    // Own properties of Gcr-4.Gcr.SystemPrompterClass

    static name: string
}

export interface SystemPrompterPrivate {
}

export class SystemPrompterPrivate {

    // Own properties of Gcr-4.Gcr.SystemPrompterPrivate

    static name: string
}

/**
 * Name of the imported GIR library
 * @see https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
 */
export const __name__: string
/**
 * Version of the imported GIR library
 * @see https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
 */
export const __version__: string
// END