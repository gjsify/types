/**
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in `ts-for-gir` or create a bug report on https://github.com/gjsify/ts-for-gir
 *
 * The based EJS template file is used for the generated .d.ts file of each GIR module like Gtk-4.0, GObject-2.0, ...
 */

// Module dependencies
import type freetype2 from '@girs/freetype2-2.0';
import type fontconfig from '@girs/fontconfig-2.0';
import type cairo from '@girs/cairo-1.0';
import type GObject from '@girs/gobject-2.0';
import type GLib from '@girs/glib-2.0';
import type PangoFT2 from '@girs/pangoft2-1.0';
import type PangoFc from '@girs/pangofc-1.0';
import type Pango from '@girs/pango-1.0';
import type HarfBuzz from '@girs/harfbuzz-0.0';
import type Gio from '@girs/gio-2.0';
import type PangoCairo from '@girs/pangocairo-1.0';
import type Json from '@girs/json-1.0';
import type GL from '@girs/gl-1.0';
import type CoglPango from '@girs/coglpango-1.0';
import type Cogl from '@girs/cogl-1.0';
import type Clutter from '@girs/clutter-1.0';
import type Atk from '@girs/atk-1.0';

export namespace Mx {
    /**
     * Mx-2.0
     */

    export namespace ActorManagerError {
        export const $gtype: GObject.GType<ActorManagerError>;
    }

    enum ActorManagerError {
        CONTAINER_DESTROYED,
        ACTOR_DESTROYED,
        CREATION_FAILED,
        UNKNOWN_OPERATION,
    }
    /**
     * Set the alignment of the item
     */

    /**
     * Set the alignment of the item
     */
    export namespace Align {
        export const $gtype: GObject.GType<Align>;
    }

    enum Align {
        /**
         * Align at the beginning of the axis
         */
        START,
        /**
         * Align in the middle of the axis
         */
        MIDDLE,
        /**
         * Align at the end of the axis
         */
        END,
    }
    /**
     * Values for the "display" style property.
     */

    /**
     * Values for the "display" style property.
     */
    export namespace DisplayStyle {
        export const $gtype: GObject.GType<DisplayStyle>;
    }

    enum DisplayStyle {
        NONE,
        INLINE,
    }

    export namespace DragAxis {
        export const $gtype: GObject.GType<DragAxis>;
    }

    enum DragAxis {
        NONE,
        X,
        Y,
    }

    export namespace FocusDirection {
        export const $gtype: GObject.GType<FocusDirection>;
    }

    enum FocusDirection {
        OUT,
        UP,
        DOWN,
        LEFT,
        RIGHT,
        NEXT,
        PREVIOUS,
    }

    export namespace FocusHint {
        export const $gtype: GObject.GType<FocusHint>;
    }

    enum FocusHint {
        FIRST,
        LAST,
        PRIOR,
        FROM_ABOVE,
        FROM_BELOW,
        FROM_LEFT,
        FROM_RIGHT,
    }
    /**
     * Support values of font weight
     */

    /**
     * Support values of font weight
     */
    export namespace FontWeight {
        export const $gtype: GObject.GType<FontWeight>;
    }

    enum FontWeight {
        /**
         * Normal font weight
         */
        NORMAL,
        /**
         * Bold font weight
         */
        BOLD,
        /**
         * Bolder font weight
         */
        BOLDER,
        /**
         * Lighter font weight
         */
        LIGHTER,
    }
    class ImageError extends GLib.Error {
        static $gtype: GObject.GType<ImageError>;

        // Static fields

        static BAD_FORMAT: number;
        static NO_ASYNC: number;
        static INTERNAL: number;
        static INVALID_PARAMETER: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        static quark(): GLib.Quark;
    }

    /**
     * Defines the scaling mode of an image.
     */

    /**
     * Defines the scaling mode of an image.
     */
    export namespace ImageScaleMode {
        export const $gtype: GObject.GType<ImageScaleMode>;
    }

    enum ImageScaleMode {
        /**
         * Do not apply any scaling and center the image within the allocation
         */
        NONE,
        /**
         * Scale the image, but maintain the aspect ratio so that it fits exactly within the allocation
         */
        FIT,
        /**
         * Scale and crop the image so that it covers the entire allocation while retaining the correct aspect ratio
         */
        CROP,
    }

    export namespace KineticScrollViewState {
        export const $gtype: GObject.GType<KineticScrollViewState>;
    }

    enum KineticScrollViewState {
        IDLE,
        PANNING,
        SCROLLING,
        CLAMPING,
    }

    export namespace LongPressAction {
        export const $gtype: GObject.GType<LongPressAction>;
    }

    enum LongPressAction {
        QUERY,
        ACTION,
        CANCEL,
    }
    /**
     * Defines the orientation of various layout widgets.
     */

    /**
     * Defines the orientation of various layout widgets.
     */
    export namespace Orientation {
        export const $gtype: GObject.GType<Orientation>;
    }

    enum Orientation {
        /**
         * horizontal orientation
         */
        HORIZONTAL,
        /**
         * vertical orientation
         */
        VERTICAL,
    }
    /**
     * Defines the position of an interface element.
     */

    /**
     * Defines the position of an interface element.
     */
    export namespace Position {
        export const $gtype: GObject.GType<Position>;
    }

    enum Position {
        /**
         * The top position
         */
        TOP,
        /**
         * The right position
         */
        RIGHT,
        /**
         * The bottom position
         */
        BOTTOM,
        /**
         * The left position
         */
        LEFT,
    }
    /**
     * Defines the scrolling policy of scrollable widgets.
     */

    /**
     * Defines the scrolling policy of scrollable widgets.
     */
    export namespace ScrollPolicy {
        export const $gtype: GObject.GType<ScrollPolicy>;
    }

    enum ScrollPolicy {
        /**
         * Never scroll
         */
        NONE,
        /**
         * Only allow horizontal scrolling
         */
        HORIZONTAL,
        /**
         * Only allow vertical scrolling
         */
        VERTICAL,
        /**
         * Allow scrolling both horizontally and vertically
         */
        BOTH,
        /**
         * Automatically align scroll to horizontal or vertical direction or both depending on the drag angle.
         */
        AUTOMATIC,
    }

    export namespace StyleError {
        export const $gtype: GObject.GType<StyleError>;
    }

    enum StyleError {
        INVALID_FILE,
        PARSE_ERROR,
    }
    /**
     * The horizontal alignment and layout of multiple lines of text.
     */

    /**
     * The horizontal alignment and layout of multiple lines of text.
     */
    export namespace TextAlign {
        export const $gtype: GObject.GType<TextAlign>;
    }

    enum TextAlign {
        LEFT,
        RIGHT,
        CENTER,
        JUSTIFY,
    }
    /**
     * Defines the animation when tooltips are shown and hidden.
     */

    /**
     * Defines the animation when tooltips are shown and hidden.
     */
    export namespace TooltipAnimation {
        export const $gtype: GObject.GType<TooltipAnimation>;
    }

    enum TooltipAnimation {
        /**
         * Bounce the tooltips when they appear
         */
        BOUNCE,
        /**
         * Fade the tooltips on show and hide
         */
        FADE,
    }
    /**
     * Values for the "visibility" style property.
     */

    /**
     * Values for the "visibility" style property.
     */
    export namespace VisibilityStyle {
        export const $gtype: GObject.GType<VisibilityStyle>;
    }

    enum VisibilityStyle {
        VISIBLE,
        HIDDEN,
    }
    /**
     * Defines the clock-wise rotation angle of a window.
     */
    /**
     * Defines the clock-wise rotation angle of a window.
     */
    class WindowRotation {
        static $gtype: GObject.GType<WindowRotation>;

        // Static fields

        /**
         * Zero degrees of rotation
         */
        static '0': number;
        /**
         * 90 degrees of rotation
         */
        static '90': number;
        /**
         * 180 degrees of rotation
         */
        static '180': number;
        /**
         * 270 degrees of rotation
         */
        static '270': number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The major version of the Mx clibrary (1 if version is 1.2.3)
     */
    const MAJOR_VERSION: number;
    /**
     * The micro version of the Mx library (3, if version is 1.2.3)
     */
    const MICRO_VERSION: number;
    /**
     * The minor version of the Mx library (2, if version is 1.2.3)
     */
    const MINOR_VERSION: number;
    const PARAM_STYLE_INHERIT: number;
    const PARAM_TRANSLATEABLE: number;
    /**
     * Numerically encoded version of the Mx library, like 0x010203
     */
    const VERSION_HEX: number;
    /**
     * The full version of the Mx library, in string form (suited for
     * string concatenation)
     */
    const VERSION_S: string;
    function actor_box_clamp_to_pixels(box: Clutter.ActorBox): void;
    function allocate_align_fill(
        child: Clutter.Actor,
        childbox: Clutter.ActorBox,
        x_alignment: Align | null,
        y_alignment: Align | null,
        x_fill: boolean,
        y_fill: boolean,
    ): void;
    function border_image_set_from_string(value: GObject.Value | any, str: string, filename: string): void;
    /**
     * Transforms a focus direction to a focus hint. This is a convenience
     * function for actors that implement the #MxFocusable interface, to
     * pass the correct #MxFocusHint to their children when calling
     * mx_focusable_accept_focus().
     *
     * %MX_FOCUS_DIRECTION_UP maps to %MX_FOCUS_HINT_FROM_BELOW,
     * %MX_FOCUS_DIRECTION_DOWN maps to %MX_FOCUS_HINT_FROM_ABOVE,
     * %MX_FOCUS_DIRECTION_LEFT maps to %MX_FOCUS_HINT_FROM_RIGHT,
     * %MX_FOCUS_DIRECTION_RIGHT maps to %MX_FOCUS_HINT_FROM_LEFT,
     * %MX_FOCUS_DIRECTION_NEXT maps to %MX_FOCUS_HINT_FIRST,
     * %MX_FOCUS_DIRECTION_PREVIOUS maps to %MX_FOCUS_HINT_LAST and
     * anything else maps to %MX_FOCUS_HINT_PRIOR.
     * @param direction A #MxFocusDirection
     * @returns A #MxFocusHint
     */
    function focus_hint_from_direction(direction: FocusDirection | null): FocusHint;
    function font_weight_set_from_string(value: GObject.Value | any, str: string): void;
    function image_error_quark(): GLib.Quark;
    /**
     * Initializes internationalization support for Mx. If MxApplication is
     * used, this is called automatically. Otherwise it has to be called
     * together with clutter_init() before using Mx.
     */
    function set_locale(): void;
    /**
     * Generates a string describing the time given in `time_` using
     * colloquial language suitable for display to the user. Examples of
     * what might be returned are "A few minutes ago" or "Yesterday".
     * @param time_ a time value
     * @returns a string. Free with g_free().
     */
    function utils_format_time(time_: GLib.TimeVal): string;
    interface ActionCallbackFunc {
        (action: Action): void;
    }
    interface ClipboardCallbackFunc {
        (clipboard: Clipboard, text: string): void;
    }

    export namespace StyleChangedFlags {
        export const $gtype: GObject.GType<StyleChangedFlags>;
    }

    enum StyleChangedFlags {
        /**
         * No flag set
         */
        NONE,
        /**
         * Whether to force propogation of the style-changed signal, regardless of the state of the stylable object.
         */
        FORCE,
        /**
         * Internal flag used to track style caching state.
         */
        INVALIDATE_CACHE,
    }
    module Action {
        // Signal callback interfaces

        interface Activate {
            (parameter: GLib.Variant): void;
        }

        interface Activated {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.InitiallyUnowned.ConstructorProps, Gio.Action.ConstructorProps {
            active: boolean;
            display_name: string;
            displayName: string;
            icon: string;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class Action extends GObject.InitiallyUnowned implements Gio.Action {
        static $gtype: GObject.GType<Action>;

        // Properties

        get active(): boolean;
        set active(val: boolean);
        get display_name(): string;
        set display_name(val: string);
        get displayName(): string;
        set displayName(val: string);
        get icon(): string;
        set icon(val: string);

        // Constructors

        constructor(properties?: Partial<Action.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Action;

        static new_full(name: string, display_name: string, activated_cb: ActionCallbackFunc): Action;

        static new_stateful(name: string, parameter_type: GLib.VariantType, state: GLib.Variant): Action;

        static new_with_parameter(name: string, parameter_type: GLib.VariantType): Action;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'activate', callback: (_source: this, parameter: GLib.Variant) => void): number;
        connect_after(signal: 'activate', callback: (_source: this, parameter: GLib.Variant) => void): number;
        emit(signal: 'activate', parameter: GLib.Variant): void;
        connect(signal: 'activated', callback: (_source: this) => void): number;
        connect_after(signal: 'activated', callback: (_source: this) => void): number;
        emit(signal: 'activated'): void;

        // Virtual methods

        vfunc_activated(): void;

        // Methods

        /**
         * Get the value of the active property
         * @returns #TRUE if the action is active
         */
        get_active(): boolean;
        /**
         * Get the display name of the action
         * @returns display-name of the action, owned by MxAction
         */
        get_display_name(): string;
        /**
         * Get the icon of the action
         * @returns icon of the action, owned by MxAction
         */
        get_icon(): string;
        /**
         * Get the name of the action
         * @returns name of the action, owned by MxAction
         */
        get_name(): string;
        /**
         * Set the value of the active property
         * @param active the value to set
         */
        set_active(active: boolean): void;
        /**
         * Set the name of the action to display to the user
         * @param name new display name to set
         */
        set_display_name(name: string): void;
        /**
         * The icon to be used in a visual representation of an action.
         * @param name new icon to set
         */
        set_icon(name: string): void;
        /**
         * Set the name of the action
         * @param name new name to set
         */
        set_name(name: string): void;

        // Inherited properties
        /**
         * If `action` is currently enabled.
         *
         * If the action is disabled then calls to g_action_activate() and
         * g_action_change_state() have no effect.
         */
        get enabled(): boolean;
        /**
         * The name of the action.  This is mostly meaningful for identifying
         * the action once it has been added to a #GActionGroup. It is immutable.
         */
        get name(): string;
        /**
         * The type of the parameter that must be given when activating the
         * action. This is immutable, and may be %NULL if no parameter is needed when
         * activating the action.
         */
        get parameter_type(): GLib.VariantType;
        /**
         * The type of the parameter that must be given when activating the
         * action. This is immutable, and may be %NULL if no parameter is needed when
         * activating the action.
         */
        get parameterType(): GLib.VariantType;
        /**
         * The state of the action, or %NULL if the action is stateless.
         */
        get state(): GLib.Variant;
        /**
         * The #GVariantType of the state that the action has, or %NULL if the
         * action is stateless. This is immutable.
         */
        get state_type(): GLib.VariantType;
        /**
         * The #GVariantType of the state that the action has, or %NULL if the
         * action is stateless. This is immutable.
         */
        get stateType(): GLib.VariantType;

        // Inherited methods
        /**
         * Activates the action.
         *
         * `parameter` must be the correct type of parameter for the action (ie:
         * the parameter type given at construction time).  If the parameter
         * type was %NULL then `parameter` must also be %NULL.
         *
         * If the `parameter` GVariant is floating, it is consumed.
         * @param parameter the parameter to the activation
         */
        activate(parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of `action` to be changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_get_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_get_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param value the new state
         */
        change_state(value: GLib.Variant): void;
        /**
         * Checks if `action` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @returns whether the action is enabled
         */
        get_enabled(): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * `action`.
         *
         * When activating the action using g_action_activate(), the #GVariant
         * given to that function must be of the type returned by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         * @returns the parameter type
         */
        get_parameter_type(): GLib.VariantType | null;
        /**
         * Queries the current state of `action`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_get_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @returns the current state of the action
         */
        get_state(): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of
         * `action`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @returns the state range hint
         */
        get_state_hint(): GLib.Variant | null;
        /**
         * Queries the type of the state of `action`.
         *
         * If the action is stateful (e.g. created with
         * g_simple_action_new_stateful()) then this function returns the
         * #GVariantType of the state.  This is the type of the initial value
         * given as the state. All calls to g_action_change_state() must give a
         * #GVariant of this type and g_action_get_state() will return a
         * #GVariant of the same type.
         *
         * If the action is not stateful (e.g. created with g_simple_action_new())
         * then this function will return %NULL. In that case, g_action_get_state()
         * will return %NULL and you must not call g_action_change_state().
         * @returns the state type, if the action is stateful
         */
        get_state_type(): GLib.VariantType | null;
        /**
         * Activates the action.
         *
         * `parameter` must be the correct type of parameter for the action (ie:
         * the parameter type given at construction time).  If the parameter
         * type was %NULL then `parameter` must also be %NULL.
         *
         * If the `parameter` GVariant is floating, it is consumed.
         * @param parameter the parameter to the activation
         */
        vfunc_activate(parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of `action` to be changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_get_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_get_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param value the new state
         */
        vfunc_change_state(value: GLib.Variant): void;
        /**
         * Checks if `action` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         */
        vfunc_get_enabled(): boolean;
        /**
         * Queries the name of `action`.
         */
        vfunc_get_name(): string;
        /**
         * Queries the type of the parameter that must be given when activating
         * `action`.
         *
         * When activating the action using g_action_activate(), the #GVariant
         * given to that function must be of the type returned by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         */
        vfunc_get_parameter_type(): GLib.VariantType | null;
        /**
         * Queries the current state of `action`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_get_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         */
        vfunc_get_state(): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of
         * `action`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         */
        vfunc_get_state_hint(): GLib.Variant | null;
        /**
         * Queries the type of the state of `action`.
         *
         * If the action is stateful (e.g. created with
         * g_simple_action_new_stateful()) then this function returns the
         * #GVariantType of the state.  This is the type of the initial value
         * given as the state. All calls to g_action_change_state() must give a
         * #GVariant of this type and g_action_get_state() will return a
         * #GVariant of the same type.
         *
         * If the action is not stateful (e.g. created with g_simple_action_new())
         * then this function will return %NULL. In that case, g_action_get_state()
         * will return %NULL and you must not call g_action_change_state().
         */
        vfunc_get_state_type(): GLib.VariantType | null;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ActorManager {
        // Signal callback interfaces

        interface ActorAdded {
            (id: number, container: Clutter.Actor, actor: Clutter.Actor): void;
        }

        interface ActorCreated {
            (id: number, actor: Clutter.Actor): void;
        }

        interface ActorFinished {
            (actor: Clutter.Actor): void;
        }

        interface ActorRemoved {
            (id: number, container: Clutter.Actor, actor: Clutter.Actor): void;
        }

        interface OperationCancelled {
            (id: number): void;
        }

        interface OperationCompleted {
            (id: number): void;
        }

        interface OperationFailed {
            (id: number, error: GLib.Error): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            n_operations: number;
            nOperations: number;
            stage: Clutter.Stage;
            time_slice: number;
            timeSlice: number;
        }
    }

    class ActorManager extends GObject.Object {
        static $gtype: GObject.GType<ActorManager>;

        // Properties

        get n_operations(): number;
        get nOperations(): number;
        get stage(): Clutter.Stage;
        get time_slice(): number;
        set time_slice(val: number);
        get timeSlice(): number;
        set timeSlice(val: number);

        // Constructors

        constructor(properties?: Partial<ActorManager.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](stage: Clutter.Stage): ActorManager;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'actor-added',
            callback: (_source: this, id: number, container: Clutter.Actor, actor: Clutter.Actor) => void,
        ): number;
        connect_after(
            signal: 'actor-added',
            callback: (_source: this, id: number, container: Clutter.Actor, actor: Clutter.Actor) => void,
        ): number;
        emit(signal: 'actor-added', id: number, container: Clutter.Actor, actor: Clutter.Actor): void;
        connect(signal: 'actor-created', callback: (_source: this, id: number, actor: Clutter.Actor) => void): number;
        connect_after(
            signal: 'actor-created',
            callback: (_source: this, id: number, actor: Clutter.Actor) => void,
        ): number;
        emit(signal: 'actor-created', id: number, actor: Clutter.Actor): void;
        connect(signal: 'actor-finished', callback: (_source: this, actor: Clutter.Actor) => void): number;
        connect_after(signal: 'actor-finished', callback: (_source: this, actor: Clutter.Actor) => void): number;
        emit(signal: 'actor-finished', actor: Clutter.Actor): void;
        connect(
            signal: 'actor-removed',
            callback: (_source: this, id: number, container: Clutter.Actor, actor: Clutter.Actor) => void,
        ): number;
        connect_after(
            signal: 'actor-removed',
            callback: (_source: this, id: number, container: Clutter.Actor, actor: Clutter.Actor) => void,
        ): number;
        emit(signal: 'actor-removed', id: number, container: Clutter.Actor, actor: Clutter.Actor): void;
        connect(signal: 'operation-cancelled', callback: (_source: this, id: number) => void): number;
        connect_after(signal: 'operation-cancelled', callback: (_source: this, id: number) => void): number;
        emit(signal: 'operation-cancelled', id: number): void;
        connect(signal: 'operation-completed', callback: (_source: this, id: number) => void): number;
        connect_after(signal: 'operation-completed', callback: (_source: this, id: number) => void): number;
        emit(signal: 'operation-completed', id: number): void;
        connect(signal: 'operation-failed', callback: (_source: this, id: number, error: GLib.Error) => void): number;
        connect_after(
            signal: 'operation-failed',
            callback: (_source: this, id: number, error: GLib.Error) => void,
        ): number;
        emit(signal: 'operation-failed', id: number, error: GLib.Error): void;

        // Static methods

        /**
         * Get the MxActorManager associated with a stage, or creates one if this is the
         * first call to the function with the given #ClutterStage.
         *
         * This is a convenience function that allows for easy association of one
         * #MxActorManager to a #ClutterStage.
         * @param stage A #ClutterStage
         */
        static get_for_stage(stage: Clutter.Stage): ActorManager;

        // Virtual methods

        vfunc_actor_added(id: number, container: Clutter.Actor, actor: Clutter.Actor): void;
        vfunc_actor_created(id: number, actor: Clutter.Actor): void;
        vfunc_actor_finished(actor: Clutter.Actor): void;
        vfunc_actor_removed(id: number, container: Clutter.Actor, actor: Clutter.Actor): void;
        vfunc_operation_cancelled(id: number): void;
        vfunc_operation_completed(id: number): void;
        vfunc_operation_failed(id: number, error: GLib.Error): void;

        // Methods

        /**
         * Adds `actor` to `container`. The actor may not be parented immediately,
         * or at all, if the operation is cancelled.
         *
         * On successful completion, the #MxActorManager::actor_added signal will
         * be fired.
         * @param container A #ClutterActor
         * @param actor A #ClutterActor
         * @returns The ID for this operation.
         */
        add_actor(container: Clutter.Actor, actor: Clutter.Actor): number;
        /**
         * Cancels the given operation, if it exists. The
         * #MxActorManager::operation_cancelled signal is fired whenever an operation
         * is cancelled.
         * @param id An operation ID
         */
        cancel_operation(id: number): void;
        /**
         * Cancels all operations associated with the given actor.
         * @param actor A #ClutterActor
         */
        cancel_operations(actor: Clutter.Actor): void;
        /**
         * Retrieves the amount of operations left in the queue.
         * @returns Number of operations left to perform
         */
        get_n_operations(): number;
        /**
         * Gets the #ClutterStage the actor manager is associated with.
         * @returns The #ClutterStage the actor is associated with.
         */
        get_stage(): Clutter.Stage;
        /**
         * Retrieves the current time slice being used for operations.
         * @returns The time-slice being used, in milliseconds
         */
        get_time_slice(): number;
        /**
         * Removes `actor` from `container`.
         *
         * On successful completion, the #MxActorManager::actor_removed signal will
         * be fired.
         *
         * <note><para>
         * The actor may not be removed immediately, and thus you may want to set
         * the actor's opacity to 0 before calling this function.
         * </para></note>
         * @param container A #ClutterActor
         * @param actor A #ClutterActor
         * @returns The ID for this operation.
         */
        remove_actor(container: Clutter.Actor, actor: Clutter.Actor): number;
        /**
         * Removes the container. This is a utility function that works by first
         * removing all the children of the container, then the children itself. This
         * effectively spreads the load of removing a large container. All prior
         * operations associated with this container will be cancelled.
         *
         * <note><para>
         * The container may not be removed immediately, and thus you may want to set
         * the container's opacity to 0 before calling this function.
         * </para></note>
         * @param container A #ClutterActor
         */
        remove_container(container: Clutter.Actor): void;
        /**
         * Sets the amount of time the actor manager will spend performing operations,
         * before yielding to allow any necessary redrawing to occur.
         *
         * Lower times will lead to smoother performance, but will increase the amount
         * of time it takes for operations to complete.
         * @param msecs A time, in milliseconds
         */
        set_time_slice(msecs: number): void;
    }

    module Adjustment {
        // Signal callback interfaces

        interface Changed {
            (): void;
        }

        interface ChangedImmediate {
            (): void;
        }

        interface InterpolationCompleted {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            clamp_value: boolean;
            clampValue: boolean;
            elastic: boolean;
            lower: number;
            page_increment: number;
            pageIncrement: number;
            page_size: number;
            pageSize: number;
            step_increment: number;
            stepIncrement: number;
            upper: number;
            value: number;
        }
    }

    /**
     * Class for handling an interval between to values. The contents of
     * the #MxAdjustment are private and should be accessed using the
     * public API.
     */
    class Adjustment extends GObject.Object {
        static $gtype: GObject.GType<Adjustment>;

        // Properties

        get clamp_value(): boolean;
        set clamp_value(val: boolean);
        get clampValue(): boolean;
        set clampValue(val: boolean);
        get elastic(): boolean;
        set elastic(val: boolean);
        get lower(): number;
        set lower(val: number);
        get page_increment(): number;
        set page_increment(val: number);
        get pageIncrement(): number;
        set pageIncrement(val: number);
        get page_size(): number;
        set page_size(val: number);
        get pageSize(): number;
        set pageSize(val: number);
        get step_increment(): number;
        set step_increment(val: number);
        get stepIncrement(): number;
        set stepIncrement(val: number);
        get upper(): number;
        set upper(val: number);
        get value(): number;
        set value(val: number);

        // Constructors

        constructor(properties?: Partial<Adjustment.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Adjustment;

        static new_with_values(
            value: number,
            lower: number,
            upper: number,
            step_increment: number,
            page_increment: number,
            page_size: number,
        ): Adjustment;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'changed', callback: (_source: this) => void): number;
        connect_after(signal: 'changed', callback: (_source: this) => void): number;
        emit(signal: 'changed'): void;
        connect(signal: 'changed-immediate', callback: (_source: this) => void): number;
        connect_after(signal: 'changed-immediate', callback: (_source: this) => void): number;
        emit(signal: 'changed-immediate'): void;
        connect(signal: 'interpolation-completed', callback: (_source: this) => void): number;
        connect_after(signal: 'interpolation-completed', callback: (_source: this) => void): number;
        emit(signal: 'interpolation-completed'): void;

        // Virtual methods

        vfunc_changed(): void;
        vfunc_changed_immediate(): void;
        vfunc_interpolation_completed(): void;

        // Methods

        /**
         * Get the value of the #MxAdjustment:clamp-value property.
         * @returns the current value of the "clamp-value" property.
         */
        get_clamp_value(): boolean;
        /**
         * Get the value of the #MxAdjustment:elastic property.
         * @returns the current value of the "elastic" property.
         */
        get_elastic(): boolean;
        /**
         * Get the value of the #MxAdjustment:lower property.
         * @returns the current value of the "lower" property.
         */
        get_lower(): number;
        /**
         * Get the value of the MxAdjustment:page-increment property.
         * @returns the current value of the "page-increment" property.
         */
        get_page_increment(): number;
        /**
         * Get the value of the #MxAdjustment:page-size property.
         * @returns the current value of the "page-size" property.
         */
        get_page_size(): number;
        /**
         * Get the value of the MxAdjustment:step-increment property.
         * @returns the current value of the "step-increment" property.
         */
        get_step_increment(): number;
        /**
         * Get the value of the #MxAdjustment:upper property.
         * @returns the current value of the "upper" property.
         */
        get_upper(): number;
        /**
         * Get the current value of the #MxAdjustment:value property
         * @returns the current value of the "value" property
         */
        get_value(): number;
        /**
         * Get the various properties of MxAdjustment.
         */
        get_values(): [number, number, number, number, number, number];
        /**
         * Interpolate #MxAdjustment:value to the new value specified by `value,` using
         * the mode and duration given.
         * @param value A #gdouble
         * @param duration duration in milliseconds
         * @param mode A #ClutterAnimationMode
         */
        interpolate(value: number, duration: number, mode: number): void;
        /**
         * Interpolate the value of #MxAdjustment:value to a new value calculated from
         * `offset`.
         * @param offset A #gdouble
         * @param duration duration in milliseconds
         * @param mode A #ClutterAnimationMode
         */
        interpolate_relative(offset: number, duration: number, mode: number): void;
        /**
         * Set the value of the #MxAdjustment:clamp-value property.
         * @param clamp a #gboolean
         */
        set_clamp_value(clamp: boolean): void;
        /**
         * Set the value of the #MxAdjustment:elastic property.
         * @param elastic A #gboolean
         */
        set_elastic(elastic: boolean): void;
        /**
         * Set the value of the #MxAdjustment:lower property.
         * @param lower A #gdouble
         */
        set_lower(lower: number): void;
        /**
         * Set the value of the #MxAdjustment:page-increment property.
         * @param increment A #gdouble
         */
        set_page_increment(increment: number): void;
        /**
         * Set the #MxAdjustment:page-size property.
         * @param page_size A #gdouble
         */
        set_page_size(page_size: number): void;
        /**
         * Set the value of the #MxAdjustment:step-increment property.
         * @param increment A #gdouble
         */
        set_step_increment(increment: number): void;
        /**
         * Set the value of the #MxAdjustment:upper property.
         * @param upper A #gdouble
         */
        set_upper(upper: number): void;
        /**
         * Set the value of the #MxAdjustment:value property.
         * @param value A #gdouble
         */
        set_value(value: number): void;
        /**
         * Set the various properties of MxAdjustment.
         * @param value A #gdouble
         * @param lower A #gdouble
         * @param upper A #gdouble
         * @param step_increment A #gdouble
         * @param page_increment A #gdouble
         * @param page_size A #gdouble
         */
        set_values(
            value: number,
            lower: number,
            upper: number,
            step_increment: number,
            page_increment: number,
            page_size: number,
        ): void;
    }

    module Application {
        // Constructor properties interface

        interface ConstructorProps
            extends Gio.Application.ConstructorProps,
                Gio.ActionGroup.ConstructorProps,
                Gio.ActionMap.ConstructorProps {}
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class Application extends Gio.Application implements Gio.ActionGroup, Gio.ActionMap {
        static $gtype: GObject.GType<Application>;

        // Constructors

        constructor(properties?: Partial<Application.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](application_id: string, flags: Gio.ApplicationFlags): Application;
        // Conflicted with Gio.Application.new

        static ['new'](...args: never[]): any;

        // Methods

        /**
         * Adds a window to the list of windows associated with `application`. If this
         * is the first window, it will be treated as the primary window and used for
         * startup notification.
         *
         * This function does not take a reference on `window`.
         * @param window The #MxWindow to add to the application
         */
        add_window(window: Window): void;
        /**
         * Creates a new #MxWindow and adds it to MxApplication. The application must be
         * registered before this function is run.
         * @param window_title Title for the new window
         * @returns The newly created MxWindow
         */
        create_window(window_title: string): Window;
        /**
         * Retrieves all windows added to `application`.
         * @returns a list of #MxWindow<!-- -->s. The returned list is owned by @application and must not be altered.
         */
        get_windows(): Window[];
        /**
         * Remove the specified window from the application. This will cause the window
         * to be unreferenced and destroyed unless another reference is held on it.
         * @param window an #MxWindow
         */
        remove_window(window: Window): void;

        // Inherited methods
        /**
         * Emits the #GActionGroup::action-added signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        action_added(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param enabled whether or not the action is now enabled
         */
        action_enabled_changed(action_name: string, enabled: boolean): void;
        /**
         * Emits the #GActionGroup::action-removed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        action_removed(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-state-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param state the new state of the named action
         */
        action_state_changed(action_name: string, state: GLib.Variant): void;
        /**
         * Activate the named action within `action_group`.
         *
         * If the action is expecting a parameter, then the correct type of
         * parameter must be given as `parameter`.  If the action is expecting no
         * parameters then `parameter` must be %NULL.  See
         * g_action_group_get_action_parameter_type().
         *
         * If the #GActionGroup implementation supports asynchronous remote
         * activation over D-Bus, this call may return before the relevant
         * D-Bus traffic has been sent, or any replies have been received. In
         * order to block on such asynchronous activation calls,
         * g_dbus_connection_flush() should be called prior to the code, which
         * depends on the result of the action activation. Without flushing
         * the D-Bus connection, there is no guarantee that the action would
         * have been activated.
         *
         * The following code which runs in a remote app instance, shows an
         * example of a "quit" action being activated on the primary app
         * instance over D-Bus. Here g_dbus_connection_flush() is called
         * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
         * may fail to be activated on the primary instance.
         *
         *
         * ```c
         * // call "quit" action on primary instance
         * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
         *
         * // make sure the action is activated now
         * g_dbus_connection_flush (...);
         *
         * g_debug ("application has been terminated. exiting.");
         *
         * exit (0);
         * ```
         *
         * @param action_name the name of the action to activate
         * @param parameter parameters to the activation
         */
        activate_action(action_name: string, parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of the named action within `action_group` to be
         * changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_group_get_action_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_group_get_action_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param action_name the name of the action to request the change on
         * @param value the new state
         */
        change_action_state(action_name: string, value: GLib.Variant): void;
        /**
         * Checks if the named action within `action_group` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @param action_name the name of the action to query
         * @returns whether or not the action is currently enabled
         */
        get_action_enabled(action_name: string): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * the named action within `action_group`.
         *
         * When activating the action using g_action_group_activate_action(),
         * the #GVariant given to that function must be of the type returned
         * by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         *
         * The parameter type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different parameter type.
         * @param action_name the name of the action to query
         * @returns the parameter type
         */
        get_action_parameter_type(action_name: string): GLib.VariantType | null;
        /**
         * Queries the current state of the named action within `action_group`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_group_get_action_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         * @returns the current state of the action
         */
        get_action_state(action_name: string): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of the
         * named action within `action_group`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         * @returns the state range hint
         */
        get_action_state_hint(action_name: string): GLib.Variant | null;
        /**
         * Queries the type of the state of the named action within
         * `action_group`.
         *
         * If the action is stateful then this function returns the
         * #GVariantType of the state.  All calls to
         * g_action_group_change_action_state() must give a #GVariant of this
         * type and g_action_group_get_action_state() will return a #GVariant
         * of the same type.
         *
         * If the action is not stateful then this function will return %NULL.
         * In that case, g_action_group_get_action_state() will return %NULL
         * and you must not call g_action_group_change_action_state().
         *
         * The state type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different state type.
         * @param action_name the name of the action to query
         * @returns the state type, if the action is stateful
         */
        get_action_state_type(action_name: string): GLib.VariantType | null;
        /**
         * Checks if the named action exists within `action_group`.
         * @param action_name the name of the action to check for
         * @returns whether the named action exists
         */
        has_action(action_name: string): boolean;
        /**
         * Lists the actions contained within `action_group`.
         *
         * The caller is responsible for freeing the list with g_strfreev() when
         * it is no longer required.
         * @returns a %NULL-terminated array of the names of the actions in the group
         */
        list_actions(): string[];
        /**
         * Queries all aspects of the named action within an `action_group`.
         *
         * This function acquires the information available from
         * g_action_group_has_action(), g_action_group_get_action_enabled(),
         * g_action_group_get_action_parameter_type(),
         * g_action_group_get_action_state_type(),
         * g_action_group_get_action_state_hint() and
         * g_action_group_get_action_state() with a single function call.
         *
         * This provides two main benefits.
         *
         * The first is the improvement in efficiency that comes with not having
         * to perform repeated lookups of the action in order to discover
         * different things about it.  The second is that implementing
         * #GActionGroup can now be done by only overriding this one virtual
         * function.
         *
         * The interface provides a default implementation of this function that
         * calls the individual functions, as required, to fetch the
         * information.  The interface also provides default implementations of
         * those functions that call this function.  All implementations,
         * therefore, must override either this function or all of the others.
         *
         * If the action exists, %TRUE is returned and any of the requested
         * fields (as indicated by having a non-%NULL reference passed in) are
         * filled.  If the action doesn't exist, %FALSE is returned and the
         * fields may or may not have been modified.
         * @param action_name the name of an action in the group
         * @returns %TRUE if the action exists, else %FALSE
         */
        query_action(
            action_name: string,
        ): [
            boolean,
            boolean,
            GLib.VariantType | null,
            GLib.VariantType | null,
            GLib.Variant | null,
            GLib.Variant | null,
        ];
        /**
         * Emits the #GActionGroup::action-added signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        vfunc_action_added(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-enabled-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param enabled whether or not the action is now enabled
         */
        vfunc_action_enabled_changed(action_name: string, enabled: boolean): void;
        /**
         * Emits the #GActionGroup::action-removed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         */
        vfunc_action_removed(action_name: string): void;
        /**
         * Emits the #GActionGroup::action-state-changed signal on `action_group`.
         *
         * This function should only be called by #GActionGroup implementations.
         * @param action_name the name of an action in the group
         * @param state the new state of the named action
         */
        vfunc_action_state_changed(action_name: string, state: GLib.Variant): void;
        /**
         * Activate the named action within `action_group`.
         *
         * If the action is expecting a parameter, then the correct type of
         * parameter must be given as `parameter`.  If the action is expecting no
         * parameters then `parameter` must be %NULL.  See
         * g_action_group_get_action_parameter_type().
         *
         * If the #GActionGroup implementation supports asynchronous remote
         * activation over D-Bus, this call may return before the relevant
         * D-Bus traffic has been sent, or any replies have been received. In
         * order to block on such asynchronous activation calls,
         * g_dbus_connection_flush() should be called prior to the code, which
         * depends on the result of the action activation. Without flushing
         * the D-Bus connection, there is no guarantee that the action would
         * have been activated.
         *
         * The following code which runs in a remote app instance, shows an
         * example of a "quit" action being activated on the primary app
         * instance over D-Bus. Here g_dbus_connection_flush() is called
         * before `exit()`. Without g_dbus_connection_flush(), the "quit" action
         * may fail to be activated on the primary instance.
         *
         *
         * ```c
         * // call "quit" action on primary instance
         * g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
         *
         * // make sure the action is activated now
         * g_dbus_connection_flush (...);
         *
         * g_debug ("application has been terminated. exiting.");
         *
         * exit (0);
         * ```
         *
         * @param action_name the name of the action to activate
         * @param parameter parameters to the activation
         */
        vfunc_activate_action(action_name: string, parameter?: GLib.Variant | null): void;
        /**
         * Request for the state of the named action within `action_group` to be
         * changed to `value`.
         *
         * The action must be stateful and `value` must be of the correct type.
         * See g_action_group_get_action_state_type().
         *
         * This call merely requests a change.  The action may refuse to change
         * its state or may change its state to something other than `value`.
         * See g_action_group_get_action_state_hint().
         *
         * If the `value` GVariant is floating, it is consumed.
         * @param action_name the name of the action to request the change on
         * @param value the new state
         */
        vfunc_change_action_state(action_name: string, value: GLib.Variant): void;
        /**
         * Checks if the named action within `action_group` is currently enabled.
         *
         * An action must be enabled in order to be activated or in order to
         * have its state changed from outside callers.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_enabled(action_name: string): boolean;
        /**
         * Queries the type of the parameter that must be given when activating
         * the named action within `action_group`.
         *
         * When activating the action using g_action_group_activate_action(),
         * the #GVariant given to that function must be of the type returned
         * by this function.
         *
         * In the case that this function returns %NULL, you must not give any
         * #GVariant, but %NULL instead.
         *
         * The parameter type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different parameter type.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_parameter_type(action_name: string): GLib.VariantType | null;
        /**
         * Queries the current state of the named action within `action_group`.
         *
         * If the action is not stateful then %NULL will be returned.  If the
         * action is stateful then the type of the return value is the type
         * given by g_action_group_get_action_state_type().
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state(action_name: string): GLib.Variant | null;
        /**
         * Requests a hint about the valid range of values for the state of the
         * named action within `action_group`.
         *
         * If %NULL is returned it either means that the action is not stateful
         * or that there is no hint about the valid range of values for the
         * state of the action.
         *
         * If a #GVariant array is returned then each item in the array is a
         * possible value for the state.  If a #GVariant pair (ie: two-tuple) is
         * returned then the tuple specifies the inclusive lower and upper bound
         * of valid values for the state.
         *
         * In any case, the information is merely a hint.  It may be possible to
         * have a state value outside of the hinted range and setting a value
         * within the range may fail.
         *
         * The return value (if non-%NULL) should be freed with
         * g_variant_unref() when it is no longer required.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state_hint(action_name: string): GLib.Variant | null;
        /**
         * Queries the type of the state of the named action within
         * `action_group`.
         *
         * If the action is stateful then this function returns the
         * #GVariantType of the state.  All calls to
         * g_action_group_change_action_state() must give a #GVariant of this
         * type and g_action_group_get_action_state() will return a #GVariant
         * of the same type.
         *
         * If the action is not stateful then this function will return %NULL.
         * In that case, g_action_group_get_action_state() will return %NULL
         * and you must not call g_action_group_change_action_state().
         *
         * The state type of a particular action will never change but it is
         * possible for an action to be removed and for a new action to be added
         * with the same name but a different state type.
         * @param action_name the name of the action to query
         */
        vfunc_get_action_state_type(action_name: string): GLib.VariantType | null;
        /**
         * Checks if the named action exists within `action_group`.
         * @param action_name the name of the action to check for
         */
        vfunc_has_action(action_name: string): boolean;
        /**
         * Lists the actions contained within `action_group`.
         *
         * The caller is responsible for freeing the list with g_strfreev() when
         * it is no longer required.
         */
        vfunc_list_actions(): string[];
        /**
         * Queries all aspects of the named action within an `action_group`.
         *
         * This function acquires the information available from
         * g_action_group_has_action(), g_action_group_get_action_enabled(),
         * g_action_group_get_action_parameter_type(),
         * g_action_group_get_action_state_type(),
         * g_action_group_get_action_state_hint() and
         * g_action_group_get_action_state() with a single function call.
         *
         * This provides two main benefits.
         *
         * The first is the improvement in efficiency that comes with not having
         * to perform repeated lookups of the action in order to discover
         * different things about it.  The second is that implementing
         * #GActionGroup can now be done by only overriding this one virtual
         * function.
         *
         * The interface provides a default implementation of this function that
         * calls the individual functions, as required, to fetch the
         * information.  The interface also provides default implementations of
         * those functions that call this function.  All implementations,
         * therefore, must override either this function or all of the others.
         *
         * If the action exists, %TRUE is returned and any of the requested
         * fields (as indicated by having a non-%NULL reference passed in) are
         * filled.  If the action doesn't exist, %FALSE is returned and the
         * fields may or may not have been modified.
         * @param action_name the name of an action in the group
         */
        vfunc_query_action(
            action_name: string,
        ): [
            boolean,
            boolean,
            GLib.VariantType | null,
            GLib.VariantType | null,
            GLib.Variant | null,
            GLib.Variant | null,
        ];
        /**
         * Adds an action to the `action_map`.
         *
         * If the action map already contains an action with the same name
         * as `action` then the old action is dropped from the action map.
         *
         * The action map takes its own reference on `action`.
         * @param action a #GAction
         */
        add_action(action: Gio.Action): void;
        /**
         * A convenience function for creating multiple simple actions.
         * See Gio.ActionEntryObj for the structure of the action entry.
         * @param entries Array of action entries to add
         */
        add_action_entries(entries: Gio.ActionEntryObj[]): void;
        /**
         * Looks up the action with the name `action_name` in `action_map`.
         *
         * If no such action exists, returns %NULL.
         * @param action_name the name of an action
         * @returns a #GAction, or %NULL
         */
        lookup_action(action_name: string): Gio.Action | null;
        /**
         * Removes the named action from the action map.
         *
         * If no action of this name is in the map then nothing happens.
         * @param action_name the name of the action
         */
        remove_action(action_name: string): void;
        /**
         * Remove actions from a #GActionMap. This is meant as the reverse of
         * g_action_map_add_action_entries().
         *
         *
         *
         * ```c
         * static const GActionEntry entries[] = {
         *     { "quit",         activate_quit              },
         *     { "print-string", activate_print_string, "s" }
         * };
         *
         * void
         * add_actions (GActionMap *map)
         * {
         *   g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), NULL);
         * }
         *
         * void
         * remove_actions (GActionMap *map)
         * {
         *   g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
         * }
         * ```
         *
         * @param entries a pointer to           the first item in an array of #GActionEntry structs
         */
        remove_action_entries(entries: Gio.ActionEntry[]): void;
        /**
         * Adds an action to the `action_map`.
         *
         * If the action map already contains an action with the same name
         * as `action` then the old action is dropped from the action map.
         *
         * The action map takes its own reference on `action`.
         * @param action a #GAction
         */
        vfunc_add_action(action: Gio.Action): void;
        /**
         * Looks up the action with the name `action_name` in `action_map`.
         *
         * If no such action exists, returns %NULL.
         * @param action_name the name of an action
         */
        vfunc_lookup_action(action_name: string): Gio.Action | null;
        /**
         * Removes the named action from the action map.
         *
         * If no action of this name is in the map then nothing happens.
         * @param action_name the name of the action
         */
        vfunc_remove_action(action_name: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Bin {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {
            child: Clutter.Actor;
            x_align: Align | any;
            xAlign: Align | any;
            x_fill: boolean;
            xFill: boolean;
            y_align: Align | any;
            yAlign: Align | any;
            y_fill: boolean;
            yFill: boolean;
        }
    }

    /**
     * The #MxBin struct contains only private data
     */
    abstract class Bin
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<Bin>;

        // Properties

        /**
         * The child #ClutterActor of the #MxBin container.
         */
        get child(): Clutter.Actor;
        set child(val: Clutter.Actor);
        /**
         * The horizontal alignment of the #MxBin child.
         */
        // This accessor conflicts with another accessor's type in a parent class or interface.
        get x_align(): Align | any;
        // This accessor conflicts with another accessor's type in a parent class or interface.
        set x_align(val: Align | any);
        /**
         * The horizontal alignment of the #MxBin child.
         */
        // This accessor conflicts with another accessor's type in a parent class or interface.
        get xAlign(): Align | any;
        // This accessor conflicts with another accessor's type in a parent class or interface.
        set xAlign(val: Align | any);
        /**
         * Whether the child should fill the horizontal allocation
         */
        get x_fill(): boolean;
        set x_fill(val: boolean);
        /**
         * Whether the child should fill the horizontal allocation
         */
        get xFill(): boolean;
        set xFill(val: boolean);
        /**
         * The vertical alignment of the #MxBin child.
         */
        // This accessor conflicts with another accessor's type in a parent class or interface.
        get y_align(): Align | any;
        // This accessor conflicts with another accessor's type in a parent class or interface.
        set y_align(val: Align | any);
        /**
         * The vertical alignment of the #MxBin child.
         */
        // This accessor conflicts with another accessor's type in a parent class or interface.
        get yAlign(): Align | any;
        // This accessor conflicts with another accessor's type in a parent class or interface.
        set yAlign(val: Align | any);
        /**
         * Whether the child should fill the vertical allocation
         */
        get y_fill(): boolean;
        set y_fill(val: boolean);
        /**
         * Whether the child should fill the vertical allocation
         */
        get yFill(): boolean;
        set yFill(val: boolean);

        // Constructors

        constructor(properties?: Partial<Bin.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Allocates the child of an #MxBin using the width and height from `box`.
         * This function should usually only be called by subclasses of #MxBin.
         *
         * This function can be used to allocate the child of an #MxBin if no special
         * allocation requirements are needed. It is similar to
         * #mx_allocate_align_fill, except that it reads the alignment, padding and
         * fill values from the #MxBin, and will call #clutter_actor_allocate on the
         * child.
         * @param box The allocation box of the parent actor.
         * @param flags #ClutterAllocationFlags, usually provided by the. clutter_actor_allocate function.
         */
        allocate_child(box: Clutter.ActorBox, flags: Clutter.AllocationFlags | null): void;
        /**
         * Retrieves the horizontal and vertical alignment of the child
         * inside a #MxBin, as set by mx_bin_set_alignment().
         */
        get_alignment(): [Align | null, Align | null];
        /**
         * Retrieves a pointer to the child of `bin`.
         * @returns a #ClutterActor, or %NULL
         */
        get_child(): Clutter.Actor;
        /**
         * Retrieves the horizontal and vertical fill settings
         */
        get_fill(): [boolean, boolean];
        /**
         * Sets the horizontal and vertical alignment of the child
         * inside a #MxBin.
         * @param x_align horizontal alignment
         * @param y_align vertical alignment
         */
        set_alignment(x_align: Align | null, y_align: Align | null): void;
        /**
         * Sets `child` as the child of `bin`.
         *
         * If `bin` already has a child, the previous child is removed.
         * @param child a #ClutterActor, or %NULL
         */
        set_child(child: Clutter.Actor): void;
        /**
         * Sets whether the child of `bin` should fill out the horizontal
         * and/or vertical allocation of the parent
         * @param x_fill %TRUE if the child should fill horizontally the @bin
         * @param y_fill %TRUE if the child should fill vertically the @bin
         */
        set_fill(x_fill: boolean, y_fill: boolean): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module BoxLayout {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Scrollable.ConstructorProps,
                Stylable.ConstructorProps {
            enable_animations: boolean;
            enableAnimations: boolean;
            orientation: Orientation;
            scroll_to_focused: boolean;
            scrollToFocused: boolean;
            spacing: number;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class BoxLayout
        extends Widget
        implements
            Atk.ImplementorIface,
            Clutter.Animatable,
            Clutter.Container,
            Clutter.Scriptable,
            Focusable,
            Scrollable,
            Stylable
    {
        static $gtype: GObject.GType<BoxLayout>;

        // Properties

        get enable_animations(): boolean;
        set enable_animations(val: boolean);
        get enableAnimations(): boolean;
        set enableAnimations(val: boolean);
        get orientation(): Orientation;
        set orientation(val: Orientation);
        get scroll_to_focused(): boolean;
        set scroll_to_focused(val: boolean);
        get scrollToFocused(): boolean;
        set scrollToFocused(val: boolean);
        get spacing(): number;
        set spacing(val: number);

        // Constructors

        constructor(properties?: Partial<BoxLayout.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): BoxLayout;

        static new_with_orientation(orientation: Orientation): BoxLayout;

        // Methods

        /**
         * Get the value of the #MxBoxLayoutChild:expand property
         * @param child A #ClutterActor
         * @returns the current value of the "expand" property
         */
        child_get_expand(child: Clutter.Actor): boolean;
        /**
         * Get the value of the #MxBoxLayoutChild:x-align property
         * @param child A #ClutterActor
         * @returns the current value of the "x-align" property
         */
        child_get_x_align(child: Clutter.Actor): Align;
        /**
         * Get the value of the #MxBoxLayoutChild:x-fill property.
         * @param child A #ClutterActor
         * @returns the current value of the "x-fill" property.
         */
        child_get_x_fill(child: Clutter.Actor): boolean;
        /**
         * Get the value of the #MxBoxLayoutChild:y-align property.
         * @param child A #ClutterActor
         * @returns the current value of the "y-align" property.
         */
        child_get_y_align(child: Clutter.Actor): Align;
        /**
         * Get the value of the #MxBoxLayoutChild:y-fill property
         * @param child A #ClutterActor
         * @returns the current value of the "y-fill" property
         */
        child_get_y_fill(child: Clutter.Actor): boolean;
        /**
         * Set the value of the #MxBoxLayoutChild:expand property.
         * @param child A #ClutterActor
         * @param expand A #gboolean
         */
        child_set_expand(child: Clutter.Actor, expand: boolean): void;
        /**
         * Set the value of the #MxBoxLayoutChild:x-align property.
         * @param child A #ClutterActor
         * @param x_align An #MxAlign
         */
        child_set_x_align(child: Clutter.Actor, x_align: Align | null): void;
        /**
         * Set the value of the #MxBoxLayoutChild:x-fill property.
         * @param child A #ClutterActor
         * @param x_fill A #gboolean
         */
        child_set_x_fill(child: Clutter.Actor, x_fill: boolean): void;
        /**
         * Set the value of the #MxBoxLayoutChild:y-align property.
         * @param child A #ClutterActor
         * @param y_align An #MxAlign
         */
        child_set_y_align(child: Clutter.Actor, y_align: Align | null): void;
        /**
         * Set the value of the #MxBoxLayoutChild:y-fill property.
         * @param child A #ClutterActor
         * @param y_fill A #gboolean
         */
        child_set_y_fill(child: Clutter.Actor, y_fill: boolean): void;
        /**
         * Get the value of the #MxBoxLayout:enable-animations property.
         * @returns #TRUE if animations enabled
         */
        get_enable_animations(): boolean;
        /**
         * Get the value of the #MxBoxLayout:orientation property.
         * @returns the orientation of the layout
         */
        get_orientation(): Orientation;
        /**
         * Get the value of the #MxBoxLayout:scroll-to-focused property.
         * @returns #TRUE if automatically scrolling to the focused actor is enabled
         */
        get_scroll_to_focused(): boolean;
        /**
         * Get the spacing between children in pixels
         * @returns the spacing value
         */
        get_spacing(): number;
        /**
         * Inserts `actor` at `position` in `box`.
         * @param actor the #ClutterActor actor to add to the box layout
         * @param position the position where to insert the actor
         */
        insert_actor(actor: Clutter.Actor, position: number): void;
        /**
         * Enable animations when certain properties change.
         * @param enable_animations #TRUE to enable animations
         */
        set_enable_animations(enable_animations: boolean): void;
        /**
         * Set the orientation of the box layout.
         * @param orientation orientation value for the layout
         */
        set_orientation(orientation: Orientation | null): void;
        /**
         * Enables or disables automatic scrolling to the focused actor.
         * @param scroll_to_focused #TRUE to enable automatically scrolling to the focused actor
         */
        set_scroll_to_focused(scroll_to_focused: boolean): void;
        /**
         * Set the amount of spacing between children in pixels
         * @param spacing the spacing value
         */
        set_spacing(spacing: number): void;

        // Inherited properties
        get horizontal_adjustment(): Adjustment;
        set horizontal_adjustment(val: Adjustment);
        get horizontalAdjustment(): Adjustment;
        set horizontalAdjustment(val: Adjustment);
        get vertical_adjustment(): Adjustment;
        set vertical_adjustment(val: Adjustment);
        get verticalAdjustment(): Adjustment;
        set verticalAdjustment(val: Adjustment);
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        get_adjustments(): [Adjustment | null, Adjustment | null];
        set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        vfunc_get_adjustments(): [Adjustment | null, Adjustment | null];
        vfunc_set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module BoxLayoutChild {
        // Constructor properties interface

        interface ConstructorProps extends Clutter.ChildMeta.ConstructorProps {
            expand: boolean;
            x_align: Align;
            xAlign: Align;
            x_fill: boolean;
            xFill: boolean;
            y_align: Align;
            yAlign: Align;
            y_fill: boolean;
            yFill: boolean;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class BoxLayoutChild extends Clutter.ChildMeta {
        static $gtype: GObject.GType<BoxLayoutChild>;

        // Properties

        get expand(): boolean;
        set expand(val: boolean);
        get x_align(): Align;
        set x_align(val: Align);
        get xAlign(): Align;
        set xAlign(val: Align);
        get x_fill(): boolean;
        set x_fill(val: boolean);
        get xFill(): boolean;
        set xFill(val: boolean);
        get y_align(): Align;
        set y_align(val: Align);
        get yAlign(): Align;
        set yAlign(val: Align);
        get y_fill(): boolean;
        set y_fill(val: boolean);
        get yFill(): boolean;
        set yFill(val: boolean);

        // Constructors

        constructor(properties?: Partial<BoxLayoutChild.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;
    }

    module Button {
        // Signal callback interfaces

        interface Clicked {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {
            action: Action;
            icon_name: string;
            iconName: string;
            icon_position: Position;
            iconPosition: Position;
            icon_size: number;
            iconSize: number;
            icon_visible: boolean;
            iconVisible: boolean;
            is_toggle: boolean;
            isToggle: boolean;
            label: string;
            label_visible: boolean;
            labelVisible: boolean;
            toggled: boolean;
        }
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class Button
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<Button>;

        // Properties

        get action(): Action;
        set action(val: Action);
        get icon_name(): string;
        set icon_name(val: string);
        get iconName(): string;
        set iconName(val: string);
        get icon_position(): Position;
        set icon_position(val: Position);
        get iconPosition(): Position;
        set iconPosition(val: Position);
        get icon_size(): number;
        set icon_size(val: number);
        get iconSize(): number;
        set iconSize(val: number);
        get icon_visible(): boolean;
        set icon_visible(val: boolean);
        get iconVisible(): boolean;
        set iconVisible(val: boolean);
        get is_toggle(): boolean;
        set is_toggle(val: boolean);
        get isToggle(): boolean;
        set isToggle(val: boolean);
        get label(): string;
        set label(val: string);
        get label_visible(): boolean;
        set label_visible(val: boolean);
        get labelVisible(): boolean;
        set labelVisible(val: boolean);
        get toggled(): boolean;
        set toggled(val: boolean);

        // Constructors

        constructor(properties?: Partial<Button.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Button;

        static new_with_label(text: string): Button;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'clicked', callback: (_source: this) => void): number;
        connect_after(signal: 'clicked', callback: (_source: this) => void): number;
        emit(signal: 'clicked'): void;

        // Virtual methods

        vfunc_clicked(): void;

        // Methods

        /**
         * Retrieves the #MxAction associated with `button`.
         * @returns A #MxAction
         */
        get_action(): Action;
        // Conflicted with Clutter.Actor.get_action
        get_action(...args: never[]): any;
        /**
         * Get the icon-name being used on the button.
         * @returns the icon-name. This must not be freed by the application. %NULL if no icon has been set
         */
        get_icon_name(): string;
        /**
         * Retrieves the icon's relative position to the text.
         * @returns A #MxPosition
         */
        get_icon_position(): Position;
        /**
         * Retrieves the icon-size being used for the displayed icon inside the button.
         * @returns The icon-size being used for the button icon, in pixels
         */
        get_icon_size(): number;
        /**
         * Retrieves the visibility of the icon associated with the button's action.
         * @returns %TRUE if the icon is visible, %FALSE otherwise
         */
        get_icon_visible(): boolean;
        /**
         * Get the toggle mode status of the button.
         * @returns #TRUE if toggle mode is set, otherwise #FALSE
         */
        get_is_toggle(): boolean;
        /**
         * Get the text displayed on the button
         * @returns the text for the button. This must not be freed by the application
         */
        get_label(): string;
        /**
         * Retrieves the visibility of the text associated with the button's action.
         * @returns %TRUE if the text is visible, %FALSE otherwise
         */
        get_label_visible(): boolean;
        /**
         * Get the state of the button that is in toggle mode.
         * @returns #TRUE if the button is toggled, or #FALSE if not
         */
        get_toggled(): boolean;
        /**
         * Sets `action` as the action for `button`. `Button` will take its label and
         * icon from `action`.
         * @param action A #MxAction
         */
        set_action(action: Action): void;
        /**
         * Sets the icon-name used to display an icon on the button. Setting %NULL
         * will remove the icon name, or resort to the icon-name set in the current
         * style. Setting an icon name overrides any icon set in the style.
         * @param icon_name icon-name to use on the button
         */
        set_icon_name(icon_name: string): void;
        /**
         * Sets the icon position, relative to the text on the button.
         * @param position A #MxPosition
         */
        set_icon_position(position: Position | null): void;
        /**
         * Sets the icon-size to use for the icon displayed inside the button. This will
         * override the icon-size set in the style. Setting a value of %0 resets to the
         * size from the style.
         * @param icon_size
         */
        set_icon_size(icon_size: number): void;
        /**
         * Sets the visibility of the icon associated with the button's action.
         * @param visible %TRUE if the icon should be visible
         */
        set_icon_visible(visible: boolean): void;
        /**
         * Enables or disables toggle mode for the button. In toggle mode, the active
         * state will be "toggled" when the user clicks the button.
         * @param toggle #TRUE or #FALSE
         */
        set_is_toggle(toggle: boolean): void;
        /**
         * Sets the text displayed on the button
         * @param text text to set the label to
         */
        set_label(text: string): void;
        /**
         * Sets the visibility of the text associated with the button's action.
         * @param visible %TRUE if the text should be visible
         */
        set_label_visible(visible: boolean): void;
        /**
         * Sets the toggled state of the button. This is only really useful if the
         * button has #toggle-mode mode set to #TRUE.
         * @param toggled #TRUE or #FALSE
         */
        set_toggled(toggled: boolean): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ButtonGroup {
        // Constructor properties interface

        interface ConstructorProps extends GObject.InitiallyUnowned.ConstructorProps {
            active_button: Button;
            activeButton: Button;
            allow_no_active: boolean;
            allowNoActive: boolean;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class ButtonGroup extends GObject.InitiallyUnowned {
        static $gtype: GObject.GType<ButtonGroup>;

        // Properties

        get active_button(): Button;
        set active_button(val: Button);
        get activeButton(): Button;
        set activeButton(val: Button);
        get allow_no_active(): boolean;
        set allow_no_active(val: boolean);
        get allowNoActive(): boolean;
        set allowNoActive(val: boolean);

        // Constructors

        constructor(properties?: Partial<ButtonGroup.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ButtonGroup;

        // Methods

        /**
         * Add `button` to the #MxButtonGroup.
         * @param button A #MxButton
         */
        add(button: Button): void;
        /**
         * Calls `callback` for each button in the group.
         * @param callback A #ClutterCallback
         */
        foreach(callback: Clutter.Callback): void;
        /**
         * Get the current active button
         * @returns the currently active button
         */
        get_active_button(): Button;
        /**
         * Get the value of the #MxButtonGroup:allow-no-active property.
         * @returns the value of the "allow-no-active" property.
         */
        get_allow_no_active(): boolean;
        /**
         * Get a list of the buttons in the button group.
         * @returns a list of buttons. The list is owned by the #MxButtonGroup and should not be modified by the application.
         */
        get_buttons(): Button[];
        /**
         * Remove `button` from the #MxButtonGroup
         * @param button A #MxButton
         */
        remove(button: Button): void;
        /**
         * Set the current active button in the group. The previous active button will
         * have #MxButton:toggled set to #FALSE.
         * @param button A #MxButton
         */
        set_active_button(button: Button): void;
        /**
         * Set the value of the #MxButtonGroup:allow-no-active property.
         * @param allow_no_active A #gboolean
         */
        set_allow_no_active(allow_no_active: boolean): void;
    }

    module Clipboard {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class Clipboard extends GObject.Object {
        static $gtype: GObject.GType<Clipboard>;

        // Constructors

        constructor(properties?: Partial<Clipboard.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Get the global #MxClipboard object that represents the clipboard.
         */
        static get_default(): Clipboard;

        // Methods

        /**
         * Request the data from the clipboard in text form. `callback` is executed
         * when the data is retreived.
         * @param callback function to be called when the text is retreived
         */
        get_text(callback: ClipboardCallbackFunc): void;
        /**
         * Sets text as the current contents of the clipboard.
         * @param text text to copy to the clipboard
         */
        set_text(text: string): void;
    }

    module ComboBox {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {
            active_icon_name: string;
            activeIconName: string;
            active_text: string;
            activeText: string;
            index: number;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class ComboBox
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<ComboBox>;

        // Properties

        get active_icon_name(): string;
        set active_icon_name(val: string);
        get activeIconName(): string;
        set activeIconName(val: string);
        get active_text(): string;
        set active_text(val: string);
        get activeText(): string;
        set activeText(val: string);
        get index(): number;
        set index(val: number);

        // Constructors

        constructor(properties?: Partial<ComboBox.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ComboBox;

        // Methods

        /**
         * Append an item to the combo box list
         * @param text name of the item
         */
        append_text(text: string): void;
        /**
         * Get the name of the icon displayed in the combo box
         * @returns the text string of the name of the displayed icon, owned by the combo box, or %NULL if there is no active icon.
         */
        get_active_icon_name(): string;
        /**
         * Get the text displayed in the combo box
         * @returns the text string, owned by the combo box
         */
        get_active_text(): string;
        /**
         * Get the index of the last item selected
         * @returns gint
         */
        get_index(): number;
        /**
         * Insert an item into the combo box list.
         * @param position zero indexed position to insert the item at
         * @param text name of the item
         */
        insert_text(position: number, text: string): void;
        /**
         * Insert an item with text and an icon into the combo box list.
         * @param position zero indexed position to insert the item at
         * @param text name of the item
         * @param icon name of an icon from the icon theme
         */
        insert_text_with_icon(position: number, text: string, icon: string): void;
        /**
         * Prepend an item to the combo box list
         * @param text name of the item
         */
        prepend_text(text: string): void;
        /**
         * Remove all the items of `box`
         */
        remove_all(): void;
        /**
         * Remove the item at `position`
         * @param position position of the item to remove
         */
        remove_text(position: number): void;
        /**
         * Set the icon displayed in the combo box.
         * @param icon_name Icon name to use for displayed icon
         */
        set_active_icon_name(icon_name: string): void;
        /**
         * Set the text displayed in the combo box
         * @param text text to display
         */
        set_active_text(text: string): void;
        /**
         * Set the current combo box text from the item at `index` in the list.
         * @param index the index of the list item to set
         */
        set_index(index: number): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Dialog {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {}
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class Dialog
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<Dialog>;

        // Constructors

        constructor(properties?: Partial<Dialog.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Dialog;

        // Methods

        /**
         * Adds an #MxButton that represents `action` to the button area of `dialog`
         * @param action A #MxAction
         */
        add_action(action: Action): void;
        // Conflicted with Clutter.Actor.add_action
        add_action(...args: never[]): any;
        /**
         * Retrieves a list of actions added to `dialog`.
         * @returns A newly allocated #GList of #MxAction objects. The actions in the list are owned by the dialog.
         */
        get_actions(): Action[];
        // Conflicted with Clutter.Actor.get_actions
        get_actions(...args: never[]): any;
        /**
         * Removes the button associated with `action` from the button area of `dialog`
         * @param action A #MxAction
         */
        remove_action(action: Action): void;
        // Conflicted with Clutter.Actor.remove_action
        remove_action(...args: never[]): any;
        /**
         * Sets the parent of the #MxDialog. This is the actor over which the
         * modal frame will appear when clutter_actor_show() is called.
         * @param actor A #ClutterActor
         */
        set_transient_parent(actor: Clutter.Actor): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Entry {
        // Signal callback interfaces

        interface PrimaryIconClicked {
            (): void;
        }

        interface SecondaryIconClicked {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {
            clutter_text: Clutter.Text;
            clutterText: Clutter.Text;
            icon_highlight_suffix: string;
            iconHighlightSuffix: string;
            password_char: number;
            passwordChar: number;
            placeholder: string;
            primary_icon_tooltip_text: string;
            primaryIconTooltipText: string;
            secondary_icon_tooltip_text: string;
            secondaryIconTooltipText: string;
            text: string;
        }
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class Entry
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<Entry>;

        // Properties

        get clutter_text(): Clutter.Text;
        get clutterText(): Clutter.Text;
        get icon_highlight_suffix(): string;
        set icon_highlight_suffix(val: string);
        get iconHighlightSuffix(): string;
        set iconHighlightSuffix(val: string);
        get password_char(): number;
        set password_char(val: number);
        get passwordChar(): number;
        set passwordChar(val: number);
        get placeholder(): string;
        set placeholder(val: string);
        get primary_icon_tooltip_text(): string;
        set primary_icon_tooltip_text(val: string);
        get primaryIconTooltipText(): string;
        set primaryIconTooltipText(val: string);
        get secondary_icon_tooltip_text(): string;
        set secondary_icon_tooltip_text(val: string);
        get secondaryIconTooltipText(): string;
        set secondaryIconTooltipText(val: string);
        get text(): string;
        set text(val: string);

        // Constructors

        constructor(properties?: Partial<Entry.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Entry;

        static new_with_text(text: string): Entry;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'primary-icon-clicked', callback: (_source: this) => void): number;
        connect_after(signal: 'primary-icon-clicked', callback: (_source: this) => void): number;
        emit(signal: 'primary-icon-clicked'): void;
        connect(signal: 'secondary-icon-clicked', callback: (_source: this) => void): number;
        connect_after(signal: 'secondary-icon-clicked', callback: (_source: this) => void): number;
        emit(signal: 'secondary-icon-clicked'): void;

        // Virtual methods

        vfunc_primary_icon_clicked(): void;
        vfunc_secondary_icon_clicked(): void;

        // Methods

        /**
         * Retrieve the internal #ClutterText so that extra parameters can be set
         * @returns the #ClutterText used by #MxEntry. The entry is owned by the #MxEntry and should not be unref'ed by the application.
         */
        get_clutter_text(): Clutter.Actor;
        /**
         * Get the suffix appended to the filename to use for the highlighted version
         * of the icon.
         * @returns the highlight filename suffix. This string is owned by the #MxEntry and should not be freed or modified.
         */
        get_icon_highlight_suffix(): string;
        /**
         * Gets the character to display instead of the text.
         * @returns a character, or 0 if input should not be hidden.
         */
        get_password_char(): number;
        /**
         * Gets the text that is displayed when the entry is empty and unfocused
         * @returns the current value of the placeholder property. This string is owned by the #MxEntry and should not be freed or modified.
         */
        get_placeholder(): string;
        /**
         * Get the text displayed on the entry
         * @returns the text for the entry. This must not be freed by the application
         */
        get_text(): string;
        /**
         * Sets the suffix appended to the filename to use for the highlighted version
         * of the icon. e.g. if you have set your primay icon to "primary-icon.png"
         * and the suffix to "-highlight" #MxEntry will look for
         * "primary-icon-highlight.png"
         * @param suffix the suffix to append to the filename for the highlight version
         */
        set_icon_highlight_suffix(suffix: string): void;
        /**
         * Sets the character to display instead of the text. Use 0 to display
         * the actual text.
         * @param password_char character to display instead of text
         */
        set_password_char(password_char: number): void;
        /**
         * Sets the text to display when the entry is empty and unfocused. When the
         * entry is displaying the hint, it has a pseudo class of "indeterminate".
         * A value of NULL unsets the hint.
         * @param text text to set as the entry hint
         */
        set_placeholder(text: string): void;
        /**
         * Set the primary icon of the entry to the given filename
         * @param filename filename of an icon
         */
        set_primary_icon_from_file(filename: string): void;
        set_primary_icon_tooltip_text(text: string): void;
        /**
         * Set the primary icon of the entry to the given filename
         * @param filename filename of an icon
         */
        set_secondary_icon_from_file(filename: string): void;
        set_secondary_icon_tooltip_text(text: string): void;
        /**
         * Sets the text displayed on the entry
         * @param text text to set the entry to
         */
        set_text(text: string): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Expander {
        // Signal callback interfaces

        interface ExpandComplete {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Stylable.ConstructorProps {
            expanded: boolean;
            label: string;
        }
    }

    /**
     * The contents of the this structure are private and should only be accessed
     * through the public API.
     */
    class Expander
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Stylable
    {
        static $gtype: GObject.GType<Expander>;

        // Properties

        get expanded(): boolean;
        set expanded(val: boolean);
        get label(): string;
        set label(val: string);

        // Constructors

        constructor(properties?: Partial<Expander.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Expander;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'expand-complete', callback: (_source: this) => void): number;
        connect_after(signal: 'expand-complete', callback: (_source: this) => void): number;
        emit(signal: 'expand-complete'): void;

        // Virtual methods

        vfunc_expand_complete(): void;

        // Methods

        /**
         * Get the current state of the expander (the value of #MxExpander:expanded)
         * @returns #TRUE if the expander is open, #FALSE if it is closed
         */
        get_expanded(): boolean;
        /**
         * Set the state (the #MxExpander:expanded property) of the expander.
         * This will cause the expander to open or close.
         * @param expanded the state of the expander to set
         */
        set_expanded(expanded: boolean): void;
        /**
         * Sets the text displayed as the title of the expander
         * @param label string to set as the expander label
         */
        set_label(label: string): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module FadeEffect {
        // Constructor properties interface

        interface ConstructorProps extends Clutter.OffscreenEffect.ConstructorProps {
            border_bottom: number;
            borderBottom: number;
            border_left: number;
            borderLeft: number;
            border_right: number;
            borderRight: number;
            border_top: number;
            borderTop: number;
            bounds_height: number;
            boundsHeight: number;
            bounds_width: number;
            boundsWidth: number;
            bounds_x: number;
            boundsX: number;
            bounds_y: number;
            boundsY: number;
            color: Clutter.Color;
            freeze_update: boolean;
            freezeUpdate: boolean;
        }
    }

    class FadeEffect extends Clutter.OffscreenEffect {
        static $gtype: GObject.GType<FadeEffect>;

        // Properties

        get border_bottom(): number;
        set border_bottom(val: number);
        get borderBottom(): number;
        set borderBottom(val: number);
        get border_left(): number;
        set border_left(val: number);
        get borderLeft(): number;
        set borderLeft(val: number);
        get border_right(): number;
        set border_right(val: number);
        get borderRight(): number;
        set borderRight(val: number);
        get border_top(): number;
        set border_top(val: number);
        get borderTop(): number;
        set borderTop(val: number);
        get bounds_height(): number;
        set bounds_height(val: number);
        get boundsHeight(): number;
        set boundsHeight(val: number);
        get bounds_width(): number;
        set bounds_width(val: number);
        get boundsWidth(): number;
        set boundsWidth(val: number);
        get bounds_x(): number;
        set bounds_x(val: number);
        get boundsX(): number;
        set boundsX(val: number);
        get bounds_y(): number;
        set bounds_y(val: number);
        get boundsY(): number;
        set boundsY(val: number);
        get color(): Clutter.Color;
        set color(val: Clutter.Color);
        get freeze_update(): boolean;
        set freeze_update(val: boolean);
        get freezeUpdate(): boolean;
        set freezeUpdate(val: boolean);

        // Constructors

        constructor(properties?: Partial<FadeEffect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): FadeEffect;

        // Methods

        /**
         * Retrieves the border values for `effect`.
         */
        get_border(): [number, number, number, number];
        /**
         * Retrieves the bounding box of the effect.
         */
        get_bounds(): [number, number, number, number];
        /**
         * Retrieves the color used for the fade effect.
         */
        get_color(): Clutter.Color;
        /**
         * Sets the border to be used for the fading effect. This is the number of
         * pixels on each side of the effect that should be used to fade.
         * @param top The upper border, in pixels
         * @param right The right border, in pixels
         * @param bottom The lower border, in pixels
         * @param left The left border, in pixels
         */
        set_border(top: number, right: number, bottom: number, left: number): void;
        /**
         * Sets the bounding box of the effect. The effect will essentially treat
         * this box as a clipping rectangle. Setting width or height to %0 will
         * use the width or height of the #ClutterActor the effect is attached to.
         *
         * <note><para>
         * The effect border will apply to the bounds, and not to the un-altered
         * rectangle, so an effect with an %x of %5 and a %left-border of %5 will
         * have a gap of 5 blank pixels to the left, with a fade length of 5 pixels.
         * </para></note>
         * @param x The x value of the effect bounds, in pixels
         * @param y The y value of the effect bounds, in pixels
         * @param width The width of the effect bounds, in pixels, or %0
         * @param height The height of the effect bounds, in pixels, or %0
         */
        set_bounds(x: number, y: number, width: number, height: number): void;
        /**
         * Sets the color of the fade effect. The effect will fade out towards
         * the set border to this color.
         * @param color A #ClutterColor
         */
        set_color(color: Clutter.Color): void;
    }

    module FloatingWidget {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Stylable.ConstructorProps {}
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    abstract class FloatingWidget
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Stylable
    {
        static $gtype: GObject.GType<FloatingWidget>;

        // Constructors

        constructor(properties?: Partial<FloatingWidget.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module FocusManager {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            focused: Clutter.Actor;
            stage: Clutter.Stage;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class FocusManager extends GObject.Object {
        static $gtype: GObject.GType<FocusManager>;

        // Properties

        get focused(): Clutter.Actor;
        get stage(): Clutter.Stage;

        // Constructors

        constructor(properties?: Partial<FocusManager.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Get the MxFocusManager associated with a stage, or create one if none exist
         * for the specified stage.
         * @param stage A #ClutterStage
         */
        static get_for_stage(stage: Clutter.Stage): FocusManager;

        // Methods

        /**
         * Get the currently focused #MxFocusable
         * @returns MxFocusable
         */
        get_focused(): Focusable;
        /**
         * Get the stage the MxFocusManager is associated with
         * @returns A #ClutterStage
         */
        get_stage(): Clutter.Stage;
        /**
         * Moves the current focus in the given direction.
         * @param direction The direction to move focus in
         */
        move_focus(direction: FocusDirection | null): void;
        /**
         * Sets the currently focused actor, with an #MxFocusHint of
         * %MX_FOCUS_HINT_PRIOR.
         *
         * Note: the final focused object may not be the same as `focusable` if
         * `focusable` does not accept focus directly.
         * @param focusable the object to set focus on
         */
        push_focus(focusable: Focusable): void;
        /**
         * Similar to #mx_focus_manager_push_focus, but allows the hint to be specified.
         *
         * Note: the final focused object may not be the same as `focusable` if
         * `focusable` does not accept focus directly.
         * @param focusable the object to set focus on
         * @param hint an #MxFocusHint
         */
        push_focus_with_hint(focusable: Focusable, hint: FocusHint | null): void;
    }

    module Frame {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Stylable.ConstructorProps {}
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class Frame
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Stylable
    {
        static $gtype: GObject.GType<Frame>;

        // Constructors

        constructor(properties?: Partial<Frame.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Frame;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Grid {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Scrollable.ConstructorProps,
                Stylable.ConstructorProps {
            child_x_align: Align;
            childXAlign: Align;
            child_y_align: Align;
            childYAlign: Align;
            column_spacing: number;
            columnSpacing: number;
            homogenous_columns: boolean;
            homogenousColumns: boolean;
            homogenous_rows: boolean;
            homogenousRows: boolean;
            line_alignment: Align;
            lineAlignment: Align;
            max_stride: number;
            maxStride: number;
            orientation: Orientation;
            row_spacing: number;
            rowSpacing: number;
        }
    }

    /**
     * The contents of the this structure are private and should only be accessed
     * through the public API.
     */
    class Grid
        extends Widget
        implements
            Atk.ImplementorIface,
            Clutter.Animatable,
            Clutter.Container,
            Clutter.Scriptable,
            Focusable,
            Scrollable,
            Stylable
    {
        static $gtype: GObject.GType<Grid>;

        // Properties

        get child_x_align(): Align;
        set child_x_align(val: Align);
        get childXAlign(): Align;
        set childXAlign(val: Align);
        get child_y_align(): Align;
        set child_y_align(val: Align);
        get childYAlign(): Align;
        set childYAlign(val: Align);
        get column_spacing(): number;
        set column_spacing(val: number);
        get columnSpacing(): number;
        set columnSpacing(val: number);
        get homogenous_columns(): boolean;
        set homogenous_columns(val: boolean);
        get homogenousColumns(): boolean;
        set homogenousColumns(val: boolean);
        get homogenous_rows(): boolean;
        set homogenous_rows(val: boolean);
        get homogenousRows(): boolean;
        set homogenousRows(val: boolean);
        get line_alignment(): Align;
        set line_alignment(val: Align);
        get lineAlignment(): Align;
        set lineAlignment(val: Align);
        get max_stride(): number;
        set max_stride(val: number);
        get maxStride(): number;
        set maxStride(val: number);
        get orientation(): Orientation;
        set orientation(val: Orientation);
        get row_spacing(): number;
        set row_spacing(val: number);
        get rowSpacing(): number;
        set rowSpacing(val: number);

        // Constructors

        constructor(properties?: Partial<Grid.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Grid;

        // Methods

        get_child_x_align(): Align;
        get_child_y_align(): Align;
        get_column_spacing(): number;
        get_homogenous_columns(): boolean;
        get_homogenous_rows(): boolean;
        get_line_alignment(): Align;
        get_max_stride(): number;
        get_orientation(): Orientation;
        get_row_spacing(): number;
        set_child_x_align(value: Align | null): void;
        set_child_y_align(value: Align | null): void;
        set_column_spacing(value: number): void;
        set_homogenous_columns(value: boolean): void;
        set_homogenous_rows(value: boolean): void;
        set_line_alignment(value: Align | null): void;
        set_max_stride(value: number): void;
        set_orientation(orientation: Orientation | null): void;
        set_row_spacing(value: number): void;

        // Inherited properties
        get horizontal_adjustment(): Adjustment;
        set horizontal_adjustment(val: Adjustment);
        get horizontalAdjustment(): Adjustment;
        set horizontalAdjustment(val: Adjustment);
        get vertical_adjustment(): Adjustment;
        set vertical_adjustment(val: Adjustment);
        get verticalAdjustment(): Adjustment;
        set verticalAdjustment(val: Adjustment);
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        get_adjustments(): [Adjustment | null, Adjustment | null];
        set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        vfunc_get_adjustments(): [Adjustment | null, Adjustment | null];
        vfunc_set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Icon {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Stylable.ConstructorProps {
            icon_name: string;
            iconName: string;
            icon_size: number;
            iconSize: number;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class Icon
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Stylable
    {
        static $gtype: GObject.GType<Icon>;

        // Properties

        get icon_name(): string;
        set icon_name(val: string);
        get iconName(): string;
        set iconName(val: string);
        get icon_size(): number;
        set icon_size(val: number);
        get iconSize(): number;
        set iconSize(val: number);

        // Constructors

        constructor(properties?: Partial<Icon.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Icon;

        // Methods

        get_icon_name(): string;
        get_icon_size(): number;
        set_icon_name(icon_name: string): void;
        set_icon_size(size: number): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module IconTheme {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            theme_name: string;
            themeName: string;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class IconTheme extends GObject.Object {
        static $gtype: GObject.GType<IconTheme>;

        // Properties

        get theme_name(): string;
        set theme_name(val: string);
        get themeName(): string;
        set themeName(val: string);

        // Constructors

        constructor(properties?: Partial<IconTheme.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): IconTheme;

        // Static methods

        /**
         * Return the default #MxIconTheme object used by the toolkit.
         */
        static get_default(): IconTheme;

        // Methods

        /**
         * Gets the directories the #MxIconTheme will search in to find icons.
         * @returns the search paths
         */
        get_search_paths(): string[];
        /**
         * Get the value of the #MxIconTheme:theme-name property.
         * @returns the current value of the "theme-name" property.
         */
        get_theme_name(): string;
        has_icon(icon_name: string): boolean;
        /**
         * If the icon is available, returns a #CoglHandle of the icon.
         * @param icon_name The name of the icon
         * @param size The desired size of the icon
         * @returns a #CoglHandle of the icon, or %NULL.
         */
        lookup(icon_name: string, size: number): Cogl.Handle;
        /**
         * If the icon is available, returns a #ClutterTexture of the icon.
         * @param icon_name The name of the icon
         * @param size The desired size of the icon
         * @returns a #ClutterTexture of the icon, or %NULL.
         */
        lookup_texture(icon_name: string, size: number): Clutter.Texture;
        /**
         * Sets the directories the #MxIconTheme will search in to find icons.
         * By default, it will look in the default system and local icon
         * directories.
         * @param paths a list of search paths
         */
        set_search_paths(paths: string[]): void;
        /**
         * Set the value of the #MxIconTheme:theme-name property. This will cause the
         * icon theme to be loaded if it differs from the existing theme name. If the
         * theme could not be loaded, it will fall back to using the default icon theme
         * (hicolor).
         *
         * This will override the system's theme setting. To revert to the system
         * icon theme, this function can be called with a %NULL `theme_name` argument.
         * @param theme_name the name of an icon theme to load, or %NULL
         */
        set_theme_name(theme_name: string): void;
    }

    module Image {
        // Signal callback interfaces

        interface ImageLoadError {
            (object: GLib.Error): void;
        }

        interface ImageLoaded {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Stylable.ConstructorProps {
            allow_upscale: boolean;
            allowUpscale: boolean;
            filename: string;
            image_rotation: number;
            imageRotation: number;
            load_async: boolean;
            loadAsync: boolean;
            scale_height_threshold: number;
            scaleHeightThreshold: number;
            scale_mode: ImageScaleMode;
            scaleMode: ImageScaleMode;
            scale_width_threshold: number;
            scaleWidthThreshold: number;
            transition_duration: number;
            transitionDuration: number;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class Image
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Stylable
    {
        static $gtype: GObject.GType<Image>;

        // Properties

        get allow_upscale(): boolean;
        set allow_upscale(val: boolean);
        get allowUpscale(): boolean;
        set allowUpscale(val: boolean);
        set filename(val: string);
        get image_rotation(): number;
        set image_rotation(val: number);
        get imageRotation(): number;
        set imageRotation(val: number);
        get load_async(): boolean;
        set load_async(val: boolean);
        get loadAsync(): boolean;
        set loadAsync(val: boolean);
        get scale_height_threshold(): number;
        set scale_height_threshold(val: number);
        get scaleHeightThreshold(): number;
        set scaleHeightThreshold(val: number);
        get scale_mode(): ImageScaleMode;
        set scale_mode(val: ImageScaleMode);
        get scaleMode(): ImageScaleMode;
        set scaleMode(val: ImageScaleMode);
        get scale_width_threshold(): number;
        set scale_width_threshold(val: number);
        get scaleWidthThreshold(): number;
        set scaleWidthThreshold(val: number);
        get transition_duration(): number;
        set transition_duration(val: number);
        get transitionDuration(): number;
        set transitionDuration(val: number);

        // Constructors

        constructor(properties?: Partial<Image.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Image;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'image-load-error', callback: (_source: this, object: GLib.Error) => void): number;
        connect_after(signal: 'image-load-error', callback: (_source: this, object: GLib.Error) => void): number;
        emit(signal: 'image-load-error', object: GLib.Error): void;
        connect(signal: 'image-loaded', callback: (_source: this) => void): number;
        connect_after(signal: 'image-loaded', callback: (_source: this) => void): number;
        emit(signal: 'image-loaded'): void;

        // Virtual methods

        vfunc_image_load_error(error: GLib.Error): void;
        vfunc_image_loaded(): void;

        // Methods

        /**
         * Sets the value of #MxImage:scale-mode to `scale_mode` and animates the
         * scale factor of the image between the previous value and the new value.
         * @param mode a #ClutterAnimationMode
         * @param duration duration of the animation in milliseconds
         * @param scale_mode The #MxImageScaleMode to set
         */
        animate_scale_mode(mode: number, duration: number, scale_mode: ImageScaleMode | null): void;
        /**
         * Clear the current image and set a blank, transparent image.
         * @returns static void
         */
        clear(): void;
        /**
         * Determines whether image up-scaling is allowed.
         * @returns %TRUE if upscaling is allowed, %FALSE otherwise
         */
        get_allow_upscale(): boolean;
        /**
         * Get the value of the MxImage:image-rotation property.
         * @returns The value of the image-rotation property.
         */
        get_image_rotation(): number;
        /**
         * Determines whether asynchronous image loading is in use.
         * @returns %TRUE if images are set to load asynchronously, %FALSE otherwise
         */
        get_load_async(): boolean;
        /**
         * Retrieves the height scaling threshold.
         * @returns The height scaling threshold, in pixels
         */
        get_scale_height_threshold(): number;
        /**
         * Get the current scale mode of `MxImage`.
         * @returns The current MxImageScaleMode
         */
        get_scale_mode(): ImageScaleMode;
        /**
         * Retrieves the width scaling threshold.
         * @returns The width scaling threshold, in pixels
         */
        get_scale_width_threshold(): number;
        /**
         * Get the value of the MxImage:transition-duration property.
         * @returns The value of the transition-duration property.
         */
        get_transition_duration(): number;
        /**
         * Sets whether up-scaling of images is allowed. If set to %TRUE and a size
         * larger than the image is requested, the image will be up-scaled in
         * software.
         *
         * The advantage of this is that software up-scaling is potentially higher
         * quality, but it comes at the expense of video memory.
         * @param allow %TRUE to allow upscaling, %FALSE otherwise
         */
        set_allow_upscale(allow: boolean): void;
        /**
         * Set the image data from unencoded image data, stored in memory. In case of
         * failure, #FALSE is returned and `error` is set. It is expected that `buffer`
         * will remain accessible for the duration of the load. Once it is finished
         * with, `buffer_free_func` will be called.
         * @param buffer A buffer pointing to encoded image data
         * @returns #TRUE if the image was successfully updated
         */
        set_from_buffer(buffer: Uint8Array | string): boolean;
        /**
         * Set the image data from unencoded image data, stored in memory, and scales
         * it while loading. In case of failure, #FALSE is returned and `error` is set.
         * It is expected that `buffer` will remain accessible for the duration of the
         * load. Once it is finished with, `buffer_free_func` will be called. The aspect
         * ratio will always be maintained.
         * @param buffer A buffer pointing to encoded image data
         * @param width Width to scale the image to, or -1
         * @param height Height to scale the image to, or -1
         * @returns #TRUE if the image was successfully updated
         */
        set_from_buffer_at_size(buffer: Uint8Array | string, width: number, height: number): boolean;
        /**
         * Sets the contents of the image from the given Cogl texture.
         * @param texture A #CoglHandle to a texture
         * @returns %TRUE on success, %FALSE on failure
         */
        set_from_cogl_texture(texture: Cogl.Handle): boolean;
        /**
         * Set the image data from a buffer. In case of failure, #FALSE is returned
         * and `error` is set.
         * @param data Image data
         * @param pixel_format The #CoglPixelFormat of the buffer
         * @param width Width in pixels of image data.
         * @param height Height in pixels of image data
         * @param rowstride Distance in bytes between row starts.
         * @returns #TRUE if the image was successfully updated
         */
        set_from_data(
            data: Uint8Array | string,
            pixel_format: Cogl.PixelFormat | null,
            width: number,
            height: number,
            rowstride: number,
        ): boolean;
        /**
         * Set the image data from an image file. In case of failure, #FALSE is returned
         * and `error` is set.
         * @param filename Filename to read the file from
         * @returns #TRUE if the image was successfully updated
         */
        set_from_file(filename: string): boolean;
        /**
         * Set the image data from an image file, and scale the image during loading.
         * In case of failure, #FALSE is returned and `error` is set. The aspect ratio
         * will always be maintained.
         * @param filename Filename to read the file from
         * @param width Width to scale the image to, or -1
         * @param height Height to scale the image to, or -1
         * @returns #TRUE if the image was successfully updated
         */
        set_from_file_at_size(filename: string, width: number, height: number): boolean;
        /**
         * Set the MxImage:image-rotation property.
         * @param rotation Rotation angle in degrees
         */
        set_image_rotation(rotation: number): void;
        /**
         * Sets whether to load images asynchronously. Asynchronous image loading
         * requires thread support (see g_thread_init()).
         *
         * When using asynchronous image loading, all image-loading functions will
         * return immediately as successful. The #MxImage::image-loaded and
         * #MxImage::image-load-error signals are used to signal success or failure
         * of asynchronous image loading.
         * @param load_async %TRUE to load images asynchronously
         */
        set_load_async(load_async: boolean): void;
        /**
         * Sets the threshold used to determine whether to scale the height of the
         * image. If a specific height is requested, the image height is allowed to
         * differ by this amount before scaling is employed.
         *
         * This can be useful to avoid excessive CPU usage when the image differs
         * only slightly to the desired size.
         * @param pixels Number of pixels
         */
        set_scale_height_threshold(pixels: number): void;
        /**
         * Set the scale mode on `MxImage`
         * @param mode The #MxImageScaleMode to set
         */
        set_scale_mode(mode: ImageScaleMode | null): void;
        /**
         * Sets the threshold used to determine whether to scale the width of the
         * image. If a specific width is requested, the image width is allowed to
         * differ by this amount before scaling is employed.
         *
         * This can be useful to avoid excessive CPU usage when the image differs
         * only slightly to the desired size.
         * @param pixels Number of pixels
         */
        set_scale_width_threshold(pixels: number): void;
        /**
         * Set the MxImage:transition-duration property.
         * @param duration Transition duration in milliseconds
         */
        set_transition_duration(duration: number): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ItemView {
        // Constructor properties interface

        interface ConstructorProps
            extends Grid.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Scrollable.ConstructorProps,
                Stylable.ConstructorProps {
            factory: GObject.Object;
            item_type: GObject.GType;
            itemType: GObject.GType;
            model: Clutter.Model;
        }
    }

    /**
     * The contents of the this structure are private and should only be accessed
     * through the public API.
     */
    class ItemView
        extends Grid
        implements
            Atk.ImplementorIface,
            Clutter.Animatable,
            Clutter.Container,
            Clutter.Scriptable,
            Focusable,
            Scrollable,
            Stylable
    {
        static $gtype: GObject.GType<ItemView>;

        // Properties

        get factory(): GObject.Object;
        set factory(val: GObject.Object);
        get item_type(): GObject.GType;
        set item_type(val: GObject.GType);
        get itemType(): GObject.GType;
        set itemType(val: GObject.GType);
        get model(): Clutter.Model;
        set model(val: Clutter.Model);

        // Constructors

        constructor(properties?: Partial<ItemView.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ItemView;

        // Methods

        /**
         * Adds an attribute mapping between the current model and the objects from the
         * cell renderer.
         * @param attribute Name of the attribute
         * @param column Column number
         */
        add_attribute(attribute: string, column: number): void;
        /**
         * Freeze the view. This means that the view will not act on changes to the
         * model until it is thawed. Call #mx_item_view_thaw to thaw the view
         */
        freeze(): void;
        /**
         * Gets the #MxItemFactory used for creating new items.
         * @returns A #MxItemFactory.
         */
        get_factory(): ItemFactory;
        /**
         * Get the item type currently being used to create items
         * @returns a #GType
         */
        get_item_type(): GObject.GType;
        /**
         * Get the model currently used by the #MxItemView
         * @returns the current #ClutterModel
         */
        get_model(): Clutter.Model;
        /**
         * Sets `factory` to be the factory used for creating new items
         * @param factory A #MxItemFactory
         */
        set_factory(factory: ItemFactory): void;
        /**
         * Set the item type used to create items representing each row in the
         * model
         * @param item_type A #GType
         */
        set_item_type(item_type: GObject.GType): void;
        /**
         * Set the model used by the #MxItemView
         * @param model A #ClutterModel
         */
        set_model(model: Clutter.Model): void;
        /**
         * Thaw the view. This means that the view will now act on changes to the
         * model.
         */
        thaw(): void;

        // Inherited properties
        get horizontal_adjustment(): Adjustment;
        set horizontal_adjustment(val: Adjustment);
        get horizontalAdjustment(): Adjustment;
        set horizontalAdjustment(val: Adjustment);
        get vertical_adjustment(): Adjustment;
        set vertical_adjustment(val: Adjustment);
        get verticalAdjustment(): Adjustment;
        set verticalAdjustment(val: Adjustment);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        get_adjustments(): [Adjustment | null, Adjustment | null];
        set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        vfunc_get_adjustments(): [Adjustment | null, Adjustment | null];
        vfunc_set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module KineticScrollView {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Scrollable.ConstructorProps,
                Stylable.ConstructorProps {
            acceleration_factor: number;
            accelerationFactor: number;
            clamp_duration: number;
            clampDuration: number;
            clamp_mode: number;
            clampMode: number;
            clamp_to_center: boolean;
            clampToCenter: boolean;
            deceleration: number;
            mouse_button: number;
            mouseButton: number;
            overshoot: number;
            scroll_policy: ScrollPolicy;
            scrollPolicy: ScrollPolicy;
            snap_on_page: boolean;
            snapOnPage: boolean;
            state: KineticScrollViewState;
            use_captured: boolean;
            useCaptured: boolean;
            use_grab: boolean;
            useGrab: boolean;
        }
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class KineticScrollView
        extends Widget
        implements
            Atk.ImplementorIface,
            Clutter.Animatable,
            Clutter.Container,
            Clutter.Scriptable,
            Focusable,
            Scrollable,
            Stylable
    {
        static $gtype: GObject.GType<KineticScrollView>;

        // Properties

        get acceleration_factor(): number;
        set acceleration_factor(val: number);
        get accelerationFactor(): number;
        set accelerationFactor(val: number);
        get clamp_duration(): number;
        set clamp_duration(val: number);
        get clampDuration(): number;
        set clampDuration(val: number);
        get clamp_mode(): number;
        set clamp_mode(val: number);
        get clampMode(): number;
        set clampMode(val: number);
        get clamp_to_center(): boolean;
        set clamp_to_center(val: boolean);
        get clampToCenter(): boolean;
        set clampToCenter(val: boolean);
        get deceleration(): number;
        set deceleration(val: number);
        get mouse_button(): number;
        set mouse_button(val: number);
        get mouseButton(): number;
        set mouseButton(val: number);
        get overshoot(): number;
        set overshoot(val: number);
        get scroll_policy(): ScrollPolicy;
        set scroll_policy(val: ScrollPolicy);
        get scrollPolicy(): ScrollPolicy;
        set scrollPolicy(val: ScrollPolicy);
        get snap_on_page(): boolean;
        set snap_on_page(val: boolean);
        get snapOnPage(): boolean;
        set snapOnPage(val: boolean);
        get state(): KineticScrollViewState;
        get use_captured(): boolean;
        set use_captured(val: boolean);
        get useCaptured(): boolean;
        set useCaptured(val: boolean);
        get use_grab(): boolean;
        set use_grab(val: boolean);
        get useGrab(): boolean;
        set useGrab(val: boolean);

        // Constructors

        constructor(properties?: Partial<KineticScrollView.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): KineticScrollView;

        // Methods

        /**
         * Ensures that a given region is visible in the ScrollView, with the top-left
         * taking precedence.
         * @param geometry The region to make visible
         */
        ensure_visible(geometry: Clutter.Geometry): void;
        /**
         * Retrieves the initial acceleration factor of the kinetic scroll-view.
         * @returns The initial acceleration factor of the kinetic scroll-view
         */
        get_acceleration_factor(): number;
        /**
         * Retrieves the duration of the adjustment clamp animation.
         * @returns Clamp duration
         */
        get_clamp_duration(): number;
        /**
         * Retrieves the animation mode to use for the adjustment clamp animation.
         * @returns Clamp mode
         */
        get_clamp_mode(): number;
        /**
         * Retrieves whether to clamp to step increments based on the center of the page.
         * @returns Clamp to center
         */
        get_clamp_to_center(): boolean;
        /**
         * Retrieves the deceleration rate of the kinetic scroll-view.
         * @returns The deceleration rate of the kinetic scroll-view
         */
        get_deceleration(): number;
        /**
         * Retrieves informations about the current input device driving the
         * scrolling.
         */
        get_input(): [Clutter.InputDevice | null, Clutter.EventSequence | null];
        /**
         * Gets the #MxKineticScrollView:mouse-button property
         * @returns The mouse button number used to initiate drag events on the kinetic scroll-view
         */
        get_mouse_button(): number;
        /**
         * Retrieves the deceleration rate multiplier used when the scroll-view is
         * scrolling beyond its boundaries.
         */
        get_overshoot(): number;
        /**
         * Retrieves the scrolling policy of the kinetic scroll-view.
         * @returns A #MxScrollPolicy
         */
        get_scroll_policy(): ScrollPolicy;
        /**
         * Retrieves whether animations end on step increments.
         * @returns #true if animations end on step increments, #false otherwise.
         */
        get_snap_on_page(): boolean;
        /**
         * Gets the #MxKineticScrollView:use-captured property.
         * @returns %TRUE if captured-events should be used to initiate scrolling
         */
        get_use_captured(): boolean;
        /**
         * Gets the #MxKineticScrollView:use-grab property.
         * @returns %TRUE if grab-events should be used to initiate scrolling
         */
        get_use_grab(): boolean;
        /**
         * Factor applied to the initial momentum.
         * @param acceleration_factor The acceleration factor
         */
        set_acceleration_factor(acceleration_factor: number): void;
        /**
         * Duration of the adjustment clamp animation.
         * @param clamp_duration Clamp duration
         */
        set_clamp_duration(clamp_duration: number): void;
        /**
         * Animation mode to use for the adjustment clamp animation.
         * @param clamp_mode Clamp mode
         */
        set_clamp_mode(clamp_mode: number): void;
        /**
         * Set whether to clamp to step increments based on the center of the page.
         * @param clamp_to_center Clamp to center
         */
        set_clamp_to_center(clamp_to_center: boolean): void;
        /**
         * Sets the deceleration rate when a drag is finished on the kinetic
         * scroll-view. This is the value that the momentum is divided by
         * every 60th of a second.
         * @param rate The deceleration rate
         */
        set_deceleration(rate: number): void;
        /**
         * Sets the mouse button number used to initiate drag events on the kinetic
         * scroll-view.
         * @param button A mouse button number
         */
        set_mouse_button(button: number): void;
        /**
         * Sets the rate at which the view will decelerate when scrolling beyond its
         * boundaries. The deceleration rate will be multiplied by this value every
         * 60th of a second when the view is scrolling outside of the range set by its
         * adjustments.
         *
         * See mx_kinetic_scroll_view_set_deceleration()
         * @param overshoot The rate at which the view will decelerate when scrolling beyond its boundaries.
         */
        set_overshoot(overshoot: number): void;
        /**
         * Sets the scrolling policy for the kinetic scroll-view. This controls the
         * possible axes of movement, and can affect the minimum size of the widget.
         * @param policy A #MxScrollPolicy
         */
        set_scroll_policy(policy: ScrollPolicy | null): void;
        /**
         * Set whether to stop animations on step increments.
         * @param snap_on_page #true to stop animations on step increments
         */
        set_snap_on_page(snap_on_page: boolean): void;
        /**
         * Sets whether to use captured events to initiate drag events. This can be
         * used to block events that would initiate scrolling from reaching the child
         * actor.
         * @param use_captured %TRUE to use captured events
         */
        set_use_captured(use_captured: boolean): void;
        /**
         * Sets whether to use grab events to initiate drag events. This can be
         * used to block events that would initiate scrolling from reaching the child
         * actor.
         * @param use_grab %TRUE to use grab events
         */
        set_use_grab(use_grab: boolean): void;
        /**
         * Stops any current movement due to kinetic scrolling.
         */
        stop(): void;

        // Inherited properties
        get horizontal_adjustment(): Adjustment;
        set horizontal_adjustment(val: Adjustment);
        get horizontalAdjustment(): Adjustment;
        set horizontalAdjustment(val: Adjustment);
        get vertical_adjustment(): Adjustment;
        set vertical_adjustment(val: Adjustment);
        get verticalAdjustment(): Adjustment;
        set verticalAdjustment(val: Adjustment);
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        get_adjustments(): [Adjustment | null, Adjustment | null];
        set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        vfunc_get_adjustments(): [Adjustment | null, Adjustment | null];
        vfunc_set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Label {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Stylable.ConstructorProps {
            clutter_text: Clutter.Text;
            clutterText: Clutter.Text;
            fade_out: boolean;
            fadeOut: boolean;
            line_wrap: boolean;
            lineWrap: boolean;
            show_tooltip: boolean | any;
            showTooltip: boolean;
            text: string;
            use_markup: boolean;
            useMarkup: boolean;
            x_align: Align | any;
            xAlign: Align | any;
            y_align: Align | any;
            yAlign: Align | any;
        }
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class Label
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Stylable
    {
        static $gtype: GObject.GType<Label>;

        // Properties

        get clutter_text(): Clutter.Text;
        get clutterText(): Clutter.Text;
        get fade_out(): boolean;
        set fade_out(val: boolean);
        get fadeOut(): boolean;
        set fadeOut(val: boolean);
        /**
         * Whether to wrap the lines of #MxLabel:text if the contents
         * exceed the available allocation.
         */
        get line_wrap(): boolean;
        set line_wrap(val: boolean);
        /**
         * Whether to wrap the lines of #MxLabel:text if the contents
         * exceed the available allocation.
         */
        get lineWrap(): boolean;
        set lineWrap(val: boolean);
        /**
         * Show a tooltip when there is not enough space to display the text. If set
         * to %TRUE, this will also cause the #ClutterActor:reactive property to be
         * enabled.
         */
        // This accessor conflicts with a property or field in a parent class or interface.
        show_tooltip: boolean | any;
        /**
         * Show a tooltip when there is not enough space to display the text. If set
         * to %TRUE, this will also cause the #ClutterActor:reactive property to be
         * enabled.
         */
        get showTooltip(): boolean;
        set showTooltip(val: boolean);
        get text(): string;
        set text(val: string);
        get use_markup(): boolean;
        set use_markup(val: boolean);
        get useMarkup(): boolean;
        set useMarkup(val: boolean);
        // This accessor conflicts with another accessor's type in a parent class or interface.
        get x_align(): Align | any;
        // This accessor conflicts with another accessor's type in a parent class or interface.
        set x_align(val: Align | any);
        // This accessor conflicts with another accessor's type in a parent class or interface.
        get xAlign(): Align | any;
        // This accessor conflicts with another accessor's type in a parent class or interface.
        set xAlign(val: Align | any);
        // This accessor conflicts with another accessor's type in a parent class or interface.
        get y_align(): Align | any;
        // This accessor conflicts with another accessor's type in a parent class or interface.
        set y_align(val: Align | any);
        // This accessor conflicts with another accessor's type in a parent class or interface.
        get yAlign(): Align | any;
        // This accessor conflicts with another accessor's type in a parent class or interface.
        set yAlign(val: Align | any);

        // Constructors

        constructor(properties?: Partial<Label.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Label;

        static new_with_text(text: string): Label;

        // Methods

        /**
         * Returns the text alignment on x and y axis.
         */
        get_alignment(): [Align | null, Align | null];
        /**
         * Retrieve the internal #ClutterText so that extra parameters can be set
         * @returns the #ClutterText used by #MxLabel. The label is owned by the #MxLabel and should not be unref'ed by the application.
         */
        get_clutter_text(): Clutter.Actor;
        /**
         * Determines whether the label has been set to fade out when there isn't
         * enough space allocated to display the entire label.
         * @returns %TRUE if the label is set to fade out, %FALSE otherwise
         */
        get_fade_out(): boolean;
        /**
         * Get the value of the #MxLabel:line-wrap property.
         * @returns %TRUE if the "line-wrap" property is set.
         */
        get_line_wrap(): boolean;
        /**
         * Returns the current value of the #MxLabel:show-tooltip property.
         * @returns %TRUE if the #MxLabel:show-tooltip property is enabled
         */
        get_show_tooltip(): boolean;
        /**
         * Get the text displayed on the label
         * @returns the text for the label. This must not be freed by the application
         */
        get_text(): string;
        /**
         * Determines whether the text of the label is being treated as Pango markup.
         * @returns %TRUE if the text of the label is treated as Pango markup, %FALSE otherwise.
         */
        get_use_markup(): boolean;
        get_x_align(): Align;
        // Conflicted with Clutter.Actor.get_x_align
        get_x_align(...args: never[]): any;
        get_y_align(): Align;
        // Conflicted with Clutter.Actor.get_y_align
        get_y_align(...args: never[]): any;
        /**
         * Set the text alignment on x and y axis.
         * @param x_align x alignment value
         * @param y_align y alignment value
         */
        set_alignment(x_align: Align | null, y_align: Align | null): void;
        /**
         * Set whether to fade out the end of the label, instead of ellipsizing.
         * Enabling this mode will also set the #ClutterText:single-line-mode and
         * #ClutterText:ellipsize properties.
         * @param fade %TRUE to fade out, %FALSE otherwise
         */
        set_fade_out(fade: boolean): void;
        /**
         * Set the value of the #MxLabel:line-wrap property.
         * @param line_wrap new value of the line-wrap property.
         */
        set_line_wrap(line_wrap: boolean): void;
        /**
         * Set the value of the #MxLabel:show-tooltip property
         * @param show_tooltip %TRUE if the tooltip should be shown
         */
        set_show_tooltip(show_tooltip: boolean): void;
        /**
         * Sets the text displayed on the label
         * @param text text to set the label to
         */
        set_text(text: string): void;
        /**
         * Sets whether the text of the label should be treated as Pango markup.
         * @param use_markup %TRUE to use Pango markup, %FALSE otherwise
         */
        set_use_markup(use_markup: boolean): void;
        set_x_align(align: Align | null): void;
        // Conflicted with Clutter.Actor.set_x_align
        set_x_align(...args: never[]): any;
        set_y_align(align: Align | null): void;
        // Conflicted with Clutter.Actor.set_y_align
        set_y_align(...args: never[]): any;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ListView {
        // Constructor properties interface

        interface ConstructorProps
            extends BoxLayout.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Scrollable.ConstructorProps,
                Stylable.ConstructorProps {
            factory: GObject.Object;
            item_type: GObject.GType;
            itemType: GObject.GType;
            model: Clutter.Model;
        }
    }

    /**
     * The contents of the this structure are private and should only be accessed
     * through the public API.
     */
    class ListView
        extends BoxLayout
        implements
            Atk.ImplementorIface,
            Clutter.Animatable,
            Clutter.Container,
            Clutter.Scriptable,
            Focusable,
            Scrollable,
            Stylable
    {
        static $gtype: GObject.GType<ListView>;

        // Properties

        get factory(): GObject.Object;
        set factory(val: GObject.Object);
        get item_type(): GObject.GType;
        set item_type(val: GObject.GType);
        get itemType(): GObject.GType;
        set itemType(val: GObject.GType);
        get model(): Clutter.Model;
        set model(val: Clutter.Model);

        // Constructors

        constructor(properties?: Partial<ListView.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ListView;

        // Methods

        /**
         * Adds an attribute mapping between the current model and the objects from the
         * cell renderer.
         * @param attribute Name of the attribute
         * @param column Column number
         */
        add_attribute(attribute: string, column: number): void;
        /**
         * Freeze the view. This means that the view will not act on changes to the
         * model until it is thawed. Call #mx_list_view_thaw to thaw the view.
         */
        freeze(): void;
        /**
         * Gets the #MxItemFactory used for creating new list items.
         * @returns A #MxItemFactory.
         */
        get_factory(): ItemFactory;
        /**
         * Get the item type currently being used to create items
         * @returns a #GType
         */
        get_item_type(): GObject.GType;
        /**
         * Get the model currently used by the #MxListView
         * @returns the current #ClutterModel
         */
        get_model(): Clutter.Model;
        /**
         * Sets `factory` to be the factory used for creating new list items
         * @param factory A #MxItemFactory
         */
        set_factory(factory: ItemFactory): void;
        /**
         * Set the item type used to create items representing each row in the
         * model
         * @param item_type A #GType
         */
        set_item_type(item_type: GObject.GType): void;
        /**
         * Set the model used by the #MxListView
         * @param model A #ClutterModel
         */
        set_model(model: Clutter.Model): void;
        /**
         * Thaw the view. This means that the view will now act on changes to the
         * model.
         */
        thaw(): void;

        // Inherited properties
        get horizontal_adjustment(): Adjustment;
        set horizontal_adjustment(val: Adjustment);
        get horizontalAdjustment(): Adjustment;
        set horizontalAdjustment(val: Adjustment);
        get vertical_adjustment(): Adjustment;
        set vertical_adjustment(val: Adjustment);
        get verticalAdjustment(): Adjustment;
        set verticalAdjustment(val: Adjustment);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        get_adjustments(): [Adjustment | null, Adjustment | null];
        set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        vfunc_get_adjustments(): [Adjustment | null, Adjustment | null];
        vfunc_set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Menu {
        // Signal callback interfaces

        interface ActionActivated {
            (object: Action): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends FloatingWidget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {}
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class Menu
        extends FloatingWidget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<Menu>;

        // Constructors

        constructor(properties?: Partial<Menu.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Menu;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'action-activated', callback: (_source: this, object: Action) => void): number;
        connect_after(signal: 'action-activated', callback: (_source: this, object: Action) => void): number;
        emit(signal: 'action-activated', object: Action): void;

        // Virtual methods

        vfunc_action_activated(action: Action): void;

        // Methods

        /**
         * Append `action` to `menu`.
         * @param action A #MxAction
         */
        add_action(action: Action): void;
        // Conflicted with Clutter.Actor.add_action
        add_action(...args: never[]): any;
        /**
         * Remove `action` from `menu`.
         * @param action A #MxAction
         */
        remove_action(action: Action): void;
        // Conflicted with Clutter.Actor.remove_action
        remove_action(...args: never[]): any;
        /**
         * Remove all the actions from `menu`.
         */
        remove_all(): void;
        /**
         * Moves the menu to the specified position and shows it.
         * @param x X position
         * @param y Y position
         */
        show_with_position(x: number, y: number): void;

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Notebook {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {
            current_page: Clutter.Actor;
            currentPage: Clutter.Actor;
        }
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class Notebook
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<Notebook>;

        // Properties

        get current_page(): Clutter.Actor;
        set current_page(val: Clutter.Actor);
        get currentPage(): Clutter.Actor;
        set currentPage(val: Clutter.Actor);

        // Constructors

        constructor(properties?: Partial<Notebook.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Notebook;

        // Methods

        /**
         * Get the current page
         * @returns the current page
         */
        get_current_page(): Clutter.Actor;
        /**
         * Change the current page to next one.
         */
        next_page(): void;
        /**
         * Change the current page to previous one.
         */
        previous_page(): void;
        set_current_page(page: Clutter.Actor): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Pager {
        // Constructor properties interface

        interface ConstructorProps
            extends Stack.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {
            edge_previews: boolean;
            edgePreviews: boolean;
            page_actor: Clutter.Actor;
            pageActor: Clutter.Actor;
            page_num: number;
            pageNum: number;
        }
    }

    class Pager
        extends Stack
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<Pager>;

        // Properties

        get edge_previews(): boolean;
        set edge_previews(val: boolean);
        get edgePreviews(): boolean;
        set edgePreviews(val: boolean);
        get page_actor(): Clutter.Actor;
        set page_actor(val: Clutter.Actor);
        get pageActor(): Clutter.Actor;
        set pageActor(val: Clutter.Actor);
        get page_num(): number;
        set page_num(val: number);
        get pageNum(): number;
        set pageNum(val: number);

        // Constructors

        constructor(properties?: Partial<Pager.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Pager;

        // Methods

        get_actor_for_page(page: number): Clutter.Actor;
        get_current_page(): number;
        get_current_page_actor(): Clutter.Actor;
        get_edge_previews(): boolean;
        get_n_pages(): number;
        /**
         * Inserts a page into the #MxPager at the position specified by `position`.
         * @param child the page to insert
         * @param position the position to insert the page. If this is negative, or is larger than the number of pages, it will the last page
         */
        insert_page(child: Clutter.Actor, position: number): void;
        /**
         * Move to the next page.
         */
        next(): void;
        /**
         * Move to the previous page.
         */
        previous(): void;
        /**
         * Move to `page`.
         * @param page the page to move to
         * @param animate whether to animate the move between pages
         */
        set_current_page(page: number, animate: boolean): void;
        /**
         * Move to the page containing `actor`.
         * @param actor the actor of the page to move to
         * @param animate whether to animate the move between pages
         */
        set_current_page_by_actor(actor: Clutter.Actor, animate: boolean): void;
        /**
         * Sets the #MxPager:edge-previews property.
         * @param edge_previews %TRUE to enable edge previews
         */
        set_edge_previews(edge_previews: boolean): void;

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module PathBar {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {
            clear_on_change: boolean;
            clearOnChange: boolean;
            editable: boolean;
            entry: Entry;
            level: number;
        }
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class PathBar
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<PathBar>;

        // Properties

        get clear_on_change(): boolean;
        set clear_on_change(val: boolean);
        get clearOnChange(): boolean;
        set clearOnChange(val: boolean);
        get editable(): boolean;
        set editable(val: boolean);
        get entry(): Entry;
        get level(): number;

        // Constructors

        constructor(properties?: Partial<PathBar.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): PathBar;

        // Methods

        /**
         * Remove all the current buttons
         */
        clear(): void;
        /**
         * Get the value of the #MxPathBar:clear-on-change property
         * @returns the value of the "clear-on-change" property
         */
        get_clear_on_change(): boolean;
        /**
         * Get the value of the #MxPathBar:editable property.
         * @returns the current value of the "editable" property.
         */
        get_editable(): boolean;
        /**
         * Get the MxEntry used as the editable area in the MxPathBar.
         * @returns MxEntry *
         */
        get_entry(): Entry;
        get_label(level: number): string;
        get_level(): number;
        get_text(): string;
        pop(): number;
        push(name: string): number;
        /**
         * Set theh value of the #MxPathBar:clear-on-change property
         * @param clear_on_change the new value of the property
         */
        set_clear_on_change(clear_on_change: boolean): void;
        /**
         * Set the value of the #MxPathBar:editable property.
         * @param editable #TRUE if the path bar should be editable
         */
        set_editable(editable: boolean): void;
        /**
         * Set the text on the button specified by `level`
         * @param level A #gint
         * @param label A #gchar
         */
        set_label(level: number, label: string): void;
        /**
         * Set the text in the editable area of the #MxPathBar
         * @param text string to set the editable text to.
         */
        set_text(text: string): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ProgressBar {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Stylable.ConstructorProps {
            progress: number;
        }
    }

    /**
     * The contents of this structure are private and should only be
     * accessed through the public API.
     */
    class ProgressBar
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Stylable
    {
        static $gtype: GObject.GType<ProgressBar>;

        // Properties

        get progress(): number;
        set progress(val: number);

        // Constructors

        constructor(properties?: Partial<ProgressBar.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ProgressBar;

        // Methods

        /**
         * Get the progress of the progress bar
         * @returns A value between 0.0 and 1.0
         */
        get_progress(): number;
        /**
         * Set the progress of the progress bar
         * @param progress A value between 0.0 and 1.0
         */
        set_progress(progress: number): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ScrollBar {
        // Signal callback interfaces

        interface ScrollStart {
            (): void;
        }

        interface ScrollStop {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Stylable.ConstructorProps {
            adjustment: Adjustment;
            orientation: Orientation;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class ScrollBar
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Stylable
    {
        static $gtype: GObject.GType<ScrollBar>;

        // Properties

        get adjustment(): Adjustment;
        set adjustment(val: Adjustment);
        get orientation(): Orientation;
        set orientation(val: Orientation);

        // Constructors

        constructor(properties?: Partial<ScrollBar.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ScrollBar;

        static new_with_adjustment(adjustment: Adjustment): ScrollBar;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'scroll-start', callback: (_source: this) => void): number;
        connect_after(signal: 'scroll-start', callback: (_source: this) => void): number;
        emit(signal: 'scroll-start'): void;
        connect(signal: 'scroll-stop', callback: (_source: this) => void): number;
        connect_after(signal: 'scroll-stop', callback: (_source: this) => void): number;
        emit(signal: 'scroll-stop'): void;

        // Virtual methods

        vfunc_scroll_start(): void;
        vfunc_scroll_stop(): void;

        // Methods

        /**
         * Gets the adjustment object that stores the current position
         * of the scrollbar.
         * @returns the adjustment
         */
        get_adjustment(): Adjustment;
        get_orientation(): Orientation;
        set_adjustment(adjustment: Adjustment): void;
        set_orientation(orientation: Orientation | null): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module ScrollView {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Stylable.ConstructorProps {
            enable_mouse_scrolling: boolean;
            enableMouseScrolling: boolean;
            scroll_policy: ScrollPolicy;
            scrollPolicy: ScrollPolicy;
            scroll_visibility: ScrollPolicy;
            scrollVisibility: ScrollPolicy;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class ScrollView
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Stylable
    {
        static $gtype: GObject.GType<ScrollView>;

        // Properties

        get enable_mouse_scrolling(): boolean;
        set enable_mouse_scrolling(val: boolean);
        get enableMouseScrolling(): boolean;
        set enableMouseScrolling(val: boolean);
        get scroll_policy(): ScrollPolicy;
        set scroll_policy(val: ScrollPolicy);
        get scrollPolicy(): ScrollPolicy;
        set scrollPolicy(val: ScrollPolicy);
        get scroll_visibility(): ScrollPolicy;
        set scroll_visibility(val: ScrollPolicy);
        get scrollVisibility(): ScrollPolicy;
        set scrollVisibility(val: ScrollPolicy);

        // Constructors

        constructor(properties?: Partial<ScrollView.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ScrollView;

        // Methods

        /**
         * Ensures that a given region is visible in the ScrollView, with the top-left
         * taking precedence.
         * @param geometry The region to make visible
         */
        ensure_visible(geometry: Clutter.Geometry): void;
        get_enable_mouse_scrolling(): boolean;
        get_scroll_policy(): ScrollPolicy;
        get_scroll_visibility(): ScrollPolicy;
        set_enable_mouse_scrolling(enabled: boolean): void;
        set_scroll_policy(policy: ScrollPolicy | null): void;
        set_scroll_visibility(visibility: ScrollPolicy | null): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Settings {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            drag_threshold: number;
            dragThreshold: number;
            font_name: string;
            fontName: string;
            icon_theme: string;
            iconTheme: string;
            long_press_timeout: number;
            longPressTimeout: number;
            small_screen: boolean;
            smallScreen: boolean;
            touch_mode: boolean;
            touchMode: boolean;
        }
    }

    class Settings extends GObject.Object {
        static $gtype: GObject.GType<Settings>;

        // Properties

        get drag_threshold(): number;
        set drag_threshold(val: number);
        get dragThreshold(): number;
        set dragThreshold(val: number);
        get font_name(): string;
        set font_name(val: string);
        get fontName(): string;
        set fontName(val: string);
        get icon_theme(): string;
        set icon_theme(val: string);
        get iconTheme(): string;
        set iconTheme(val: string);
        get long_press_timeout(): number;
        set long_press_timeout(val: number);
        get longPressTimeout(): number;
        set longPressTimeout(val: number);
        get small_screen(): boolean;
        set small_screen(val: boolean);
        get smallScreen(): boolean;
        set smallScreen(val: boolean);
        get touch_mode(): boolean;
        set touch_mode(val: boolean);
        get touchMode(): boolean;
        set touchMode(val: boolean);

        // Constructors

        constructor(properties?: Partial<Settings.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Get the global MxSettings object.
         */
        static get_default(): Settings;
    }

    module Slider {
        // Signal callback interfaces

        interface SlideStart {
            (): void;
        }

        interface SlideStop {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {
            buffer_value: number;
            bufferValue: number;
            value: number;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class Slider
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<Slider>;

        // Properties

        get buffer_value(): number;
        set buffer_value(val: number);
        get bufferValue(): number;
        set bufferValue(val: number);
        get value(): number;
        set value(val: number);

        // Constructors

        constructor(properties?: Partial<Slider.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Slider;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'slide-start', callback: (_source: this) => void): number;
        connect_after(signal: 'slide-start', callback: (_source: this) => void): number;
        emit(signal: 'slide-start'): void;
        connect(signal: 'slide-stop', callback: (_source: this) => void): number;
        connect_after(signal: 'slide-stop', callback: (_source: this) => void): number;
        emit(signal: 'slide-stop'): void;

        // Methods

        /**
         * Get the value of the #MxSlider:buffer-value property.
         * @returns The current value of the "buffer-value" property.
         */
        get_buffer_value(): number;
        /**
         * Retrieve the current value of the media bar
         * @returns gdouble
         */
        get_value(): number;
        /**
         * Set the value of the #MxSlider:buffer-value property.
         * @param value the new buffer value of the slider
         */
        set_buffer_value(value: number): void;
        /**
         * Set the value of the slider
         * @param value A value between 0.0 and 1.0
         */
        set_value(value: number): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Spinner {
        // Signal callback interfaces

        interface Looped {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Stylable.ConstructorProps {
            animating: boolean;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class Spinner
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Stylable
    {
        static $gtype: GObject.GType<Spinner>;

        // Properties

        get animating(): boolean;
        set animating(val: boolean);

        // Constructors

        constructor(properties?: Partial<Spinner.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Spinner;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'looped', callback: (_source: this) => void): number;
        connect_after(signal: 'looped', callback: (_source: this) => void): number;
        emit(signal: 'looped'): void;

        // Virtual methods

        vfunc_looped(): void;

        // Methods

        /**
         * Determines whether the spinner is animating.
         * @returns %TRUE if the spinner is animating, %FALSE otherwise
         */
        get_animating(): boolean;
        /**
         * Sets whether the spinner is animating. A spinner can be stopped if
         * the task it represents has finished, or to save energy.
         * @param animating %TRUE to enable animation, %FALSE to disable
         */
        set_animating(animating: boolean): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Stack {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {}
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class Stack
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<Stack>;

        // Constructors

        constructor(properties?: Partial<Stack.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Stack;

        // Methods

        /**
         * Get the value of the #MxStackChild:fit property.
         * @param child A #ClutterActor
         * @returns the current value of the #MxStackChild:crop property
         */
        child_get_crop(child: Clutter.Actor): boolean;
        /**
         * Get the value of the #MxStackChild:fit property.
         * @param child A #ClutterActor
         * @returns the current value of the #MxStackChild:fit property
         */
        child_get_fit(child: Clutter.Actor): boolean;
        /**
         * Get the value of the #MxStackChild:x-align property
         * @param child A #ClutterActor
         * @returns the current value of the "x-align" property
         */
        child_get_x_align(child: Clutter.Actor): Align;
        /**
         * Get the value of the #MxStackChild:x-fill property.
         * @param child A #ClutterActor
         * @returns the current value of the "x-fill" property.
         */
        child_get_x_fill(child: Clutter.Actor): boolean;
        /**
         * Get the value of the #MxStackChild:y-align property.
         * @param child A #ClutterActor
         * @returns the current value of the "y-align" property.
         */
        child_get_y_align(child: Clutter.Actor): Align;
        /**
         * Get the value of the #MxStackChild:y-fill property
         * @param child A #ClutterActor
         * @returns the current value of the "y-fill" property
         */
        child_get_y_fill(child: Clutter.Actor): boolean;
        /**
         * Set the value of the #MxStackChild:crop property.
         * @param child A #ClutterActor
         * @param crop A #gboolean
         */
        child_set_crop(child: Clutter.Actor, crop: boolean): void;
        /**
         * Set the value of the #MxStackChild:fit property.
         * @param child A #ClutterActor
         * @param fit A #gboolean
         */
        child_set_fit(child: Clutter.Actor, fit: boolean): void;
        /**
         * Set the value of the #MxStackChild:x-align property.
         * @param child A #ClutterActor
         * @param x_align An #MxAlign
         */
        child_set_x_align(child: Clutter.Actor, x_align: Align | null): void;
        /**
         * Set the value of the #MxStackChild:x-fill property.
         * @param child A #ClutterActor
         * @param x_fill A #gboolean
         */
        child_set_x_fill(child: Clutter.Actor, x_fill: boolean): void;
        /**
         * Set the value of the #MxStackChild:y-align property.
         * @param child A #ClutterActor
         * @param y_align An #MxAlign
         */
        child_set_y_align(child: Clutter.Actor, y_align: Align | null): void;
        /**
         * Set the value of the #MxStackChild:y-fill property.
         * @param child A #ClutterActor
         * @param y_fill A #gboolean
         */
        child_set_y_fill(child: Clutter.Actor, y_fill: boolean): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module StackChild {
        // Constructor properties interface

        interface ConstructorProps extends Clutter.ChildMeta.ConstructorProps {
            crop: boolean;
            fit: boolean;
            x_align: Align;
            xAlign: Align;
            x_fill: boolean;
            xFill: boolean;
            y_align: Align;
            yAlign: Align;
            y_fill: boolean;
            yFill: boolean;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class StackChild extends Clutter.ChildMeta {
        static $gtype: GObject.GType<StackChild>;

        // Properties

        get crop(): boolean;
        set crop(val: boolean);
        get fit(): boolean;
        set fit(val: boolean);
        get x_align(): Align;
        set x_align(val: Align);
        get xAlign(): Align;
        set xAlign(val: Align);
        get x_fill(): boolean;
        set x_fill(val: boolean);
        get xFill(): boolean;
        set xFill(val: boolean);
        get y_align(): Align;
        set y_align(val: Align);
        get yAlign(): Align;
        set yAlign(val: Align);
        get y_fill(): boolean;
        set y_fill(val: boolean);
        get yFill(): boolean;
        set yFill(val: boolean);

        // Constructors

        constructor(properties?: Partial<StackChild.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;
    }

    module Style {
        // Signal callback interfaces

        interface Changed {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class Style extends GObject.Object {
        static $gtype: GObject.GType<Style>;

        // Constructors

        constructor(properties?: Partial<Style.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Style;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'changed', callback: (_source: this) => void): number;
        connect_after(signal: 'changed', callback: (_source: this) => void): number;
        emit(signal: 'changed'): void;

        // Static methods

        /**
         * Return the default MxStyle object. This includes the current theme (if
         * any).
         */
        static get_default(): Style;

        // Virtual methods

        vfunc_changed(): void;

        // Methods

        /**
         * Requests the property described in `pspec` for the specified stylable
         * @param stylable a stylable to retreive the data for
         * @param pspec a #GParamSpec describing the property required
         */
        get_property(stylable: Stylable, pspec: GObject.ParamSpec): unknown;
        // Conflicted with GObject.Object.get_property
        get_property(...args: never[]): any;
        /**
         * Load style information from `data,` using `id` to identify the stylesheet.
         * `id` is usually the file name of the style sheet, which is used in the search
         * path when loading url resources.
         * @param id identifier of the style sheet to load
         * @param data CSS data to parse
         * @returns TRUE if the style information was loaded successfully. Returns FALSE on error.
         */
        load_from_data(id: string, data: string): boolean;
        /**
         * Load style information from the specified file.
         * @param filename filename of the style sheet to load
         * @returns TRUE if the style information was loaded successfully. Returns FALSE on error.
         */
        load_from_file(filename: string): boolean;
        load_from_resource(path: string): boolean;
    }

    module Table {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {
            column_count: number;
            columnCount: number;
            column_spacing: number;
            columnSpacing: number;
            row_count: number;
            rowCount: number;
            row_spacing: number;
            rowSpacing: number;
        }
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class Table
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<Table>;

        // Properties

        get column_count(): number;
        get columnCount(): number;
        get column_spacing(): number;
        set column_spacing(val: number);
        get columnSpacing(): number;
        set columnSpacing(val: number);
        get row_count(): number;
        get rowCount(): number;
        get row_spacing(): number;
        set row_spacing(val: number);
        get rowSpacing(): number;
        set rowSpacing(val: number);

        // Constructors

        constructor(properties?: Partial<Table.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Table;

        // Methods

        /**
         * Get the column of the child.
         * @param child a #ClutterActor
         * @returns the column of the child
         */
        child_get_column(child: Clutter.Actor): number;
        /**
         * Get the column span of the child. Defaults to 1.
         * @param child a #ClutterActor
         * @returns the column span of the child
         */
        child_get_column_span(child: Clutter.Actor): number;
        /**
         * Get the row of the child.
         * @param child a #ClutterActor
         * @returns the row of the child
         */
        child_get_row(child: Clutter.Actor): number;
        /**
         * Get the row span of the child. Defaults to 1.
         * @param child A #ClutterActor
         * @returns the row span of the child
         */
        child_get_row_span(child: Clutter.Actor): number;
        /**
         * Get the x-align value of the child
         * @param child A #ClutterActor
         * @returns An #MxAlign value
         */
        child_get_x_align(child: Clutter.Actor): Align;
        /**
         * Get the x-expand property of the child
         * @param child A #ClutterActor
         * @returns #TRUE if the child is set to x-expand
         */
        child_get_x_expand(child: Clutter.Actor): boolean;
        /**
         * Get the x-fill state of the child
         * @param child A #ClutterActor
         * @returns #TRUE if the child is set to x-fill
         */
        child_get_x_fill(child: Clutter.Actor): boolean;
        /**
         * Get the y-align value of the child
         * @param child A #ClutterActor
         * @returns An #MxAlign value
         */
        child_get_y_align(child: Clutter.Actor): Align;
        /**
         * Get the y-expand property of the child.
         * @param child A #ClutterActor
         * @returns #TRUE if the child is set to y-expand
         */
        child_get_y_expand(child: Clutter.Actor): boolean;
        /**
         * Get the y-fill state of the child
         * @param child A #ClutterActor
         * @returns #TRUE if the child is set to y-fill
         */
        child_get_y_fill(child: Clutter.Actor): boolean;
        /**
         * Set the column of the child
         * @param child a #ClutterActor
         * @param col the column of the child
         */
        child_set_column(child: Clutter.Actor, col: number): void;
        /**
         * Set the column span of the child.
         * @param child An #ClutterActor
         * @param span The number of columns to span
         */
        child_set_column_span(child: Clutter.Actor, span: number): void;
        /**
         * Set the row of the child
         * @param child a #ClutterActor
         * @param row the row of the child
         */
        child_set_row(child: Clutter.Actor, row: number): void;
        /**
         * Set the row span of the child.
         * @param child A #ClutterActor
         * @param span the number of rows to span
         */
        child_set_row_span(child: Clutter.Actor, span: number): void;
        /**
         * Set the alignment of the child within its cell. This will only have an effect
         * if the the x-fill property is FALSE.
         * @param child A #ClutterActor
         * @param align A #MxAlign value
         */
        child_set_x_align(child: Clutter.Actor, align: Align | null): void;
        /**
         * Set x-expand on the child. This causes the column which the child
         * resides in to be allocated any extra space if the allocation of the table is
         * larger than the preferred size.
         * @param child A #ClutterActor
         * @param expand the new value of the x expand child property
         */
        child_set_x_expand(child: Clutter.Actor, expand: boolean): void;
        /**
         * Set the fill state of the child on the x-axis. This will cause the child to
         * be allocated the maximum available space.
         * @param child A #ClutterActor
         * @param fill the fill state
         */
        child_set_x_fill(child: Clutter.Actor, fill: boolean): void;
        /**
         * Set the value of the y-align property. This will only have an effect if
         * y-fill value is set to FALSE.
         * @param child A #ClutterActor
         * @param align A #MxAlign value
         */
        child_set_y_align(child: Clutter.Actor, align: Align | null): void;
        /**
         * Set y-expand on the child. This causes the row which the child
         * resides in to be allocated any extra space if the allocation of the table is
         * larger than the preferred size.
         * @param child A #ClutterActor
         * @param expand the new value of the y-expand child property
         */
        child_set_y_expand(child: Clutter.Actor, expand: boolean): void;
        /**
         * Set the fill state of the child on the y-axis. This will cause the child to
         * be allocated the maximum available space.
         * @param child A #ClutterActor
         * @param fill the fill state
         */
        child_set_y_fill(child: Clutter.Actor, fill: boolean): void;
        /**
         * Get an actor at a given position in `table`.
         * @param row the row to look into
         * @param column the column to look into
         * @returns the #ClutterActor a the given position, or NULL.
         */
        get_actor_at(row: number, column: number): Clutter.Actor;
        /**
         * Retrieve the current number of columns in `table`
         * @returns the number of columns
         */
        get_column_count(): number;
        /**
         * Gets the amount of spacing between columns.
         * @returns the spacing between columns in device units
         */
        get_column_spacing(): number;
        /**
         * Retrieve the current number rows in the `table`
         * @returns the number of rows
         */
        get_row_count(): number;
        /**
         * Gets the amount of spacing between rows.
         * @returns the spacing between rows in device units
         */
        get_row_spacing(): number;
        /**
         * Insert an actor at the specified row and column
         *
         * Note, column and rows numbers start from zero
         * @param actor the child to insert
         * @param row the row to place the child into
         * @param column the column to place the child into
         */
        insert_actor(actor: Clutter.Actor, row: number, column: number): void;
        /**
         * Sets the amount of spacing between columns.
         * @param spacing spacing in pixels
         */
        set_column_spacing(spacing: number): void;
        /**
         * Sets the amount of spacing between rows.
         * @param spacing spacing in pixels
         */
        set_row_spacing(spacing: number): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module TableChild {
        // Constructor properties interface

        interface ConstructorProps extends Clutter.ChildMeta.ConstructorProps {
            column: number;
            column_span: number;
            columnSpan: number;
            row: number;
            row_span: number;
            rowSpan: number;
            x_align: Align;
            xAlign: Align;
            x_expand: boolean;
            xExpand: boolean;
            x_fill: boolean;
            xFill: boolean;
            y_align: Align;
            yAlign: Align;
            y_expand: boolean;
            yExpand: boolean;
            y_fill: boolean;
            yFill: boolean;
        }
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class TableChild extends Clutter.ChildMeta {
        static $gtype: GObject.GType<TableChild>;

        // Properties

        get column(): number;
        set column(val: number);
        get column_span(): number;
        set column_span(val: number);
        get columnSpan(): number;
        set columnSpan(val: number);
        get row(): number;
        set row(val: number);
        get row_span(): number;
        set row_span(val: number);
        get rowSpan(): number;
        set rowSpan(val: number);
        get x_align(): Align;
        set x_align(val: Align);
        get xAlign(): Align;
        set xAlign(val: Align);
        get x_expand(): boolean;
        set x_expand(val: boolean);
        get xExpand(): boolean;
        set xExpand(val: boolean);
        get x_fill(): boolean;
        set x_fill(val: boolean);
        get xFill(): boolean;
        set xFill(val: boolean);
        get y_align(): Align;
        set y_align(val: Align);
        get yAlign(): Align;
        set yAlign(val: Align);
        get y_expand(): boolean;
        set y_expand(val: boolean);
        get yExpand(): boolean;
        set yExpand(val: boolean);
        get y_fill(): boolean;
        set y_fill(val: boolean);
        get yFill(): boolean;
        set yFill(val: boolean);

        // Constructors

        constructor(properties?: Partial<TableChild.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;
    }

    module TextureCache {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class TextureCache extends GObject.Object {
        static $gtype: GObject.GType<TextureCache>;

        // Constructors

        constructor(properties?: Partial<TextureCache.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Returns the default texture cache. This is owned by Mx and should not be
         * unreferenced or freed.
         */
        static get_default(): TextureCache;

        // Virtual methods

        vfunc_error_loading(error: GLib.Error): void;
        vfunc_loaded(uri: string, texture: Clutter.Texture): void;

        // Methods

        /**
         * Checks whether the given URI/path is contained within the texture
         * cache.
         * @param uri A URI or path to an image file
         * @returns %TRUE if the image exists, %FALSE otherwise
         */
        contains(uri: string): boolean;
        /**
         * Checks whether there are any textures associated with the given URI by
         * the given identifier.
         * @param uri A URI or path to an image file
         * @param ident A unique identifier
         * @returns %TRUE if the data exists, %FALSE otherwise
         */
        contains_meta(uri: string, ident: any): boolean;
        /**
         * This is a wrapper around mx_texture_cache_get_texture() which returns
         * a ClutterActor.
         * @param uri A URI or path to a image file
         * @returns a newly created ClutterTexture
         */
        get_actor(uri: string): Clutter.Actor;
        /**
         * Create a #CoglHandle representing a texture of the specified image. Adds
         * the image to the cache if the image had not been previously loaded.
         * Subsequent calls with the same image URI/path will return the #CoglHandle of
         * the previously loaded image with an increased reference count.
         * @param uri A URI or path to an image file
         * @returns a #CoglHandle to the cached texture
         */
        get_cogl_texture(uri: string): Cogl.Handle;
        /**
         * Retrieves the #CoglHandle of the previously added image associated
         * with the given unique identifier.
         *
         * See mx_texture_cache_insert_meta()
         * @param uri A URI or path to an image file
         * @param ident A unique identifier
         * @returns A #CoglHandle to a texture, with an added reference. %NULL if no image was found.
         */
        get_meta_cogl_texture(uri: string, ident: any): Cogl.Handle;
        /**
         * Create a new ClutterTexture using the previously added image associated
         * with the given unique identifier.
         *
         * See mx_texture_cache_insert_meta()
         * @param uri A URI or path to an image file
         * @param ident A unique identifier
         * @returns A newly allocated #ClutterTexture, or %NULL if no image was found
         */
        get_meta_texture(uri: string, ident: any): Clutter.Texture;
        /**
         * Returns the number of items in the texture cache
         * @returns the current size of the cache
         */
        get_size(): number;
        /**
         * Create a new ClutterTexture with the specified image. Adds the image to the
         * cache if the image had not been previously loaded. Subsequent calls with
         * the same image URI/path will return a new ClutterTexture with the previously
         * loaded image.
         * @param uri A URI or path to a image file
         * @returns a newly created ClutterTexture
         */
        get_texture(uri: string): Clutter.Texture;
        /**
         * Inserts a texture into the texture cache. This can be useful if you
         * want to cache a texture from a custom or unhandled URI type, or you
         * want to override a particular texture.
         *
         * If the image is already in the cache, this texture will replace it. A
         * reference will be taken on the given texture.
         * @param uri A URI or local file path
         * @param texture A #CoglHandle to a texture
         */
        insert(uri: string, texture: Cogl.Handle): void;
        /**
         * Inserts a texture that's associated with a URI into the cache.
         * If the metadata already exists for this URI, it will be replaced.
         *
         * This is useful if you have a widely used modification of an image,
         * for example, an image with a border composited around it.
         * @param uri A URI or local file path
         * @param ident A unique identifier
         * @param texture A #CoglHandle to a texture
         */
        insert_meta(uri: string, ident: any, texture: Cogl.Handle): void;
        load_cache(filename: string): void;
    }

    module TextureFrame {
        // Constructor properties interface

        interface ConstructorProps
            extends Clutter.Actor.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps {
            bottom: number;
            left: number;
            parent_texture: Clutter.Texture;
            parentTexture: Clutter.Texture;
            right: number;
            top: number;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class TextureFrame
        extends Clutter.Actor
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable
    {
        static $gtype: GObject.GType<TextureFrame>;

        // Properties

        get bottom(): number;
        set bottom(val: number);
        get left(): number;
        set left(val: number);
        get parent_texture(): Clutter.Texture;
        set parent_texture(val: Clutter.Texture);
        get parentTexture(): Clutter.Texture;
        set parentTexture(val: Clutter.Texture);
        get right(): number;
        set right(val: number);
        get top(): number;
        set top(val: number);

        // Constructors

        constructor(properties?: Partial<TextureFrame.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            texture: Clutter.Texture,
            top: number,
            right: number,
            bottom: number,
            left: number,
        ): TextureFrame;
        // Conflicted with Clutter.Actor.new

        static ['new'](...args: never[]): any;

        // Static methods

        static paint_background(
            texture: Cogl.Handle,
            opacity: number,
            x: number,
            y: number,
            width: number,
            height: number,
        ): void;
        static paint_texture(
            texture: Cogl.Handle,
            opacity: number,
            top: number,
            right: number,
            bottom: number,
            left: number,
            width: number,
            height: number,
        ): void;

        // Methods

        /**
         * Retrieve the current slice lines from the specified frame.
         * @param top width of the top slice
         * @param right width of the right slice
         * @param bottom width of the bottom slice
         * @param left width of the left slice
         */
        get_border_values(top: number, right: number, bottom: number, left: number): void;
        /**
         * Return the texture used by the #MxTextureFrame
         * @returns a #ClutterTexture owned by the #MxTextureFrame
         */
        get_parent_texture(): Clutter.Texture;
        /**
         * Set the slice lines of the specified frame. The slices are calculated as
         * widths from the edge of the frame.
         * @param top width of the top slice
         * @param right width of the right slice
         * @param bottom width of the bottom slice
         * @param left width of the left slice
         */
        set_border_values(top: number, right: number, bottom: number, left: number): void;
        /**
         * Set the #ClutterTexture used by this #MxTextureFrame
         * @param texture A #ClutterTexture
         */
        set_parent_texture(texture: Clutter.Texture): void;

        // Inherited methods
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         * @returns %TRUE if the value has been validated and can   be applied to the #ClutterAnimatable, and %FALSE otherwise
         */
        animate_property(
            animation: Clutter.Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         * @returns The #GParamSpec for the given property   or %NULL
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         * @returns %TRUE if the interpolation was successful,   and %FALSE otherwise
         */
        interpolate_value(property_name: string, interval: Clutter.Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         */
        vfunc_animate_property(
            animation: Clutter.Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         */
        vfunc_find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        vfunc_get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         */
        vfunc_interpolate_value(
            property_name: string,
            interval: Clutter.Interval,
            progress: number,
        ): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        vfunc_set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        add_actor(actor: Clutter.Actor): void;
        /**
         * Gets a container specific property of a child of `container,` In general,
         * a copy is made of the property contents and the caller is responsible for
         * freeing the memory by calling g_value_unset().
         *
         * Note that clutter_container_child_set_property() is really intended for
         * language bindings, clutter_container_child_set() is much more convenient
         * for C programming.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_get_property(child: Clutter.Actor, property: string, value: GObject.Value | any): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        child_notify(child: Clutter.Actor, pspec: GObject.ParamSpec): void;
        /**
         * Sets a container-specific property on a child of `container`.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_set_property(child: Clutter.Actor, property: string, value: GObject.Value | any): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        create_child_meta(actor: Clutter.Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        destroy_child_meta(actor: Clutter.Actor): void;
        /**
         * Finds a child actor of a container by its name. Search recurses
         * into any child container.
         * @param child_name the name of the requested child.
         * @returns The child actor with the requested name,   or %NULL if no actor with that name was found.
         */
        find_child_by_name(child_name: string): Clutter.Actor;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach(callback: Clutter.Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach_with_internals(callback: Clutter.Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         * @returns the #ClutterChildMeta for the @actor child   of @container or %NULL if the specifiec actor does not exist or the   container is not configured to provide #ClutterChildMeta<!-- -->s
         */
        get_child_meta(actor: Clutter.Actor): Clutter.ChildMeta;
        /**
         * Retrieves all the children of `container`.
         * @returns a list   of #ClutterActor<!-- -->s. Use g_list_free() on the returned   list when done.
         */
        get_children(): Clutter.Actor[];
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        lower_child(actor: Clutter.Actor, sibling?: Clutter.Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        raise_child(actor: Clutter.Actor, sibling?: Clutter.Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        remove_actor(actor: Clutter.Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        sort_depth_order(): void;
        vfunc_actor_added(actor: Clutter.Actor): void;
        vfunc_actor_removed(actor: Clutter.Actor): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        vfunc_add(actor: Clutter.Actor): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        vfunc_child_notify(child: Clutter.Actor, pspec: GObject.ParamSpec): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_create_child_meta(actor: Clutter.Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_destroy_child_meta(actor: Clutter.Actor): void;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach(callback: Clutter.Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach_with_internals(callback: Clutter.Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         */
        vfunc_get_child_meta(actor: Clutter.Actor): Clutter.ChildMeta;
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        vfunc_lower(actor: Clutter.Actor, sibling?: Clutter.Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        vfunc_raise(actor: Clutter.Actor, sibling?: Clutter.Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        vfunc_remove(actor: Clutter.Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        vfunc_sort_depth_order(): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Clutter.Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Clutter.Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(
            script: Clutter.Script,
            value: GObject.Value | any,
            name: string,
            node: Json.Node,
        ): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Clutter.Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Toggle {
        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {
            active: boolean;
        }
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class Toggle
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<Toggle>;

        // Properties

        get active(): boolean;
        set active(val: boolean);

        // Constructors

        constructor(properties?: Partial<Toggle.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Toggle;

        // Methods

        get_active(): boolean;
        set_active(active: boolean): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Toolbar {
        // Signal callback interfaces

        interface CloseButtonClicked {
            (): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Stylable.ConstructorProps {
            has_close_button: boolean;
            hasCloseButton: boolean;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class Toolbar
        extends Widget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Focusable, Stylable
    {
        static $gtype: GObject.GType<Toolbar>;

        // Properties

        get has_close_button(): boolean;
        set has_close_button(val: boolean);
        get hasCloseButton(): boolean;
        set hasCloseButton(val: boolean);

        // Constructors

        constructor(properties?: Partial<Toolbar.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Toolbar;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'close-button-clicked', callback: (_source: this) => boolean): number;
        connect_after(signal: 'close-button-clicked', callback: (_source: this) => boolean): number;
        emit(signal: 'close-button-clicked'): void;

        // Virtual methods

        vfunc_close_button_clicked(): boolean;

        // Methods

        /**
         * Get the value of the #MxToolbar:has-close-button property.
         * @returns the current value of the "hast-close-button" property.
         */
        get_has_close_button(): boolean;
        /**
         * Set the #MxToolbar:has-close-button property
         * @param has_close_button #TRUE if a close button should be displayed
         */
        set_has_close_button(has_close_button: boolean): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Tooltip {
        // Constructor properties interface

        interface ConstructorProps
            extends FloatingWidget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Stylable.ConstructorProps {
            text: string;
            tip_area: Clutter.Geometry;
            tipArea: Clutter.Geometry;
        }
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class Tooltip
        extends FloatingWidget
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Stylable
    {
        static $gtype: GObject.GType<Tooltip>;

        // Properties

        get text(): string;
        set text(val: string);
        get tip_area(): Clutter.Geometry;
        set tip_area(val: Clutter.Geometry);
        get tipArea(): Clutter.Geometry;
        set tipArea(val: Clutter.Geometry);

        // Constructors

        constructor(properties?: Partial<Tooltip.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Browse mode is entered whenever a tooltip is displayed and it is
         * left after a short delay when a tooltip is hidden. This is used to
         * make tooltips display quicker when a previous tooltip is already
         * displayed.
         */
        static is_in_browse_mode(): boolean;

        // Methods

        /**
         * Get the text displayed on the tooltip
         * @returns the text for the tooltip. This must not be freed by the application
         */
        get_text(): string;
        /**
         * Retrieve the area on the stage that the tooltip currently applies to
         * @returns the #ClutterGeometry, owned by the tooltip which must not be freed by the application.
         */
        get_tip_area(): Clutter.Geometry;
        /**
         * Hide the tooltip
         */
        hide(): void;
        /**
         * Sets the text displayed on the tooltip
         * @param text text to set the label to
         */
        set_text(text: string): void;
        /**
         * Set the area on the stage that the tooltip applies to.
         * @param area A #ClutterGeometry
         */
        set_tip_area(area: Clutter.Geometry): void;
        /**
         * Utility function to set the geometry of the tooltip area
         * from an existing actor.
         * See also mx_tooltip_set_tip_area
         * @param actor A #ClutterActor
         */
        set_tip_area_from_actor(actor: Clutter.Actor): void;
        /**
         * Show the tooltip relative to the associated widget.
         */
        show(): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Viewport {
        // Constructor properties interface

        interface ConstructorProps
            extends Bin.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Focusable.ConstructorProps,
                Scrollable.ConstructorProps,
                Stylable.ConstructorProps {
            sync_adjustments: boolean;
            syncAdjustments: boolean;
            x_origin: number;
            xOrigin: number;
            y_origin: number;
            yOrigin: number;
            z_origin: number;
            zOrigin: number;
        }
    }

    /**
     * The contents of this structure are private and should only be accessed
     * through the public API.
     */
    class Viewport
        extends Bin
        implements
            Atk.ImplementorIface,
            Clutter.Animatable,
            Clutter.Container,
            Clutter.Scriptable,
            Focusable,
            Scrollable,
            Stylable
    {
        static $gtype: GObject.GType<Viewport>;

        // Properties

        get sync_adjustments(): boolean;
        set sync_adjustments(val: boolean);
        get syncAdjustments(): boolean;
        set syncAdjustments(val: boolean);
        get x_origin(): number;
        set x_origin(val: number);
        get xOrigin(): number;
        set xOrigin(val: number);
        get y_origin(): number;
        set y_origin(val: number);
        get yOrigin(): number;
        set yOrigin(val: number);
        get z_origin(): number;
        set z_origin(val: number);
        get zOrigin(): number;
        set zOrigin(val: number);

        // Constructors

        constructor(properties?: Partial<Viewport.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Viewport;

        // Methods

        get_origin(x: number, y: number, z: number): void;
        get_sync_adjustments(): boolean;
        set_origin(x: number, y: number, z: number): void;
        set_sync_adjustments(sync: boolean): void;

        // Inherited properties
        get horizontal_adjustment(): Adjustment;
        set horizontal_adjustment(val: Adjustment);
        get horizontalAdjustment(): Adjustment;
        set horizontalAdjustment(val: Adjustment);
        get vertical_adjustment(): Adjustment;
        set vertical_adjustment(val: Adjustment);
        get verticalAdjustment(): Adjustment;
        set verticalAdjustment(val: Adjustment);

        // Inherited methods
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;
        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        get_adjustments(): [Adjustment | null, Adjustment | null];
        set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        vfunc_get_adjustments(): [Adjustment | null, Adjustment | null];
        vfunc_set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Widget {
        // Signal callback interfaces

        interface LongPress {
            (object: number, p0: number, p1: LongPressAction): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Clutter.Actor.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Clutter.Animatable.ConstructorProps,
                Clutter.Container.ConstructorProps,
                Clutter.Scriptable.ConstructorProps,
                Stylable.ConstructorProps {
            disabled: boolean;
            menu: Menu;
            tooltip_delay: number;
            tooltipDelay: number;
            tooltip_text: string;
            tooltipText: string;
        }
    }

    /**
     * Base class for stylable actors. The contents of the #MxWidget
     * structure are private and should only be accessed through the
     * public API.
     */
    abstract class Widget
        extends Clutter.Actor
        implements Atk.ImplementorIface, Clutter.Animatable, Clutter.Container, Clutter.Scriptable, Stylable
    {
        static $gtype: GObject.GType<Widget>;

        // Properties

        get disabled(): boolean;
        set disabled(val: boolean);
        /**
         * #MxMenu associated with the widget.
         */
        get menu(): Menu;
        set menu(val: Menu);
        get tooltip_delay(): number;
        set tooltip_delay(val: number);
        get tooltipDelay(): number;
        set tooltipDelay(val: number);
        /**
         * text displayed on the tooltip
         */
        get tooltip_text(): string;
        set tooltip_text(val: string);
        /**
         * text displayed on the tooltip
         */
        get tooltipText(): string;
        set tooltipText(val: string);

        // Constructors

        constructor(properties?: Partial<Widget.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'long-press',
            callback: (_source: this, object: number, p0: number, p1: LongPressAction) => boolean,
        ): number;
        connect_after(
            signal: 'long-press',
            callback: (_source: this, object: number, p0: number, p1: LongPressAction) => boolean,
        ): number;
        emit(signal: 'long-press', object: number, p0: number, p1: LongPressAction): void;

        // Virtual methods

        vfunc_long_press(action: LongPressAction, x: number, y: number): boolean;

        // Methods

        /**
         * Used to implement how a new style instance should be applied in the widget.
         * For instance, setting style instance on stylable internal children.
         * @param style A #MxStyle
         */
        apply_style(style: Style): void;
        /**
         * Copies `allocation` into `area` and accounts for the padding values. This
         * gives the area that is available in which to allocate children with respect
         * to padding.
         * @param allocation A #ClutterActorBox
         * @param area A #ClutterActorBox
         */
        get_available_area(allocation: Clutter.ActorBox, area: Clutter.ActorBox): void;
        /**
         * Get the color used as the background. This is set using the
         * "background-color" CSS property. This function should normally only
         * be used by subclasses.
         * @returns a #ClutterColor
         */
        get_background_color(): Clutter.Color;
        // Conflicted with Clutter.Actor.get_background_color
        get_background_color(...args: never[]): any;
        /**
         * Get the texture used as the background image. This is set using the
         * "background-image" CSS property. This function should normally only be used
         * by subclasses.
         * @returns a #CoglHandle
         */
        get_background_texture(): Cogl.Handle;
        /**
         * Get the value of the "disabled" property.
         */
        get_disabled(): boolean;
        /**
         * Get the object in the #MxWidget:menu property.
         * @returns The current object in the "menu" property.
         */
        get_menu(): Menu;
        /**
         * Gets the padding of the widget, set using the "padding" CSS property. This
         * function should normally only be used by subclasses.
         */
        get_padding(): Padding;
        /**
         * Get the value of the "tooltip-delay" property.
         * @returns the current delay value in milliseconds
         */
        get_tooltip_delay(): number;
        /**
         * Get the current tooltip string
         * @returns The current tooltip string, owned by the #MxWidget
         */
        get_tooltip_text(): string;
        /**
         * Hide the tooltip for `widget`
         */
        hide_tooltip(): void;
        /**
         * Cancel a long-press timeout if one is running and emit the signal to notify
         * that the long-press has been cancelled.
         */
        long_press_cancel(): void;
        /**
         * Emit the long-press query signal and start a long-press timeout if required.
         * @param event the event used to determine whether to run a long-press
         */
        long_press_query(event: Clutter.Event): void;
        /**
         * Set the disabled property. Disabled widgets have a "disabled" pseudo-class
         * until disabled is set to #FALSE.
         * @param disabled value to set
         */
        set_disabled(disabled: boolean): void;
        /**
         * Set the value of the #MxWidget:menu property.
         * @param menu A #MxMenu
         */
        set_menu(menu: Menu): void;
        /**
         * Set the value, in milliseconds, of the "tooltip-delay" property.
         * This is initially set to MX_WIDGET_TOOLTIP_TIMEOUT.
         * @param delay
         */
        set_tooltip_delay(delay: number): void;
        /**
         * Set the tooltip text of the widget. Note that setting tooltip text will cause
         * the widget to be set reactive. If you no longer need tooltips and you do not
         * need the widget to be reactive, you must set ClutterActor::reactive to
         * %FALSE.
         * @param text text to set as the tooltip
         */
        set_tooltip_text(text: string): void;
        /**
         * Show the tooltip for `widget`
         */
        show_tooltip(): void;

        // Inherited properties
        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Inherited methods
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         * @returns %TRUE if the value has been validated and can   be applied to the #ClutterAnimatable, and %FALSE otherwise
         */
        animate_property(
            animation: Clutter.Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         * @returns The #GParamSpec for the given property   or %NULL
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         * @returns %TRUE if the interpolation was successful,   and %FALSE otherwise
         */
        interpolate_value(property_name: string, interval: Clutter.Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         */
        vfunc_animate_property(
            animation: Clutter.Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         */
        vfunc_find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        vfunc_get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         */
        vfunc_interpolate_value(
            property_name: string,
            interval: Clutter.Interval,
            progress: number,
        ): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        vfunc_set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        add_actor(actor: Clutter.Actor): void;
        /**
         * Gets a container specific property of a child of `container,` In general,
         * a copy is made of the property contents and the caller is responsible for
         * freeing the memory by calling g_value_unset().
         *
         * Note that clutter_container_child_set_property() is really intended for
         * language bindings, clutter_container_child_set() is much more convenient
         * for C programming.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_get_property(child: Clutter.Actor, property: string, value: GObject.Value | any): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        child_notify(child: Clutter.Actor, pspec: GObject.ParamSpec): void;
        /**
         * Sets a container-specific property on a child of `container`.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_set_property(child: Clutter.Actor, property: string, value: GObject.Value | any): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        create_child_meta(actor: Clutter.Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        destroy_child_meta(actor: Clutter.Actor): void;
        /**
         * Finds a child actor of a container by its name. Search recurses
         * into any child container.
         * @param child_name the name of the requested child.
         * @returns The child actor with the requested name,   or %NULL if no actor with that name was found.
         */
        find_child_by_name(child_name: string): Clutter.Actor;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach(callback: Clutter.Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach_with_internals(callback: Clutter.Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         * @returns the #ClutterChildMeta for the @actor child   of @container or %NULL if the specifiec actor does not exist or the   container is not configured to provide #ClutterChildMeta<!-- -->s
         */
        get_child_meta(actor: Clutter.Actor): Clutter.ChildMeta;
        /**
         * Retrieves all the children of `container`.
         * @returns a list   of #ClutterActor<!-- -->s. Use g_list_free() on the returned   list when done.
         */
        get_children(): Clutter.Actor[];
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        lower_child(actor: Clutter.Actor, sibling?: Clutter.Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        raise_child(actor: Clutter.Actor, sibling?: Clutter.Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        remove_actor(actor: Clutter.Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        sort_depth_order(): void;
        vfunc_actor_added(actor: Clutter.Actor): void;
        vfunc_actor_removed(actor: Clutter.Actor): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        vfunc_add(actor: Clutter.Actor): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        vfunc_child_notify(child: Clutter.Actor, pspec: GObject.ParamSpec): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_create_child_meta(actor: Clutter.Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_destroy_child_meta(actor: Clutter.Actor): void;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach(callback: Clutter.Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach_with_internals(callback: Clutter.Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         */
        vfunc_get_child_meta(actor: Clutter.Actor): Clutter.ChildMeta;
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        vfunc_lower(actor: Clutter.Actor, sibling?: Clutter.Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        vfunc_raise(actor: Clutter.Actor, sibling?: Clutter.Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        vfunc_remove(actor: Clutter.Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        vfunc_sort_depth_order(): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Clutter.Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Clutter.Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(
            script: Clutter.Script,
            value: GObject.Value | any,
            name: string,
            node: Json.Node,
        ): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Clutter.Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    module Window {
        // Signal callback interfaces

        interface Destroy {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            child: Clutter.Actor;
            clutter_stage: Clutter.Stage;
            clutterStage: Clutter.Stage;
            fullscreen: boolean;
            has_toolbar: boolean;
            hasToolbar: boolean;
            icon_cogl_texture: string;
            iconCoglTexture: string;
            icon_name: string;
            iconName: string;
            small_screen: boolean;
            smallScreen: boolean;
            title: string;
            toolbar: Toolbar;
            window_rotation: WindowRotation;
            windowRotation: WindowRotation;
            window_rotation_angle: number;
            windowRotationAngle: number;
            window_rotation_timeline: Clutter.Timeline;
            windowRotationTimeline: Clutter.Timeline;
        }
    }

    /**
     * The contents of this structure is private and should only be accessed using
     * the provided API.
     */
    class Window extends GObject.Object {
        static $gtype: GObject.GType<Window>;

        // Properties

        get child(): Clutter.Actor;
        set child(val: Clutter.Actor);
        get clutter_stage(): Clutter.Stage;
        get clutterStage(): Clutter.Stage;
        get fullscreen(): boolean;
        set fullscreen(val: boolean);
        get has_toolbar(): boolean;
        set has_toolbar(val: boolean);
        get hasToolbar(): boolean;
        set hasToolbar(val: boolean);
        get icon_cogl_texture(): string;
        set icon_cogl_texture(val: string);
        get iconCoglTexture(): string;
        set iconCoglTexture(val: string);
        get icon_name(): string;
        set icon_name(val: string);
        get iconName(): string;
        set iconName(val: string);
        get small_screen(): boolean;
        set small_screen(val: boolean);
        get smallScreen(): boolean;
        set smallScreen(val: boolean);
        get title(): string;
        set title(val: string);
        get toolbar(): Toolbar;
        set toolbar(val: Toolbar);
        get window_rotation(): WindowRotation;
        set window_rotation(val: WindowRotation);
        get windowRotation(): WindowRotation;
        set windowRotation(val: WindowRotation);
        get window_rotation_angle(): number;
        get windowRotationAngle(): number;
        get window_rotation_timeline(): Clutter.Timeline;
        get windowRotationTimeline(): Clutter.Timeline;

        // Constructors

        constructor(properties?: Partial<Window.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Window;

        static new_with_clutter_stage(stage: Clutter.Stage): Window;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'destroy', callback: (_source: this) => void): number;
        connect_after(signal: 'destroy', callback: (_source: this) => void): number;
        emit(signal: 'destroy'): void;

        // Static methods

        /**
         * Gets the #MxWindow parent of the #ClutterStage, if it exists.
         * @param stage A #ClutterStage
         */
        static get_for_stage(stage: Clutter.Stage): Window;

        // Virtual methods

        vfunc_destroy(): void;

        // Methods

        /**
         * Get the primary child of the window. See mx_window_set_child().
         * @returns A #ClutterActor, or %NULL
         */
        get_child(): Clutter.Actor;
        /**
         * Gets the #ClutterStage managed by the window.
         * @returns A #ClutterStage
         */
        get_clutter_stage(): Clutter.Stage;
        /**
         * Determines if the window has been set to be in fullscreen mode.
         * @returns %TRUE if the window has been set to be in fullscreen mode, otherwise %FALSE
         */
        get_fullscreen(): boolean;
        /**
         * Determines whether the window has a toolbar or not.
         * See mx_window_set_has_toolbar().
         * @returns %TRUE if the window has a toolbar, otherwise %FALSE
         */
        get_has_toolbar(): boolean;
        /**
         * Gets the currently set window icon name. This will be %NULL if there is none
         * set, or the icon was set with mx_window_set_icon_from_cogl_texture().
         * @returns The window icon name, or %NULL
         */
        get_icon_name(): string;
        /**
         * Determines if the window is in small-screen mode.
         * See mx_window_set_small_screen().
         * @returns %TRUE if the window is in small-screen mode, otherwise %FALSE
         */
        get_small_screen(): boolean;
        /**
         * Retrieves the title used for the window.
         * @returns The title used for the window
         */
        get_title(): string;
        /**
         * Retrieves the toolbar associated with the window.
         * @returns A #MxToolbar
         */
        get_toolbar(): Toolbar;
        /**
         * Retrieves the absolute position of the window on the screen.
         */
        get_window_position(): [number, number];
        /**
         * Retrieve the rotation of the window.
         * @returns An #MxWindowRotation
         */
        get_window_rotation(): WindowRotation;
        /**
         * Retrieves the size of the display area of the window, taking into
         * account any window border. This includes the area occupied by the
         * window's toolbar, if it's enabled.
         */
        get_window_size(): [number, number];
        /**
         * Hide the window
         */
        hide(): void;
        /**
         * Present the window. The actual behaviour is specific to the window system.
         */
        present(): void;
        /**
         * Adds `actor` to the window and sets it as the primary child. When the
         * stage managed in the window changes size, the child will be resized
         * to match it.
         * @param actor A #ClutterActor
         */
        set_child(actor: Clutter.Actor): void;
        /**
         * Set the window to be in fullscreen mode or windowed mode.
         *
         * <note><para>
         * Setting fullscreen mode doesn't necessarily mean the window is actually
         * fullscreen. Setting this property is only a request to the underlying
         * window system.
         * </para></note>
         * @param fullscreen %TRUE to request fullscreen mode, %FALSE to disable
         */
        set_fullscreen(fullscreen: boolean): void;
        /**
         * Sets whether the window has a toolbar or not. If the window has a toolbar,
         * client-side window decorations will be enabled.
         * @param toolbar %TRUE if the toolbar should be displayed
         */
        set_has_toolbar(toolbar: boolean): void;
        /**
         * Sets the window icon from a texture. This will take precedence over
         * any currently set icon-name.
         * @param texture A #CoglHandle for a texture
         */
        set_icon_from_cogl_texture(texture: Cogl.Handle): void;
        /**
         * Set an icon-name to use for the window icon. The icon will be looked up
         * from the default theme.
         * @param icon_name An icon name, or %NULL
         */
        set_icon_name(icon_name: string): void;
        /**
         * Enables or disables small-screen mode. This mode is meant primarily
         * for platforms with limited screen-space, such as netbooks. When enabled,
         * the window will take up all available room and will disable moving and
         * resizing.
         * @param small_screen %TRUE if small-screen mode should be enabled
         */
        set_small_screen(small_screen: boolean): void;
        /**
         * Sets the title used for the window, the results of which are
         * window-system specific.
         * @param title A string to use for the window title name
         */
        set_title(title: string): void;
        /**
         * Sets the toolbar associated with the window.
         * @param toolbar
         */
        set_toolbar(toolbar: Toolbar): void;
        /**
         * Sets the absolute position of the window on the screen.
         * @param x An x-coordinate
         * @param y A y-coordinate
         */
        set_window_position(x: number, y: number): void;
        /**
         * Set the rotation of the window.
         * @param rotation The #MxWindowRotation
         */
        set_window_rotation(rotation: WindowRotation | null): void;
        /**
         * Sets the size of the window, taking into account any window border. This
         * corresponds to the window's available area for its child, minus the area
         * occupied by the window's toolbar, if it's enabled.
         *
         * <note><para>
         * Setting the window size may involve a request to the underlying windowing
         * system, and may not immediately be reflected.
         * </para></note>
         * @param width A width, in pixels
         * @param height A height, in pixels
         */
        set_window_size(width: number, height: number): void;
        /**
         * Show the window
         */
        show(): void;
    }

    type ActionClass = typeof Action;
    abstract class ActionPrivate {
        static $gtype: GObject.GType<ActionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ActorManagerClass = typeof ActorManager;
    abstract class ActorManagerPrivate {
        static $gtype: GObject.GType<ActorManagerPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type AdjustmentClass = typeof Adjustment;
    abstract class AdjustmentPrivate {
        static $gtype: GObject.GType<AdjustmentPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ApplicationClass = typeof Application;
    abstract class ApplicationPrivate {
        static $gtype: GObject.GType<ApplicationPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BinClass = typeof Bin;
    abstract class BinPrivate {
        static $gtype: GObject.GType<BinPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    class BorderImage {
        static $gtype: GObject.GType<BorderImage>;

        // Fields

        uri: string;
        top: number;
        right: number;
        bottom: number;
        left: number;

        // Constructors

        constructor(
            properties?: Partial<{
                uri: string;
                top: number;
                right: number;
                bottom: number;
                left: number;
            }>,
        );
        _init(...args: any[]): void;

        // Static methods

        static set_from_string(value: GObject.Value | any, str: string, filename: string): void;

        // Methods

        equal(b2: BorderImage): boolean;
    }

    type BoxLayoutChildClass = typeof BoxLayoutChild;
    abstract class BoxLayoutChildPrivate {
        static $gtype: GObject.GType<BoxLayoutChildPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BoxLayoutClass = typeof BoxLayout;
    abstract class BoxLayoutPrivate {
        static $gtype: GObject.GType<BoxLayoutPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ButtonClass = typeof Button;
    type ButtonGroupClass = typeof ButtonGroup;
    abstract class ButtonGroupPrivate {
        static $gtype: GObject.GType<ButtonGroupPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class ButtonPrivate {
        static $gtype: GObject.GType<ButtonPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ClipboardClass = typeof Clipboard;
    abstract class ClipboardPrivate {
        static $gtype: GObject.GType<ClipboardPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ComboBoxClass = typeof ComboBox;
    abstract class ComboBoxPrivate {
        static $gtype: GObject.GType<ComboBoxPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DialogClass = typeof Dialog;
    abstract class DialogPrivate {
        static $gtype: GObject.GType<DialogPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DraggableIface = typeof Draggable;
    type DroppableIface = typeof Droppable;
    type EntryClass = typeof Entry;
    abstract class EntryPrivate {
        static $gtype: GObject.GType<EntryPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ExpanderClass = typeof Expander;
    abstract class ExpanderPrivate {
        static $gtype: GObject.GType<ExpanderPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type FadeEffectClass = typeof FadeEffect;
    abstract class FadeEffectPrivate {
        static $gtype: GObject.GType<FadeEffectPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type FloatingWidgetClass = typeof FloatingWidget;
    abstract class FloatingWidgetPrivate {
        static $gtype: GObject.GType<FloatingWidgetPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type FocusManagerClass = typeof FocusManager;
    abstract class FocusManagerPrivate {
        static $gtype: GObject.GType<FocusManagerPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type FocusableIface = typeof Focusable;
    type FrameClass = typeof Frame;
    abstract class FramePrivate {
        static $gtype: GObject.GType<FramePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type GridClass = typeof Grid;
    abstract class GridPrivate {
        static $gtype: GObject.GType<GridPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type IconClass = typeof Icon;
    abstract class IconPrivate {
        static $gtype: GObject.GType<IconPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type IconThemeClass = typeof IconTheme;
    abstract class IconThemePrivate {
        static $gtype: GObject.GType<IconThemePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ImageClass = typeof Image;
    abstract class ImagePrivate {
        static $gtype: GObject.GType<ImagePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ItemFactoryIface = typeof ItemFactory;
    type ItemViewClass = typeof ItemView;
    abstract class ItemViewPrivate {
        static $gtype: GObject.GType<ItemViewPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type KineticScrollViewClass = typeof KineticScrollView;
    abstract class KineticScrollViewPrivate {
        static $gtype: GObject.GType<KineticScrollViewPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type LabelClass = typeof Label;
    abstract class LabelPrivate {
        static $gtype: GObject.GType<LabelPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ListViewClass = typeof ListView;
    abstract class ListViewPrivate {
        static $gtype: GObject.GType<ListViewPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type MenuClass = typeof Menu;
    abstract class MenuPrivate {
        static $gtype: GObject.GType<MenuPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type NotebookClass = typeof Notebook;
    abstract class NotebookPrivate {
        static $gtype: GObject.GType<NotebookPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The padding from the internal border of the parent container.
     */
    class Padding {
        static $gtype: GObject.GType<Padding>;

        // Fields

        top: number;
        right: number;
        bottom: number;
        left: number;

        // Constructors

        constructor(
            properties?: Partial<{
                top: number;
                right: number;
                bottom: number;
                left: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    type PagerClass = typeof Pager;
    abstract class PagerPrivate {
        static $gtype: GObject.GType<PagerPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type PathBarClass = typeof PathBar;
    abstract class PathBarPrivate {
        static $gtype: GObject.GType<PathBarPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ProgressBarClass = typeof ProgressBar;
    abstract class ProgressBarPrivate {
        static $gtype: GObject.GType<ProgressBarPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ScrollBarClass = typeof ScrollBar;
    abstract class ScrollBarPrivate {
        static $gtype: GObject.GType<ScrollBarPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ScrollViewClass = typeof ScrollView;
    abstract class ScrollViewPrivate {
        static $gtype: GObject.GType<ScrollViewPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ScrollableIface = typeof Scrollable;
    type SettingsClass = typeof Settings;
    abstract class SettingsPrivate {
        static $gtype: GObject.GType<SettingsPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class SettingsProvider {
        static $gtype: GObject.GType<SettingsProvider>;

        // Constructors

        _init(...args: any[]): void;
    }

    class SettingsProviderIface {
        static $gtype: GObject.GType<SettingsProviderIface>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SliderClass = typeof Slider;
    abstract class SliderPrivate {
        static $gtype: GObject.GType<SliderPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SpinnerClass = typeof Spinner;
    abstract class SpinnerPrivate {
        static $gtype: GObject.GType<SpinnerPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type StackChildClass = typeof StackChild;
    abstract class StackChildPrivate {
        static $gtype: GObject.GType<StackChildPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type StackClass = typeof Stack;
    abstract class StackPrivate {
        static $gtype: GObject.GType<StackPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type StylableIface = typeof Stylable;
    type StyleClass = typeof Style;
    abstract class StylePrivate {
        static $gtype: GObject.GType<StylePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TableChildClass = typeof TableChild;
    type TableClass = typeof Table;
    abstract class TablePrivate {
        static $gtype: GObject.GType<TablePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Properties of a text shadow
     */
    class TextShadow {
        static $gtype: GObject.GType<TextShadow>;

        // Fields

        h_offset: number;
        v_offset: number;
        blur: number;
        color: Clutter.Color;

        // Constructors

        constructor(
            properties?: Partial<{
                h_offset: number;
                v_offset: number;
                blur: number;
                color: Clutter.Color;
            }>,
        );
        _init(...args: any[]): void;
    }

    type TextureCacheClass = typeof TextureCache;
    type TextureFrameClass = typeof TextureFrame;
    abstract class TextureFramePrivate {
        static $gtype: GObject.GType<TextureFramePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ToggleClass = typeof Toggle;
    abstract class TogglePrivate {
        static $gtype: GObject.GType<TogglePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ToolbarClass = typeof Toolbar;
    abstract class ToolbarPrivate {
        static $gtype: GObject.GType<ToolbarPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TooltipClass = typeof Tooltip;
    abstract class TooltipPrivate {
        static $gtype: GObject.GType<TooltipPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ViewportClass = typeof Viewport;
    abstract class ViewportPrivate {
        static $gtype: GObject.GType<ViewportPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type WidgetClass = typeof Widget;
    abstract class WidgetPrivate {
        static $gtype: GObject.GType<WidgetPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type WindowClass = typeof Window;
    abstract class WindowPrivate {
        static $gtype: GObject.GType<WindowPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    module Draggable {
        // Constructor properties interface

        interface ConstructorProps extends Clutter.Actor.ConstructorProps {
            axis: DragAxis;
            drag_actor: Clutter.Actor;
            dragActor: Clutter.Actor;
            drag_enabled: boolean;
            dragEnabled: boolean;
            drag_threshold: number;
            dragThreshold: number;
        }
    }

    export interface DraggableNamespace {
        $gtype: GObject.GType<Draggable>;
        prototype: Draggable;
    }
    interface Draggable extends Clutter.Actor {
        // Properties

        get axis(): DragAxis;
        set axis(val: DragAxis);
        get drag_actor(): Clutter.Actor;
        set drag_actor(val: Clutter.Actor);
        get dragActor(): Clutter.Actor;
        set dragActor(val: Clutter.Actor);
        get drag_enabled(): boolean;
        set drag_enabled(val: boolean);
        get dragEnabled(): boolean;
        set dragEnabled(val: boolean);
        get drag_threshold(): number;
        set drag_threshold(val: number);
        get dragThreshold(): number;
        set dragThreshold(val: number);

        // Methods

        disable(): void;
        enable(): void;
        get_axis(): DragAxis;
        /**
         * FIXME
         * @returns a #ClutterActor, or %NULL
         */
        get_drag_actor(): Clutter.Actor;
        get_drag_threshold(): number;
        is_enabled(): boolean;
        set_axis(axis: DragAxis | null): void;
        set_drag_actor(actor: Clutter.Actor): void;
        set_drag_threshold(threshold: number): void;

        // Virtual methods

        vfunc_disable(): void;
        vfunc_drag_begin(event_x: number, event_y: number, event_button: number, modifiers: Clutter.ModifierType): void;
        vfunc_drag_end(event_x: number, event_y: number): void;
        vfunc_drag_motion(delta_x: number, delta_y: number): void;
        vfunc_enable(): void;
    }

    export const Draggable: DraggableNamespace & {
        new (): Draggable; // This allows `obj instanceof Draggable`
    };

    module Droppable {
        // Constructor properties interface

        interface ConstructorProps extends Clutter.Actor.ConstructorProps {
            drop_enabled: boolean;
            dropEnabled: boolean;
        }
    }

    export interface DroppableNamespace {
        $gtype: GObject.GType<Droppable>;
        prototype: Droppable;
    }
    interface Droppable extends Clutter.Actor {
        // Properties

        get drop_enabled(): boolean;
        set drop_enabled(val: boolean);
        get dropEnabled(): boolean;
        set dropEnabled(val: boolean);

        // Methods

        accept_drop(draggable: Draggable): boolean;
        disable(): void;
        enable(): void;
        is_enabled(): boolean;

        // Virtual methods

        vfunc_accept_drop(draggable: Draggable): boolean;
        vfunc_disable(): void;
        vfunc_drop(
            draggable: Draggable,
            event_x: number,
            event_y: number,
            button: number,
            modifiers: Clutter.ModifierType,
        ): void;
        vfunc_enable(): void;
        vfunc_over_in(draggable: Draggable): void;
        vfunc_over_out(draggable: Draggable): void;
    }

    export const Droppable: DroppableNamespace & {
        new (): Droppable; // This allows `obj instanceof Droppable`
    };

    module Focusable {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface FocusableNamespace {
        $gtype: GObject.GType<Focusable>;
        prototype: Focusable;
    }
    interface Focusable extends GObject.Object {
        // Methods

        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         * @returns the focusable
         */
        accept_focus(hint: FocusHint | null): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         * @returns the newly focused focusable
         */
        move_focus(direction: FocusDirection | null, from: Focusable): Focusable;

        // Virtual methods

        /**
         * Accept the focus
         * @param hint A #MxFocusHint
         */
        vfunc_accept_focus(hint: FocusHint): Focusable;
        /**
         * Move the focus
         * @param direction A #MxFocusDirection
         * @param from focusable to move the focus from
         */
        vfunc_move_focus(direction: FocusDirection, from: Focusable): Focusable;
    }

    export const Focusable: FocusableNamespace & {
        new (): Focusable; // This allows `obj instanceof Focusable`
    };

    module ItemFactory {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ItemFactoryNamespace {
        $gtype: GObject.GType<ItemFactory>;
        prototype: ItemFactory;
    }
    interface ItemFactory extends GObject.Object {
        // Methods

        /**
         * Create an item
         * @returns the new item
         */
        create(): Clutter.Actor;

        // Virtual methods

        /**
         * Create an item
         */
        vfunc_create(): Clutter.Actor;
    }

    export const ItemFactory: ItemFactoryNamespace & {
        new (): ItemFactory; // This allows `obj instanceof ItemFactory`
    };

    module Scrollable {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            horizontal_adjustment: Adjustment;
            horizontalAdjustment: Adjustment;
            vertical_adjustment: Adjustment;
            verticalAdjustment: Adjustment;
        }
    }

    export interface ScrollableNamespace {
        $gtype: GObject.GType<Scrollable>;
        prototype: Scrollable;
    }
    interface Scrollable extends GObject.Object {
        // Properties

        get horizontal_adjustment(): Adjustment;
        set horizontal_adjustment(val: Adjustment);
        get horizontalAdjustment(): Adjustment;
        set horizontalAdjustment(val: Adjustment);
        get vertical_adjustment(): Adjustment;
        set vertical_adjustment(val: Adjustment);
        get verticalAdjustment(): Adjustment;
        set verticalAdjustment(val: Adjustment);

        // Methods

        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        get_adjustments(): [Adjustment | null, Adjustment | null];
        set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;

        // Virtual methods

        /**
         * Gets the adjustment objects that store the offsets of the scrollable widget
         * into its possible scrolling area.
         */
        vfunc_get_adjustments(): [Adjustment | null, Adjustment | null];
        vfunc_set_adjustments(hadjustment: Adjustment, vadjustment: Adjustment): void;
    }

    export const Scrollable: ScrollableNamespace & {
        new (): Scrollable; // This allows `obj instanceof Scrollable`
    };

    module Stylable {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            style: Style;
            style_class: string;
            styleClass: string;
            style_pseudo_class: string;
            stylePseudoClass: string;
        }
    }

    export interface StylableNamespace {
        $gtype: GObject.GType<Stylable>;
        prototype: Stylable;
    }
    interface Stylable extends GObject.Object {
        // Properties

        get style(): Style;
        set style(val: Style);
        get style_class(): string;
        set style_class(val: string);
        get styleClass(): string;
        set styleClass(val: string);
        get style_pseudo_class(): string;
        set style_pseudo_class(val: string);
        get stylePseudoClass(): string;
        set stylePseudoClass(val: string);

        // Methods

        apply_clutter_text_attributes(text: Clutter.Text): void;
        connect_change_notifiers(): void;
        disconnect_change_notifiers(): void;
        /**
         * Finds the #GParamSpec installed by `stylable` for the property
         * with `property_name`.
         * @param property_name the name of the property to find
         * @returns a #GParamSpec for the given property, or %NULL if no property with that name was found
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Query `stylable` for the default value of property `property_name` and
         * fill `value_out` with the result.
         * @param property_name name of the property to query
         * @returns %TRUE if property @property_name exists and the default value has been returned.
         */
        get_default_value(property_name: string): [boolean, unknown];
        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         * @returns a #MxStyle
         */
        get_style(): Style;
        /**
         * Get the current style class name
         * @returns the class name string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_class(): string;
        /**
         * Retrieves the value of `property_name` for `stylable,` and puts it
         * into `value`.
         * @param property_name the name of the property
         */
        get_style_property(property_name: string): unknown;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         * @returns the pseudo class string. The string is owned by the #MxWidget and should not be modified or freed.
         */
        get_style_pseudo_class(): string;
        /**
         * Retrieves all the #GParamSpec<!-- -->s installed by `stylable`.
         * @returns an array of #GParamSpec<!-- -->s. Free it with  g_free() when done.
         */
        list_properties(): GObject.ParamSpec[];
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        style_changed(flags: StyleChangedFlags | null): void;
        /**
         * Add a pseudo-class name to the list of pseudo classes, contained in the
         * #MxStylable:style-pseudo-class property.
         * @param new_class A pseudo-class name to add
         */
        style_pseudo_class_add(new_class: string): void;
        /**
         * Check if the given pseudo-class name is contained in the list of
         * set pseudo classes on this #MxStylable object.
         * @param pseudo_class A pseudo-class name
         * @returns %TRUE if the given pseudo-class is set, %FALSE otherwise
         */
        style_pseudo_class_contains(pseudo_class: string): boolean;
        /**
         * Remove the specified pseudo class name from the list of pseudo classes
         * contained in the #MxStylable:style-pseudo-class property.
         * @param remove_class A pseudo class name to remove
         */
        style_pseudo_class_remove(remove_class: string): void;

        // Virtual methods

        /**
         * Retrieves the #MxStyle used by `stylable`. This function does not
         * alter the reference count of the returned object.
         */
        vfunc_get_style(): Style;
        /**
         * Get the current style class name
         */
        vfunc_get_style_class(): string;
        /**
         * Get the current style pseudo class. This can contain multiple pseudo class
         * names, separated by ':'.
         */
        vfunc_get_style_pseudo_class(): string;
        /**
         * Sets `style` as the new #MxStyle to be used by `stylable`.
         *
         * The #MxStylable will take ownership of the passed #MxStyle.
         *
         * After the #MxStyle has been set, the MxStylable::style-set signal
         * will be emitted.
         * @param style a #MxStyle
         */
        vfunc_set_style(style: Style): void;
        /**
         * Set the style class name
         * @param style_class a new style class string
         */
        vfunc_set_style_class(style_class: string): void;
        /**
         * Set the style pseudo class. The string can contain multiple pseudo class
         * names, separated by ':'.
         * @param pseudo_class a new pseudo class string
         */
        vfunc_set_style_pseudo_class(pseudo_class: string): void;
        /**
         * Emit the "style-changed" signal on `stylable` to notify it that one or more
         * of the style properties has changed.
         *
         * If `stylable` is a #ClutterContainer then the "style-changed" notification is
         * propagated to it's children, since their style may depend on one or more
         * properties of the parent.
         * @param flags flags that control the style changing
         */
        vfunc_style_changed(flags: StyleChangedFlags): void;
    }

    export const Stylable: StylableNamespace & {
        new (): Stylable; // This allows `obj instanceof Stylable`
    };

    /**
     * Name of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
     */
    const __name__: string;
    /**
     * Version of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
     */
    const __version__: string;
}

export default Mx;

// END
