/**
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in `ts-for-gir` or create a bug report on https://github.com/gjsify/ts-for-gir
 *
 * The based EJS template file is used for the generated .d.ts file of each GIR module like Gtk-4.0, GObject-2.0, ...
 */

// Module dependencies
import type libxml2 from '@girs/libxml2-2.0';
import type MPID from '@girs/mpid-3.0';
import type GObject from '@girs/gobject-2.0';
import type GLib from '@girs/glib-2.0';
import type Gtk from '@girs/gtk-3.0';
import type xlib from '@girs/xlib-2.0';
import type Gdk from '@girs/gdk-3.0';
import type cairo from '@girs/cairo-1.0';
import type Pango from '@girs/pango-1.0';
import type HarfBuzz from '@girs/harfbuzz-0.0';
import type freetype2 from '@girs/freetype2-2.0';
import type Gio from '@girs/gio-2.0';
import type GModule from '@girs/gmodule-2.0';
import type GdkPixbuf from '@girs/gdkpixbuf-2.0';
import type Atk from '@girs/atk-1.0';
import type GstPbutils from '@girs/gstpbutils-1.0';
import type GstVideo from '@girs/gstvideo-1.0';
import type GstBase from '@girs/gstbase-1.0';
import type Gst from '@girs/gst-1.0';
import type GstAudio from '@girs/gstaudio-1.0';

export namespace RB {
    /**
     * RB-3.0
     */

    export namespace DisplayPageGroupCategory {
        export const $gtype: GObject.GType<DisplayPageGroupCategory>;
    }

    enum DisplayPageGroupCategory {
        FIXED,
        REMOVABLE,
        PERSISTENT,
        TRANSIENT,
        TOOLS,
        LAST,
    }
    /**
     * Predefined categories of page group. The order they're defined here is the order they
     * appear in the page tree.
     */

    /**
     * Predefined categories of page group. The order they're defined here is the order they
     * appear in the page tree.
     */
    export namespace DisplayPageGroupType {
        export const $gtype: GObject.GType<DisplayPageGroupType>;
    }

    enum DisplayPageGroupType {
        /**
         * Fixed single instance sources (e.g., library)
         */
        FIXED,
        /**
         * Persistent multiple-instance sources (e.g. playlists)
         */
        PERSISTENT,
        /**
         * Sources representing removable devices
         */
        REMOVABLE,
        /**
         * Transient sources (e.g. network shares)
         */
        TRANSIENT,
        /**
         * Utility (ie non-source) pages
         */
        TOOLS,
    }
    /**
     * Columns present in the display page model.
     */

    /**
     * Columns present in the display page model.
     */
    export namespace DisplayPageModelColumn {
        export const $gtype: GObject.GType<DisplayPageModelColumn>;
    }

    enum DisplayPageModelColumn {
        /**
         * TRUE if the page is the playing source
         */
        PLAYING,
        /**
         * the #RBDisplayPage object
         */
        PAGE,
    }
    class EncoderError extends GLib.Error {
        static $gtype: GObject.GType<EncoderError>;

        // Static fields

        static FORMAT_UNSUPPORTED: number;
        static INTERNAL_ERROR: number;
        static FILE_ACCESS_ERROR: number;
        static OUT_OF_SPACE: number;
        static DESTINATION_READ_ONLY: number;
        static DESTINATION_EXISTS: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        static quark(): GLib.Quark;
    }

    /**
     * Predefined column types to use in #RBEntryView<!-- -->s.  Use
     * #rb_entry_view_append_column to add these to an entry view.
     * The predefined column names map directly to the #RhythmDBEntry properties
     * the columns display.
     */

    /**
     * Predefined column types to use in #RBEntryView<!-- -->s.  Use
     * #rb_entry_view_append_column to add these to an entry view.
     * The predefined column names map directly to the #RhythmDBEntry properties
     * the columns display.
     */
    export namespace EntryViewColumn {
        export const $gtype: GObject.GType<EntryViewColumn>;
    }

    enum EntryViewColumn {
        /**
         * the track number column
         */
        TRACK_NUMBER,
        /**
         * the title column
         */
        TITLE,
        /**
         * the artist column
         */
        ARTIST,
        /**
         * the album column
         */
        ALBUM,
        /**
         * the genre column
         */
        GENRE,
        /**
         * the comment column
         */
        COMMENT,
        /**
         * the duration column
         */
        DURATION,
        /**
         * the quality (bitrate) column
         */
        QUALITY,
        /**
         * the rating column
         */
        RATING,
        /**
         * the play count column
         */
        PLAY_COUNT,
        /**
         * the year (release date) column
         */
        YEAR,
        /**
         * the last played time column
         */
        LAST_PLAYED,
        /**
         * the first seen (imported) column
         */
        FIRST_SEEN,
        /**
         * the last seen column
         */
        LAST_SEEN,
        /**
         * the location column
         */
        LOCATION,
        /**
         * the BPM column
         */
        BPM,
        /**
         * the error column
         */
        ERROR,
        /**
         * the composer column
         */
        COMPOSER,
    }

    export namespace EntryViewState {
        export const $gtype: GObject.GType<EntryViewState>;
    }

    enum EntryViewState {
        NOT_PLAYING,
        PLAYING,
        PAUSED,
    }

    export namespace ExtDBSourceType {
        export const $gtype: GObject.GType<ExtDBSourceType>;
    }

    enum ExtDBSourceType {
        NONE,
        SEARCH,
        EMBEDDED,
        USER,
        USER_EXPLICIT,
    }

    export namespace GstMediaType {
        export const $gtype: GObject.GType<GstMediaType>;
    }

    enum GstMediaType {
        NONE,
        CONTAINER,
        AUDIO,
        VIDEO,
        OTHER,
    }

    export namespace MetaDataError {
        export const $gtype: GObject.GType<MetaDataError>;
    }

    enum MetaDataError {
        IO,
        MISSING_PLUGIN,
        UNRECOGNIZED,
        UNSUPPORTED,
        GENERAL,
        INTERNAL,
        EMPTY_FILE,
    }
    /**
     * Metadata fields that can be read from and written to files.
     */

    /**
     * Metadata fields that can be read from and written to files.
     */
    export namespace MetaDataField {
        export const $gtype: GObject.GType<MetaDataField>;
    }

    enum MetaDataField {
        /**
         * Title of the recording
         */
        TITLE,
        /**
         * Person(s) responsible for the recording
         */
        ARTIST,
        /**
         * Album containing the recording
         */
        ALBUM,
        /**
         * Release date of the album
         */
        DATE,
        /**
         * Genre of the recording
         */
        GENRE,
        /**
         * Free form comment on the recording
         */
        COMMENT,
        /**
         * Track number inside a collection
         */
        TRACK_NUMBER,
        /**
         * Count of tracks inside the collection
         */
        MAX_TRACK_NUMBER,
        /**
         * Disc number inside a collection
         */
        DISC_NUMBER,
        /**
         * Count of discs inside the collection
         */
        MAX_DISC_NUMBER,
        /**
         * Short text describing the recording
         */
        DESCRIPTION,
        /**
         * Version of the recording
         */
        VERSION,
        /**
         * International Standard Recording Code
         */
        ISRC,
        /**
         * Organization responsible for the recording
         */
        ORGANIZATION,
        /**
         * Copyright notice on the recording
         */
        COPYRIGHT,
        /**
         * Contact information
         */
        CONTACT,
        /**
         * License of the recording
         */
        LICENSE,
        /**
         * Person(s) performing in the recording
         */
        PERFORMER,
        /**
         * Duration of the recording
         */
        DURATION,
        /**
         * Codec used to store the recording
         */
        CODEC,
        /**
         * Exact or average encoding bitrate in bits/s
         */
        BITRATE,
        /**
         * Track gain in dB for replaygain
         */
        TRACK_GAIN,
        /**
         * Track peak volume level
         */
        TRACK_PEAK,
        /**
         * Album gain in dB for replaygain
         */
        ALBUM_GAIN,
        /**
         * Album peak volume level
         */
        ALBUM_PEAK,
        /**
         * Language code (ISO-639-1)
         */
        LANGUAGE_CODE,
        /**
         * Beats Per Minute
         */
        BPM,
        /**
         * MusicBrainz track ID
         */
        MUSICBRAINZ_TRACKID,
        /**
         * MusicBrainz artist ID
         */
        MUSICBRAINZ_ARTISTID,
        /**
         * MusicBrainz album ID
         */
        MUSICBRAINZ_ALBUMID,
        /**
         * MusicBrainz album artist ID
         */
        MUSICBRAINZ_ALBUMARTISTID,
        /**
         * Person(s) responsible for the recording, as used for sorting
         */
        ARTIST_SORTNAME,
        /**
         * Album containing the recording, as used for sorting
         */
        ALBUM_SORTNAME,
        /**
         * The artist of the entire album
         */
        ALBUM_ARTIST,
        /**
         * The artist of the entire album, as it should be sorted
         */
        ALBUM_ARTIST_SORTNAME,
        /**
         * The composer of the recording
         */
        COMPOSER,
        /**
         * The composer of the recording, as it should be sorted
         */
        COMPOSER_SORTNAME,
        /**
         * invalid field
         */
        LAST,
    }
    class MetadataErrorType extends GLib.Error {
        static $gtype: GObject.GType<MetadataErrorType>;

        // Static fields

        static IO_ERROR: number;
        static MISSING_PLUGINS: number;
        static IDENTIFY_FAILED: number;
        static UNSUPPORTED_FILETYPE: number;
        static GENERAL_ERROR: number;
        static INTERNAL_ERROR: number;
        static EMPTY_FILE: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        static quark(): GLib.Quark;
    }

    export namespace MetadataFieldType {
        export const $gtype: GObject.GType<MetadataFieldType>;
    }

    enum MetadataFieldType {
        TITLE,
        ARTIST,
        ALBUM,
        DATE,
        GENRE,
        COMMENT,
        TRACK_NUMBER,
        TRACK_COUNT,
        ALBUM_DISC_NUMBER,
        ALBUM_DISC_COUNT,
        DESCRIPTION,
        VERSION,
        ISRC,
        ORGANIZATION,
        COPYRIGHT,
        CONTACT,
        LICENSE,
        PERFORMER,
        DURATION,
        CODEC,
        BITRATE,
        REPLAYGAIN_TRACK_GAIN,
        REPLAYGAIN_TRACK_PEAK,
        REPLAYGAIN_ALBUM_GAIN,
        REPLAYGAIN_ALBUM_PEAK,
        BEATS_PER_MINUTE,
        LANGUAGE_CODE,
        MUSICBRAINZ_TRACKID,
        MUSICBRAINZ_ARTISTID,
        MUSICBRAINZ_ALBUMID,
        MUSICBRAINZ_ALBUMARTISTID,
        MUSICBRAINZ_SORTNAME,
        ALBUM_SORTNAME,
        ALBUM_ARTIST,
        ALBUM_ARTIST_SORTNAME,
        COMPOSER,
        COMPOSER_SORTNAME,
    }
    class PlayerError extends GLib.Error {
        static $gtype: GObject.GType<PlayerError>;

        // Static fields

        /**
         * Audio playback not available
         */
        static NO_AUDIO: number;
        /**
         * Nonspecific error
         */
        static GENERAL_ERROR: number;
        /**
         * Internal error
         */
        static INTERNAL_ERROR: number;
        /**
         * The resource could not be found
         */
        static NOT_FOUND: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        static quark(): GLib.Quark;
    }

    export namespace PlayerPlayType {
        export const $gtype: GObject.GType<PlayerPlayType>;
    }

    enum PlayerPlayType {
        /**
         * Replace the existing stream
         */
        REPLACE,
        /**
         * Start the new stream after the current stream ends
         */
        START_AFTER_EOS,
        /**
         * Crossfade between the existing stream and the new stream
         */
        CROSSFADE,
    }

    export namespace PlaylistExportType {
        export const $gtype: GObject.GType<PlaylistExportType>;
    }

    enum PlaylistExportType {
        UNKNOWN,
        M3U,
        PLS,
        XSPF,
    }

    export namespace PlaylistManagerError {
        export const $gtype: GObject.GType<PlaylistManagerError>;
    }

    enum PlaylistManagerError {
        PARSE,
        PLAYLIST_EXISTS,
        PLAYLIST_NOT_FOUND,
    }

    export namespace PodcastFeedUpdateStatus {
        export const $gtype: GObject.GType<PodcastFeedUpdateStatus>;
    }

    enum PodcastFeedUpdateStatus {
        STARTED,
        ERROR,
        ERROR_BACKGROUND,
        CONFLICT,
        CANCELLED,
        SUBSCRIBED,
        UNCHANGED,
        UPDATED,
    }
    class PodcastParseError extends GLib.Error {
        static $gtype: GObject.GType<PodcastParseError>;

        // Static fields

        static FILE_INFO: number;
        static MIME_TYPE: number;
        static XML_PARSE: number;
        static NO_ITEMS: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;
    }

    export namespace PodcastParseStatus {
        export const $gtype: GObject.GType<PodcastParseStatus>;
    }

    enum PodcastParseStatus {
        UNPARSED,
        SUCCESS,
        ERROR,
    }
    /**
     * Various events that can result in changes to the entry's availability.
     */

    /**
     * Various events that can result in changes to the entry's availability.
     */
    export namespace RhythmDBEntryAvailability {
        export const $gtype: GObject.GType<RhythmDBEntryAvailability>;
    }

    enum RhythmDBEntryAvailability {
        /**
         * File was checked and found present
         */
        CHECKED,
        /**
         * Filesystem holding the file was mounted
         */
        MOUNTED,
        /**
         * Filesystem holding the file was unmounted
         */
        UNMOUNTED,
        /**
         * File was checked or played and could not be found
         */
        NOT_FOUND,
    }
    /**
     * Categories used to group entry types.  These are used in a few places to control
     * handling of entries.
     */

    /**
     * Categories used to group entry types.  These are used in a few places to control
     * handling of entries.
     */
    export namespace RhythmDBEntryCategory {
        export const $gtype: GObject.GType<RhythmDBEntryCategory>;
    }

    enum RhythmDBEntryCategory {
        /**
         * Normal files on disk
         */
        NORMAL,
        /**
         * Endless streams (eg shoutcast)
         */
        STREAM,
        /**
         * Containers for other entries (eg podcast feeds)
         */
        CONTAINER,
        /**
         * Things Rhythmbox shouldn't normally deal with
         */
        VIRTUAL,
    }

    export namespace RhythmDBError {
        export const $gtype: GObject.GType<RhythmDBError>;
    }

    enum RhythmDBError {
        RHYTHMDB_ERROR_ACCESS_FAILED,
    }

    export namespace RhythmDBPropType {
        export const $gtype: GObject.GType<RhythmDBPropType>;
    }

    enum RhythmDBPropType {
        TYPE,
        ENTRY_ID,
        TITLE,
        GENRE,
        ARTIST,
        ALBUM,
        TRACK_NUMBER,
        TRACK_TOTAL,
        DISC_NUMBER,
        DISC_TOTAL,
        DURATION,
        FILE_SIZE,
        LOCATION,
        MOUNTPOINT,
        MTIME,
        FIRST_SEEN,
        LAST_SEEN,
        RATING,
        PLAY_COUNT,
        LAST_PLAYED,
        BITRATE,
        DATE,
        REPLAYGAIN_TRACK_GAIN,
        REPLAYGAIN_TRACK_PEAK,
        REPLAYGAIN_ALBUM_GAIN,
        REPLAYGAIN_ALBUM_PEAK,
        MEDIA_TYPE,
        TITLE_SORT_KEY,
        GENRE_SORT_KEY,
        ARTIST_SORT_KEY,
        ALBUM_SORT_KEY,
        TITLE_FOLDED,
        GENRE_FOLDED,
        ARTIST_FOLDED,
        ALBUM_FOLDED,
        LAST_PLAYED_STR,
        HIDDEN,
        PLAYBACK_ERROR,
        FIRST_SEEN_STR,
        LAST_SEEN_STR,
        SEARCH_MATCH,
        YEAR,
        KEYWORD,
        STATUS,
        DESCRIPTION,
        SUBTITLE,
        SUMMARY,
        LANG,
        COPYRIGHT,
        IMAGE,
        POST_TIME,
        PODCAST_GUID,
        MB_TRACKID,
        MB_ARTISTID,
        MB_ALBUMID,
        MB_ALBUMARTISTID,
        MB_ARTISTSORTNAME,
        ALBUM_SORTNAME,
        ARTIST_SORTNAME_SORT_KEY,
        ARTIST_SORTNAME_FOLDED,
        ALBUM_SORTNAME_SORT_KEY,
        ALBUM_SORTNAME_FOLDED,
        COMMENT,
        ALBUM_ARTIST,
        ALBUM_ARTIST_SORT_KEY,
        ALBUM_ARTIST_FOLDED,
        ALBUM_ARTIST_SORTNAME,
        ALBUM_ARTIST_SORTNAME_SORT_KEY,
        ALBUM_ARTIST_SORTNAME_FOLDED,
        BEATS_PER_MINUTE,
        COMPOSER,
        COMPOSER_SORT_KEY,
        COMPOSER_FOLDED,
        COMPOSER_SORTNAME,
        COMPOSER_SORTNAME_SORT_KEY,
        COMPOSER_SORTNAME_FOLDED,
    }

    export namespace RhythmDBPropertyModelColumn {
        export const $gtype: GObject.GType<RhythmDBPropertyModelColumn>;
    }

    enum RhythmDBPropertyModelColumn {
        PROPERTY_TITLE,
        VALUE_PRIORITY,
        TRACK_COUNT,
    }

    export namespace RhythmDBQueryModelLimitType {
        export const $gtype: GObject.GType<RhythmDBQueryModelLimitType>;
    }

    enum RhythmDBQueryModelLimitType {
        NO_LIMIT,
        LIMIT_COUNT,
        LIMIT_SIZE,
        LIMIT_DURATION,
    }

    export namespace RhythmDBQueryType {
        export const $gtype: GObject.GType<RhythmDBQueryType>;
    }

    enum RhythmDBQueryType {
        QUERY_END,
        DISJUNCTIVE_MARKER,
        SUBQUERY,
        EQUALS,
        NOT_EQUAL,
        FUZZY_MATCH,
        INVERTED_FUZZY_MATCH,
        STARTS_WITH,
        ENDS_WITH,
        GREATER_THAN,
        LESS_THAN,
        WITHIN_CURRENT_TIME,
        NOT_WITHIN_CURRENT_TIME,
        YEAR_EQUALS,
        YEAR_NOT_EQUALS,
        YEAR_GREATER_THAN,
        YEAR_LESS_THAN,
    }

    export namespace ShellActivationType {
        export const $gtype: GObject.GType<ShellActivationType>;
    }

    enum ShellActivationType {
        SELECT,
        PLAY,
        ALWAYS_PLAY,
    }

    export namespace ShellError {
        export const $gtype: GObject.GType<ShellError>;
    }

    enum ShellError {
        NO_SUCH_URI,
        NO_SUCH_PROPERTY,
        IMMUTABLE_PROPERTY,
        INVALID_PROPERTY_TYPE,
        NO_SOURCE_FOR_URI,
    }
    class ShellErrorType extends GLib.Error {
        static $gtype: GObject.GType<ShellErrorType>;

        // Static fields

        static NO_SUCH_URI: number;
        static NO_SUCH_PROPERTY: number;
        static IMMUTABLE_PROPERTY: number;
        static INVALID_PROPERTY_TYPE: number;
        static NO_SOURCE_FOR_URI: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        /**
         * Returns the #GQuark used for #RBShell errors
         */
        static quark(): GLib.Quark;
    }

    class ShellPlayerError extends GLib.Error {
        static $gtype: GObject.GType<ShellPlayerError>;

        // Static fields

        static PLAYLIST_PARSE_FAILED: number;
        static END_OF_PLAYLIST: number;
        static NOT_PLAYING: number;
        static NOT_SEEKABLE: number;
        static POSITION_NOT_AVAILABLE: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        static quark(): GLib.Quark;
    }

    /**
     * Locations available for adding new widgets to the preferences dialog.
     */

    /**
     * Locations available for adding new widgets to the preferences dialog.
     */
    export namespace ShellPrefsUILocation {
        export const $gtype: GObject.GType<ShellPrefsUILocation>;
    }

    enum ShellPrefsUILocation {
        /**
         * The "general" preferences page
         */
        GENERAL,
        /**
         * THe "playback" preferences page
         */
        PLAYBACK,
    }

    export namespace ShellUILocation {
        export const $gtype: GObject.GType<ShellUILocation>;
    }

    enum ShellUILocation {
        SIDEBAR,
        RIGHT_SIDEBAR,
        MAIN_TOP,
        MAIN_BOTTOM,
    }

    export namespace SourceEOFType {
        export const $gtype: GObject.GType<SourceEOFType>;
    }

    enum SourceEOFType {
        ERROR,
        STOP,
        RETRY,
        NEXT,
    }

    export namespace SourceLoadStatus {
        export const $gtype: GObject.GType<SourceLoadStatus>;
    }

    enum SourceLoadStatus {
        NOT_LOADED,
        WAITING,
        LOADING,
        LOADED,
    }

    export namespace TaskOutcome {
        export const $gtype: GObject.GType<TaskOutcome>;
    }

    enum TaskOutcome {
        NONE,
        COMPLETE,
        CANCELLED,
    }
    const ENABLE_PROFILING: number;
    const ENCODER_DEST_TEMPFILE: string;
    const ENCODING_STYLE_CBR: string;
    const ENCODING_STYLE_VBR: string;
    const FFWD_OFFSET: number;
    const GST_MEDIA_TYPE_AAC: string;
    const GST_MEDIA_TYPE_FLAC: string;
    const GST_MEDIA_TYPE_MP3: string;
    const GST_MEDIA_TYPE_OGG_VORBIS: string;
    const PLAYER_SECOND: number;
    const PLAYLIST_AUTOMATIC: string;
    const PLAYLIST_BROWSER_POSITION: string;
    const PLAYLIST_LIMIT: string;
    const PLAYLIST_LIMIT_COUNT: string;
    const PLAYLIST_LIMIT_SIZE: string;
    const PLAYLIST_LIMIT_TIME: string;
    const PLAYLIST_LOCATION: string;
    const PLAYLIST_NAME: string;
    const PLAYLIST_PLAYLIST: string;
    const PLAYLIST_QUEUE: string;
    const PLAYLIST_SEARCH_TYPE: string;
    const PLAYLIST_SHOW_BROWSER: string;
    const PLAYLIST_SORT_DIRECTION: string;
    const PLAYLIST_SORT_KEY: string;
    const PLAYLIST_STATIC: string;
    const PLAYLIST_TYPE: string;
    const PLAYLIST_XML_VERSION: string;
    const PROFILE_INDENTATION: number;
    const RHYTHMDB_PROP_COVER_ART: string;
    const RHYTHMDB_PROP_COVER_ART_URI: string;
    const RHYTHMDB_PROP_STREAM_SONG_ALBUM: string;
    const RHYTHMDB_PROP_STREAM_SONG_ARTIST: string;
    const RHYTHMDB_PROP_STREAM_SONG_TITLE: string;
    const RHYTHMDB_QUERY_MODEL_SUGGESTED_UPDATE_CHUNK: number;
    const RWD_OFFSET: number;
    /**
     * Makes a label built from a GtkBuilder file bold.
     * @param builder a #GtkBuilder instance
     * @param name name of the label to boldify
     */
    function builder_boldify_label(builder: Gtk.Builder, name: string): void;
    /**
     * Locates and reads a GtkBuilder file, automatically connecting
     * signal handlers where possible.
     *
     * The caller can specify an absolute path to the file, a resource path
     * starting with /org/gnome/Rhythmbox/ or just a filename.
     * The file will be loaded from GResources.
     * @param file filename, either absolute or relative to the data directory
     * @param user_data user data to pass to autoconnected signal handlers
     * @returns #GtkBuilder object built from the file
     */
    function builder_load(file: string, user_data?: any | null): Gtk.Builder;
    /**
     * Like #rb_builder_load, except it finds files associated with
     * plugins as well as those in the core data directories.
     * @param plugin #RBPlugin instance
     * @param file name of file to load
     * @param user_data user data to pass to autoconnected signal handlers
     * @returns #GtkBuilder object built from the file
     */
    function builder_load_plugin_file(plugin: GObject.Object, file: string, user_data?: any | null): Gtk.Builder;
    /**
     * Converts `uri` to canonical URI form, ensuring it doesn't contain
     * any redundant directory fragments or unnecessarily escaped characters.
     * All URIs passed to #RhythmDB functions should be canonicalised.
     * @param uri URI to canonicalise
     * @returns canonical URI, must be freed by caller
     */
    function canonicalise_uri(uri: string): string;
    /**
     * Checks that the filesystem holding `file` has at least `bytes_needed`
     * bytes available.
     * @param dir a #GFile to check
     * @param bytes_needed number of bytes to check for
     * @returns %TRUE if enough space is available.
     */
    function check_dir_has_space(dir: Gio.File, bytes_needed: number): boolean;
    /**
     * Checks that the filesystem holding `uri` has at least `bytes_needed`
     * bytes available.
     * @param uri a URI to check
     * @param bytes_needed number of bytes to check for
     * @returns %TRUE if enough space is available.
     */
    function check_dir_has_space_uri(uri: string, bytes_needed: number): boolean;
    /**
     * A row separator function to use for GtkComboBox widgets.
     * It expects the model to contain a string in its first column,
     * and interprets a string containing a single hyphen character
     * as a separator.
     * @param model a #GtkTreeModel
     * @param iter a #GtkTreeIter
     * @param data nothing
     * @returns %TRUE if the row pointed to by @iter is a separator
     */
    function combo_box_hyphen_separator_func(model: Gtk.TreeModel, iter: Gtk.TreeIter, data?: any | null): boolean;
    /**
     * Compares two #GTimeVal structures for sorting.
     * @param a left hand side
     * @param b right hand size
     * @returns -1 if @a < @b, 0 if @a == @b, 1 if @a > @b
     */
    function compare_gtimeval(a: GLib.TimeVal, b: GLib.TimeVal): number;
    /**
     * Constructs arguments to pass to another process using
     * this debug output code that will produce the same debug output
     * settings.
     * @returns debug output arguments, must be freed with #g_strfreev()
     */
    function debug_get_args(): string[];
    /**
     * Sets up debug output, with either all debug enabled
     * or none.
     * @param debug if TRUE, enable all debug output
     */
    function debug_init(debug: boolean): void;
    /**
     * Sets up debug output, enabling debug output from file and function
     * names that contain the specified match string.
     *
     * Also sets up a GLib log handler that will trigger a debugger
     * break for critical or warning level output if any debug output
     * at all is enabled.
     * @param match string to match functions and filenames against
     */
    function debug_init_match(match: string): void;
    /**
     * Checks if `file` or `func` matches the current debug output settings.
     * @param func function to check
     * @param file filename to check
     * @returns %TRUE if matched
     */
    function debug_matches(func: string, file: string): boolean;
    /**
     * If the debug output settings match the function or file names,
     * the debug message will be formatted and written to standard error.
     * @param func function name
     * @param file file name
     * @param line line number
     * @param newline if TRUE, add a newline to the output
     * @param message the debug message
     */
    function debug_real(func: string, file: string, line: number, newline: boolean, message: string): void;
    /**
     * Raises a SIGINT signal to get the attention of the debugger.
     * When not running under the debugger, we don't want to stop,
     * so we ignore the signal for just the moment that we raise it.
     */
    function debug_stop_in_debugger(): void;
    /**
     * Returns %TRUE if `uri` matches `source`.  This should be
     * used to implement the uri_is_source #RBSource method.
     * @param source a #RBDeviceSource
     * @param uri a URI to check
     * @returns %TRUE if @uri matches @source
     */
    function device_source_uri_is_source(source: Source, uri: string): boolean;
    /**
     * Checks whether `uri` identifies a path underneath the
     * device's mount point.  Should be used to implement
     * the #RBSource want_uri method.
     * @param source a #RBDeviceSource
     * @param uri a URI to consider
     * @returns URI match strength
     */
    function device_source_want_uri(source: Source, uri: string): number;
    function encoder_error_quark(): GLib.Quark;
    /**
     * Creates a new #RBEncoder instance.
     * @returns the new #RBEncoder
     */
    function encoder_new(): Encoder;
    /**
     * Creates a new metadata lookup key with a single field.
     * Use `rb_ext_db_key_add_field` to add more.
     * @param field required field name
     * @param value value for field
     * @returns the new key
     */
    function ext_db_key_create_lookup(field: string, value: string): ExtDBKey;
    /**
     * Creates a new metadata storage key with a single field.
     * Use `rb_ext_db_key_add_field` to add more.
     * @param field required field name
     * @param value value for field
     * @returns the new key
     */
    function ext_db_key_create_storage(field: string, value: string): ExtDBKey;
    /**
     * Searches for an installed file, returning the full path name
     * if found, NULL otherwise.
     * @param filename name of file to search for
     * @returns Full file name, if found.  Must not be freed.
     */
    function file(filename: string): string;
    /**
     * Creates and shows a regular gtk+ file chooser dialog with
     * a given title.  The user's music directory (typically ~/Music) is
     * added as a shortcut.
     *
     * For consistency, this should be used anywhere a file chooser is required.
     *
     * After creating the dialog, the caller should connect a handler to its
     * 'response' signal to process the user's selected files or folders.
     * @param title title for the file chooser
     * @param parent parent #GtkWindow for the file chooser
     * @param action the #GtkFileChooserAction
     * @param local_only if TRUE, don't show network locations
     * @returns the file chooser #GtkWidget
     */
    function file_chooser_new(
        title: string,
        parent: Gtk.Window,
        action: Gtk.FileChooserAction | null,
        local_only: boolean,
    ): Gtk.Widget;
    /**
     * Walks up the filesystem hierarchy to find a #GFile representing
     * the nearest extant ancestor of the specified file, which may be
     * the file itself if it exists.
     * @param file a #GFile to find an extant ancestor of
     * @returns #GFile for the nearest extant ancestor
     */
    function file_find_extant_parent(file: Gio.File): Gio.File;
    /**
     * Sets up file search paths for `rb_file`.  Must be called on startup.
     */
    function file_helpers_init(): void;
    /**
     * Frees various data allocated by file helper functions.
     * Should be called on shutdown.
     */
    function file_helpers_shutdown(): void;
    /**
     * Attempts to resolve symlinks leading to `file` and return a canonical location.
     * @param file the file to process
     * @returns a #GFile representing the canonical location, or NULL on error
     */
    function file_resolve_symlink(file: Gio.File): Gio.File;
    /**
     * Locates a file under the plugin's data directory.
     * @param plugin the plugin object
     * @param name name of the file to find
     * @returns allocated string containing the location of the file
     */
    function find_plugin_data_file(plugin: GObject.Object, name: string): string;
    /**
     * Constructs a resource path for a plugin data file.
     * @param plugin the plugin object
     * @param name name of the file to find
     * @returns allocated string containing the resource path
     */
    function find_plugin_resource(plugin: GObject.Object, name: string): string;
    /**
     * Determines the full path to use for user-specific cached files
     * within the user cache directory.
     * @param name name of file to find
     * @returns allocated string containing the location of the file to use, even if  an error occurred.
     */
    function find_user_cache_file(name: string): string;
    /**
     * Determines the full path to use for user-specific files, such as rhythmdb.xml,
     * within the user data directory (see `rb_user_data_dir)`.
     * @param name name of file to find
     * @returns allocated string containing the location of the file to use, even if  an error occurred.
     */
    function find_user_data_file(name: string): string;
    /**
     * Inserts a filter into the filter bin, using pad blocking (if requested) to
     * avoid breaking the data flow.  Pad blocking should be used when the pipeline
     * is in PLAYING state, or when in PAUSED state where a streaming thread will
     * be holding the stream lock for the filter bin.
     * @param player player object (must implement @RBPlayerGstFilter interface)
     * @param filterbin the filter bin
     * @param element the filter to add
     * @param use_pad_block if %TRUE, block the src pad connected to the filter bin
     */
    function gst_add_filter(
        player: Player,
        filterbin: Gst.Element,
        element: Gst.Element,
        use_pad_block: boolean,
    ): boolean;
    /**
     * Attaches a branch to the tee, using pad blocking (if requested) to
     * avoid breaking the data flow.  Pad blocking should be used when the pipeline
     * is in PLAYING state, or when in PAUSED state where a streaming thread will
     * be holding the stream lock for the filter bin.
     * @param player player object (must implement @RBPlayerGstTee interface)
     * @param tee a tee element
     * @param element the tee branch to add
     * @param use_pad_block if %TRUE, block the src pad connected to the filter bin
     */
    function gst_add_tee(player: Player, tee: Gst.Element, element: Gst.Element, use_pad_block: boolean): boolean;
    function gst_caps_to_media_type(caps: Gst.Caps): string;
    /**
     * Creates an initial bin to use for dynamically plugging filter elements into the
     * pipeline.
     * @returns filter bin
     */
    function gst_create_filter_bin(): Gst.Element;
    function gst_encoder_set_encoding_style(element: Gst.Element, style: string): boolean;
    function gst_encoding_profile_get_encoder(profile: GstPbutils.EncodingProfile): Gst.Element;
    function gst_encoding_profile_get_encoder_caps(profile: GstPbutils.EncodingProfile): Gst.Caps;
    function gst_encoding_profile_get_media_type(profile: GstPbutils.EncodingProfile): string;
    function gst_encoding_profile_get_presets(profile: GstPbutils.EncodingProfile): number[];
    /**
     * Returns a list of settings for the profile `profile` that can usefully
     * be exposed to a user.  This usually means just bitrate/quality settings.
     * This works by finding the name of the encoder element for the profile
     * and retrieving a list specific to that encoder.
     * @param profile a #GstEncodingProfile
     * @param style encoding style (NULL or "cbr" or "vbr")
     * @returns list of settings
     */
    function gst_encoding_profile_get_settings(profile: GstPbutils.EncodingProfile, style: string): string[];
    /**
     * Applies the preset `preset` to the audio encoding profile within `profile`.
     * @param profile a #GstEncodingProfile
     * @param preset preset to apply
     */
    function gst_encoding_profile_set_preset(profile: GstPbutils.EncodingProfile, preset: string): void;
    /**
     * Maps a GStreamer error to an #RBPlayerError error code.
     * @param error error received from GStreamer
     * @returns the #RBPlayerError value to use
     */
    function gst_error_get_error_code(error: GLib.Error): number;
    function gst_get_default_encoding_target(): GstPbutils.EncodingTarget;
    function gst_get_encoding_profile(media_type: string): GstPbutils.EncodingProfile;
    function gst_get_missing_plugin_type(structure: Gst.Structure): GstMediaType;
    function gst_media_type_is_lossless(media_type: string): boolean;
    function gst_media_type_matches_profile(profile: GstPbutils.EncodingProfile, media_type: string): boolean;
    function gst_media_type_to_caps(media_type: string): Gst.Caps;
    function gst_media_type_to_extension(media_type: string): string;
    function gst_media_type_to_mime_type(media_type: string): string;
    function gst_mime_type_to_media_type(mime_type: string): string;
    /**
     * Converts embedded image data extracted from a tag list into
     * a #GdkPixbuf.  The returned #GdkPixbuf is owned by the caller.
     * @param taglist a #GstTagList containing an image
     * @param tag the tag name
     * @returns a #GdkPixbuf, or NULL.
     */
    function gst_process_embedded_image(taglist: Gst.TagList, tag: string): GdkPixbuf.Pixbuf;
    /**
     * Processes a tag string, determining the metadata field identifier
     * corresponding to the tag name, and converting the tag data into the
     * appropriate value type.
     * @param taglist a #GstTagList containing a string tag
     * @param tag tag name
     * @param field returns the #RBMetaDataField corresponding to the tag
     * @param value returns the tag value
     * @returns %TRUE if the tag was successfully converted.
     */
    function gst_process_tag_string(
        taglist: Gst.TagList,
        tag: string,
        field: MetaDataField | null,
        value: GObject.Value | any,
    ): boolean;
    /**
     * Removes a filter from the filter bin, using pad blocking (if requested) to
     * avoid breaking the data flow.  Pad blocking should be used when the pipeline
     * is in PLAYING state, or when in PAUSED state where a streaming thread will
     * be holding the stream lock for the filter bin.
     * @param player player object (must implement @RBPlayerGstFilter interface)
     * @param filterbin the filter bin
     * @param element the filter to remove
     * @param use_pad_block if %TRUE, block the src pad connected to the filter bin
     */
    function gst_remove_filter(
        player: Player,
        filterbin: Gst.Element,
        element: Gst.Element,
        use_pad_block: boolean,
    ): boolean;
    /**
     * Removes a branch from the tee, using pad blocking (if requested) to
     * avoid breaking the data flow.  Pad blocking should be used when the pipeline
     * is in PLAYING state, or when in PAUSED state where a streaming thread will
     * be holding the stream lock for the filter bin.
     * @param player player object (must implement @RBPlayerGstTee interface)
     * @param tee a tee element
     * @param element the tee branch to remove
     * @param use_pad_block if %TRUE, block the src pad connected to the filter bin
     */
    function gst_remove_tee(player: Player, tee: Gst.Element, element: Gst.Element, use_pad_block: boolean): boolean;
    /**
     * Checks if currently executing on the main thread.
     * @returns %TRUE if on the main thread
     */
    function is_main_thread(): boolean;
    /**
     * Returns the locale directory identified at build configuration time.
     * @returns locale dir
     */
    function locale_dir(): string;
    /**
     * Constructs a string describing the specified duration.  The string
     * describes hours, minutes, and seconds, and its format is localised.
     * @param duration duration in seconds
     * @returns duration string
     */
    function make_duration_string(duration: number): string;
    /**
     * Constructs a string describing a playback position.  The string describes hours,
     * minutes, and seconds, and its format is localised.  The string can describe either
     * the elapsed time or the time remaining.
     * @param elapsed elapsed time (in seconds)
     * @param duration duration (in seconds)
     * @param show_remaining if %TRUE, show the remaining time, otherwise show elapsed time
     * @returns elapsed/remaining time string
     */
    function make_elapsed_time_string(elapsed: number, duration: number, show_remaining: boolean): string;
    /**
     * Constructs a string describing the specified time.
     * @param seconds time in seconds
     * @returns time string
     */
    function make_time_string(seconds: number): string;
    /**
     * Updates a submenu link to point to the specified target menu.
     * @param menu menu to update
     * @param link_attr attribute indicating the menu link to update
     * @param target new menu link target
     */
    function menu_update_link(menu: Gio.Menu, link_attr: string, target: Gio.MenuModel): void;
    function metadata_error_quark(): GLib.Quark;
    /**
     * Returns the default directory for the user's music library.
     * This will usually be the 'Music' directory under the home directory.
     * @returns user's music directory.  must not be freed.
     */
    function music_dir(): string;
    function player_error_quark(): GLib.Quark;
    /**
     * Finds an element inside `element` that has a property with the specified name.
     * @param element element to search
     * @param property name of property to search for
     * @returns element instance, or NULL if not found
     */
    function player_gst_find_element_with_property(element: Gst.Element, property: string): Gst.Element;
    /**
     * Creates and tests an instance of the specified audio sink.
     * @param plugin_name audio sink plugin name
     * @param name name to give to the element
     * @returns element instance, or NULL
     */
    function player_gst_try_audio_sink(plugin_name: string, name: string): Gst.Element;
    /**
     * Creates a new player object.
     * @param want_crossfade if TRUE, try to use a backend that supports 		    crossfading and other track transitions.
     * @returns new player object.
     */
    function player_new(want_crossfade: boolean): Player;
    function podcast_parse_channel_copy(data: PodcastChannel): PodcastChannel;
    function podcast_parse_channel_new(): PodcastChannel;
    function podcast_parse_channel_ref(data: PodcastChannel): PodcastChannel;
    function podcast_parse_channel_unref(data: PodcastChannel): void;
    function podcast_parse_error_quark(): GLib.Quark;
    function podcast_parse_item_copy(data: PodcastItem): PodcastItem;
    function podcast_parse_item_free(data: PodcastItem): void;
    /**
     * Key equality function suitable for use with #GHashTable.
     * Equality checks for #RBRefString are just pointer comparisons,
     * since there can only be one refstring for a given string.
     * @param ap an #RBRefString
     * @param bp another #RBRefstring
     * @returns %TRUE if the strings are the same
     */
    function refstring_equal(ap?: any | null, bp?: any | null): boolean;
    /**
     * Returns an existing #RBRefString for `init` if one exists,
     * otherwise returns NULL.  If an existing refstring is found,
     * its reference count is increased.
     * @param init string to find
     * @returns existing #RBRefString, or NULL
     */
    function refstring_find(init: string): RefString;
    /**
     * Hash function suitable for use with `GHashTable`.
     * @param p an #RBRefString
     * @returns hash value for the string underlying @p
     */
    function refstring_hash(p?: any | null): number;
    /**
     * Sets up the refstring system.  Called on startup.
     */
    function refstring_system_init(): void;
    /**
     * Frees all data associated with the refstring system.
     * Only called on shutdown.
     */
    function refstring_system_shutdown(): void;
    function rhythmbox_get_resource(): Gio.Resource;
    function rhythmdb_query_get_type(): GObject.GType;
    function safe_strcmp(a: string, b: string): number;
    /**
     * Modifies `path` such that it represents a legal path for MS DOS
     * filesystems.  Note that it replaces forward slash characters,
     * so it's only appropriate for use with individual path segments
     * rather than entire paths.
     * @param path a path segment to sanitize (modified in place)
     */
    function sanitize_path_for_msdos_filesystem(path: string): void;
    /**
     * Removes characters from `uri` that are not allowed by the filesystem
     * on which it would be stored, or a specific type of filesystem if specified.
     * At present, this only supports MS DOS filesystems.
     * @param uri a URI to sanitize
     * @param filesystem a specific filesystem to sanitize for
     * @returns sanitized copy of @uri, must be freed by caller.
     */
    function sanitize_uri_for_filesystem(uri: string, filesystem?: string | null): string;
    /**
     * Creates a new #GdkPixbuf from the original one, for a target of
     * size, respecting the aspect ratio of the image.
     * @param pixbuf the #GdkPixbuf containing the original image
     * @param size a stock icon size
     * @returns scaled #GdkPixbuf
     */
    function scale_pixbuf_to_size(pixbuf: GdkPixbuf.Pixbuf, size: Gtk.IconSize | null): GdkPixbuf.Pixbuf;
    /**
     * Returns a case-folded and punctuation-stripped version of `original,` useful
     * for performing text searches.
     * @param original the string to fold
     * @returns case-folded string
     */
    function search_fold(original: string): string;
    /**
     * Sets a fixed size for a tree view column based on
     * a set of strings to be displayed in the column.
     * @param treeview the #GtkTreeView containing the column
     * @param column the #GtkTreeViewColumn to size
     * @param renderer the #GtkCellRenderer used in the column
     * @param strings a NULL-terminated set of strings to base the size on
     * @param padding a small amount of extra padding for the column
     */
    function set_tree_view_column_fixed_width(
        treeview: Gtk.Widget,
        column: Gtk.TreeViewColumn,
        renderer: Gtk.CellRenderer,
        strings: string[],
        padding: number,
    ): void;
    /**
     * Synchronizes settings in the `settings` instance after 500ms has elapsed
     * with no further changes.
     * @param settings #GSettings instance
     * @param sync_func function to call
     * @param destroy function to use to free @data
     */
    function settings_delayed_sync(
        settings: Gio.Settings,
        sync_func?: DelayedSyncFunc | null,
        destroy?: GLib.DestroyNotify | null,
    ): void;
    /**
     * Returns the #GQuark used for #RBShell errors
     * @returns shell error #GQuark
     */
    function shell_error_quark(): GLib.Quark;
    function shell_player_error_quark(): GLib.Quark;
    /**
     * Initializes the stock icons, adding the necessary filesystem
     * locations to the GTK icon search path.  Must be called on startup.
     */
    function stock_icons_init(): void;
    /**
     * If anything was necessary to clean up the stock icons, this function
     * would do it.  Doesn't do anything, but should be called on shutdown
     * anyway.
     */
    function stock_icons_shutdown(): void;
    /**
     * Splits `string` on word boundaries using Unicode character definitions.
     * @param string the string to split
     * @returns NULL-terminated array of strings
     */
    function string_split_words(string: string): string[];
    /**
     * Creates a new URI consisting of `path` appended to `uri`.
     * @param uri the URI to append to
     * @param path the path fragment to append
     * @returns new URI, must be freed by caller
     */
    function uri_append_path(uri: string, path: string): string;
    /**
     * Creates a new URI consisting of `fragment` appended to `uri`.
     * Generally isn't a good idea.
     * @param uri the URI to append to
     * @param fragment the URI fragment to append
     * @returns new URI, must be freed by caller
     */
    function uri_append_uri(uri: string, fragment: string): string;
    /**
     * Checks if `uri` identifies a resource that is probably a podcast
     * (RSS or Atom feed).  This does not perform any IO, it just guesses
     * based on the URI itself.
     * @param uri a URI to check
     * @param is_opml returns whether the URI identifies an OPML document
     * @returns %TRUE if @uri may be a podcast
     */
    function uri_could_be_podcast(uri: string, is_opml: boolean): boolean;
    /**
     * Ensures that all parent directories of `uri` exist so that
     * `uri` itself can be created directly.
     * @param uri a URI for which to create parent directories
     * @returns %TRUE if successful
     */
    function uri_create_parent_dirs(uri: string): boolean;
    /**
     * Checks if a URI identifies a resource that exists
     * @param uri a URI to check
     * @returns %TRUE if @uri exists
     */
    function uri_exists(uri: string): boolean;
    /**
     * Returns the directory component of `uri,` that is, everything up
     * to the start of the filename.
     * @param uri a URI
     * @returns new URI for parent of @uri, must be freed by caller.
     */
    function uri_get_dir_name(uri: string): string;
    /**
     * Returns a string describing the type of the filesystem containing `uri`.
     * @param uri URI to get filesystem type for
     * @param mount_point optionally returns the mount point for the filesystem as a URI
     * @returns filesystem type string, must be freed by caller.
     */
    function uri_get_filesystem_type(uri: string, mount_point: string): string;
    /**
     * Returns the mount point of the filesystem holding `uri`.
     * If `uri` is on a normal filesystem mount (such as /, /home,
     * /var, etc.) this will be NULL.
     * @param uri a URI
     * @returns filesystem mount point (must be freed by caller)  or NULL.
     */
    function uri_get_mount_point(uri: string): string;
    /**
     * Returns the filename component of `uri,` that is, everything after the
     * final slash and before the start of the query string or fragment.
     * @param uri a URI
     * @returns filename component of @uri, must be freed by caller
     */
    function uri_get_short_path_name(uri: string): string;
    /**
     * Calls `func` for each file found under the directory identified by `uri`.
     * If `uri` identifies a file, calls `func` for that instead.
     * @param uri URI to visit
     * @param cancel an optional #GCancellable to allow cancellation
     * @param func Callback function
     */
    function uri_handle_recursively(uri: string, cancel: Gio.Cancellable | null, func: UriRecurseFunc): void;
    /**
     * Calls `func` for each file found under the directory identified
     * by `uri,` or if `uri` identifies a file, calls it once
     * with that.
     *
     * If non-NULL, `destroy_data` will be called once all files have been
     * processed, or when the operation is cancelled.
     * @param uri the URI to visit
     * @param cancel a #GCancellable to allow cancellation
     * @param func callback function
     */
    function uri_handle_recursively_async(uri: string, cancel: Gio.Cancellable | null, func: UriRecurseFunc): void;
    /**
     * Checks if `uri` refers to a path beneath `ancestor,` such that removing some number
     * of path segments of `uri` would result in `ancestor`.
     * It doesn't do any filesystem operations, it just looks at the URIs as strings.
     * The URI strings should be built by looking at a filesystem rather than user input,
     * and must not have path segments that are empty (multiple slashes) or '.' or '..'.
     *
     * Given this input, checking if one URI is a descendant of another is pretty simple.
     * A descendant URI must have the ancestor as a prefix, and if the ancestor ends with
     * a slash, there must be at least one character after that, otherwise the following
     * character must be a slash with at least one character after it.
     * @param uri URI to check
     * @param ancestor a URI to check against
     * @returns %TRUE if @uri is a descendant of @ancestor
     */
    function uri_is_descendant(uri: string, ancestor: string): boolean;
    /**
     * Checks if `uri` identifies a directory.
     * @param uri the URI to check
     * @returns %TRUE if @uri is a directory
     */
    function uri_is_directory(uri: string): boolean;
    /**
     * Checks if `uri` is hidden, according to the Unix filename convention.
     * If the filename component of `uri` begins with a dot, the file is considered
     * hidden.
     * @param uri a URI to check
     * @returns %TRUE if @uri is hidden
     */
    function uri_is_hidden(uri: string): boolean;
    /**
     * Checks if `uri` identifies a local resource.  Currently this just
     * checks that it uses the 'file' URI scheme.
     * @param uri a URI to check
     * @returns %TRUE if @uri is local
     */
    function uri_is_local(uri: string): boolean;
    /**
     * Checks if the user can read the resource identified by `uri`
     * @param uri a URI to check
     * @returns %TRUE if @uri is readable
     */
    function uri_is_readable(uri: string): boolean;
    /**
     * Checks if the user can write to the resource identified by `uri`
     * @param uri a URI to check
     * @returns %TRUE if @uri is writable
     */
    function uri_is_writable(uri: string): boolean;
    /**
     * Converts a single string containing a list of URIs into
     * a #GList of URI strings.
     * @param uri_list string containing URIs to parse
     * @returns #GList of URI strings
     */
    function uri_list_parse(uri_list: string): string[];
    /**
     * Constructs a URI that is similar to `uri` but which identifies
     * a hidden file.  This can be used for temporary files that should not
     * be visible to the user while they are in use.
     * @param uri a URI to construct a hidden version of
     * @returns hidden URI, must be freed by the caller.
     */
    function uri_make_hidden(uri: string): string;
    /**
     * Creates a temporary file whose URI begins with `prefix,` returning
     * the file URI and an output stream for writing to it.
     * @param prefix URI prefix
     * @param uri_ret returns the temporary file URI
     * @param stream returns a @GOutputStream for the temporary file
     * @returns %TRUE if successful
     */
    function uri_mkstemp(prefix: string, uri_ret: string, stream: Gio.OutputStream): boolean;
    /**
     * Attempts to resolve symlinks in `uri` and return a canonical URI for the file
     * it identifies.
     * @param uri the URI to process
     * @returns resolved URI, or NULL on error
     */
    function uri_resolve_symlink(uri: string): string;
    /**
     * This will create the rhythmbox user cache directory, using the XDG
     * Base Directory specification.  If none of the XDG environment
     * variables are set, this will be ~/.cache/rhythmbox.
     * @returns string holding the path to the rhythmbox user cache directory, or NULL if the directory does not exist and could not be created.
     */
    function user_cache_dir(): string;
    /**
     * This will create the rhythmbox user data directory, using the XDG Base
     * Directory specification.  If none of the XDG environment variables are
     * set, this will be ~/.local/share/rhythmbox.
     * @returns string holding the path to the rhythmbox user data directory, or NULL if the directory does not exist and cannot be created.
     */
    function user_data_dir(): string;
    interface AsyncCopyCallback {
        (copy: AsyncCopy, success: boolean, data?: any | null): void;
    }
    interface AsyncCopyProgressCallback {
        (copy: AsyncCopy, position: number, total: number, data?: any | null): void;
    }
    interface BrowserSourceFeatureFunc {
        (source: BrowserSource): boolean;
    }
    interface BrowserSourceStringFunc {
        (source: BrowserSource): string;
    }
    interface ChunkLoaderCallback {
        (loader: ChunkLoader, data: GLib.Bytes | Uint8Array, total: number): void;
    }
    interface DelayedSyncFunc {
        (settings: Gio.Settings, data?: any | null): void;
    }
    interface ExtDBRequestCallback {
        (key: ExtDBKey, store_key: ExtDBKey, filename: string, data: GObject.Value | any): void;
    }
    interface PlayOrderQueryFunc {
        (porder: PlayOrder): boolean;
    }
    interface PlayerFeatureFunc {
        (player: Player): boolean;
    }
    interface PodcastParseCallback {
        (data: PodcastChannel, error: GLib.Error): void;
    }
    interface RhythmDBEntryForeachFunc {
        (entry: RhythmDBEntry, data?: any | null): void;
    }
    interface RhythmDBEntryTypeBooleanFunc {
        (entry_type: RhythmDBEntryType, entry: RhythmDBEntry): boolean;
    }
    interface RhythmDBEntryTypeStringFunc {
        (entry_type: RhythmDBEntryType, entry: RhythmDBEntry): string;
    }
    interface SegmentedBarValueFormatter {
        (percent: number, data?: any | null): string;
    }
    interface SourceAddCallback {
        (source: Source, uri: string, data?: any | null): void;
    }
    interface SourceFeatureFunc {
        (source: Source): boolean;
    }
    interface SourceStringFunc {
        (source: Source): string;
    }
    interface UriRecurseFunc {
        (file: Gio.File, info: Gio.FileInfo, data?: any | null): boolean;
    }
    namespace Application {
        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Application.ConstructorProps,
                Gio.ActionGroup.ConstructorProps,
                Gio.ActionMap.ConstructorProps {
            shell: Shell;
        }
    }

    class Application extends Gtk.Application implements Gio.ActionGroup, Gio.ActionMap {
        static $gtype: GObject.GType<Application>;

        // Properties

        get shell(): Shell;

        // Constructors

        constructor(properties?: Partial<Application.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Application;

        // Methods

        /**
         * Attempts to activate an accelerator registered using #rb_application_add_accelerator.
         * @param event a #GdkEventKey
         * @returns %TRUE if an accelerator was activated
         */
        activate_key(event: Gdk.EventKey): boolean;
        /**
         * Like #gtk_application_add_accelerator, except the accelerator only applies
         * if the key was not handled by the focused widget.
         * @param accel accelerator string
         * @param action the name of the action to activate
         * @param parameter parameter to pass when activating the action, or NULL if   the action does not accept an activation parameter.
         */
        add_accelerator(accel: string, action: string, parameter?: GLib.Variant | null): void;
        /**
         * Adds an item to a plugin menu.  The id can be used to remove the item.
         * @param menu name of the menu to add to
         * @param id id of the item to add (used to remove it, must be unique within the menu)
         * @param item menu item to add
         */
        add_plugin_menu_item(menu: string, id: string, item: Gio.MenuItem): void;
        /**
         * Adds a menu model to the set of shared menus
         * available for linking into other menus.
         * @param name a name for the menu
         * @param menu #GMenuModel instance
         */
        add_shared_menu(name: string, menu: Gio.MenuModel): void;
        /**
         * Returns a plugin menu instance.  Plugin menus are like shared menus except
         * they are created empty on first access, and they consist solely of entries
         * added through `rb_application_add_plugin_item`.
         * @param menu name of plugin menu to return
         * @returns plugin menu instance.
         */
        get_plugin_menu(menu: string): Gio.MenuModel;
        /**
         * Returns a shared menu instance added with `rb_application_add_shared_menu`
         * @param name name of menu to return
         * @returns menu model instance, or NULL if not found
         */
        get_shared_menu(name: string): Gio.MenuModel;
        /**
         * Processes shared menu links in the given menu.  Menu links take the
         * form of items with "rb-menu-link" or "rb-plugin-menu-link" and "rb-menu-link-type" attributes.
         * "rb-menu-link" specifies the name of a shared menu to link in,
         * "rb-plugin-menu-link" specifies the name of a plugin menu to link in,
         * "rb-menu-link-type" specifies the link type, either "section" or
         * "submenu".  A link item must have "rb-menu-link-type" and one of
         * "rb-menu-link" or "rb-plugin-menu-link".
         * @param menu a #GMenu to process
         */
        link_shared_menus(menu: Gio.Menu): void;
        remove_plugin_menu_item(menu: string, id: string): void;
        /**
         * Runs the application
         * @param argc arg count
         * @param argv arg values
         * @returns exit code
         */
        run(argc: number, argv: string): number;
        // Conflicted with Gio.Application.run
        run(...args: never[]): any;
        /**
         * Enables or disables accelerators for items in `menu`.
         * @param menu a #GMenuModel for which to enable or disable accelerators
         * @param enable %TRUE to enable accelerators, %FALSE to disable
         */
        set_menu_accelerators(menu: Gio.MenuModel, enable: boolean): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace AsyncCopy {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class AsyncCopy extends GObject.Object {
        static $gtype: GObject.GType<AsyncCopy>;

        // Constructors

        constructor(properties?: Partial<AsyncCopy.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): AsyncCopy;

        // Methods

        /**
         * Cancels the loading operation, ensuring that the callback
         * will not be called again.
         */
        cancel(): void;
        /**
         * If an error has occurred that prevents the copy from proceeding,
         * this function will return a #GError, otherwise NULL.
         * @returns copy error or NULL
         */
        get_error(): GLib.Error;
        set_progress(callback: AsyncCopyProgressCallback): void;
        /**
         * Starts copying `src` to `dest,` calling `callback` on completion or error.
         * @param src source URI
         * @param dest destination URI
         * @param callback completion callback
         */
        start(src: string, dest: string, callback: AsyncCopyCallback): void;
    }

    namespace AutoPlaylistSource {
        // Constructor properties interface

        interface ConstructorProps
            extends PlaylistSource.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {}
    }

    class AutoPlaylistSource extends PlaylistSource implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<AutoPlaylistSource>;

        // Constructors

        constructor(properties?: Partial<AutoPlaylistSource.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](shell: Shell, name: string, local: boolean): AutoPlaylistSource;
        // Conflicted with Gtk.Box.new

        static ['new'](...args: never[]): any;

        static new_from_xml(shell: Shell, name: string, node: libxml2.NodePtr): AutoPlaylistSource;
        // Conflicted with RB.PlaylistSource.new_from_xml

        static new_from_xml(...args: never[]): any;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace BrowserSource {
        // Constructor properties interface

        interface ConstructorProps
            extends Source.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {
            populate: boolean;
        }
    }

    abstract class BrowserSource extends Source implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<BrowserSource>;

        // Properties

        get populate(): boolean;
        set populate(val: boolean);

        // Constructors

        constructor(properties?: Partial<BrowserSource.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        /**
         * This is a virtual method that should be implemented by subclasses.  It returns %TRUE
         * if drag and drop target support for the source should be activated.
         */
        vfunc_has_drop_support(): boolean;
        vfunc_pack_content(content: Gtk.Widget): void;
        vfunc_show_entry_popup(): void;

        // Methods

        /**
         * This is a virtual method that should be implemented by subclasses.  It returns %TRUE
         * if drag and drop target support for the source should be activated.
         * @returns %TRUE if drop support should be activated
         */
        has_drop_support(): boolean;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace ButtonBar {
        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Grid.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {
            model: Gio.MenuModel;
            target: GObject.Object;
        }
    }

    class ButtonBar extends Gtk.Grid implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<ButtonBar>;

        // Properties

        get model(): Gio.MenuModel;
        get target(): GObject.Object;

        // Constructors

        constructor(properties?: Partial<ButtonBar.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](model: Gio.MenuModel, target: GObject.Object): ButtonBar;
        // Conflicted with Gtk.Grid.new

        static ['new'](...args: never[]): any;

        // Methods

        /**
         * Adds accelerators for the buttons in `bar` to the accelerator
         * group `group`.
         * @param group the #GtkAccelGroup to add accelerators to
         */
        add_accelerators(group: Gtk.AccelGroup): void;
        /**
         * Reverses the effects of `rb_button_bar_add_accelerators`.
         * @param group the #GtkAccelGroup to remove accelerators from
         */
        remove_accelerators(group: Gtk.AccelGroup): void;

        // Inherited properties
        /**
         * The orientation of the orientable.
         */
        get orientation(): Gtk.Orientation;
        set orientation(val: Gtk.Orientation);

        // Inherited methods
        /**
         * Retrieves the orientation of the `orientable`.
         * @returns the orientation of the @orientable.
         */
        get_orientation(): Gtk.Orientation;
        /**
         * Sets the orientation of the `orientable`.
         * @param orientation the orientable’s new orientation.
         */
        set_orientation(orientation: Gtk.Orientation | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace CellRendererPixbuf {
        // Signal callback interfaces

        interface PixbufClicked {
            (path: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Gtk.CellRendererPixbuf.ConstructorProps {}
    }

    class CellRendererPixbuf extends Gtk.CellRendererPixbuf {
        static $gtype: GObject.GType<CellRendererPixbuf>;

        // Constructors

        constructor(properties?: Partial<CellRendererPixbuf.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): CellRendererPixbuf;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'pixbuf-clicked', callback: (_source: this, path: string) => void): number;
        connect_after(signal: 'pixbuf-clicked', callback: (_source: this, path: string) => void): number;
        emit(signal: 'pixbuf-clicked', path: string): void;

        // Virtual methods

        vfunc_pixbuf_clicked(path: Gtk.TreePath): void;
    }

    namespace CellRendererRating {
        // Signal callback interfaces

        interface Rated {
            (score: string, path: number): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Gtk.CellRenderer.ConstructorProps {
            rating: number;
        }
    }

    class CellRendererRating extends Gtk.CellRenderer {
        static $gtype: GObject.GType<CellRendererRating>;

        // Properties

        /**
         * The rating displayed by the renderer, as a floating point value
         * between 0.0 and 5.0.
         */
        get rating(): number;
        set rating(val: number);

        // Constructors

        constructor(properties?: Partial<CellRendererRating.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): CellRendererRating;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'rated', callback: (_source: this, score: string, path: number) => void): number;
        connect_after(signal: 'rated', callback: (_source: this, score: string, path: number) => void): number;
        emit(signal: 'rated', score: string, path: number): void;

        // Virtual methods

        vfunc_rated(path: string, rating: number): void;
    }

    namespace ChunkLoader {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class ChunkLoader extends GObject.Object {
        static $gtype: GObject.GType<ChunkLoader>;

        // Constructors

        constructor(properties?: Partial<ChunkLoader.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ChunkLoader;

        // Methods

        /**
         * Cancels the loading operation, ensuring that the callback
         * will not be called again.
         */
        cancel(): void;
        /**
         * If an error has occurred that prevents the loader from providing
         * any further data, this function will return a #GError, otherwise
         * NULL.
         * @returns loader error or NULL
         */
        get_error(): GLib.Error;
        /**
         * Sets the loader data callback.  This will be called with each
         * chunk of data read, or with NULL to indicate the end of the file
         * or that an error has occurred.  To determine which of these is
         * the case, call `rb_chunk_loader_get_error`.
         *
         * This must be called before `rb_chunk_loader_start`.
         * @param callback the data/error callback
         */
        set_callback(callback: ChunkLoaderCallback): void;
        /**
         * Starts loading data from the specified URI, passing it in chunks
         * of at most `chunk_size` to the callback.
         * @param uri the uri to load
         * @param chunk_size maximum chunk size
         */
        start(uri: string, chunk_size: number): void;
    }

    namespace DisplayPage {
        // Signal callback interfaces

        interface Deleted {
            (): void;
        }

        interface StatusChanged {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Box.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {
            icon: Gio.Icon;
            name: string;
            parent: DisplayPage;
            plugin: GObject.Object;
            selected: boolean;
            shell: Shell;
            visibility: boolean;
        }
    }

    abstract class DisplayPage extends Gtk.Box implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<DisplayPage>;

        // Properties

        /**
         * Icon to display in the page tree
         */
        get icon(): Gio.Icon;
        set icon(val: Gio.Icon);
        /**
         * Page name as displayed in the tree
         */
        get name(): string;
        set name(val: string);
        /**
         * The parent page in the tree (may be NULL)
         */
        get parent(): DisplayPage;
        /**
         * The plugin that created this page.
         */
        get plugin(): GObject.Object;
        set plugin(val: GObject.Object);
        /**
         * TRUE when the page is selected in the page tree.
         */
        get selected(): boolean;
        /**
         * The rhythmbox shell object
         */
        get shell(): Shell;
        /**
         * If FALSE, the page will not be displayed in the tree
         */
        get visibility(): boolean;
        set visibility(val: boolean);

        // Constructors

        constructor(properties?: Partial<DisplayPage.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'deleted', callback: (_source: this) => void): number;
        connect_after(signal: 'deleted', callback: (_source: this) => void): number;
        emit(signal: 'deleted'): void;
        connect(signal: 'status-changed', callback: (_source: this) => void): number;
        connect_after(signal: 'status-changed', callback: (_source: this) => void): number;
        emit(signal: 'status-changed'): void;

        // Virtual methods

        /**
         * Called when the page is activated (double clicked, etc.) in the page tree.
         */
        vfunc_activate(): void;
        /**
         * Called to check whether the user is able to remove the page
         */
        vfunc_can_remove(): boolean;
        /**
         * This is called when the page should delete itself.
         * The 'deleted' signal will be emitted, which removes the page
         * from the page model.  This will not actually dispose of the
         * page object, so reference counting must still be handled
         * correctly.
         */
        vfunc_delete_thyself(): void;
        vfunc_deleted(): void;
        /**
         * Called when the page is deselected in the page tree.
         */
        vfunc_deselected(): void;
        /**
         * Source implementations can use this to return an optional
         * configuration widget. The widget will be displayed in a
         * page in the preferences dialog.
         * @param prefs the #RBShellPreferences object
         */
        vfunc_get_config_widget(prefs: ShellPreferences): Gtk.Widget;
        /**
         * Retrieves status details for the page.
         * @param text holds the returned status text
         * @param busy holds the busy status
         */
        vfunc_get_status(text: string, busy: boolean): [string, boolean];
        vfunc_receive_drag(data: Gtk.SelectionData): boolean;
        /**
         * Called when the user requests removal of a page.
         */
        vfunc_remove(): void;
        /**
         * Checks if `page` can be selected
         */
        vfunc_selectable(): boolean;
        /**
         * Called when the page is selected in the page tree.
         */
        vfunc_selected(): void;
        vfunc_status_changed(): void;

        // Methods

        /**
         * Called when the page is activated (double clicked, etc.) in the page tree.
         */
        activate(): void;
        // Conflicted with Gtk.Widget.activate
        activate(...args: never[]): any;
        /**
         * Called to check whether the user is able to remove the page
         * @returns %TRUE if the page can be removed
         */
        can_remove(): boolean;
        /**
         * This is called when the page should delete itself.
         * The 'deleted' signal will be emitted, which removes the page
         * from the page model.  This will not actually dispose of the
         * page object, so reference counting must still be handled
         * correctly.
         */
        delete_thyself(): void;
        /**
         * Called when the page is deselected in the page tree.
         */
        deselected(): void;
        /**
         * Source implementations can use this to return an optional
         * configuration widget. The widget will be displayed in a
         * page in the preferences dialog.
         * @param prefs the #RBShellPreferences object
         * @returns configuration widget
         */
        get_config_widget(prefs: ShellPreferences): Gtk.Widget;
        /**
         * Retrieves status details for the page.
         * @param text holds the returned status text
         * @param busy holds the busy status
         */
        get_status(text: string, busy: boolean): [string, boolean];
        /**
         * Page implementations call this when their status bar information
         * changes.
         */
        notify_status_changed(): void;
        receive_drag(data: Gtk.SelectionData): boolean;
        /**
         * Called when the user requests removal of a page.
         */
        remove(): void;
        /**
         * Checks if `page` can be selected
         */
        selectable(): boolean;
        /**
         * Sets the icon for the page to the specified icon name.
         * @param icon_name icon name to use
         */
        set_icon_name(icon_name: string): void;

        // Inherited properties
        /**
         * The orientation of the orientable.
         */
        get orientation(): Gtk.Orientation;
        set orientation(val: Gtk.Orientation);

        // Inherited methods
        /**
         * Retrieves the orientation of the `orientable`.
         * @returns the orientation of the @orientable.
         */
        get_orientation(): Gtk.Orientation;
        /**
         * Sets the orientation of the `orientable`.
         * @param orientation the orientable’s new orientation.
         */
        set_orientation(orientation: Gtk.Orientation | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace DisplayPageGroup {
        // Constructor properties interface

        interface ConstructorProps
            extends DisplayPage.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {
            category: DisplayPageGroupType;
            id: string;
            loaded: boolean;
        }
    }

    class DisplayPageGroup extends DisplayPage implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<DisplayPageGroup>;

        // Properties

        /**
         * Page group category that the group falls into
         */
        get category(): DisplayPageGroupType;
        /**
         * Internal (untranslated) name for the page group
         */
        get id(): string;
        get loaded(): boolean;

        // Constructors

        constructor(properties?: Partial<DisplayPageGroup.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            shell: GObject.Object,
            id: string,
            name: string,
            category: DisplayPageGroupCategory,
        ): DisplayPageGroup;
        // Conflicted with Gtk.Box.new

        static ['new'](...args: never[]): any;

        // Static methods

        /**
         * Registers core page groups.
         * @param shell the #RBShell
         * @param page_model the #RBDisplayPageModel
         */
        static add_core_groups(shell: GObject.Object, page_model: DisplayPageModel): void;
        /**
         * Locates a page group by name.  If the page group has not been registered yet,
         * returns NULL instead.
         * @param id name of page group to find
         */
        static get_by_id(id: string): DisplayPageGroup;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace DisplayPageModel {
        // Signal callback interfaces

        interface DropReceived {
            (target: DisplayPage, pos: number, data?: any | null): void;
        }

        interface PageInserted {
            (page: DisplayPage, iter: Gtk.TreeIter): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.TreeModelFilter.ConstructorProps,
                Gtk.TreeDragSource.ConstructorProps,
                Gtk.TreeModel.ConstructorProps {}
    }

    class DisplayPageModel extends Gtk.TreeModelFilter implements Gtk.TreeDragSource, Gtk.TreeModel {
        static $gtype: GObject.GType<DisplayPageModel>;

        // Constructors

        constructor(properties?: Partial<DisplayPageModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DisplayPageModel;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'drop-received',
            callback: (_source: this, target: DisplayPage, pos: number, data: any | null) => void,
        ): number;
        connect_after(
            signal: 'drop-received',
            callback: (_source: this, target: DisplayPage, pos: number, data: any | null) => void,
        ): number;
        emit(signal: 'drop-received', target: DisplayPage, pos: number, data?: any | null): void;
        connect(
            signal: 'page-inserted',
            callback: (_source: this, page: DisplayPage, iter: Gtk.TreeIter) => void,
        ): number;
        connect_after(
            signal: 'page-inserted',
            callback: (_source: this, page: DisplayPage, iter: Gtk.TreeIter) => void,
        ): number;
        emit(signal: 'page-inserted', page: DisplayPage, iter: Gtk.TreeIter): void;

        // Virtual methods

        vfunc_drop_received(target: DisplayPage, pos: Gtk.TreeViewDropPosition, data: Gtk.SelectionData): void;
        vfunc_page_inserted(page: DisplayPage, iter: Gtk.TreeIter): void;

        // Methods

        /**
         * Adds a page to the model, either below a specified page (if it's a source or
         * something else) or at the top level (if it's a group)
         * @param page the #RBDisplayPage to add
         * @param parent the parent under which to add @page
         */
        add_page(page: DisplayPage, parent: DisplayPage): void;
        /**
         * Finds a #GtkTreeIter for a specified page in the model.  This will only
         * find pages that are currently visible.  The returned #GtkTreeIter can be used
         * with the #RBDisplayPageModel.
         * @param page the #RBDisplayPage to find
         * @param iter returns a #GtkTreeIter for the page
         * @returns %TRUE if the page was found
         */
        find_page(page: DisplayPage, iter: Gtk.TreeIter): boolean;
        /**
         * Finds a #GtkTreeIter for a specified page in the model.  This function
         * searches the full page model, so it will find pages that are not currently
         * visible, and the returned iterator can only be used with the child model
         * (see #gtk_tree_model_filter_get_model).
         * @param page the #RBDisplayPage to find
         * @param iter returns a #GtkTreeIter for the page
         * @returns %TRUE if the page was found
         */
        find_page_full(page: DisplayPage, iter: Gtk.TreeIter): boolean;
        /**
         * Removes a page from the model.
         * @param page the #RBDisplayPage to remove
         */
        remove_page(page: DisplayPage): void;
        /**
         * Sets up the drag and drop targets for the display page tree.
         * @param treeview the sourcel ist #GtkTreeView
         */
        set_dnd_targets(treeview: Gtk.TreeView): void;
        /**
         * Updates the model with the new playing source.
         * @param source the new playing #RBSource (as a #RBDisplayPage)
         */
        set_playing_source(source: DisplayPage): void;

        // Inherited methods
        /**
         * Asks the #GtkTreeDragSource to delete the row at `path,` because
         * it was moved somewhere else via drag-and-drop. Returns %FALSE
         * if the deletion fails because `path` no longer exists, or for
         * some model-specific reason. Should robustly handle a `path` no
         * longer found in the model!
         * @param path row that was being dragged
         * @returns %TRUE if the row was successfully deleted
         */
        drag_data_delete(path: Gtk.TreePath): boolean;
        /**
         * Asks the #GtkTreeDragSource to fill in `selection_data` with a
         * representation of the row at `path`. `selection_data->`target gives
         * the required type of the data.  Should robustly handle a `path` no
         * longer found in the model!
         * @param path row that was dragged
         * @param selection_data a #GtkSelectionData to fill with data                  from the dragged row
         * @returns %TRUE if data of the required type was provided
         */
        drag_data_get(path: Gtk.TreePath, selection_data: Gtk.SelectionData): boolean;
        /**
         * Asks the #GtkTreeDragSource whether a particular row can be used as
         * the source of a DND operation. If the source doesn’t implement
         * this interface, the row is assumed draggable.
         * @param path row on which user is initiating a drag
         * @returns %TRUE if the row can be dragged
         */
        row_draggable(path: Gtk.TreePath): boolean;
        /**
         * Asks the #GtkTreeDragSource to delete the row at `path,` because
         * it was moved somewhere else via drag-and-drop. Returns %FALSE
         * if the deletion fails because `path` no longer exists, or for
         * some model-specific reason. Should robustly handle a `path` no
         * longer found in the model!
         * @param path row that was being dragged
         */
        vfunc_drag_data_delete(path: Gtk.TreePath): boolean;
        /**
         * Asks the #GtkTreeDragSource to fill in `selection_data` with a
         * representation of the row at `path`. `selection_data->`target gives
         * the required type of the data.  Should robustly handle a `path` no
         * longer found in the model!
         * @param path row that was dragged
         * @param selection_data a #GtkSelectionData to fill with data                  from the dragged row
         */
        vfunc_drag_data_get(path: Gtk.TreePath, selection_data: Gtk.SelectionData): boolean;
        /**
         * Asks the #GtkTreeDragSource whether a particular row can be used as
         * the source of a DND operation. If the source doesn’t implement
         * this interface, the row is assumed draggable.
         * @param path row on which user is initiating a drag
         */
        vfunc_row_draggable(path: Gtk.TreePath): boolean;
        /**
         * Creates a new #GtkTreeModel, with `child_model` as the child_model
         * and `root` as the virtual root.
         * @param root A #GtkTreePath or %NULL.
         * @returns A new #GtkTreeModel.
         */
        filter_new(root?: Gtk.TreePath | null): Gtk.TreeModel;
        /**
         * Calls func on each node in model in a depth-first fashion.
         *
         * If `func` returns %TRUE, then the tree ceases to be walked,
         * and gtk_tree_model_foreach() returns.
         * @param func a function to be called on each row
         */
        foreach(func: Gtk.TreeModelForeachFunc): void;
        /**
         * Returns the type of the column.
         * @param index_ the column index
         * @returns the type of the column
         */
        get_column_type(index_: number): GObject.GType;
        /**
         * Returns a set of flags supported by this interface.
         *
         * The flags are a bitwise combination of #GtkTreeModelFlags.
         * The flags supported should not change during the lifetime
         * of the `tree_model`.
         * @returns the flags supported by this interface
         */
        get_flags(): Gtk.TreeModelFlags;
        /**
         * Sets `iter` to a valid iterator pointing to `path`.  If `path` does
         * not exist, `iter` is set to an invalid iterator and %FALSE is returned.
         * @param path the #GtkTreePath-struct
         * @returns %TRUE, if @iter was set
         */
        get_iter(path: Gtk.TreePath): [boolean, Gtk.TreeIter];
        /**
         * Initializes `iter` with the first iterator in the tree
         * (the one at the path "0") and returns %TRUE. Returns
         * %FALSE if the tree is empty.
         * @returns %TRUE, if @iter was set
         */
        get_iter_first(): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to a valid iterator pointing to `path_string,` if it
         * exists. Otherwise, `iter` is left invalid and %FALSE is returned.
         * @param path_string a string representation of a #GtkTreePath-struct
         * @returns %TRUE, if @iter was set
         */
        get_iter_from_string(path_string: string): [boolean, Gtk.TreeIter];
        /**
         * Returns the number of columns supported by `tree_model`.
         * @returns the number of columns
         */
        get_n_columns(): number;
        /**
         * Returns a newly-created #GtkTreePath-struct referenced by `iter`.
         *
         * This path should be freed with gtk_tree_path_free().
         * @param iter the #GtkTreeIter-struct
         * @returns a newly-created #GtkTreePath-struct
         */
        get_path(iter: Gtk.TreeIter): Gtk.TreePath;
        /**
         * Generates a string representation of the iter.
         *
         * This string is a “:” separated list of numbers.
         * For example, “4:10:0:3” would be an acceptable
         * return value for this string.
         * @param iter a #GtkTreeIter-struct
         * @returns a newly-allocated string.     Must be freed with g_free().
         */
        get_string_from_iter(iter: Gtk.TreeIter): string;
        /**
         * Initializes and sets `value` to that at `column`.
         *
         * When done with `value,` g_value_unset() needs to be called
         * to free any allocated memory.
         * @param iter the #GtkTreeIter-struct
         * @param column the column to lookup the value at
         */
        get_value(iter: Gtk.TreeIter, column: number): unknown;
        /**
         * Sets `iter` to point to the first child of `parent`.
         *
         * If `parent` has no children, %FALSE is returned and `iter` is
         * set to be invalid. `parent` will remain a valid node after this
         * function has been called.
         *
         * If `parent` is %NULL returns the first node, equivalent to
         * `gtk_tree_model_get_iter_first (tree_model, iter);`
         * @param parent the #GtkTreeIter-struct, or %NULL
         * @returns %TRUE, if @iter has been set to the first child
         */
        iter_children(parent?: Gtk.TreeIter | null): [boolean, Gtk.TreeIter];
        /**
         * Returns %TRUE if `iter` has children, %FALSE otherwise.
         * @param iter the #GtkTreeIter-struct to test for children
         * @returns %TRUE if @iter has children
         */
        iter_has_child(iter: Gtk.TreeIter): boolean;
        /**
         * Returns the number of children that `iter` has.
         *
         * As a special case, if `iter` is %NULL, then the number
         * of toplevel nodes is returned.
         * @param iter the #GtkTreeIter-struct, or %NULL
         * @returns the number of children of @iter
         */
        iter_n_children(iter?: Gtk.TreeIter | null): number;
        /**
         * Sets `iter` to point to the node following it at the current level.
         *
         * If there is no next `iter,` %FALSE is returned and `iter` is set
         * to be invalid.
         * @param iter the #GtkTreeIter-struct
         * @returns %TRUE if @iter has been changed to the next node
         */
        iter_next(iter: Gtk.TreeIter): boolean;
        /**
         * Sets `iter` to be the child of `parent,` using the given index.
         *
         * The first index is 0. If `n` is too big, or `parent` has no children,
         * `iter` is set to an invalid iterator and %FALSE is returned. `parent`
         * will remain a valid node after this function has been called. As a
         * special case, if `parent` is %NULL, then the `n-th` root node
         * is set.
         * @param parent the #GtkTreeIter-struct to get the child from, or %NULL.
         * @param n the index of the desired child
         * @returns %TRUE, if @parent has an @n-th child
         */
        iter_nth_child(parent: Gtk.TreeIter | null, n: number): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to be the parent of `child`.
         *
         * If `child` is at the toplevel, and doesn’t have a parent, then
         * `iter` is set to an invalid iterator and %FALSE is returned.
         * `child` will remain a valid node after this function has been
         * called.
         *
         * `iter` will be initialized before the lookup is performed, so `child`
         * and `iter` cannot point to the same memory location.
         * @param child the #GtkTreeIter-struct
         * @returns %TRUE, if @iter is set to the parent of @child
         */
        iter_parent(child: Gtk.TreeIter): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to point to the previous node at the current level.
         *
         * If there is no previous `iter,` %FALSE is returned and `iter` is
         * set to be invalid.
         * @param iter the #GtkTreeIter-struct
         * @returns %TRUE if @iter has been changed to the previous node
         */
        iter_previous(iter: Gtk.TreeIter): boolean;
        /**
         * Lets the tree ref the node.
         *
         * This is an optional method for models to implement.
         * To be more specific, models may ignore this call as it exists
         * primarily for performance reasons.
         *
         * This function is primarily meant as a way for views to let
         * caching models know when nodes are being displayed (and hence,
         * whether or not to cache that node). Being displayed means a node
         * is in an expanded branch, regardless of whether the node is currently
         * visible in the viewport. For example, a file-system based model
         * would not want to keep the entire file-hierarchy in memory,
         * just the sections that are currently being displayed by
         * every current view.
         *
         * A model should be expected to be able to get an iter independent
         * of its reffed state.
         * @param iter the #GtkTreeIter-struct
         */
        ref_node(iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-changed signal on `tree_model`.
         * @param path a #GtkTreePath-struct pointing to the changed row
         * @param iter a valid #GtkTreeIter-struct pointing to the changed row
         */
        row_changed(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-deleted signal on `tree_model`.
         *
         * This should be called by models after a row has been removed.
         * The location pointed to by `path` should be the location that
         * the row previously was at. It may not be a valid location anymore.
         *
         * Nodes that are deleted are not unreffed, this means that any
         * outstanding references on the deleted node should not be released.
         * @param path a #GtkTreePath-struct pointing to the previous location of     the deleted row
         */
        row_deleted(path: Gtk.TreePath): void;
        /**
         * Emits the #GtkTreeModel::row-has-child-toggled signal on
         * `tree_model`. This should be called by models after the child
         * state of a node changes.
         * @param path a #GtkTreePath-struct pointing to the changed row
         * @param iter a valid #GtkTreeIter-struct pointing to the changed row
         */
        row_has_child_toggled(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-inserted signal on `tree_model`.
         * @param path a #GtkTreePath-struct pointing to the inserted row
         * @param iter a valid #GtkTreeIter-struct pointing to the inserted row
         */
        row_inserted(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::rows-reordered signal on `tree_model`.
         *
         * This should be called by models when their rows have been
         * reordered.
         * @param path a #GtkTreePath-struct pointing to the tree node whose children     have been reordered
         * @param iter a valid #GtkTreeIter-struct pointing to the node     whose children have been reordered, or %NULL if the depth     of @path is 0
         * @param new_order an array of integers     mapping the current position of each child to its old     position before the re-ordering,     i.e. @new_order`[newpos] = oldpos`
         */
        rows_reordered(path: Gtk.TreePath, iter: Gtk.TreeIter | null, new_order: number[]): void;
        /**
         * Lets the tree unref the node.
         *
         * This is an optional method for models to implement.
         * To be more specific, models may ignore this call as it exists
         * primarily for performance reasons. For more information on what
         * this means, see gtk_tree_model_ref_node().
         *
         * Please note that nodes that are deleted are not unreffed.
         * @param iter the #GtkTreeIter-struct
         */
        unref_node(iter: Gtk.TreeIter): void;
        /**
         * Returns the type of the column.
         * @param index_ the column index
         */
        vfunc_get_column_type(index_: number): GObject.GType;
        /**
         * Returns a set of flags supported by this interface.
         *
         * The flags are a bitwise combination of #GtkTreeModelFlags.
         * The flags supported should not change during the lifetime
         * of the `tree_model`.
         */
        vfunc_get_flags(): Gtk.TreeModelFlags;
        /**
         * Sets `iter` to a valid iterator pointing to `path`.  If `path` does
         * not exist, `iter` is set to an invalid iterator and %FALSE is returned.
         * @param path the #GtkTreePath-struct
         */
        vfunc_get_iter(path: Gtk.TreePath): [boolean, Gtk.TreeIter];
        /**
         * Returns the number of columns supported by `tree_model`.
         */
        vfunc_get_n_columns(): number;
        /**
         * Returns a newly-created #GtkTreePath-struct referenced by `iter`.
         *
         * This path should be freed with gtk_tree_path_free().
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_get_path(iter: Gtk.TreeIter): Gtk.TreePath;
        /**
         * Initializes and sets `value` to that at `column`.
         *
         * When done with `value,` g_value_unset() needs to be called
         * to free any allocated memory.
         * @param iter the #GtkTreeIter-struct
         * @param column the column to lookup the value at
         */
        vfunc_get_value(iter: Gtk.TreeIter, column: number): unknown;
        /**
         * Sets `iter` to point to the first child of `parent`.
         *
         * If `parent` has no children, %FALSE is returned and `iter` is
         * set to be invalid. `parent` will remain a valid node after this
         * function has been called.
         *
         * If `parent` is %NULL returns the first node, equivalent to
         * `gtk_tree_model_get_iter_first (tree_model, iter);`
         * @param parent the #GtkTreeIter-struct, or %NULL
         */
        vfunc_iter_children(parent?: Gtk.TreeIter | null): [boolean, Gtk.TreeIter];
        /**
         * Returns %TRUE if `iter` has children, %FALSE otherwise.
         * @param iter the #GtkTreeIter-struct to test for children
         */
        vfunc_iter_has_child(iter: Gtk.TreeIter): boolean;
        /**
         * Returns the number of children that `iter` has.
         *
         * As a special case, if `iter` is %NULL, then the number
         * of toplevel nodes is returned.
         * @param iter the #GtkTreeIter-struct, or %NULL
         */
        vfunc_iter_n_children(iter?: Gtk.TreeIter | null): number;
        /**
         * Sets `iter` to point to the node following it at the current level.
         *
         * If there is no next `iter,` %FALSE is returned and `iter` is set
         * to be invalid.
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_iter_next(iter: Gtk.TreeIter): boolean;
        /**
         * Sets `iter` to be the child of `parent,` using the given index.
         *
         * The first index is 0. If `n` is too big, or `parent` has no children,
         * `iter` is set to an invalid iterator and %FALSE is returned. `parent`
         * will remain a valid node after this function has been called. As a
         * special case, if `parent` is %NULL, then the `n-th` root node
         * is set.
         * @param parent the #GtkTreeIter-struct to get the child from, or %NULL.
         * @param n the index of the desired child
         */
        vfunc_iter_nth_child(parent: Gtk.TreeIter | null, n: number): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to be the parent of `child`.
         *
         * If `child` is at the toplevel, and doesn’t have a parent, then
         * `iter` is set to an invalid iterator and %FALSE is returned.
         * `child` will remain a valid node after this function has been
         * called.
         *
         * `iter` will be initialized before the lookup is performed, so `child`
         * and `iter` cannot point to the same memory location.
         * @param child the #GtkTreeIter-struct
         */
        vfunc_iter_parent(child: Gtk.TreeIter): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to point to the previous node at the current level.
         *
         * If there is no previous `iter,` %FALSE is returned and `iter` is
         * set to be invalid.
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_iter_previous(iter: Gtk.TreeIter): boolean;
        /**
         * Lets the tree ref the node.
         *
         * This is an optional method for models to implement.
         * To be more specific, models may ignore this call as it exists
         * primarily for performance reasons.
         *
         * This function is primarily meant as a way for views to let
         * caching models know when nodes are being displayed (and hence,
         * whether or not to cache that node). Being displayed means a node
         * is in an expanded branch, regardless of whether the node is currently
         * visible in the viewport. For example, a file-system based model
         * would not want to keep the entire file-hierarchy in memory,
         * just the sections that are currently being displayed by
         * every current view.
         *
         * A model should be expected to be able to get an iter independent
         * of its reffed state.
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_ref_node(iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-changed signal on `tree_model`.
         * @param path a #GtkTreePath-struct pointing to the changed row
         * @param iter a valid #GtkTreeIter-struct pointing to the changed row
         */
        vfunc_row_changed(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-deleted signal on `tree_model`.
         *
         * This should be called by models after a row has been removed.
         * The location pointed to by `path` should be the location that
         * the row previously was at. It may not be a valid location anymore.
         *
         * Nodes that are deleted are not unreffed, this means that any
         * outstanding references on the deleted node should not be released.
         * @param path a #GtkTreePath-struct pointing to the previous location of     the deleted row
         */
        vfunc_row_deleted(path: Gtk.TreePath): void;
        /**
         * Emits the #GtkTreeModel::row-has-child-toggled signal on
         * `tree_model`. This should be called by models after the child
         * state of a node changes.
         * @param path a #GtkTreePath-struct pointing to the changed row
         * @param iter a valid #GtkTreeIter-struct pointing to the changed row
         */
        vfunc_row_has_child_toggled(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-inserted signal on `tree_model`.
         * @param path a #GtkTreePath-struct pointing to the inserted row
         * @param iter a valid #GtkTreeIter-struct pointing to the inserted row
         */
        vfunc_row_inserted(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Lets the tree unref the node.
         *
         * This is an optional method for models to implement.
         * To be more specific, models may ignore this call as it exists
         * primarily for performance reasons. For more information on what
         * this means, see gtk_tree_model_ref_node().
         *
         * Please note that nodes that are deleted are not unreffed.
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_unref_node(iter: Gtk.TreeIter): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace DisplayPageTree {
        // Signal callback interfaces

        interface DropReceived {
            (page?: any | null, data?: any | null): void;
        }

        interface Selected {
            (page: GObject.Object): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Grid.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {
            model: Gtk.TreeModel;
            shell: Shell;
        }
    }

    class DisplayPageTree extends Gtk.Grid implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<DisplayPageTree>;

        // Properties

        /**
         * The #GtkTreeModel for the display page tree
         */
        get model(): Gtk.TreeModel;
        /**
         * The #RBShell instance
         */
        get shell(): Shell;

        // Constructors

        constructor(properties?: Partial<DisplayPageTree.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](shell: Shell): DisplayPageTree;
        // Conflicted with Gtk.Grid.new

        static ['new'](...args: never[]): any;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'drop-received', callback: (_source: this, page: any | null, data: any | null) => void): number;
        connect_after(
            signal: 'drop-received',
            callback: (_source: this, page: any | null, data: any | null) => void,
        ): number;
        emit(signal: 'drop-received', page?: any | null, data?: any | null): void;
        connect(signal: 'selected', callback: (_source: this, page: GObject.Object) => void): number;
        connect_after(signal: 'selected', callback: (_source: this, page: GObject.Object) => void): number;
        emit(signal: 'selected', page: GObject.Object): void;

        // Virtual methods

        vfunc_drop_received(page: DisplayPage, data: Gtk.SelectionData): void;
        vfunc_selected(page: DisplayPage): void;

        // Methods

        /**
         * Initiates editing of the name of the specified source.  The row for the source
         * is selected and given input focus, allowing the user to edit the name.
         * source_name_edited_cb is called when the user finishes editing.
         * @param source the #RBSource to edit
         */
        edit_source_name(source: Source): void;
        /**
         * Selects the specified page in the tree.  This will result in the 'selected'
         * signal being emitted.
         * @param page the #RBDisplayPage to select
         */
        select(page: DisplayPage): void;
        /**
         * If `page` is expanded (children visible), collapses it, otherwise expands it.
         * @param page the #RBDisplayPage to toggle
         */
        toggle_expanded(page: DisplayPage): void;

        // Inherited properties
        /**
         * The orientation of the orientable.
         */
        get orientation(): Gtk.Orientation;
        set orientation(val: Gtk.Orientation);

        // Inherited methods
        /**
         * Retrieves the orientation of the `orientable`.
         * @returns the orientation of the @orientable.
         */
        get_orientation(): Gtk.Orientation;
        /**
         * Sets the orientation of the `orientable`.
         * @param orientation the orientable’s new orientation.
         */
        set_orientation(orientation: Gtk.Orientation | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace EncoderFactory {
        // Signal callback interfaces

        interface PrepareSink {
            (uri: string, sink: GObject.Object): void;
        }

        interface PrepareSource {
            (uri: string, source: GObject.Object): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class EncoderFactory extends GObject.Object {
        static $gtype: GObject.GType<EncoderFactory>;

        // Fields

        obj: GObject.Object;

        // Constructors

        constructor(properties?: Partial<EncoderFactory.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'prepare-sink', callback: (_source: this, uri: string, sink: GObject.Object) => void): number;
        connect_after(
            signal: 'prepare-sink',
            callback: (_source: this, uri: string, sink: GObject.Object) => void,
        ): number;
        emit(signal: 'prepare-sink', uri: string, sink: GObject.Object): void;
        connect(
            signal: 'prepare-source',
            callback: (_source: this, uri: string, source: GObject.Object) => void,
        ): number;
        connect_after(
            signal: 'prepare-source',
            callback: (_source: this, uri: string, source: GObject.Object) => void,
        ): number;
        emit(signal: 'prepare-source', uri: string, source: GObject.Object): void;

        // Static methods

        /**
         * Returns the #RBEncoderFactory instance.
         */
        static get(): EncoderFactory;

        // Virtual methods

        vfunc_prepare_sink(uri: string, sink: GObject.Object): void;
        vfunc_prepare_source(uri: string, source: GObject.Object): void;
    }

    namespace EntryView {
        // Signal callback interfaces

        interface EntriesReplaced {
            (): void;
        }

        interface EntryActivated {
            (entry: RhythmDBEntry): void;
        }

        interface EntryAdded {
            (entry: RhythmDBEntry): void;
        }

        interface EntryDeleted {
            (entry: RhythmDBEntry): void;
        }

        interface HaveSelectionChanged {
            (have_selection: boolean): void;
        }

        interface SelectionChanged {
            (): void;
        }

        interface ShowPopup {
            (over_entry: boolean): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Box.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {
            db: RhythmDB;
            is_drag_dest: boolean;
            isDragDest: boolean;
            is_drag_source: boolean;
            isDragSource: boolean;
            model: RhythmDBQueryModel;
            playing_state: number;
            playingState: number;
            shell_player: ShellPlayer;
            shellPlayer: ShellPlayer;
            sort_order: string;
            sortOrder: string;
            visible_columns: string[];
            visibleColumns: string[];
        }
    }

    class EntryView extends Gtk.Box implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<EntryView>;

        // Properties

        /**
         * #RhythmDB instance
         */
        get db(): RhythmDB;
        /**
         * If TRUE, the view acts as a destination for drag and drop operations.
         */
        get is_drag_dest(): boolean;
        /**
         * If TRUE, the view acts as a destination for drag and drop operations.
         */
        get isDragDest(): boolean;
        /**
         * If TRUE, the view acts as a data source for drag and drop operations.
         */
        get is_drag_source(): boolean;
        /**
         * If TRUE, the view acts as a data source for drag and drop operations.
         */
        get isDragSource(): boolean;
        /**
         * The #RhythmDBQueryModel backing the view
         */
        get model(): RhythmDBQueryModel;
        set model(val: RhythmDBQueryModel);
        /**
         * Determines the icon to show in the 'playing' column next to the current
         * playing entry.
         */
        get playing_state(): number;
        set playing_state(val: number);
        /**
         * Determines the icon to show in the 'playing' column next to the current
         * playing entry.
         */
        get playingState(): number;
        set playingState(val: number);
        /**
         * #RBShellPlayer instance
         */
        get shell_player(): ShellPlayer;
        /**
         * #RBShellPlayer instance
         */
        get shellPlayer(): ShellPlayer;
        /**
         * The sort order for the track listing.
         */
        get sort_order(): string;
        set sort_order(val: string);
        /**
         * The sort order for the track listing.
         */
        get sortOrder(): string;
        set sortOrder(val: string);
        /**
         * An array containing the names of the visible columns.
         */
        get visible_columns(): string[];
        set visible_columns(val: string[]);
        /**
         * An array containing the names of the visible columns.
         */
        get visibleColumns(): string[];
        set visibleColumns(val: string[]);

        // Constructors

        constructor(properties?: Partial<EntryView.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            db: RhythmDB,
            shell_player: GObject.Object,
            is_drag_source: boolean,
            is_drag_dest: boolean,
        ): EntryView;
        // Conflicted with Gtk.Box.new

        static ['new'](...args: never[]): any;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'entries-replaced', callback: (_source: this) => void): number;
        connect_after(signal: 'entries-replaced', callback: (_source: this) => void): number;
        emit(signal: 'entries-replaced'): void;
        connect(signal: 'entry-activated', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        connect_after(signal: 'entry-activated', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        emit(signal: 'entry-activated', entry: RhythmDBEntry): void;
        connect(signal: 'entry-added', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        connect_after(signal: 'entry-added', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        emit(signal: 'entry-added', entry: RhythmDBEntry): void;
        connect(signal: 'entry-deleted', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        connect_after(signal: 'entry-deleted', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        emit(signal: 'entry-deleted', entry: RhythmDBEntry): void;
        connect(signal: 'have-selection-changed', callback: (_source: this, have_selection: boolean) => void): number;
        connect_after(
            signal: 'have-selection-changed',
            callback: (_source: this, have_selection: boolean) => void,
        ): number;
        emit(signal: 'have-selection-changed', have_selection: boolean): void;
        connect(signal: 'selection-changed', callback: (_source: this) => void): number;
        connect_after(signal: 'selection-changed', callback: (_source: this) => void): number;
        emit(signal: 'selection-changed'): void;
        connect(signal: 'show-popup', callback: (_source: this, over_entry: boolean) => void): number;
        connect_after(signal: 'show-popup', callback: (_source: this, over_entry: boolean) => void): number;
        emit(signal: 'show-popup', over_entry: boolean): void;

        // Static methods

        /**
         * Returns a sample string for use in columns displaying times
         * and dates in 'friendly' form (see `rb_utf_friendly_time)`.
         * For use with `rb_entry_view_set_fixed_column_width`.
         */
        static get_time_date_column_sample(): string;

        // Virtual methods

        vfunc_entries_replaced(): void;
        vfunc_entry_activated(entry: RhythmDBEntry): void;
        vfunc_entry_added(entry: RhythmDBEntry): void;
        vfunc_entry_deleted(entry: RhythmDBEntry): void;
        vfunc_have_selection_changed(have_selection: boolean): void;
        vfunc_selection_changed(): void;
        vfunc_show_popup(over_entry: boolean): void;

        // Methods

        /**
         * Appends a predefined column type to the set of columns already present
         * in the entry view.  If `always_visible` is TRUE, the column will ignore
         * the user's coulmn visibility settings and will always be visible.
         * This should only be used when it is vital for the purpose of the
         * source that the column be visible.
         * @param coltype type of column to append
         * @param always_visible if TRUE, ignore the user's column visibility settings
         */
        append_column(coltype: EntryViewColumn | null, always_visible: boolean): void;
        /**
         * Appends a custom column to the entry view.
         * @param column a #GtkTreeViewColumn to append
         * @param title title for the column (translated)
         * @param key sort key for the column (not translated)
         * @param sort_func comparison function to use for sorting on the column
         */
        append_column_custom(
            column: Gtk.TreeViewColumn,
            title: string,
            key: string,
            sort_func: GLib.CompareDataFunc,
        ): void;
        /**
         * Enables the entry view to act as a data source for drag an drop operations,
         * using a specified set of data targets.
         * @param targets an array of #GtkTargetEntry structures defining the drag data targets
         * @param n_targets the number of entries in the target array
         */
        enable_drag_source(targets: Gtk.TargetEntry, n_targets: number): void;
        /**
         * Retrieves a predefined column from the entry view.  This can be used
         * to insert additional cell renderers into the column.
         * @param coltype type of column to retrieve
         * @returns a #GtkTreeViewColumn instance, or NULL
         */
        get_column(coltype: EntryViewColumn | null): Gtk.TreeViewColumn;
        /**
         * Determines whether a specified entry is present in the view.
         * @param entry a #RhythmDBEntry to check
         * @returns TRUE if the entry is present in the view
         */
        get_entry_contained(entry: RhythmDBEntry): boolean;
        /**
         * Determines whether a specified entry is present in the view
         * and is currently visible.
         * @param entry a #RhythmDBEntry to check
         * @returns TRUE if the entry is visible
         */
        get_entry_visible(entry: RhythmDBEntry): boolean;
        /**
         * Gathers the selected entries from the view.
         * @returns a #GList of selected entries in the view.
         */
        get_selected_entries(): RhythmDBEntry[];
        /**
         * Retrieves the sort settings for the view.
         */
        get_sorting_order(): [string, number];
        /**
         * Constructs a string that describes the sort settings for the entry view.
         * This consists of a column name and an order ('ascending' or 'descending')
         * separated by a comma.
         * @returns sort order description
         */
        get_sorting_type(): string;
        /**
         * Determines whether all entries in the view are selected.
         * @returns TRUE if all rows in the view are selected
         */
        have_complete_selection(): boolean;
        /**
         * Determines whether there is an active selection in the view.
         * @returns TRUE if one or more rows are selected
         */
        have_selection(): boolean;
        /**
         * Inserts a custom column at the specified position.
         * @param column a #GtkTreeViewColumn to append
         * @param title title for the column (translated)
         * @param key sort key for the column (not translated)
         * @param sort_func comparison function to use for sorting on the column
         * @param position position at which to insert the column (-1 to insert at the end)
         */
        insert_column_custom(
            column: Gtk.TreeViewColumn,
            title: string,
            key: string,
            sort_func: GLib.CompareDataFunc,
            position: number,
        ): void;
        /**
         * Resorts the entries in the entry view.  Mostly to be used
         * when a new model is associated with the view.
         */
        resort_model(): void;
        /**
         * If the specified entry is present in the view, the view will be
         * scrolled so that the entry is visible.
         * @param entry a #RhythmDBEntry to scroll to
         */
        scroll_to_entry(entry: RhythmDBEntry): void;
        /**
         * Selects all rows in the view
         */
        select_all(): void;
        /**
         * If the specified entry is present in the view, it is added
         * to the selection.
         * @param entry a #RhythmDBEntry to select
         */
        select_entry(entry: RhythmDBEntry): void;
        /**
         * Deselects all rows in the view.
         */
        select_none(): void;
        /**
         * Enables in-place editing of the values in a column.
         * The underlying %RhythmDBEntry is updated when editing is complete.
         * @param column a #RBEntryViewColumn to update
         * @param editable %TRUE to make the column editable, %FALSE otherwise
         */
        set_column_editable(column: EntryViewColumn | null, editable: boolean): void;
        /**
         * Makes the headers for sortable columns (those for which a sort function was
         * provided) clickable, so the user can set the sort order.
         * @param clickable if TRUE, sortable columns will be made clickable
         */
        set_columns_clickable(clickable: boolean): void;
        /**
         * Helper function for calling `rb_set_tree_view_column_fixed_width` on
         * a column.  This is important for performance reasons, as having the
         * tree view measure the strings in each of 20000 rows is very slow.
         * @param column the column to set the width for
         * @param renderer a temporary cell renderer to use
         * @param strings a NULL-terminated array of strings that will be displayed in the column
         */
        set_fixed_column_width(column: Gtk.TreeViewColumn, renderer: Gtk.CellRenderer, strings: string[]): void;
        /**
         * Replaces the model backing the entry view.
         * @param model the new #RhythmDBQueryModel to use for the view
         */
        set_model(model: RhythmDBQueryModel): void;
        /**
         * Sets the sort order for the entry view.
         * @param column_name name of the column to sort on
         * @param sort_order order to sort in, as a #GtkSortType
         */
        set_sorting_order(column_name: string, sort_order: number): void;
        /**
         * Changes the sort order for the entry view.  The sort order
         * description must be a column name, followed by a comma, followed
         * by an order description ('ascending' or 'descending').
         * @param sorttype sort order description
         */
        set_sorting_type(sorttype: string): void;
        /**
         * Sets the icon to be drawn in the 'playing' column next to the
         * current playing entry.  RB_ENTRY_VIEW_PLAYING and RB_ENTRY_VIEW_PAUSED
         * should be used when the source containing the entry view is playing,
         * and RB_ENTRY_VIEW_NOT_PLAYING otherwise.
         * @param state the new playing entry state
         */
        set_state(state: EntryViewState | null): void;
        // Conflicted with Gtk.Widget.set_state
        set_state(...args: never[]): any;
        /**
         * Sets the status text to be displayed inside the entry view, and
         * shows the spinner if busy.
         * @param status status text to display, or NULL
         * @param busy whether the source is busy
         */
        set_status(status: string, busy: boolean): void;

        // Inherited properties
        /**
         * The orientation of the orientable.
         */
        get orientation(): Gtk.Orientation;
        set orientation(val: Gtk.Orientation);

        // Inherited methods
        /**
         * Retrieves the orientation of the `orientable`.
         * @returns the orientation of the @orientable.
         */
        get_orientation(): Gtk.Orientation;
        /**
         * Sets the orientation of the `orientable`.
         * @param orientation the orientable’s new orientation.
         */
        set_orientation(orientation: Gtk.Orientation | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace ExtDB {
        // Signal callback interfaces

        interface Added {
            (key: ExtDBKey, filename: string, data: GObject.Value | any): void;
        }

        interface Load {
            (data: GObject.Value | any): any | null;
        }

        interface Request {
            (key: ExtDBKey, last_time: number): boolean;
        }

        interface Store {
            (data: GObject.Value | any): any | null;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            name: string;
        }
    }

    class ExtDB extends GObject.Object {
        static $gtype: GObject.GType<ExtDB>;

        // Properties

        /**
         * Name of the metadata store.  Used to locate instances.
         */
        get name(): string;

        // Constructors

        constructor(properties?: Partial<ExtDB.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](name: string): ExtDB;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'added',
            callback: (_source: this, key: ExtDBKey, filename: string, data: GObject.Value) => void,
        ): number;
        connect_after(
            signal: 'added',
            callback: (_source: this, key: ExtDBKey, filename: string, data: GObject.Value) => void,
        ): number;
        emit(signal: 'added', key: ExtDBKey, filename: string, data: GObject.Value | any): void;
        connect(signal: 'load', callback: (_source: this, data: GObject.Value) => any | null): number;
        connect_after(signal: 'load', callback: (_source: this, data: GObject.Value) => any | null): number;
        emit(signal: 'load', data: GObject.Value | any): void;
        connect(signal: 'request', callback: (_source: this, key: ExtDBKey, last_time: number) => boolean): number;
        connect_after(
            signal: 'request',
            callback: (_source: this, key: ExtDBKey, last_time: number) => boolean,
        ): number;
        emit(signal: 'request', key: ExtDBKey, last_time: number): void;
        connect(signal: 'store', callback: (_source: this, data: GObject.Value) => any | null): number;
        connect_after(signal: 'store', callback: (_source: this, data: GObject.Value) => any | null): number;
        emit(signal: 'store', data: GObject.Value | any): void;

        // Virtual methods

        vfunc_added(key: ExtDBKey, filename: string, data: GObject.Value | any): void;
        vfunc_load(data: GObject.Value | any): unknown;
        vfunc_request(key: ExtDBKey, last_time: number): boolean;
        vfunc_store(data: GObject.Value | any): unknown;

        // Methods

        /**
         * Deletes the item stored in the metadata store under the specified storage key.
         * @param key metadata storage key
         */
        ['delete'](key: ExtDBKey): void;
        /**
         * Looks up a cached metadata item.
         * @param key metadata lookup key
         * @returns name of the file storing the cached metadata item
         */
        lookup(key: ExtDBKey): [string, ExtDBKey | null];
        /**
         * Requests a metadata item.  If the item is cached, the callback will be called
         * synchronously.  Otherwise, metadata providers will provide results asynchronously.
         * @param key metadata lookup key
         * @param callback callback to call with results
         * @returns %TRUE if results may be provided after returning
         */
        request(key: ExtDBKey, callback: ExtDBRequestCallback): boolean;
        /**
         * Stores an item in the metadata store so that lookups matching `key` will
         * return it.  `data` should contain an object that must be transformed using
         * the RBExtDB::store signal before being stored.  For example,
         * the album art cache expects #GdkPixbuf objects here, rather than buffers
         * containing JPEG encoded files.
         * @param key metadata storage key
         * @param source_type metadata source type
         * @param data data to store
         */
        store(key: ExtDBKey, source_type: ExtDBSourceType | null, data?: GObject.Value | null): void;
        /**
         * Stores an item in the metadata store so that lookpus matching `key`
         * will return it.  `data` should contain the data to be written to the
         * store, either as a string or as a #GByteArray.
         * @param key metadata storage key
         * @param source_type metadata source type
         * @param data data to store
         */
        store_raw(key: ExtDBKey, source_type: ExtDBSourceType | null, data?: GObject.Value | null): void;
        /**
         * Stores an item identified by `uri` in the metadata store so that
         * lookups matching `key` will return it.
         * @param key metadata storage key
         * @param source_type metadata source type
         * @param uri URI of the item to store
         */
        store_uri(key: ExtDBKey, source_type: ExtDBSourceType | null, uri?: string | null): void;
    }

    namespace FadingImage {
        // Signal callback interfaces

        interface PixbufDropped {
            (pixbuf: GdkPixbuf.Pixbuf): void;
        }

        interface UriDropped {
            (uri: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps {
            fallback: string;
            use_tooltip: boolean;
            useTooltip: boolean;
        }
    }

    class FadingImage extends Gtk.Widget implements Atk.ImplementorIface, Gtk.Buildable {
        static $gtype: GObject.GType<FadingImage>;

        // Properties

        /**
         * Name of an icon to display when no image is available.
         */
        get fallback(): string;
        /**
         * Whether to display a tooltip on the image
         */
        get use_tooltip(): boolean;
        /**
         * Whether to display a tooltip on the image
         */
        get useTooltip(): boolean;

        // Constructors

        constructor(properties?: Partial<FadingImage.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'pixbuf-dropped', callback: (_source: this, pixbuf: GdkPixbuf.Pixbuf) => void): number;
        connect_after(signal: 'pixbuf-dropped', callback: (_source: this, pixbuf: GdkPixbuf.Pixbuf) => void): number;
        emit(signal: 'pixbuf-dropped', pixbuf: GdkPixbuf.Pixbuf): void;
        connect(signal: 'uri-dropped', callback: (_source: this, uri: string) => void): number;
        connect_after(signal: 'uri-dropped', callback: (_source: this, uri: string) => void): number;
        emit(signal: 'uri-dropped', uri: string): void;

        // Methods

        /**
         * Sets the next image to be displayed.
         * @param pixbuf the next pixbuf to display
         */
        set_pixbuf(pixbuf?: GdkPixbuf.Pixbuf | null): void;
        /**
         * Starts fading to the next image.  If no next image has been supplied,
         * the fallback image will be used instead.  If the next image has been
         * supplied, but has not finished loading yet, the fade will be delayed
         * until it finishes.  If the previous fade has not yet finished,
         * something tricky happens.
         * @param duration length of fade in milliseconds
         */
        start(duration: number): void;

        // Inherited methods
        /**
         * Adds a child to `buildable`. `type` is an optional string
         * describing how the child should be added.
         * @param builder a #GtkBuilder
         * @param child child to add
         * @param type kind of child or %NULL
         */
        add_child(builder: Gtk.Builder, child: GObject.Object, type?: string | null): void;
        /**
         * Constructs a child of `buildable` with the name `name`.
         *
         * #GtkBuilder calls this function if a “constructor” has been
         * specified in the UI definition.
         * @param builder #GtkBuilder used to construct this object
         * @param name name of child to construct
         * @returns the constructed child
         */
        construct_child<T = GObject.Object>(builder: Gtk.Builder, name: string): T;
        /**
         * This is similar to gtk_buildable_parser_finished() but is
         * called once for each custom tag handled by the `buildable`.
         * @param builder a #GtkBuilder
         * @param child child object or %NULL for non-child tags
         * @param tagname the name of the tag
         * @param data user data created in custom_tag_start
         */
        custom_finished(builder: Gtk.Builder, child: GObject.Object | null, tagname: string, data?: any | null): void;
        /**
         * This is called at the end of each custom element handled by
         * the buildable.
         * @param builder #GtkBuilder used to construct this object
         * @param child child object or %NULL for non-child tags
         * @param tagname name of tag
         * @param data user data that will be passed in to parser functions
         */
        custom_tag_end(builder: Gtk.Builder, child: GObject.Object | null, tagname: string, data?: any | null): void;
        /**
         * This is called for each unknown element under `<child>`.
         * @param builder a #GtkBuilder used to construct this object
         * @param child child object or %NULL for non-child tags
         * @param tagname name of tag
         * @returns %TRUE if a object has a custom implementation, %FALSE          if it doesn't.
         */
        custom_tag_start(
            builder: Gtk.Builder,
            child: GObject.Object | null,
            tagname: string,
        ): [boolean, GLib.MarkupParser, any];
        /**
         * Get the internal child called `childname` of the `buildable` object.
         * @param builder a #GtkBuilder
         * @param childname name of child
         * @returns the internal child of the buildable object
         */
        get_internal_child<T = GObject.Object>(builder: Gtk.Builder, childname: string): T;
        /**
         * Gets the name of the `buildable` object.
         *
         * #GtkBuilder sets the name based on the
         * [GtkBuilder UI definition][BUILDER-UI]
         * used to construct the `buildable`.
         * @returns the name set with gtk_buildable_set_name()
         */
        get_name(): string;
        /**
         * Called when the builder finishes the parsing of a
         * [GtkBuilder UI definition][BUILDER-UI].
         * Note that this will be called once for each time
         * gtk_builder_add_from_file() or gtk_builder_add_from_string()
         * is called on a builder.
         * @param builder a #GtkBuilder
         */
        parser_finished(builder: Gtk.Builder): void;
        /**
         * Sets the property name `name` to `value` on the `buildable` object.
         * @param builder a #GtkBuilder
         * @param name name of property
         * @param value value of property
         */
        set_buildable_property(builder: Gtk.Builder, name: string, value: GObject.Value | any): void;
        /**
         * Sets the name of the `buildable` object.
         * @param name name to set
         */
        set_name(name: string): void;
        /**
         * Adds a child to `buildable`. `type` is an optional string
         * describing how the child should be added.
         * @param builder a #GtkBuilder
         * @param child child to add
         * @param type kind of child or %NULL
         */
        vfunc_add_child(builder: Gtk.Builder, child: GObject.Object, type?: string | null): void;
        /**
         * Constructs a child of `buildable` with the name `name`.
         *
         * #GtkBuilder calls this function if a “constructor” has been
         * specified in the UI definition.
         * @param builder #GtkBuilder used to construct this object
         * @param name name of child to construct
         */
        vfunc_construct_child<T = GObject.Object>(builder: Gtk.Builder, name: string): T;
        /**
         * This is similar to gtk_buildable_parser_finished() but is
         * called once for each custom tag handled by the `buildable`.
         * @param builder a #GtkBuilder
         * @param child child object or %NULL for non-child tags
         * @param tagname the name of the tag
         * @param data user data created in custom_tag_start
         */
        vfunc_custom_finished(
            builder: Gtk.Builder,
            child: GObject.Object | null,
            tagname: string,
            data?: any | null,
        ): void;
        /**
         * This is called at the end of each custom element handled by
         * the buildable.
         * @param builder #GtkBuilder used to construct this object
         * @param child child object or %NULL for non-child tags
         * @param tagname name of tag
         * @param data user data that will be passed in to parser functions
         */
        vfunc_custom_tag_end(
            builder: Gtk.Builder,
            child: GObject.Object | null,
            tagname: string,
            data?: any | null,
        ): void;
        /**
         * This is called for each unknown element under `<child>`.
         * @param builder a #GtkBuilder used to construct this object
         * @param child child object or %NULL for non-child tags
         * @param tagname name of tag
         */
        vfunc_custom_tag_start(
            builder: Gtk.Builder,
            child: GObject.Object | null,
            tagname: string,
        ): [boolean, GLib.MarkupParser, any];
        /**
         * Get the internal child called `childname` of the `buildable` object.
         * @param builder a #GtkBuilder
         * @param childname name of child
         */
        vfunc_get_internal_child<T = GObject.Object>(builder: Gtk.Builder, childname: string): T;
        /**
         * Gets the name of the `buildable` object.
         *
         * #GtkBuilder sets the name based on the
         * [GtkBuilder UI definition][BUILDER-UI]
         * used to construct the `buildable`.
         */
        vfunc_get_name(): string;
        /**
         * Called when the builder finishes the parsing of a
         * [GtkBuilder UI definition][BUILDER-UI].
         * Note that this will be called once for each time
         * gtk_builder_add_from_file() or gtk_builder_add_from_string()
         * is called on a builder.
         * @param builder a #GtkBuilder
         */
        vfunc_parser_finished(builder: Gtk.Builder): void;
        /**
         * Sets the property name `name` to `value` on the `buildable` object.
         * @param builder a #GtkBuilder
         * @param name name of property
         * @param value value of property
         */
        vfunc_set_buildable_property(builder: Gtk.Builder, name: string, value: GObject.Value | any): void;
        /**
         * Sets the name of the `buildable` object.
         * @param name name to set
         */
        vfunc_set_name(name: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace History {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            maximum_size: number;
            maximumSize: number;
            truncate_on_play: boolean;
            truncateOnPlay: boolean;
        }
    }

    class History extends GObject.Object {
        static $gtype: GObject.GType<History>;

        // Properties

        /**
         * Maximum number of entries to store in the history.  If 0, no limit is applied.
         */
        get maximum_size(): number;
        set maximum_size(val: number);
        /**
         * Maximum number of entries to store in the history.  If 0, no limit is applied.
         */
        get maximumSize(): number;
        set maximumSize(val: number);
        /**
         * If set, rb_history_set_playing() truncates the rest of the history
         */
        get truncate_on_play(): boolean;
        set truncate_on_play(val: boolean);
        /**
         * If set, rb_history_set_playing() truncates the rest of the history
         */
        get truncateOnPlay(): boolean;
        set truncateOnPlay(val: boolean);

        // Constructors

        constructor(properties?: Partial<History.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](truncate_on_play: boolean, destroyer: GLib.Func): History;

        // Methods

        /**
         * Adds a new entry to the end of the history list.
         * If a size limit is set, an entry may be removed from the start to
         * keep the history list within the limit.
         * @param entry a #RhythmDBEntry to append
         */
        append(entry: RhythmDBEntry): void;
        /**
         * Empties the history list.
         */
        clear(): void;
        /**
         * Returns %TRUE if the entry is present in the history list.
         * @param entry a #RhythmDBEntry to check for
         * @returns %TRUE if found
         */
        contains_entry(entry: RhythmDBEntry): boolean;
        /**
         * Returns the current #RhythmDBEntry, or NULL if there is no current position
         * @returns current entry or NULL
         */
        current(): RhythmDBEntry;
        /**
         * Constructs a copy of the whole history in order. Caller must free the result.
         * The caller does not own any references on the entries in the returned array.
         * Takes O(Nlog(N)) time.
         * @returns a copy of the history list
         */
        dump(): RhythmDBEntry[];
        /**
         * Returns the first entry in the history.
         * @returns first entry
         */
        first(): RhythmDBEntry;
        /**
         * Gets the index of the current entry. This is guaranteed to be < the
         * history's size, so if the history is empty, it returns -1.
         * @returns index of the current entry
         */
        get_current_index(): number;
        /**
         * Moves the current position to the first entry in the history
         */
        go_first(): void;
        /**
         * Moves the current position to the last entry in the history
         */
        go_last(): void;
        /**
         * Moves the current position to the next entry.  If the current position is
         * already at the end of the history, nothing happens.
         */
        go_next(): void;
        /**
         * Moves the current position to the previous entry.  If the current position is
         * already at the start of the history, nothing happens.
         */
        go_previous(): void;
        /**
         * Inserts `entry` at `index` within the history list. 0<=`index<`=size
         * @param entry a #RhythmDBEntry to insert
         * @param index position at which to insert @entry
         */
        insert_at_index(entry: RhythmDBEntry, index: number): void;
        /**
         * Returns the last #RhythmDBEntry in the history
         * @returns last entry
         */
        last(): RhythmDBEntry;
        /**
         * Returns the number of entries in the history.
         * @returns number of entries
         */
        length(): number;
        /**
         * Returns the #RhythmDBEntry after the current position
         * @returns next entry
         */
        next(): RhythmDBEntry;
        /**
         * Returns the #RhythmDBEntry before the current position.
         * @returns previous entry
         */
        previous(): RhythmDBEntry;
        /**
         * Removes the specified entry from the history list.
         * @param entry the #RhythmDBEntry to remove
         */
        remove_entry(entry: RhythmDBEntry): void;
        /**
         * Sets a new function to call when removing entries from the history.
         * @param destroyer function to call when removing an entry from the history
         */
        set_destroy_notify(destroyer: GLib.Func): void;
        /**
         * Sets the maximum-size property
         * @param maximum_size new maximum size of the history (or 0 for no limit)
         */
        set_maximum_size(maximum_size: number): void;
        /**
         * Updates the current position to point to the specified entry.
         * If the truncate-on-play property is set, this will remove all entries
         * after that.
         * @param entry the new playing #RhythmDBEntry
         */
        set_playing(entry: RhythmDBEntry): void;
        /**
         * Sets the 'truncate-on-play' property.
         * @param truncate_on_play Whether rb_history_set_playing() should truncate the history
         */
        set_truncate_on_play(truncate_on_play: boolean): void;
    }

    namespace LibraryBrowser {
        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Box.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {
            browser_views: string;
            browserViews: string;
            db: RhythmDB;
            entry_type: RhythmDBEntryType;
            entryType: RhythmDBEntryType;
            input_model: RhythmDBQueryModel;
            inputModel: RhythmDBQueryModel;
            output_model: RhythmDBQueryModel;
            outputModel: RhythmDBQueryModel;
        }
    }

    class LibraryBrowser extends Gtk.Box implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<LibraryBrowser>;

        // Properties

        /**
         * The set of browsers to display.
         */
        get browser_views(): string;
        set browser_views(val: string);
        /**
         * The set of browsers to display.
         */
        get browserViews(): string;
        set browserViews(val: string);
        /**
         * #RhythmDB instance
         */
        get db(): RhythmDB;
        /**
         * The type of entries to use in the browser.
         */
        get entry_type(): RhythmDBEntryType;
        /**
         * The type of entries to use in the browser.
         */
        get entryType(): RhythmDBEntryType;
        /**
         * This #RhythmDBQueryModel defines the set of entries that
         * the browser filters.  This property is not writeable.
         * To set a new input query model, use
         * #rb_library_browser_set_model.
         */
        get input_model(): RhythmDBQueryModel;
        /**
         * This #RhythmDBQueryModel defines the set of entries that
         * the browser filters.  This property is not writeable.
         * To set a new input query model, use
         * #rb_library_browser_set_model.
         */
        get inputModel(): RhythmDBQueryModel;
        /**
         * This #RhythmDBQueryModel contains the filtered set of
         * entries.  It is a subset of the entries contained in the
         * input model.  This should be used as the model backing
         * the source's entry view.
         *
         * Sources using this widget should connect to the notify
         * signal for this property, updating their entry view when
         * it changes.
         */
        get output_model(): RhythmDBQueryModel;
        /**
         * This #RhythmDBQueryModel contains the filtered set of
         * entries.  It is a subset of the entries contained in the
         * input model.  This should be used as the model backing
         * the source's entry view.
         *
         * Sources using this widget should connect to the notify
         * signal for this property, updating their entry view when
         * it changes.
         */
        get outputModel(): RhythmDBQueryModel;

        // Constructors

        constructor(properties?: Partial<LibraryBrowser.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](db: RhythmDB, entry_type: RhythmDBEntryType): LibraryBrowser;
        // Conflicted with Gtk.Box.new

        static ['new'](...args: never[]): any;

        // Methods

        /**
         * Constructs a #RhythmDBQuery from the current selections in the browser.
         * @returns a #RhythmDBQuery constructed from the current selection.
         */
        construct_query(): RhythmDBQuery;
        /**
         * Retrieves the property view widget for the specified property,
         * if there is one.
         * @param type the property
         * @returns #RBPropertyView widget, or NULL
         */
        get_property_view(type: RhythmDBPropType | null): PropertyView;
        /**
         * Retrieves the property view widgets from the browser.
         * @returns a #GList containing the #RBPropertyView widgets in the browser.
         */
        get_property_views(): PropertyView[];
        /**
         * Determines whether the browser has an active selection.
         * @returns TRUE if any items in the browser are selected.
         */
        has_selection(): boolean;
        /**
         * Clears all selections in the browser.
         * @returns TRUE if anything was changed
         */
        reset(): boolean;
        /**
         * Specifies a new input query model for the browser.
         * This should be the query model constructed from the
         * current search text, or the basic query model for the
         * source if there is no search text.
         * @param model the new input #RhythmDBQueryModel
         * @param query_pending if TRUE, the caller promises to run a  query to populate the input query model.
         */
        set_model(model: RhythmDBQueryModel, query_pending: boolean): void;
        /**
         * Replaces any current selection for the specified property.
         * @param type the property for which to set the selection
         * @param selection a list of strings to select
         */
        set_selection(type: RhythmDBPropType | null, selection: string[]): void;

        // Inherited properties
        /**
         * The orientation of the orientable.
         */
        get orientation(): Gtk.Orientation;
        set orientation(val: Gtk.Orientation);

        // Inherited methods
        /**
         * Retrieves the orientation of the `orientable`.
         * @returns the orientation of the @orientable.
         */
        get_orientation(): Gtk.Orientation;
        /**
         * Sets the orientation of the `orientable`.
         * @param orientation the orientable’s new orientation.
         */
        set_orientation(orientation: Gtk.Orientation | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace ListModel {
        // Signal callback interfaces

        interface ItemsChanged {
            (object: number, p0: number, p1: number): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class ListModel extends GObject.Object {
        static $gtype: GObject.GType<ListModel>;

        // Constructors

        constructor(properties?: Partial<ListModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](item_type: GObject.GType): ListModel;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'items-changed',
            callback: (_source: this, object: number, p0: number, p1: number) => void,
        ): number;
        connect_after(
            signal: 'items-changed',
            callback: (_source: this, object: number, p0: number, p1: number) => void,
        ): number;
        emit(signal: 'items-changed', object: number, p0: number, p1: number): void;

        // Methods

        /**
         * Appends `item` to the list.
         * @param item item to append
         */
        append(item?: any | null): void;
        /**
         * Returns the lowest index at which `item` appears in the list,
         * or -1 if the item is not in the list.
         * @param item item to find
         * @returns list index
         */
        find(item?: any | null): number;
        /**
         * Returns an item from the list.
         * @param index item to retrieve
         * @returns item at the specified index
         */
        get(index: number): any | null;
        /**
         * Returns the list entry type.
         * @returns list entry type
         */
        get_item_type(): GObject.GType;
        /**
         * Inserts at item into the list.  If `index` is less than zero or
         * greater than the length of the list, the item is appended to the
         * list.
         * @param index position to insert the item at
         * @param item item to insert
         */
        insert(index: number, item?: any | null): void;
        /**
         * Returns the length of the list.
         * @returns list length
         */
        n_items(): number;
        /**
         * Prepends `item` to the list.
         * @param item item to prepend
         */
        prepend(item?: any | null): void;
        /**
         * Removes the item at `index` from the list.
         * @param index index of the item to remove
         */
        remove(index: number): void;
        /**
         * Removes `item` from the list.  If the item appears in the
         * list multiple times, only the first instance is removed.
         * @param item item to remove
         */
        remove_item(item?: any | null): void;
    }

    namespace MediaPlayerEntryType {
        // Constructor properties interface

        interface ConstructorProps extends RhythmDBEntryType.ConstructorProps {
            key_prefix: string;
            keyPrefix: string;
            uri_prefix: string;
            uriPrefix: string;
        }
    }

    class MediaPlayerEntryType extends RhythmDBEntryType {
        static $gtype: GObject.GType<MediaPlayerEntryType>;

        // Properties

        get key_prefix(): string;
        get keyPrefix(): string;
        get uri_prefix(): string;
        get uriPrefix(): string;

        // Constructors

        constructor(properties?: Partial<MediaPlayerEntryType.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;
    }

    namespace MediaPlayerSource {
        // Constructor properties interface

        interface ConstructorProps
            extends BrowserSource.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {
            encoding_settings: Gio.Settings;
            encodingSettings: Gio.Settings;
            encoding_target: GstPbutils.EncodingTarget;
            encodingTarget: GstPbutils.EncodingTarget;
            serial: string;
        }
    }

    class MediaPlayerSource extends BrowserSource implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<MediaPlayerSource>;

        // Properties

        /**
         * The #GSettings instance holding encoding settings for this device
         */
        get encoding_settings(): Gio.Settings;
        set encoding_settings(val: Gio.Settings);
        /**
         * The #GSettings instance holding encoding settings for this device
         */
        get encodingSettings(): Gio.Settings;
        set encodingSettings(val: Gio.Settings);
        /**
         * The #GstEncodingTarget for this device
         */
        get encoding_target(): GstPbutils.EncodingTarget;
        set encoding_target(val: GstPbutils.EncodingTarget);
        /**
         * The #GstEncodingTarget for this device
         */
        get encodingTarget(): GstPbutils.EncodingTarget;
        set encodingTarget(val: GstPbutils.EncodingTarget);
        get serial(): string;

        // Constructors

        constructor(properties?: Partial<MediaPlayerSource.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        vfunc_delete_entries(entries: RhythmDBEntry[], callback?: Gio.AsyncReadyCallback<this> | null): void;
        vfunc_get_capacity(): number;
        vfunc_get_entries(category: string, map: { [key: string]: any } | GLib.HashTable<string, RhythmDBEntry>): void;
        vfunc_get_free_space(): number;
        vfunc_remove_playlists(): void;
        vfunc_show_properties(info_box: Gtk.Widget, notebook: Gtk.Widget): void;

        // Methods

        delete_entries(entries: RhythmDBEntry[], callback?: Gio.AsyncReadyCallback<this> | null): void;
        get_capacity(): number;
        get_entries(category: string, map: { [key: string]: any } | GLib.HashTable<string, RhythmDBEntry>): void;
        get_free_space(): number;
        load(): void;
        purge_metadata_cache(): void;
        show_properties(): void;
        sync(): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace MetaData {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class MetaData extends GObject.Object {
        static $gtype: GObject.GType<MetaData>;

        // Constructors

        constructor(properties?: Partial<MetaData.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): MetaData;

        // Static methods

        /**
         * Returns the name of a metadata field.
         * @param field a #RBMetaDataField
         */
        static get_field_name(field: MetaDataField): string;
        /**
         * Returns the #GType of the value for a metadata field.
         * @param field a #RBMetaDataField
         */
        static get_field_type(field: MetaDataField): GObject.GType;

        // Methods

        /**
         * Checks if the metadata writer is capable of updating file metadata
         * for a given media type.
         * @param media_type the media type string to check
         * @returns TRUE if the file metadata for the given media type can be updated
         */
        can_save(media_type: string): boolean;
        /**
         * Retrieves the value of a metadata field extracted from the target URI.
         * If the target URI contained no value for the field, returns FALSE.
         * @param field the #RBMetaDataField to retrieve
         * @returns TRUE if a value was returned
         */
        get(field: MetaDataField | null): [boolean, unknown];
        /**
         * Returns the type of the file from which metadata was read.
         * This may look like a MIME type, but it isn't.
         * @returns media type string
         */
        get_media_type(): string;
        /**
         * This function returns the information used to request automatic
         * installation of media framework plugins required to decode the target URI.
         * Use g_strfreev() to free the returned information arrays.
         * @returns TRUE if missing plugin information was returned
         */
        get_missing_plugins(): [boolean, string[], string[]];
        /**
         * Constructs a list of the media types for which the metadata backend
         * implements tag saving.
         * @returns a NULL-terminated array of media type strings.  Use g_strfreev to free it.
         */
        get_saveable_types(): string[];
        has_audio(): boolean;
        /**
         * If the metadata reader could not decode the file it was asked to
         * because one or more media framework plugins (specifically, for the
         * existing implementations, GStreamer plugins) required are missing,
         * this will return TRUE.
         * @returns TRUE if required plugins are missing
         */
        has_missing_plugins(): boolean;
        has_other_data(): boolean;
        has_video(): boolean;
        /**
         * Reads metadata information from the specified URI.
         * Once this has returned successfully (with *error == NULL),
         * rb_metadata_get, rb_metadata_get_media_type, rb_metadata_has_missing_plugins,
         * and rb_metadata_get_missing_plugins can usefully be called.
         * @param uri URI from which to load metadata
         */
        load(uri: string): void;
        /**
         * Resets the state of the metadata interface.  Call this before
         * setting tags to be written to a file.
         */
        reset(): void;
        /**
         * Saves all metadata changes made with rb_metadata_set to the
         * target URI.
         * @param uri the target URI
         */
        save(uri: string): void;
        /**
         * Sets a metadata field value.  The value is only stored inside the
         * #RBMetaData object until rb_metadata_save is called.
         * @param field the #RBMetaDataField to set
         * @param val the value to set
         * @returns TRUE if the field is valid
         */
        set(field: MetaDataField | null, val: GObject.Value | any): boolean;
        // Conflicted with GObject.Object.set
        set(...args: never[]): any;
    }

    namespace PlayOrder {
        // Signal callback interfaces

        interface HaveNextPreviousChanged {
            (have_next: boolean, have_previous: boolean): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            player: ShellPlayer;
            playing_entry: RhythmDBEntry;
            playingEntry: RhythmDBEntry;
        }
    }

    class PlayOrder extends GObject.Object {
        static $gtype: GObject.GType<PlayOrder>;

        // Properties

        /**
         * The #RBShellPlayer instance
         */
        get player(): ShellPlayer;
        /**
         * The current playing #RhythmDBEntry
         */
        get playing_entry(): RhythmDBEntry;
        set playing_entry(val: RhythmDBEntry);
        /**
         * The current playing #RhythmDBEntry
         */
        get playingEntry(): RhythmDBEntry;
        set playingEntry(val: RhythmDBEntry);

        // Constructors

        constructor(properties?: Partial<PlayOrder.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'have-next-previous-changed',
            callback: (_source: this, have_next: boolean, have_previous: boolean) => void,
        ): number;
        connect_after(
            signal: 'have-next-previous-changed',
            callback: (_source: this, have_next: boolean, have_previous: boolean) => void,
        ): number;
        emit(signal: 'have-next-previous-changed', have_next: boolean, have_previous: boolean): void;

        // Virtual methods

        vfunc_db_changed(new_db: RhythmDB): void;
        vfunc_db_entry_deleted(entry: RhythmDBEntry): void;
        vfunc_entry_added(entry: RhythmDBEntry): void;
        vfunc_entry_removed(entry: RhythmDBEntry): void;
        /**
         * Returns the next entry in the play order, or the first if not currently playing.
         */
        vfunc_get_next(): RhythmDBEntry;
        /**
         * Returns the previous entry in the play order, or NULL if not currently playing.
         */
        vfunc_get_previous(): RhythmDBEntry;
        /**
         * Moves to the next entry in the play order.  If not currently playing, sets the
         * first entry in the play order as the playing entry.
         */
        vfunc_go_next(): void;
        /**
         * Moves to the previous entry in the play order.  If not currently playing, does nothing.
         */
        vfunc_go_previous(): void;
        /**
         * If there is no current playing entry, returns true if the play order is non-empty.
         */
        vfunc_has_next(): boolean;
        /**
         * Returns %TRUE if there is an entry before the current entry in the play order.
         * If not currently playing, returns %FALSE.
         */
        vfunc_has_previous(): boolean;
        vfunc_have_next_previous_changed(have_next: boolean, have_previous: boolean): void;
        vfunc_playing_entry_changed(old_entry: RhythmDBEntry, new_entry: RhythmDBEntry): void;
        vfunc_playing_entry_removed(entry: RhythmDBEntry): void;
        vfunc_playing_source_changed(): void;
        /**
         * Updates the #RhythmDBQueryModel instance for the play order.
         * Called from the #RBSource notify signal handler, and also from
         * #rb_play_order_source_changed.  Subclasses should implement
         * query_model_changed() to make any necessary adjustments if they
         * store any state based on the contents of the #RhythmDBQueryModel.
         */
        vfunc_query_model_changed(): void;

        // Methods

        /**
         * Only for use by #RBPlayOrder subclasses.
         * @returns the #RhythmDB instance.
         */
        get_db(): RhythmDB;
        /**
         * Returns the next entry in the play order, or the first if not currently playing.
         * @returns next entry to play
         */
        get_next(): RhythmDBEntry;
        /**
         * Only for use by #RBPlayOrder subclasses.
         * @returns #RBShellPlayer instance
         */
        get_player(): ShellPlayer;
        /**
         * Returns the current playing entry in the play order.
         * @returns playing entry
         */
        get_playing_entry(): RhythmDBEntry;
        /**
         * Returns the previous entry in the play order, or NULL if not currently playing.
         * @returns previous entry
         */
        get_previous(): RhythmDBEntry;
        /**
         * Only for use by #RBPlayOrder subclasses.
         * @returns the active #RhythmDBQueryModel for the playing source.
         */
        get_query_model(): RhythmDBQueryModel;
        /**
         * Only for use by #RBPlayOrder subclasses.
         * @returns the playing #RBSource instance.
         */
        get_source(): Source;
        /**
         * Moves to the next entry in the play order.  If not currently playing, sets the
         * first entry in the play order as the playing entry.
         */
        go_next(): void;
        /**
         * Moves to the previous entry in the play order.  If not currently playing, does nothing.
         */
        go_previous(): void;
        /**
         * If there is no current playing entry, returns true if the play order is non-empty.
         * @returns true if there is an entry after the current playing entry in the play order.
         */
        has_next(): boolean;
        /**
         * Returns %TRUE if there is an entry before the current entry in the play order.
         * If not currently playing, returns %FALSE.
         * @returns %TRUE if previous entry exists
         */
        has_previous(): boolean;
        /**
         * Returns %TRUE if the #RhythmDBQueryModel is not empty.
         * Can be used to implement has_next and has_previous for play orders
         * that have no beginning or end.
         * @returns %TRUE if not empty
         */
        model_not_empty(): boolean;
        /**
         * Returns %TRUE if there is a current playing entry in the play order.
         * @returns %TRUE if playing
         */
        player_is_playing(): boolean;
        /**
         * Sets the playing #RBSource for the play order.  Should be called
         * by #RBShellPlayer when the active source changes.  Subclasses
         * should implement playing_source_changed() to make any necessary
         * changes.
         * @param source New playing #RBSource
         */
        playing_source_changed(source: Source): void;
        /**
         * Updates the #RhythmDBQueryModel instance for the play order.
         * Called from the #RBSource notify signal handler, and also from
         * #rb_play_order_source_changed.  Subclasses should implement
         * query_model_changed() to make any necessary adjustments if they
         * store any state based on the contents of the #RhythmDBQueryModel.
         */
        query_model_changed(): void;
        /**
         * Sets the playing entry in the play order.
         * @param entry The new playing entry (or NULL for none)
         */
        set_playing_entry(entry?: RhythmDBEntry | null): void;
    }

    namespace PlaylistManager {
        // Signal callback interfaces

        interface LoadFinish {
            (): void;
        }

        interface LoadStart {
            (): void;
        }

        interface PlaylistAdded {
            (source: GObject.Object): void;
        }

        interface PlaylistCreated {
            (source: GObject.Object): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            playlists_file: string;
            playlistsFile: string;
            shell: Shell;
            source: Source;
        }
    }

    class PlaylistManager extends GObject.Object {
        static $gtype: GObject.GType<PlaylistManager>;

        // Properties

        get playlists_file(): string;
        set playlists_file(val: string);
        get playlistsFile(): string;
        set playlistsFile(val: string);
        get shell(): Shell;
        set shell(val: Shell);
        get source(): Source;
        set source(val: Source);

        // Constructors

        constructor(properties?: Partial<PlaylistManager.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](shell: Shell, playlists_file: string): PlaylistManager;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'load-finish', callback: (_source: this) => void): number;
        connect_after(signal: 'load-finish', callback: (_source: this) => void): number;
        emit(signal: 'load-finish'): void;
        connect(signal: 'load-start', callback: (_source: this) => void): number;
        connect_after(signal: 'load-start', callback: (_source: this) => void): number;
        emit(signal: 'load-start'): void;
        connect(signal: 'playlist-added', callback: (_source: this, source: GObject.Object) => void): number;
        connect_after(signal: 'playlist-added', callback: (_source: this, source: GObject.Object) => void): number;
        emit(signal: 'playlist-added', source: GObject.Object): void;
        connect(signal: 'playlist-created', callback: (_source: this, source: GObject.Object) => void): number;
        connect_after(signal: 'playlist-created', callback: (_source: this, source: GObject.Object) => void): number;
        emit(signal: 'playlist-created', source: GObject.Object): void;

        // Static methods

        static error_quark(): GLib.Quark;

        // Virtual methods

        vfunc_load_finish(): void;
        vfunc_load_start(): void;
        vfunc_playlist_added(source: Source): void;
        vfunc_playlist_created(source: Source): void;

        // Methods

        /**
         * Adds an entry to the specified playlist.
         * Fails if no playlist with that name exists.
         * This is part of the playlist manager dbus interface.
         * @param name name of the playlist to add to
         * @param uri URI of the entry to add to the playlist
         * @returns TRUE if successful.
         */
        add_to_playlist(name: string, uri: string): boolean;
        /**
         * Creates a new static playlist source with the given name.
         * Will fail if a playlist with that name already exists.
         * This is part of the playlist manager dbus interface.
         * @param name name of the new playlist
         * @returns TRUE if successful.
         */
        create_static_playlist(name: string): boolean;
        /**
         * Deletes the specified playlist.  Will fail if no playlist with
         * that name exists. This is part of the playlist manager dbus interface.
         * @param name name of the playlist to delete
         * @returns TRUE if successful.
         */
        delete_playlist(name: string): boolean;
        /**
         * Saves the specified playlist to a file in either M3U or PLS format.
         * This is part of the playlist manager dbus interface.
         * @param name name of the playlist to export
         * @param uri playlist save location
         * @param m3u_format if TRUE, save in M3U format, otherwise save in PLS format
         * @returns TRUE if successful.
         */
        export_playlist(name: string, uri: string, m3u_format: boolean): boolean;
        /**
         * Allocates and returns an array containing the names of all local
         * playlists.  This is part of the playlist manager dbus interface.
         * @returns TRUE if successful.
         */
        get_playlist_names(): [boolean, string];
        /**
         * Returns a #GList containing all local playlist source objects.
         * @returns list of playlists
         */
        get_playlists(): Source[];
        /**
         * Loads the user's playlists, or if the playlist file does not exists,
         * reads the default playlist file.  Should be called only once on startup.
         */
        load_playlists(): void;
        /**
         * Creates a new playlist and adds it to the source list.
         * @param suggested_name optional name to use for the new playlist
         * @param automatic if TRUE, create an auto playlist
         * @returns the new playlist object.
         */
        new_playlist(suggested_name: string, automatic: boolean): Source;
        /**
         * Creates a new playlist based on selection data from gtk.
         * Used to implement playlist creation through drag and drop
         * to the source list.
         * @param data the #GtkSelectionData from which to create a playlist
         * @returns the new playlist.
         */
        new_playlist_from_selection_data(data: Gtk.SelectionData): Source;
        /**
         * Parses a playlist file, adding entries to the database and to a new
         * static playlist.  If the playlist file includes a title, the static
         * playlist created will have the same title.
         * @param uri URI of the playlist to load
         * @returns TRUE on success
         */
        parse_file(uri: string): boolean;
        /**
         * Removes an entry from the specified playlist.
         * Fails if no playlist with that name exists.
         * This is part of the playlist manager dbus interface.
         * @param name name of the playlist to remove from
         * @param uri URI of the entry to remove from the playlist
         * @returns TRUE if successful.
         */
        remove_from_playlist(name: string, uri: string): boolean;
        save_playlist_file(source: Source): void;
        /**
         * Saves the user's playlists.  If the force flag is
         * TRUE, the playlists will always be saved.  Otherwise, the playlists
         * will only be saved if a playlist has been created, modified, or deleted
         * since the last time the playlists were saved, and no save operation is
         * currently taking place.
         * @param force if TRUE, save playlists synchronously and unconditionally
         * @returns TRUE if a playlist save operation has been started
         */
        save_playlists(force: boolean): boolean;
        /**
         * Shuts down the playlist manager, making sure any outstanding playlist save
         * operation finishes.
         */
        shutdown(): void;
    }

    namespace PlaylistSource {
        // Constructor properties interface

        interface ConstructorProps
            extends Source.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {
            db: RhythmDB;
            dirty: boolean;
            is_local: boolean;
            isLocal: boolean;
        }
    }

    abstract class PlaylistSource extends Source implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<PlaylistSource>;

        // Properties

        /**
         * The #RhythmDB instance
         */
        get db(): RhythmDB;
        /**
         * Whether the playlist has been changed since it was last saved
         * to disk.
         */
        get dirty(): boolean;
        /**
         * Whether the playlist is attached to the local library.
         * Remote DAAP playlists, for example, are not local.
         */
        get is_local(): boolean;
        /**
         * Whether the playlist is attached to the local library.
         * Remote DAAP playlists, for example, are not local.
         */
        get isLocal(): boolean;

        // Constructors

        constructor(properties?: Partial<PlaylistSource.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_from_xml(shell: Shell, node: libxml2.NodePtr): PlaylistSource;

        // Virtual methods

        /**
         * Marks the playlist dirty.  This generally means that the playlist
         * will be saved to disk fairly soon, but the exact meaning can vary
         * between playlist types.
         */
        vfunc_mark_dirty(): void;
        vfunc_save_contents_to_xml(node: libxml2.NodePtr): void;
        vfunc_show_entry_view_popup(view: EntryView, over_entry: boolean): void;

        // Methods

        /**
         * Adds a URI to the playlist's entry map.  This is useful when the
         * URI is being added to the database, but no entry exists for it yet.
         * When the entry is created, it will be added to the query model.
         * @param location a URI to add
         * @returns TRUE if the URI was added to the entry map,  FALSE if it was already there.
         */
        add_to_map(location: string): boolean;
        /**
         * Returns the #RhythmDB instance.  The caller must not
         * unref the object once finished with it.
         * @returns the #RhythmDB instance
         */
        get_db(): RhythmDB;
        /**
         * Returns the current #RhythmDBQueryModel for the playlist.
         * The caller must not unref the object once finished with it.
         * @returns the current #RhythmDBQueryModel
         */
        get_query_model(): RhythmDBQueryModel;
        /**
         * Returns TRUE if the specified URI is in the playlist entry map
         * @param location a URI to check
         * @returns %TRUE if the URI is present
         */
        location_in_map(location: string): boolean;
        /**
         * Marks the playlist dirty.  This generally means that the playlist
         * will be saved to disk fairly soon, but the exact meaning can vary
         * between playlist types.
         */
        mark_dirty(): void;
        /**
         * Saves the playlist to an external file in a standard
         * format (M3U, PLS, or XSPF).
         * @param uri destination URI
         * @param export_type format to save in
         */
        save_playlist(uri: string, export_type: PlaylistExportType | null): void;
        /**
         * Converts the playlist to XML format, below the specified
         * parent node.
         * @param parent_node libxml node below which to save the playlist
         */
        save_to_xml(parent_node: libxml2.NodePtr): void;
        /**
         * Sets a new query model for the playlist.  This updates the
         * entry view to use the new query model and also updates the
         * source query-model property.
         *
         * This needs to be called when the playlist subclass
         * creates a new query model.
         * @param model the new #RhythmDBQueryModel
         */
        set_query_model(model: RhythmDBQueryModel): void;
        /**
         * Connects signal handlers and sets up drag and drop support for
         * an entry view to be used by a playlist source.  This only needs
         * to be called if the playlist subclass is creating a new entry view.
         * @param entry_view the new #RBEntryView to set up
         */
        setup_entry_view(entry_view: EntryView): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace PodcastManager {
        // Signal callback interfaces

        interface FeedUpdateStatus {
            (object: string, p0: PodcastFeedUpdateStatus, p1: string): void;
        }

        interface FinishDownload {
            (object: RhythmDBEntry, p0: GLib.Error): void;
        }

        interface StartDownload {
            (object: RhythmDBEntry): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            db: RhythmDB;
            updating: boolean;
        }
    }

    class PodcastManager extends GObject.Object {
        static $gtype: GObject.GType<PodcastManager>;

        // Properties

        get db(): RhythmDB;
        set db(val: RhythmDB);
        get updating(): boolean;

        // Constructors

        constructor(properties?: Partial<PodcastManager.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](db: RhythmDB): PodcastManager;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'feed-update-status',
            callback: (_source: this, object: string, p0: PodcastFeedUpdateStatus, p1: string) => void,
        ): number;
        connect_after(
            signal: 'feed-update-status',
            callback: (_source: this, object: string, p0: PodcastFeedUpdateStatus, p1: string) => void,
        ): number;
        emit(signal: 'feed-update-status', object: string, p0: PodcastFeedUpdateStatus, p1: string): void;
        connect(
            signal: 'finish-download',
            callback: (_source: this, object: RhythmDBEntry, p0: GLib.Error) => void,
        ): number;
        connect_after(
            signal: 'finish-download',
            callback: (_source: this, object: RhythmDBEntry, p0: GLib.Error) => void,
        ): number;
        emit(signal: 'finish-download', object: RhythmDBEntry, p0: GLib.Error): void;
        connect(signal: 'start-download', callback: (_source: this, object: RhythmDBEntry) => void): number;
        connect_after(signal: 'start-download', callback: (_source: this, object: RhythmDBEntry) => void): number;
        emit(signal: 'start-download', object: RhythmDBEntry): void;

        // Static methods

        static add_post(
            db: RhythmDB,
            search_result: boolean,
            entry: RhythmDBEntry,
            name: string,
            title: string,
            subtitle: string,
            generator: string,
            uri: string,
            description: string,
            guid: string,
            date: number,
            duration: number,
            position: number,
            filesize: number,
        ): RhythmDBEntry;
        static entry_downloaded(entry: RhythmDBEntry): boolean;

        // Methods

        add_parsed_feed(feed: PodcastChannel): void;
        add_search(search_type: GObject.GType): void;
        cancel_download(entry: RhythmDBEntry): boolean;
        delete_download(entry: RhythmDBEntry): void;
        download_entry(entry: RhythmDBEntry): void;
        entry_in_download_queue(entry: RhythmDBEntry): boolean;
        feed_updating(url: string): boolean;
        get_podcast_dir(): string;
        /**
         * Returns the list of podcast searches
         * @returns list of search instances
         */
        get_searches(): PodcastSearch[];
        insert_feed_url(url: string): void;
        remove_feed(url: string, remove_files: boolean): boolean;
        shutdown(): void;
        start_sync(): void;
        subscribe_feed(url: string, automatic: boolean): boolean;
        update_feeds(): void;
    }

    namespace PodcastSearch {
        // Signal callback interfaces

        interface Finished {
            (object: boolean): void;
        }

        interface Result {
            (object?: any | null): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class PodcastSearch extends GObject.Object {
        static $gtype: GObject.GType<PodcastSearch>;

        // Constructors

        constructor(properties?: Partial<PodcastSearch.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'finished', callback: (_source: this, object: boolean) => void): number;
        connect_after(signal: 'finished', callback: (_source: this, object: boolean) => void): number;
        emit(signal: 'finished', object: boolean): void;
        connect(signal: 'result', callback: (_source: this, object: any | null) => void): number;
        connect_after(signal: 'result', callback: (_source: this, object: any | null) => void): number;
        emit(signal: 'result', object?: any | null): void;

        // Virtual methods

        vfunc_cancel(): void;
        vfunc_start(text: string, max_results: number): void;

        // Methods

        cancel(): void;
        finished(successful: boolean): void;
        result(data: PodcastChannel): void;
        start(text: string, max_results: number): void;
    }

    namespace PodcastSearchITunes {
        // Constructor properties interface

        interface ConstructorProps extends PodcastSearch.ConstructorProps {}
    }

    class PodcastSearchITunes extends PodcastSearch {
        static $gtype: GObject.GType<PodcastSearchITunes>;

        // Constructors

        constructor(properties?: Partial<PodcastSearchITunes.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;
    }

    namespace PropertyView {
        // Signal callback interfaces

        interface PropertiesSelected {
            (properties?: any | null): void;
        }

        interface PropertyActivated {
            (name: string): void;
        }

        interface PropertySelected {
            (name: string): void;
        }

        interface PropertySelectionReset {
            (): void;
        }

        interface ShowPopup {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.ScrolledWindow.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps {
            db: RhythmDB;
            draggable: boolean;
            prop: RhythmDBPropType;
            property_model: RhythmDBPropertyModel;
            propertyModel: RhythmDBPropertyModel;
            title: string;
        }
    }

    class PropertyView extends Gtk.ScrolledWindow implements Atk.ImplementorIface, Gtk.Buildable {
        static $gtype: GObject.GType<PropertyView>;

        // Properties

        /**
         * #RhythmDB instance
         */
        get db(): RhythmDB;
        /**
         * Whether the property view acts as a data source for drag and drop operations.
         */
        get draggable(): boolean;
        /**
         * The property that is displayed in this view
         */
        get prop(): RhythmDBPropType;
        /**
         * The #RhythmDBPropertyModel backing the view.
         */
        get property_model(): RhythmDBPropertyModel;
        set property_model(val: RhythmDBPropertyModel);
        /**
         * The #RhythmDBPropertyModel backing the view.
         */
        get propertyModel(): RhythmDBPropertyModel;
        set propertyModel(val: RhythmDBPropertyModel);
        /**
         * The title displayed in the header of the property view
         */
        get title(): string;

        // Constructors

        constructor(properties?: Partial<PropertyView.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](db: RhythmDB, propid: number, title: string): PropertyView;
        // Conflicted with Gtk.ScrolledWindow.new

        static ['new'](...args: never[]): any;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'properties-selected', callback: (_source: this, properties: any | null) => void): number;
        connect_after(signal: 'properties-selected', callback: (_source: this, properties: any | null) => void): number;
        emit(signal: 'properties-selected', properties?: any | null): void;
        connect(signal: 'property-activated', callback: (_source: this, name: string) => void): number;
        connect_after(signal: 'property-activated', callback: (_source: this, name: string) => void): number;
        emit(signal: 'property-activated', name: string): void;
        connect(signal: 'property-selected', callback: (_source: this, name: string) => void): number;
        connect_after(signal: 'property-selected', callback: (_source: this, name: string) => void): number;
        emit(signal: 'property-selected', name: string): void;
        connect(signal: 'property-selection-reset', callback: (_source: this) => void): number;
        connect_after(signal: 'property-selection-reset', callback: (_source: this) => void): number;
        emit(signal: 'property-selection-reset'): void;
        connect(signal: 'show-popup', callback: (_source: this) => void): number;
        connect_after(signal: 'show-popup', callback: (_source: this) => void): number;
        emit(signal: 'show-popup'): void;

        // Virtual methods

        vfunc_property_activated(name: string): void;
        vfunc_property_selected(name: string): void;
        vfunc_selection_reset(): void;
        vfunc_show_popup(): void;

        // Methods

        /**
         * Appends a custom created column to the view.
         * @param column a #GtkTreeViewColumn to append to the view
         */
        append_column_custom(column: Gtk.TreeViewColumn): void;
        /**
         * Returns the #RhythmDBPropertyModel backing the view; no reference is taken
         * @returns property model
         */
        get_model(): RhythmDBPropertyModel;
        /**
         * Returns the number of property values present in the view.
         * @returns number of properties
         */
        get_num_properties(): number;
        /**
         * Returns a #GList containing the selected property values.  The list must
         * be freed by the caller.
         * @returns list of selected values
         */
        get_selection(): string[];
        /**
         * Clears the selection in the property view.
         */
        reset(): void;
        /**
         * Sets the visibility of the property column.
         * @param visible whether the property column should be visible
         */
        set_column_visible(visible: boolean): void;
        /**
         * Replaces the model backing the property view.
         * @param model the new #RhythmDBPropertyModel for the property view
         */
        set_model(model: RhythmDBPropertyModel): void;
        /**
         * Sets the compare function for the interactive search capabilities.
         * The function must return FALSE when the search key string matches
         * the row it is passed.
         * @param func tree view search function to use for this view
         */
        set_search_func(func: Gtk.TreeViewSearchEqualFunc): void;
        /**
         * Replaces the selection in the property view.  All values in the list
         * that are present in the view will be selected, and the view will be
         * scrolled to show the last value selected.
         * @param vals the values to be selected
         */
        set_selection(vals: string[]): void;
        /**
         * Sets the selection mode (single or multiple) for the property view>
         * The default selection mode is single.
         * @param mode the new #GtkSelectionMode for the property view
         */
        set_selection_mode(mode: Gtk.SelectionMode | null): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace Rating {
        // Signal callback interfaces

        interface AdjustRating {
            (adjust: number): void;
        }

        interface Rated {
            (score: number): void;
        }

        interface SetRating {
            (score: number): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps {
            rating: number;
        }
    }

    class Rating extends Gtk.Widget implements Atk.ImplementorIface, Gtk.Buildable {
        static $gtype: GObject.GType<Rating>;

        // Properties

        /**
         * The rating displayed in the widget, as a floating point value
         * between 0.0 and 5.0.
         */
        get rating(): number;
        set rating(val: number);

        // Constructors

        constructor(properties?: Partial<Rating.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Rating;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'adjust-rating', callback: (_source: this, adjust: number) => void): number;
        connect_after(signal: 'adjust-rating', callback: (_source: this, adjust: number) => void): number;
        emit(signal: 'adjust-rating', adjust: number): void;
        connect(signal: 'rated', callback: (_source: this, score: number) => void): number;
        connect_after(signal: 'rated', callback: (_source: this, score: number) => void): number;
        emit(signal: 'rated', score: number): void;
        connect(signal: 'set-rating', callback: (_source: this, score: number) => void): number;
        connect_after(signal: 'set-rating', callback: (_source: this, score: number) => void): number;
        emit(signal: 'set-rating', score: number): void;

        // Virtual methods

        vfunc_adjust_rating(adjust: number): boolean;
        vfunc_rated(score: number): void;
        vfunc_set_rating(score: number): boolean;

        // Inherited methods
        /**
         * Adds a child to `buildable`. `type` is an optional string
         * describing how the child should be added.
         * @param builder a #GtkBuilder
         * @param child child to add
         * @param type kind of child or %NULL
         */
        add_child(builder: Gtk.Builder, child: GObject.Object, type?: string | null): void;
        /**
         * Constructs a child of `buildable` with the name `name`.
         *
         * #GtkBuilder calls this function if a “constructor” has been
         * specified in the UI definition.
         * @param builder #GtkBuilder used to construct this object
         * @param name name of child to construct
         * @returns the constructed child
         */
        construct_child<T = GObject.Object>(builder: Gtk.Builder, name: string): T;
        /**
         * This is similar to gtk_buildable_parser_finished() but is
         * called once for each custom tag handled by the `buildable`.
         * @param builder a #GtkBuilder
         * @param child child object or %NULL for non-child tags
         * @param tagname the name of the tag
         * @param data user data created in custom_tag_start
         */
        custom_finished(builder: Gtk.Builder, child: GObject.Object | null, tagname: string, data?: any | null): void;
        /**
         * This is called at the end of each custom element handled by
         * the buildable.
         * @param builder #GtkBuilder used to construct this object
         * @param child child object or %NULL for non-child tags
         * @param tagname name of tag
         * @param data user data that will be passed in to parser functions
         */
        custom_tag_end(builder: Gtk.Builder, child: GObject.Object | null, tagname: string, data?: any | null): void;
        /**
         * This is called for each unknown element under `<child>`.
         * @param builder a #GtkBuilder used to construct this object
         * @param child child object or %NULL for non-child tags
         * @param tagname name of tag
         * @returns %TRUE if a object has a custom implementation, %FALSE          if it doesn't.
         */
        custom_tag_start(
            builder: Gtk.Builder,
            child: GObject.Object | null,
            tagname: string,
        ): [boolean, GLib.MarkupParser, any];
        /**
         * Get the internal child called `childname` of the `buildable` object.
         * @param builder a #GtkBuilder
         * @param childname name of child
         * @returns the internal child of the buildable object
         */
        get_internal_child<T = GObject.Object>(builder: Gtk.Builder, childname: string): T;
        /**
         * Gets the name of the `buildable` object.
         *
         * #GtkBuilder sets the name based on the
         * [GtkBuilder UI definition][BUILDER-UI]
         * used to construct the `buildable`.
         * @returns the name set with gtk_buildable_set_name()
         */
        get_name(): string;
        /**
         * Called when the builder finishes the parsing of a
         * [GtkBuilder UI definition][BUILDER-UI].
         * Note that this will be called once for each time
         * gtk_builder_add_from_file() or gtk_builder_add_from_string()
         * is called on a builder.
         * @param builder a #GtkBuilder
         */
        parser_finished(builder: Gtk.Builder): void;
        /**
         * Sets the property name `name` to `value` on the `buildable` object.
         * @param builder a #GtkBuilder
         * @param name name of property
         * @param value value of property
         */
        set_buildable_property(builder: Gtk.Builder, name: string, value: GObject.Value | any): void;
        /**
         * Sets the name of the `buildable` object.
         * @param name name to set
         */
        set_name(name: string): void;
        /**
         * Adds a child to `buildable`. `type` is an optional string
         * describing how the child should be added.
         * @param builder a #GtkBuilder
         * @param child child to add
         * @param type kind of child or %NULL
         */
        vfunc_add_child(builder: Gtk.Builder, child: GObject.Object, type?: string | null): void;
        /**
         * Constructs a child of `buildable` with the name `name`.
         *
         * #GtkBuilder calls this function if a “constructor” has been
         * specified in the UI definition.
         * @param builder #GtkBuilder used to construct this object
         * @param name name of child to construct
         */
        vfunc_construct_child<T = GObject.Object>(builder: Gtk.Builder, name: string): T;
        /**
         * This is similar to gtk_buildable_parser_finished() but is
         * called once for each custom tag handled by the `buildable`.
         * @param builder a #GtkBuilder
         * @param child child object or %NULL for non-child tags
         * @param tagname the name of the tag
         * @param data user data created in custom_tag_start
         */
        vfunc_custom_finished(
            builder: Gtk.Builder,
            child: GObject.Object | null,
            tagname: string,
            data?: any | null,
        ): void;
        /**
         * This is called at the end of each custom element handled by
         * the buildable.
         * @param builder #GtkBuilder used to construct this object
         * @param child child object or %NULL for non-child tags
         * @param tagname name of tag
         * @param data user data that will be passed in to parser functions
         */
        vfunc_custom_tag_end(
            builder: Gtk.Builder,
            child: GObject.Object | null,
            tagname: string,
            data?: any | null,
        ): void;
        /**
         * This is called for each unknown element under `<child>`.
         * @param builder a #GtkBuilder used to construct this object
         * @param child child object or %NULL for non-child tags
         * @param tagname name of tag
         */
        vfunc_custom_tag_start(
            builder: Gtk.Builder,
            child: GObject.Object | null,
            tagname: string,
        ): [boolean, GLib.MarkupParser, any];
        /**
         * Get the internal child called `childname` of the `buildable` object.
         * @param builder a #GtkBuilder
         * @param childname name of child
         */
        vfunc_get_internal_child<T = GObject.Object>(builder: Gtk.Builder, childname: string): T;
        /**
         * Gets the name of the `buildable` object.
         *
         * #GtkBuilder sets the name based on the
         * [GtkBuilder UI definition][BUILDER-UI]
         * used to construct the `buildable`.
         */
        vfunc_get_name(): string;
        /**
         * Called when the builder finishes the parsing of a
         * [GtkBuilder UI definition][BUILDER-UI].
         * Note that this will be called once for each time
         * gtk_builder_add_from_file() or gtk_builder_add_from_string()
         * is called on a builder.
         * @param builder a #GtkBuilder
         */
        vfunc_parser_finished(builder: Gtk.Builder): void;
        /**
         * Sets the property name `name` to `value` on the `buildable` object.
         * @param builder a #GtkBuilder
         * @param name name of property
         * @param value value of property
         */
        vfunc_set_buildable_property(builder: Gtk.Builder, name: string, value: GObject.Value | any): void;
        /**
         * Sets the name of the `buildable` object.
         * @param name name to set
         */
        vfunc_set_name(name: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace RemovableMediaManager {
        // Signal callback interfaces

        interface CreateSourceDevice {
            (device: GObject.Object): Source;
        }

        interface CreateSourceMount {
            (device_info: Gio.Mount, mount: MPID.Device): Source;
        }

        interface CreateSourceVolume {
            (volume: Gio.Volume): Source;
        }

        interface MediumAdded {
            (source: GObject.Object): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            scanned: boolean;
            shell: Shell;
        }
    }

    class RemovableMediaManager extends GObject.Object {
        static $gtype: GObject.GType<RemovableMediaManager>;

        // Properties

        /**
         * This is set to TRUE when the removable media manager has scanned
         * all existing volumes and mounts.  When a plugin that handles removable
         * media is activated, it should request a new scan if this property is
         * already set to TRUE.
         */
        get scanned(): boolean;
        /**
         * The #RBShell instance.
         */
        get shell(): Shell;

        // Constructors

        constructor(properties?: Partial<RemovableMediaManager.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](shell: Shell): RemovableMediaManager;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'create-source-device', callback: (_source: this, device: GObject.Object) => Source): number;
        connect_after(
            signal: 'create-source-device',
            callback: (_source: this, device: GObject.Object) => Source,
        ): number;
        emit(signal: 'create-source-device', device: GObject.Object): void;
        connect(
            signal: 'create-source-mount',
            callback: (_source: this, device_info: Gio.Mount, mount: MPID.Device) => Source,
        ): number;
        connect_after(
            signal: 'create-source-mount',
            callback: (_source: this, device_info: Gio.Mount, mount: MPID.Device) => Source,
        ): number;
        emit(signal: 'create-source-mount', device_info: Gio.Mount, mount: MPID.Device): void;
        connect(signal: 'create-source-volume', callback: (_source: this, volume: Gio.Volume) => Source): number;
        connect_after(signal: 'create-source-volume', callback: (_source: this, volume: Gio.Volume) => Source): number;
        emit(signal: 'create-source-volume', volume: Gio.Volume): void;
        connect(signal: 'medium-added', callback: (_source: this, source: GObject.Object) => void): number;
        connect_after(signal: 'medium-added', callback: (_source: this, source: GObject.Object) => void): number;
        emit(signal: 'medium-added', source: GObject.Object): void;

        // Virtual methods

        vfunc_medium_added(source: Source): void;

        // Methods

        /**
         * Determines whether the specified device looks like an Android device.
         * @param device the #GUdevDevice to query
         * @returns %TRUE if the device appears to be Android-based
         */
        device_is_android(device: GObject.Object): boolean;
        /**
         * Finds the #GUdevDevice for the volume.
         * @param volume the #GVolume
         * @returns the #GUDevDevice instance, if any
         */
        get_gudev_device<T = GObject.Object>(volume: Gio.Volume): T;
        /**
         * Initiates a new scan of all attached media.  Newly activated plugins that use
         * the create-source-volume or create-source-mount signals should call this if
         * the 'scanned' property is %TRUE.  Otherwise, the first scan will catch any
         * existing volumes or mounts that the plugin is interested in.
         */
        scan(): void;
    }

    namespace RhythmDB {
        // Signal callback interfaces

        interface CreateMountOp {
            (): Gio.MountOperation;
        }

        interface EntryAdded {
            (entry: RhythmDBEntry): void;
        }

        interface EntryChanged {
            (entry: RhythmDBEntry, changes: RhythmDBEntryChange[]): void;
        }

        interface EntryDeleted {
            (entry: RhythmDBEntry): void;
        }

        interface EntryExtraMetadataGather {
            (entry: RhythmDBEntry, data: StringValueMap): void;
        }

        interface EntryExtraMetadataNotify {
            (entry: RhythmDBEntry, field: string, metadata: GObject.Value | any): void;
        }

        interface EntryExtraMetadataRequest {
            (entry: RhythmDBEntry): GObject.Value;
        }

        interface EntryKeywordAdded {
            (entry: RhythmDBEntry, keyword: RefString): void;
        }

        interface EntryKeywordRemoved {
            (entry: RhythmDBEntry, keyword: RefString): void;
        }

        interface LoadComplete {
            (): void;
        }

        interface ReadOnly {
            (readonly: boolean): void;
        }

        interface SaveComplete {
            (): void;
        }

        interface SaveError {
            (uri: string, error?: any | null): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            dry_run: boolean;
            dryRun: boolean;
            name: string;
            no_update: boolean;
            noUpdate: boolean;
        }
    }

    /**
     * RhythmDB is an in-memory database containing #RhythmDBEntry items.  It
     * runs queries represented as #GPtrArray<!-- -->s containing query criteria,
     * feeding the results into #RhythmDBQueryResults implementations such as
     * #RhythmDBQueryModel.  From there, entries are grouped by particular property
     * values to form #RhythmDBPropertyModel<!-- -->s.
     *
     * #RhythmDBEntry contains a fixed set of properties, defined by #RhythmDBPropType,
     */
    abstract class RhythmDB extends GObject.Object {
        static $gtype: GObject.GType<RhythmDB>;

        // Properties

        /**
         * If %TRUE, no metadata changes will be written back to media fies.
         */
        get dry_run(): boolean;
        set dry_run(val: boolean);
        /**
         * If %TRUE, no metadata changes will be written back to media fies.
         */
        get dryRun(): boolean;
        set dryRun(val: boolean);
        /**
         * Database name.  Not sure whta this is used for.
         */
        get name(): string;
        set name(val: string);
        /**
         * If %TRUE, the database will not be updated.
         */
        get no_update(): boolean;
        set no_update(val: boolean);
        /**
         * If %TRUE, the database will not be updated.
         */
        get noUpdate(): boolean;
        set noUpdate(val: boolean);

        // Constructors

        constructor(properties?: Partial<RhythmDB.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'create-mount-op', callback: (_source: this) => Gio.MountOperation): number;
        connect_after(signal: 'create-mount-op', callback: (_source: this) => Gio.MountOperation): number;
        emit(signal: 'create-mount-op'): void;
        connect(signal: 'entry-added', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        connect_after(signal: 'entry-added', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        emit(signal: 'entry-added', entry: RhythmDBEntry): void;
        connect(
            signal: 'entry-changed',
            callback: (_source: this, entry: RhythmDBEntry, changes: RhythmDBEntryChange[]) => void,
        ): number;
        connect_after(
            signal: 'entry-changed',
            callback: (_source: this, entry: RhythmDBEntry, changes: RhythmDBEntryChange[]) => void,
        ): number;
        emit(signal: 'entry-changed', entry: RhythmDBEntry, changes: RhythmDBEntryChange[]): void;
        connect(signal: 'entry-deleted', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        connect_after(signal: 'entry-deleted', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        emit(signal: 'entry-deleted', entry: RhythmDBEntry): void;
        connect(
            signal: 'entry-extra-metadata-gather',
            callback: (_source: this, entry: RhythmDBEntry, data: StringValueMap) => void,
        ): number;
        connect_after(
            signal: 'entry-extra-metadata-gather',
            callback: (_source: this, entry: RhythmDBEntry, data: StringValueMap) => void,
        ): number;
        emit(signal: 'entry-extra-metadata-gather', entry: RhythmDBEntry, data: StringValueMap): void;
        connect(
            signal: 'entry-extra-metadata-notify',
            callback: (_source: this, entry: RhythmDBEntry, field: string, metadata: GObject.Value) => void,
        ): number;
        connect_after(
            signal: 'entry-extra-metadata-notify',
            callback: (_source: this, entry: RhythmDBEntry, field: string, metadata: GObject.Value) => void,
        ): number;
        emit(
            signal: 'entry-extra-metadata-notify',
            entry: RhythmDBEntry,
            field: string,
            metadata: GObject.Value | any,
        ): void;
        connect(
            signal: 'entry-extra-metadata-request',
            callback: (_source: this, entry: RhythmDBEntry) => GObject.Value,
        ): number;
        connect_after(
            signal: 'entry-extra-metadata-request',
            callback: (_source: this, entry: RhythmDBEntry) => GObject.Value,
        ): number;
        emit(signal: 'entry-extra-metadata-request', entry: RhythmDBEntry): void;
        connect(
            signal: 'entry-keyword-added',
            callback: (_source: this, entry: RhythmDBEntry, keyword: RefString) => void,
        ): number;
        connect_after(
            signal: 'entry-keyword-added',
            callback: (_source: this, entry: RhythmDBEntry, keyword: RefString) => void,
        ): number;
        emit(signal: 'entry-keyword-added', entry: RhythmDBEntry, keyword: RefString): void;
        connect(
            signal: 'entry-keyword-removed',
            callback: (_source: this, entry: RhythmDBEntry, keyword: RefString) => void,
        ): number;
        connect_after(
            signal: 'entry-keyword-removed',
            callback: (_source: this, entry: RhythmDBEntry, keyword: RefString) => void,
        ): number;
        emit(signal: 'entry-keyword-removed', entry: RhythmDBEntry, keyword: RefString): void;
        connect(signal: 'load-complete', callback: (_source: this) => void): number;
        connect_after(signal: 'load-complete', callback: (_source: this) => void): number;
        emit(signal: 'load-complete'): void;
        connect(signal: 'read-only', callback: (_source: this, readonly: boolean) => void): number;
        connect_after(signal: 'read-only', callback: (_source: this, readonly: boolean) => void): number;
        emit(signal: 'read-only', readonly: boolean): void;
        connect(signal: 'save-complete', callback: (_source: this) => void): number;
        connect_after(signal: 'save-complete', callback: (_source: this) => void): number;
        emit(signal: 'save-complete'): void;
        connect(signal: 'save-error', callback: (_source: this, uri: string, error: any | null) => void): number;
        connect_after(signal: 'save-error', callback: (_source: this, uri: string, error: any | null) => void): number;
        emit(signal: 'save-error', uri: string, error?: any | null): void;

        // Static methods

        /**
         * Creates a string containing the "status" information about a list of tracks.
         * The singular and plural strings must be used in a direct ngettext call
         * elsewhere in order for them to be marked for translation correctly.
         * @param n_songs the number of tracks.
         * @param duration the total duration of the tracks.
         * @param size the total size of the tracks.
         * @param singular singular form of the format string to use for entries (eg "%d song")
         * @param plural plural form of the format string to use for entries (eg "%d songs")
         */
        static compute_status_normal(
            n_songs: number,
            duration: number,
            size: number,
            singular: string,
            plural: string,
        ): string;
        /**
         * Returns the #GQuark used for #RhythmDBError information
         */
        static error_quark(): GLib.Quark;
        /**
         * Returns the #RhythmDBEntryType for import errors
         */
        static get_error_entry_type(): RhythmDBEntryType;
        /**
         * Returns the #RhythmDBEntryType for ignored files
         */
        static get_ignore_entry_type(): RhythmDBEntryType;
        /**
         * Returns the #RhythmDBEntryType for normal songs.
         */
        static get_song_entry_type(): RhythmDBEntryType;
        /**
         * Appends `query2` to `query1`.
         * @param query1 query to append to
         * @param query2 query to append
         */
        static query_concatenate(query1: RhythmDBQuery, query2: RhythmDBQuery): void;
        /**
         * Creates a copy of a query.
         * @param array the query to copy.
         */
        static query_copy(array: RhythmDBQuery): RhythmDBQuery;
        /**
         * Frees the query `query`
         * @param query a query.
         */
        static query_free(query: RhythmDBQuery): void;

        // Virtual methods

        vfunc_entry_added(entry: RhythmDBEntry): void;
        vfunc_entry_deleted(entry: RhythmDBEntry): void;
        vfunc_entry_extra_metadata_gather(entry: RhythmDBEntry, data: StringValueMap): void;
        vfunc_entry_extra_metadata_notify(entry: RhythmDBEntry, field: string, metadata: GObject.Value | any): void;
        vfunc_entry_extra_metadata_request(entry: RhythmDBEntry): unknown;
        vfunc_entry_keyword_added(entry: RhythmDBEntry, keyword: RefString): void;
        vfunc_entry_keyword_removed(entry: RhythmDBEntry, keyword: RefString): void;
        vfunc_impl_do_full_query(query: RhythmDBQuery, results: RhythmDBQueryResults, cancel: boolean): void;
        vfunc_impl_entry_count(): number;
        vfunc_impl_entry_count_by_type(type: RhythmDBEntryType): number;
        vfunc_impl_entry_delete(entry: RhythmDBEntry): void;
        vfunc_impl_entry_delete_by_type(type: RhythmDBEntryType): void;
        vfunc_impl_entry_get(entry: RhythmDBEntry, propid: number, value: GObject.Value | any): void;
        vfunc_impl_entry_keyword_add(entry: RhythmDBEntry, keyword: RefString): boolean;
        vfunc_impl_entry_keyword_has(entry: RhythmDBEntry, keyword: RefString): boolean;
        vfunc_impl_entry_keyword_remove(entry: RhythmDBEntry, keyword: RefString): boolean;
        vfunc_impl_entry_new(entry: RhythmDBEntry): void;
        vfunc_impl_entry_set(entry: RhythmDBEntry, propid: number, value: GObject.Value | any): boolean;
        vfunc_impl_entry_type_registered(type: RhythmDBEntryType): void;
        vfunc_impl_evaluate_query(query: RhythmDBQuery, entry: RhythmDBEntry): boolean;
        vfunc_impl_load(cancel?: Gio.Cancellable | null): boolean;
        vfunc_impl_lookup_by_id(id: number): RhythmDBEntry;
        vfunc_impl_lookup_by_location(uri: RefString): RhythmDBEntry;
        vfunc_impl_save(): void;
        vfunc_load_complete(): void;
        vfunc_load_error(uri: string, msg: string): void;
        vfunc_read_only(readonly: boolean): void;
        vfunc_save_complete(): void;
        vfunc_save_error(uri: string, error: GLib.Error): void;

        // Methods

        /**
         * Adds the file(s) pointed to by `uri` to the database, as entries of type
         * RHYTHMDB_ENTRY_TYPE_SONG. If the URI is that of a file, it will be added.
         * If the URI is that of a directory, everything under it will be added recursively.
         * @param uri the URI to add an entry/entries for
         */
        add_uri(uri: string): void;
        /**
         * Adds the file(s) pointed to by `uri` to the database, as entries
         * of the specified type. If the URI points to a file, it will be added.
         * The the URI identifies a directory, everything under it will be added
         * recursively.
         * @param uri the URI to add
         * @param type the #RhythmDBEntryType to use for new entries
         * @param ignore_type the #RhythmDBEntryType to use for ignored files
         * @param error_type the #RhythmDBEntryType to use for import errors
         */
        add_uri_with_types(
            uri: string,
            type: RhythmDBEntryType,
            ignore_type: RhythmDBEntryType,
            error_type: RhythmDBEntryType,
        ): void;
        /**
         * Apply all database changes, and send notification of changes and new entries.
         * This needs to be called after any changes have been made, such as a group of
         * rhythmdb_entry_set() calls, or a new entry has been added.
         */
        commit(): void;
        /**
         * Asynchronously runs a parsed query across the database, feeding matching
         * entries to `results` in chunks.  This can only be called from the
         * main thread.
         *
         * Since `results` is always a `RhythmDBQueryModel,`
         * use the RhythmDBQueryModel::complete signal to identify when the
         * query is complete.
         * @param results a #RhythmDBQueryResults instance to feed results to
         * @param query the query to run
         */
        do_full_query_async_parsed(results: RhythmDBQueryResults, query: RhythmDBQuery): void;
        /**
         * Synchronously evaluates the parsed query `query,` feeding results
         * to `results` in chunks.  Does not return until the query is complete.
         * @param results a #RhythmDBQueryResults instance to feed results to
         * @param query a parsed query
         */
        do_full_query_parsed(results: RhythmDBQueryResults, query: RhythmDBQuery): void;
        emit_entry_added(entry: RhythmDBEntry): void;
        emit_entry_deleted(entry: RhythmDBEntry): void;
        /**
         * Emits a signal describing extra metadata for the `entry`.  The `property_name`
         * argument is emitted as the ::detail part of the
         * "entry_extra_metadata_notify" signal and as the 'field' parameter.  Handlers
         * can ensure they only get metadata they are interested in by supplying an
         * appropriate ::detail part when connecting to the signal.  If handlers are
         * interested in the metadata they should ref or copy the contents of `metadata`
         * and unref or free it when they are finished with it.
         * @param entry a #RhythmDBEntry
         * @param property_name the metadata predicate
         * @param metadata a #GValue
         */
        emit_entry_extra_metadata_notify(
            entry: RhythmDBEntry,
            property_name: string,
            metadata: GObject.Value | any,
        ): void;
        /**
         * Returns the number of entries in the database.
         * @returns number of entries
         */
        entry_count(): number;
        /**
         * Returns the number of entries in the database of a particular type.
         * @param entry_type a #RhythmDBEntryType.
         * @returns entry count
         */
        entry_count_by_type(entry_type: RhythmDBEntryType): number;
        /**
         * Delete entry `entry` from the database, sending notification of its deletion.
         * This is usually used by sources where entries can disappear randomly, such
         * as a network source.
         * @param entry a #RhythmDBEntry.
         */
        entry_delete(entry: RhythmDBEntry): void;
        /**
         * Delete all entries from the database of the given type.
         * This is usually used by non-permanent sources when they disappear, such as
         * removable media being removed, or a network share becoming unavailable.
         * @param type type of entried to delete.
         */
        entry_delete_by_type(type: RhythmDBEntryType): void;
        /**
         * Calls the given function for each of the entries in the database.
         * @param func the function to call with each entry.
         */
        entry_foreach(func: RhythmDBEntryForeachFunc): void;
        /**
         * Calls the given function for each of the entries in the database
         * of a given type.
         * @param entry_type the type of entry to retrieve
         * @param func the function to call with each entry
         */
        entry_foreach_by_type(entry_type: RhythmDBEntryType, func: RhythmDBEntryForeachFunc): void;
        /**
         * Gathers all metadata for the `entry`. The returned GHashTable maps property
         * names and extra metadata names (described under
         * `rhythmdb_entry_request_extra_metadata)` to GValues. Anything wanting to
         * provide extra metadata should connect to the "entry_extra_metadata_gather"
         * signal.
         * @param entry a #RhythmDBEntry
         * @returns a RBStringValueMap containing metadata for the entry. This must be freed using g_object_unref.
         */
        entry_gather_metadata(entry: RhythmDBEntry): StringValueMap;
        /**
         * Gets a property of an entry, storing it in the given #GValue.
         * @param entry a #RhythmDBEntry.
         * @param propid the id of the property to get.
         * @param val return location for the property value.
         */
        entry_get(entry: RhythmDBEntry, propid: RhythmDBPropType | null, val: GObject.Value | any): void;
        /**
         * Adds a keyword to an entry.
         * @param entry a #RhythmDBEntry.
         * @param keyword the keyword to add.
         * @returns whether the keyword was already on the entry
         */
        entry_keyword_add(entry: RhythmDBEntry, keyword: RefString): boolean;
        /**
         * Checks whether a keyword is has been added to an entry.
         * @param entry a #RhythmDBEntry.
         * @param keyword the keyword to check for.
         * @returns whether the keyword had been added to the entry.
         */
        entry_keyword_has(entry: RhythmDBEntry, keyword: RefString): boolean;
        /**
         * Removed a keyword from an entry.
         * @param entry a #RhythmDBEntry.
         * @param keyword the keyword to remove.
         * @returns whether the keyword had previously been added to the entry.
         */
        entry_keyword_remove(entry: RhythmDBEntry, keyword: RefString): boolean;
        /**
         * Gets the list ofkeywords that have been added to an entry.
         * @param entry a #RhythmDBEntry.
         * @returns the list of keywords          that have been added to the entry.
         */
        entry_keywords_get(entry: RhythmDBEntry): RefString[];
        /**
         * Looks up the entry with id `id`.
         * @param id entry ID
         * @returns the entry with id @id, or NULL if no such entry exists.
         */
        entry_lookup_by_id(id: number): RhythmDBEntry;
        /**
         * Looks up the entry with location `uri`.
         * @param uri the URI of the entry to lookup.
         * @returns the entry with location @uri, or NULL if no such entry exists.
         */
        entry_lookup_by_location(uri: string): RhythmDBEntry;
        /**
         * Locates an entry using a string containing either an entry ID
         * or a location.
         * @param str string
         * @param is_id whether the string is an entry ID or a location.
         * @returns the entry matching the string, or NULL if no such entry exists.
         */
        entry_lookup_from_string(str: string, is_id: boolean): RhythmDBEntry;
        /**
         * Checks whether `key` matches `entry`.
         * @param entry a #RhythmDBEntry
         * @param key a #RBExtDBKey
         * @returns %TRUE if the key matches the entry
         */
        entry_matches_ext_db_key(entry: RhythmDBEntry, key: ExtDBKey): boolean;
        /**
         * Trashes the file represented by #entry.  If possible, the file is
         * moved to the user's trash directory and the entry is set to hidden,
         * otherwise the error will be stored as the playback error for the entry.
         * @param entry #RhythmDBEntry to trash
         */
        entry_move_to_trash(entry: RhythmDBEntry): void;
        /**
         * Emits a request for extra metadata for the `entry`.
         * The `property_name` argument is emitted as the ::detail part of the
         * "entry_extra_metadata_request" signal. It should be a namespaced RDF
         * predicate e.g. from Dublin Core, MusicBrainz, or internal to Rhythmbox
         * (namespace "rb:"). Suitable predicates would be those that are expensive to
         * acquire or only apply to a limited range of entries.
         * Handlers capable of providing a particular predicate may ensure they only
         * see appropriate requests by supplying an appropriate ::detail part when
         * connecting to the signal. Upon a handler returning a non-%NULL value,
         * emission will be stopped and the value returned to the caller; if no
         * handlers return a non-%NULL value, the caller will receive %NULL. Priority
         * is determined by signal connection order, with %G_CONNECT_AFTER providing a
         * second, lower rank of priority.
         * A handler returning a value should do so in a #GValue allocated on the heap;
         * the accumulator will take ownership. The caller should unset and free the
         * #GValue if non-%NULL when finished with it.
         * @param entry a #RhythmDBEntry
         * @param property_name the metadata predicate
         * @returns an allocated, initialised, set #GValue, or NULL
         */
        entry_request_extra_metadata(entry: RhythmDBEntry, property_name: string): unknown;
        /**
         * This function can be called by any code which wishes to change a
         * song property and send a notification.  It may be called when the
         * database is read-only; in this case the change will be queued for
         * an unspecified time in the future.  The implication of this is that
         * rhythmdb_entry_get() may not reflect the changes immediately.  However,
         * if this property is exposed in the user interface, you should still
         * make the change in the widget.  Then when the database returns to a
         * writable state, your change will take effect in the database too,
         * and a notification will be sent at that point.
         *
         * Note that you must call rhythmdb_commit() at some point after invoking
         * this function, and that even after the commit, your change may not
         * have taken effect.
         * @param entry a #RhythmDBEntry.
         * @param propid the id of the property to set.
         * @param value the property value.
         */
        entry_set(entry: RhythmDBEntry, propid: number, value: GObject.Value | any): void;
        /**
         * Locates a #RhythmDBEntryType by name. Returns NULL if no entry
         * type is registered with the specified name.
         * @param name name of the type to look for
         * @returns the #RhythmDBEntryType
         */
        entry_type_get_by_name(name: string): RhythmDBEntryType;
        /**
         * This can be called from a #RhythmDBEntryType sync_metadata function
         * when the appropriate action is to write the metadata changes
         * to the file at the entry's location.
         * @param entry the #RhythmDBEntry to update
         * @param changes a list of changes to write
         */
        entry_write_metadata_changes(entry: RhythmDBEntry, changes: RhythmDBEntryChange[]): void;
        /**
         * Evaluates the given entry against the given query.
         * @param query a query.
         * @param entry a @RhythmDBEntry.
         * @returns whether the given entry matches the criteria of the given query.
         */
        evaluate_query(query: RhythmDBQuery, entry: RhythmDBEntry): boolean;
        /**
         * Returns the #GType for the value of the property.
         * @param property_id a property ID (#RhythmDBPropType)
         * @returns property value type
         */
        get_property_type(property_id: number): GObject.GType;
        /**
         * Load the database from disk.
         */
        load(): void;
        /**
         * Returns a short non-translated name for the property #propid.
         * This name is suitable for use as an XML tag name, for example.
         * @param propid property ID
         * @returns property ID name, must not be freed
         */
        nice_elt_name_from_propid(propid: RhythmDBPropType | null): libxml2.Char;
        /**
         * Converts a property name returned by `rhythmdb_propid_from_nice_elt_name`
         * back to a #RhythmDBPropType.  If the name does not match a property ID,
         * -1 will be returned instead.
         * @param name a property ID name
         * @returns a #RhythmDBPropType, or -1
         */
        propid_from_nice_elt_name(name: libxml2.Char): number;
        /**
         * Appends a new query term to `query`.
         * @param query the query to append to
         * @param type query type
         * @param prop query property
         * @param value query value
         */
        query_append_params(
            query: RhythmDBQuery,
            type: RhythmDBQueryType | null,
            prop: RhythmDBPropType | null,
            value: GObject.Value | any,
        ): void;
        /**
         * Appends a set of criteria to a query to match against any of the values
         * listed in `items`.
         * @param query the query to append to
         * @param propid property ID to match
         * @param items #GList of values to match against
         */
        query_append_prop_multiple(
            query: RhythmDBQuery,
            propid: RhythmDBPropType | null,
            items: (GObject.Value | any)[],
        ): void;
        /**
         * Converts a serialized query back into a `GPtrArray` query.
         * @param parent parent XML node of serialized query
         * @returns deserialized query.
         */
        query_deserialize(parent: libxml2.NodePtr): RhythmDBQuery;
        /**
         * Checks if a query contains any time-relative criteria.
         * @param query the query to check
         * @returns %TRUE if time-relative criteria found
         */
        query_is_time_relative(query: RhythmDBQuery): boolean;
        /**
         * Preprocesses a query to prepare it for execution.  This has two main
         * roles: to perform expensive data transformations once per query, rather
         * than once per entry, and converting criteria to lower-level forms that
         * are implemented by the database backend.
         *
         * For RHYTHMDB_PROP_SEARCH_MATCH, this converts the search terms into
         * an array of case-folded words.
         *
         * When matching against case-folded properties such as
         * #RHYTHMDB_PROP_TITLE_FOLDED, this case-folds the query value.
         *
         * When performing year-based criteria such as #RHYTHMDB_QUERY_PROP_YEAR_LESS,
         * it converts the year into the Julian date such that a simple numeric
         * comparison will work.
         * @param query query to preprocess
         */
        query_preprocess(query: RhythmDBQuery): void;
        /**
         * Converts `query` into XML form as a child of `parent`.  It can be converted
         * back into a query by passing `parent` to `rhythmdb_query_deserialize`.
         * @param query query to serialize
         * @param parent XML node to attach the query to
         */
        query_serialize(query: RhythmDBQuery, parent: libxml2.NodePtr): void;
        /**
         * Returns a supposedly human-readable form of the query.
         * This is only intended for debug usage.
         * @param query a query.
         * @returns allocated string form of the query
         */
        query_to_string(query: RhythmDBQuery): string;
        /**
         * Registers a new entry type.  An entry type must be registered before
         * any entries can be created for it.
         * @param entry_type the new entry type to register
         */
        register_entry_type(entry_type: RhythmDBEntryType): void;
        /**
         * Save the database to disk, not returning until it has been saved.
         */
        save(): void;
        /**
         * Save the database to disk, asynchronously.
         */
        save_async(): void;
        /**
         * Ceases all #RhythmDB operations, including stopping all directory monitoring, and
         * removing all actions and events currently queued.
         */
        shutdown(): void;
        /**
         * Starts the #RhythmDB processing thread. Needs to be called during startup.
         */
        start_action_thread(): void;
    }

    namespace RhythmDBEntryType {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            cache_name: string;
            cacheName: string;
            category: RhythmDBEntryCategory;
            db: RhythmDB;
            name: string;
            save_to_disk: boolean;
            saveToDisk: boolean;
            type_data_size: number;
            typeDataSize: number;
        }
    }

    class RhythmDBEntryType extends GObject.Object {
        static $gtype: GObject.GType<RhythmDBEntryType>;

        // Properties

        /**
         * Metadata cache name.  For entry types created by a plugin, should match the plugin name.
         * If this is set, the entry type must also implement the uri_to_cache_key method.
         */
        get cache_name(): string;
        /**
         * Metadata cache name.  For entry types created by a plugin, should match the plugin name.
         * If this is set, the entry type must also implement the uri_to_cache_key method.
         */
        get cacheName(): string;
        /**
         * The #RhythmDBEntryCategory that this entry type fits into.
         */
        get category(): RhythmDBEntryCategory;
        /**
         * The #RhythmDB instance.
         */
        get db(): RhythmDB;
        /**
         * Entry type name.  This must be unique.
         */
        get name(): string;
        /**
         * If %TRUE, entries of this type should be written to the
         * on-disk database.
         */
        get save_to_disk(): boolean;
        /**
         * If %TRUE, entries of this type should be written to the
         * on-disk database.
         */
        get saveToDisk(): boolean;
        /**
         * The size of the type-specific data structure to allocate for each
         * entry of this type.
         */
        get type_data_size(): number;
        /**
         * The size of the type-specific data structure to allocate for each
         * entry of this type.
         */
        get typeDataSize(): number;

        // Constructors

        constructor(properties?: Partial<RhythmDBEntryType.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Virtual methods

        vfunc_cache_key_to_uri(key: string): string;
        vfunc_can_sync_metadata(entry: RhythmDBEntry): boolean;
        vfunc_destroy_entry(entry: RhythmDBEntry): void;
        vfunc_entry_created(entry: RhythmDBEntry): void;
        vfunc_get_playback_uri(entry: RhythmDBEntry): string;
        vfunc_update_availability(entry: RhythmDBEntry, avail: RhythmDBEntryAvailability): void;
        vfunc_uri_to_cache_key(uri: string): string;

        // Methods

        /**
         * Fetches metadata for a URI (not an entry yet, at this point) from a cache, if possible.
         *
         * The `metadata` array contains RhythmDBEntryChange items with just the 'new' value set.
         * @param uri uri of the item to fetch
         * @param metadata returns fetched metadata
         * @returns %TRUE if metadata is returned
         */
        fetch_metadata(uri: string, metadata: RhythmDBEntryChange[]): boolean;
        /**
         * Returns the name of the entry type
         * @returns entry type name
         */
        get_name(): string;
        purge_metadata_cache(prefix: string, max_age: number): void;
    }

    namespace RhythmDBImportJob {
        // Signal callback interfaces

        interface Complete {
            (total: number): void;
        }

        interface EntryAdded {
            (entry: RhythmDBEntry): void;
        }

        interface ScanComplete {
            (total: number): void;
        }

        interface StatusChanged {
            (total: number, imported: number): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, TaskProgress.ConstructorProps {
            db: RhythmDB;
            entry_type: RhythmDBEntryType;
            entryType: RhythmDBEntryType;
            error_type: RhythmDBEntryType;
            errorType: RhythmDBEntryType;
            ignore_type: RhythmDBEntryType;
            ignoreType: RhythmDBEntryType;
        }
    }

    class RhythmDBImportJob extends GObject.Object implements TaskProgress {
        static $gtype: GObject.GType<RhythmDBImportJob>;

        // Properties

        get db(): RhythmDB;
        get entry_type(): RhythmDBEntryType;
        get entryType(): RhythmDBEntryType;
        get error_type(): RhythmDBEntryType;
        get errorType(): RhythmDBEntryType;
        get ignore_type(): RhythmDBEntryType;
        get ignoreType(): RhythmDBEntryType;

        // Constructors

        constructor(properties?: Partial<RhythmDBImportJob.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            db: RhythmDB,
            entry_type: RhythmDBEntryType,
            ignore_type: RhythmDBEntryType,
            error_type: RhythmDBEntryType,
        ): RhythmDBImportJob;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'complete', callback: (_source: this, total: number) => void): number;
        connect_after(signal: 'complete', callback: (_source: this, total: number) => void): number;
        emit(signal: 'complete', total: number): void;
        connect(signal: 'entry-added', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        connect_after(signal: 'entry-added', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        emit(signal: 'entry-added', entry: RhythmDBEntry): void;
        connect(signal: 'scan-complete', callback: (_source: this, total: number) => void): number;
        connect_after(signal: 'scan-complete', callback: (_source: this, total: number) => void): number;
        emit(signal: 'scan-complete', total: number): void;
        connect(signal: 'status-changed', callback: (_source: this, total: number, imported: number) => void): number;
        connect_after(
            signal: 'status-changed',
            callback: (_source: this, total: number, imported: number) => void,
        ): number;
        emit(signal: 'status-changed', total: number, imported: number): void;

        // Virtual methods

        vfunc_complete(total: number): void;
        vfunc_entry_added(entry: RhythmDBEntry): void;
        vfunc_scan_complete(total: number): void;
        vfunc_status_changed(total: number, imported: number): void;

        // Methods

        /**
         * Adds a URI to import.  All files under the specified
         * URI will be imported.
         * @param uri the URI to import
         */
        add_uri(uri: string): void;
        /**
         * Cancels the import job.  The job will cease as soon
         * as possible.  More directories may be scanned and
         * more files may be imported before the job actually
         * ceases.
         */
        cancel(): void;
        /**
         * Returns whether the import job is complete.
         * @returns TRUE if complete.
         */
        complete(): boolean;
        /**
         * Returns the number of files successfully imported by the import job so far.
         * @returns file count
         */
        get_imported(): number;
        /**
         * Returns the number of files processed by the import job so far.
         * @returns file count
         */
        get_processed(): number;
        /**
         * Returns the total number of files that will be processed by
         * this import job.  This increases as the import directories are
         * scanned.
         * @returns the total number of files to be processed
         */
        get_total(): number;
        /**
         * Checks if the specified URI is included in the import job.
         * @param uri a URI to check
         * @returns %TRUE if the import job includes the URI
         */
        includes_uri(uri: string): boolean;
        /**
         * Returns whether the directory scan phase of the import job is complete.
         * @returns TRUE if complete
         */
        scan_complete(): boolean;
        /**
         * Starts the import job.  After this method has been called,
         * no more URIs may be added to the import job.  May only be
         * called once for a given import job.
         */
        start(): void;

        // Inherited properties
        get task_cancellable(): boolean;
        set task_cancellable(val: boolean);
        get taskCancellable(): boolean;
        set taskCancellable(val: boolean);
        get task_detail(): string;
        set task_detail(val: string);
        get taskDetail(): string;
        set taskDetail(val: string);
        get task_label(): string;
        set task_label(val: string);
        get taskLabel(): string;
        set taskLabel(val: string);
        get task_notify(): boolean;
        set task_notify(val: boolean);
        get taskNotify(): boolean;
        set taskNotify(val: boolean);
        get task_outcome(): TaskOutcome;
        set task_outcome(val: TaskOutcome);
        get taskOutcome(): TaskOutcome;
        set taskOutcome(val: TaskOutcome);
        get task_progress(): number;
        set task_progress(val: number);
        get taskProgress(): number;
        set taskProgress(val: number);

        // Inherited methods
        vfunc_cancel(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace RhythmDBPropertyModel {
        // Signal callback interfaces

        interface PreRowDeletion {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Gtk.TreeModel.ConstructorProps {
            db: RhythmDB;
            prop: number;
            query_model: RhythmDBQueryModel;
            queryModel: RhythmDBQueryModel;
        }
    }

    class RhythmDBPropertyModel extends GObject.Object implements Gtk.TreeModel {
        static $gtype: GObject.GType<RhythmDBPropertyModel>;

        // Properties

        /**
         * The #RhythmDB object the model is associated with.
         */
        get db(): RhythmDB;
        /**
         * The property that this property model indexes.
         */
        get prop(): number;
        /**
         * The query model that this property model indexes.
         */
        get query_model(): RhythmDBQueryModel;
        set query_model(val: RhythmDBQueryModel);
        /**
         * The query model that this property model indexes.
         */
        get queryModel(): RhythmDBQueryModel;
        set queryModel(val: RhythmDBQueryModel);

        // Constructors

        constructor(properties?: Partial<RhythmDBPropertyModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](db: RhythmDB, propid: RhythmDBPropType): RhythmDBPropertyModel;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'pre-row-deletion', callback: (_source: this) => void): number;
        connect_after(signal: 'pre-row-deletion', callback: (_source: this) => void): number;
        emit(signal: 'pre-row-deletion'): void;

        // Virtual methods

        vfunc_pre_row_deletion(): void;

        // Methods

        /**
         * Enables drag and drop from a specified #GtkTreeView that is
         * backed by the #RhythmDBPropertyModel.  Drag targets are
         * determined by the indexed property.
         * @param view the #GtkTreeView from which to enable drag and drop
         */
        enable_drag(view: Gtk.TreeView): void;
        /**
         * Locates the row in the model for a property value.
         * @param name the property value to find
         * @param iter a #GtkTreeIter to point to the row
         * @returns TRUE if the value was found.
         */
        iter_from_string(name: string, iter: Gtk.TreeIter): boolean;

        // Inherited methods
        /**
         * Creates a new #GtkTreeModel, with `child_model` as the child_model
         * and `root` as the virtual root.
         * @param root A #GtkTreePath or %NULL.
         * @returns A new #GtkTreeModel.
         */
        filter_new(root?: Gtk.TreePath | null): Gtk.TreeModel;
        /**
         * Calls func on each node in model in a depth-first fashion.
         *
         * If `func` returns %TRUE, then the tree ceases to be walked,
         * and gtk_tree_model_foreach() returns.
         * @param func a function to be called on each row
         */
        foreach(func: Gtk.TreeModelForeachFunc): void;
        /**
         * Returns the type of the column.
         * @param index_ the column index
         * @returns the type of the column
         */
        get_column_type(index_: number): GObject.GType;
        /**
         * Returns a set of flags supported by this interface.
         *
         * The flags are a bitwise combination of #GtkTreeModelFlags.
         * The flags supported should not change during the lifetime
         * of the `tree_model`.
         * @returns the flags supported by this interface
         */
        get_flags(): Gtk.TreeModelFlags;
        /**
         * Sets `iter` to a valid iterator pointing to `path`.  If `path` does
         * not exist, `iter` is set to an invalid iterator and %FALSE is returned.
         * @param path the #GtkTreePath-struct
         * @returns %TRUE, if @iter was set
         */
        get_iter(path: Gtk.TreePath): [boolean, Gtk.TreeIter];
        /**
         * Initializes `iter` with the first iterator in the tree
         * (the one at the path "0") and returns %TRUE. Returns
         * %FALSE if the tree is empty.
         * @returns %TRUE, if @iter was set
         */
        get_iter_first(): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to a valid iterator pointing to `path_string,` if it
         * exists. Otherwise, `iter` is left invalid and %FALSE is returned.
         * @param path_string a string representation of a #GtkTreePath-struct
         * @returns %TRUE, if @iter was set
         */
        get_iter_from_string(path_string: string): [boolean, Gtk.TreeIter];
        /**
         * Returns the number of columns supported by `tree_model`.
         * @returns the number of columns
         */
        get_n_columns(): number;
        /**
         * Returns a newly-created #GtkTreePath-struct referenced by `iter`.
         *
         * This path should be freed with gtk_tree_path_free().
         * @param iter the #GtkTreeIter-struct
         * @returns a newly-created #GtkTreePath-struct
         */
        get_path(iter: Gtk.TreeIter): Gtk.TreePath;
        /**
         * Generates a string representation of the iter.
         *
         * This string is a “:” separated list of numbers.
         * For example, “4:10:0:3” would be an acceptable
         * return value for this string.
         * @param iter a #GtkTreeIter-struct
         * @returns a newly-allocated string.     Must be freed with g_free().
         */
        get_string_from_iter(iter: Gtk.TreeIter): string;
        /**
         * Initializes and sets `value` to that at `column`.
         *
         * When done with `value,` g_value_unset() needs to be called
         * to free any allocated memory.
         * @param iter the #GtkTreeIter-struct
         * @param column the column to lookup the value at
         */
        get_value(iter: Gtk.TreeIter, column: number): unknown;
        /**
         * Sets `iter` to point to the first child of `parent`.
         *
         * If `parent` has no children, %FALSE is returned and `iter` is
         * set to be invalid. `parent` will remain a valid node after this
         * function has been called.
         *
         * If `parent` is %NULL returns the first node, equivalent to
         * `gtk_tree_model_get_iter_first (tree_model, iter);`
         * @param parent the #GtkTreeIter-struct, or %NULL
         * @returns %TRUE, if @iter has been set to the first child
         */
        iter_children(parent?: Gtk.TreeIter | null): [boolean, Gtk.TreeIter];
        /**
         * Returns %TRUE if `iter` has children, %FALSE otherwise.
         * @param iter the #GtkTreeIter-struct to test for children
         * @returns %TRUE if @iter has children
         */
        iter_has_child(iter: Gtk.TreeIter): boolean;
        /**
         * Returns the number of children that `iter` has.
         *
         * As a special case, if `iter` is %NULL, then the number
         * of toplevel nodes is returned.
         * @param iter the #GtkTreeIter-struct, or %NULL
         * @returns the number of children of @iter
         */
        iter_n_children(iter?: Gtk.TreeIter | null): number;
        /**
         * Sets `iter` to point to the node following it at the current level.
         *
         * If there is no next `iter,` %FALSE is returned and `iter` is set
         * to be invalid.
         * @param iter the #GtkTreeIter-struct
         * @returns %TRUE if @iter has been changed to the next node
         */
        iter_next(iter: Gtk.TreeIter): boolean;
        /**
         * Sets `iter` to be the child of `parent,` using the given index.
         *
         * The first index is 0. If `n` is too big, or `parent` has no children,
         * `iter` is set to an invalid iterator and %FALSE is returned. `parent`
         * will remain a valid node after this function has been called. As a
         * special case, if `parent` is %NULL, then the `n-th` root node
         * is set.
         * @param parent the #GtkTreeIter-struct to get the child from, or %NULL.
         * @param n the index of the desired child
         * @returns %TRUE, if @parent has an @n-th child
         */
        iter_nth_child(parent: Gtk.TreeIter | null, n: number): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to be the parent of `child`.
         *
         * If `child` is at the toplevel, and doesn’t have a parent, then
         * `iter` is set to an invalid iterator and %FALSE is returned.
         * `child` will remain a valid node after this function has been
         * called.
         *
         * `iter` will be initialized before the lookup is performed, so `child`
         * and `iter` cannot point to the same memory location.
         * @param child the #GtkTreeIter-struct
         * @returns %TRUE, if @iter is set to the parent of @child
         */
        iter_parent(child: Gtk.TreeIter): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to point to the previous node at the current level.
         *
         * If there is no previous `iter,` %FALSE is returned and `iter` is
         * set to be invalid.
         * @param iter the #GtkTreeIter-struct
         * @returns %TRUE if @iter has been changed to the previous node
         */
        iter_previous(iter: Gtk.TreeIter): boolean;
        /**
         * Lets the tree ref the node.
         *
         * This is an optional method for models to implement.
         * To be more specific, models may ignore this call as it exists
         * primarily for performance reasons.
         *
         * This function is primarily meant as a way for views to let
         * caching models know when nodes are being displayed (and hence,
         * whether or not to cache that node). Being displayed means a node
         * is in an expanded branch, regardless of whether the node is currently
         * visible in the viewport. For example, a file-system based model
         * would not want to keep the entire file-hierarchy in memory,
         * just the sections that are currently being displayed by
         * every current view.
         *
         * A model should be expected to be able to get an iter independent
         * of its reffed state.
         * @param iter the #GtkTreeIter-struct
         */
        ref_node(iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-changed signal on `tree_model`.
         * @param path a #GtkTreePath-struct pointing to the changed row
         * @param iter a valid #GtkTreeIter-struct pointing to the changed row
         */
        row_changed(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-deleted signal on `tree_model`.
         *
         * This should be called by models after a row has been removed.
         * The location pointed to by `path` should be the location that
         * the row previously was at. It may not be a valid location anymore.
         *
         * Nodes that are deleted are not unreffed, this means that any
         * outstanding references on the deleted node should not be released.
         * @param path a #GtkTreePath-struct pointing to the previous location of     the deleted row
         */
        row_deleted(path: Gtk.TreePath): void;
        /**
         * Emits the #GtkTreeModel::row-has-child-toggled signal on
         * `tree_model`. This should be called by models after the child
         * state of a node changes.
         * @param path a #GtkTreePath-struct pointing to the changed row
         * @param iter a valid #GtkTreeIter-struct pointing to the changed row
         */
        row_has_child_toggled(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-inserted signal on `tree_model`.
         * @param path a #GtkTreePath-struct pointing to the inserted row
         * @param iter a valid #GtkTreeIter-struct pointing to the inserted row
         */
        row_inserted(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::rows-reordered signal on `tree_model`.
         *
         * This should be called by models when their rows have been
         * reordered.
         * @param path a #GtkTreePath-struct pointing to the tree node whose children     have been reordered
         * @param iter a valid #GtkTreeIter-struct pointing to the node     whose children have been reordered, or %NULL if the depth     of @path is 0
         * @param new_order an array of integers     mapping the current position of each child to its old     position before the re-ordering,     i.e. @new_order`[newpos] = oldpos`
         */
        rows_reordered(path: Gtk.TreePath, iter: Gtk.TreeIter | null, new_order: number[]): void;
        /**
         * Lets the tree unref the node.
         *
         * This is an optional method for models to implement.
         * To be more specific, models may ignore this call as it exists
         * primarily for performance reasons. For more information on what
         * this means, see gtk_tree_model_ref_node().
         *
         * Please note that nodes that are deleted are not unreffed.
         * @param iter the #GtkTreeIter-struct
         */
        unref_node(iter: Gtk.TreeIter): void;
        /**
         * Returns the type of the column.
         * @param index_ the column index
         */
        vfunc_get_column_type(index_: number): GObject.GType;
        /**
         * Returns a set of flags supported by this interface.
         *
         * The flags are a bitwise combination of #GtkTreeModelFlags.
         * The flags supported should not change during the lifetime
         * of the `tree_model`.
         */
        vfunc_get_flags(): Gtk.TreeModelFlags;
        /**
         * Sets `iter` to a valid iterator pointing to `path`.  If `path` does
         * not exist, `iter` is set to an invalid iterator and %FALSE is returned.
         * @param path the #GtkTreePath-struct
         */
        vfunc_get_iter(path: Gtk.TreePath): [boolean, Gtk.TreeIter];
        /**
         * Returns the number of columns supported by `tree_model`.
         */
        vfunc_get_n_columns(): number;
        /**
         * Returns a newly-created #GtkTreePath-struct referenced by `iter`.
         *
         * This path should be freed with gtk_tree_path_free().
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_get_path(iter: Gtk.TreeIter): Gtk.TreePath;
        /**
         * Initializes and sets `value` to that at `column`.
         *
         * When done with `value,` g_value_unset() needs to be called
         * to free any allocated memory.
         * @param iter the #GtkTreeIter-struct
         * @param column the column to lookup the value at
         */
        vfunc_get_value(iter: Gtk.TreeIter, column: number): unknown;
        /**
         * Sets `iter` to point to the first child of `parent`.
         *
         * If `parent` has no children, %FALSE is returned and `iter` is
         * set to be invalid. `parent` will remain a valid node after this
         * function has been called.
         *
         * If `parent` is %NULL returns the first node, equivalent to
         * `gtk_tree_model_get_iter_first (tree_model, iter);`
         * @param parent the #GtkTreeIter-struct, or %NULL
         */
        vfunc_iter_children(parent?: Gtk.TreeIter | null): [boolean, Gtk.TreeIter];
        /**
         * Returns %TRUE if `iter` has children, %FALSE otherwise.
         * @param iter the #GtkTreeIter-struct to test for children
         */
        vfunc_iter_has_child(iter: Gtk.TreeIter): boolean;
        /**
         * Returns the number of children that `iter` has.
         *
         * As a special case, if `iter` is %NULL, then the number
         * of toplevel nodes is returned.
         * @param iter the #GtkTreeIter-struct, or %NULL
         */
        vfunc_iter_n_children(iter?: Gtk.TreeIter | null): number;
        /**
         * Sets `iter` to point to the node following it at the current level.
         *
         * If there is no next `iter,` %FALSE is returned and `iter` is set
         * to be invalid.
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_iter_next(iter: Gtk.TreeIter): boolean;
        /**
         * Sets `iter` to be the child of `parent,` using the given index.
         *
         * The first index is 0. If `n` is too big, or `parent` has no children,
         * `iter` is set to an invalid iterator and %FALSE is returned. `parent`
         * will remain a valid node after this function has been called. As a
         * special case, if `parent` is %NULL, then the `n-th` root node
         * is set.
         * @param parent the #GtkTreeIter-struct to get the child from, or %NULL.
         * @param n the index of the desired child
         */
        vfunc_iter_nth_child(parent: Gtk.TreeIter | null, n: number): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to be the parent of `child`.
         *
         * If `child` is at the toplevel, and doesn’t have a parent, then
         * `iter` is set to an invalid iterator and %FALSE is returned.
         * `child` will remain a valid node after this function has been
         * called.
         *
         * `iter` will be initialized before the lookup is performed, so `child`
         * and `iter` cannot point to the same memory location.
         * @param child the #GtkTreeIter-struct
         */
        vfunc_iter_parent(child: Gtk.TreeIter): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to point to the previous node at the current level.
         *
         * If there is no previous `iter,` %FALSE is returned and `iter` is
         * set to be invalid.
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_iter_previous(iter: Gtk.TreeIter): boolean;
        /**
         * Lets the tree ref the node.
         *
         * This is an optional method for models to implement.
         * To be more specific, models may ignore this call as it exists
         * primarily for performance reasons.
         *
         * This function is primarily meant as a way for views to let
         * caching models know when nodes are being displayed (and hence,
         * whether or not to cache that node). Being displayed means a node
         * is in an expanded branch, regardless of whether the node is currently
         * visible in the viewport. For example, a file-system based model
         * would not want to keep the entire file-hierarchy in memory,
         * just the sections that are currently being displayed by
         * every current view.
         *
         * A model should be expected to be able to get an iter independent
         * of its reffed state.
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_ref_node(iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-changed signal on `tree_model`.
         * @param path a #GtkTreePath-struct pointing to the changed row
         * @param iter a valid #GtkTreeIter-struct pointing to the changed row
         */
        vfunc_row_changed(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-deleted signal on `tree_model`.
         *
         * This should be called by models after a row has been removed.
         * The location pointed to by `path` should be the location that
         * the row previously was at. It may not be a valid location anymore.
         *
         * Nodes that are deleted are not unreffed, this means that any
         * outstanding references on the deleted node should not be released.
         * @param path a #GtkTreePath-struct pointing to the previous location of     the deleted row
         */
        vfunc_row_deleted(path: Gtk.TreePath): void;
        /**
         * Emits the #GtkTreeModel::row-has-child-toggled signal on
         * `tree_model`. This should be called by models after the child
         * state of a node changes.
         * @param path a #GtkTreePath-struct pointing to the changed row
         * @param iter a valid #GtkTreeIter-struct pointing to the changed row
         */
        vfunc_row_has_child_toggled(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-inserted signal on `tree_model`.
         * @param path a #GtkTreePath-struct pointing to the inserted row
         * @param iter a valid #GtkTreeIter-struct pointing to the inserted row
         */
        vfunc_row_inserted(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Lets the tree unref the node.
         *
         * This is an optional method for models to implement.
         * To be more specific, models may ignore this call as it exists
         * primarily for performance reasons. For more information on what
         * this means, see gtk_tree_model_ref_node().
         *
         * Please note that nodes that are deleted are not unreffed.
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_unref_node(iter: Gtk.TreeIter): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace RhythmDBQueryModel {
        // Signal callback interfaces

        interface Complete {
            (): void;
        }

        interface EntryPropChanged {
            (entry: RhythmDBEntry, prop: number, old?: any | null, new_value?: any | null): void;
        }

        interface EntryRemoved {
            (entry: RhythmDBEntry): void;
        }

        interface FilterEntryDrop {
            (entry: RhythmDBEntry): boolean;
        }

        interface NonEntryDropped {
            (uri: string, position: number): void;
        }

        interface PostEntryDelete {
            (entry: RhythmDBEntry): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends GObject.Object.ConstructorProps,
                Gtk.TreeModel.ConstructorProps,
                RhythmDBQueryResults.ConstructorProps {
            base_model: RhythmDBQueryModel;
            baseModel: RhythmDBQueryModel;
            db: RhythmDB;
            limit_type: RhythmDBQueryModelLimitType;
            limitType: RhythmDBQueryModelLimitType;
            limit_value: GLib.Variant;
            limitValue: GLib.Variant;
            query: any;
            show_hidden: boolean;
            showHidden: boolean;
            sort_data: any;
            sortData: any;
            sort_data_destroy: any;
            sortDataDestroy: any;
            sort_func: any;
            sortFunc: any;
            sort_reverse: boolean;
            sortReverse: boolean;
        }
    }

    class RhythmDBQueryModel extends GObject.Object implements Gtk.TreeModel, RhythmDBQueryResults {
        static $gtype: GObject.GType<RhythmDBQueryModel>;

        // Properties

        get base_model(): RhythmDBQueryModel;
        set base_model(val: RhythmDBQueryModel);
        get baseModel(): RhythmDBQueryModel;
        set baseModel(val: RhythmDBQueryModel);
        get db(): RhythmDB;
        get limit_type(): RhythmDBQueryModelLimitType;
        get limitType(): RhythmDBQueryModelLimitType;
        get limit_value(): GLib.Variant;
        get limitValue(): GLib.Variant;
        get query(): any;
        set query(val: any);
        get show_hidden(): boolean;
        set show_hidden(val: boolean);
        get showHidden(): boolean;
        set showHidden(val: boolean);
        get sort_data(): any;
        set sort_data(val: any);
        get sortData(): any;
        set sortData(val: any);
        get sort_data_destroy(): any;
        set sort_data_destroy(val: any);
        get sortDataDestroy(): any;
        set sortDataDestroy(val: any);
        get sort_func(): any;
        set sort_func(val: any);
        get sortFunc(): any;
        set sortFunc(val: any);
        get sort_reverse(): boolean;
        set sort_reverse(val: boolean);
        get sortReverse(): boolean;
        set sortReverse(val: boolean);

        // Constructors

        constructor(properties?: Partial<RhythmDBQueryModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_empty(db: RhythmDB): RhythmDBQueryModel;

        static new_for_entry_type(
            db: RhythmDB,
            entry_type: RhythmDBEntryType,
            show_hidden: boolean,
        ): RhythmDBQueryModel;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'complete', callback: (_source: this) => void): number;
        connect_after(signal: 'complete', callback: (_source: this) => void): number;
        emit(signal: 'complete'): void;
        connect(
            signal: 'entry-prop-changed',
            callback: (
                _source: this,
                entry: RhythmDBEntry,
                prop: number,
                old: any | null,
                new_value: any | null,
            ) => void,
        ): number;
        connect_after(
            signal: 'entry-prop-changed',
            callback: (
                _source: this,
                entry: RhythmDBEntry,
                prop: number,
                old: any | null,
                new_value: any | null,
            ) => void,
        ): number;
        emit(
            signal: 'entry-prop-changed',
            entry: RhythmDBEntry,
            prop: number,
            old?: any | null,
            new_value?: any | null,
        ): void;
        connect(signal: 'entry-removed', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        connect_after(signal: 'entry-removed', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        emit(signal: 'entry-removed', entry: RhythmDBEntry): void;
        connect(signal: 'filter-entry-drop', callback: (_source: this, entry: RhythmDBEntry) => boolean): number;
        connect_after(signal: 'filter-entry-drop', callback: (_source: this, entry: RhythmDBEntry) => boolean): number;
        emit(signal: 'filter-entry-drop', entry: RhythmDBEntry): void;
        connect(signal: 'non-entry-dropped', callback: (_source: this, uri: string, position: number) => void): number;
        connect_after(
            signal: 'non-entry-dropped',
            callback: (_source: this, uri: string, position: number) => void,
        ): number;
        emit(signal: 'non-entry-dropped', uri: string, position: number): void;
        connect(signal: 'post-entry-delete', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        connect_after(signal: 'post-entry-delete', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        emit(signal: 'post-entry-delete', entry: RhythmDBEntry): void;

        // Static methods

        /**
         * Sort function for sorting by album.  Sorts by album, then
         * disc number, then track number, then title.
         * @param a a #RhythmDBEntry
         * @param b a #RhythmDBEntry
         * @param data nothing
         */
        static album_sort_func(a: RhythmDBEntry, b: RhythmDBEntry, data?: any | null): number;
        /**
         * Sort function for sorting by artist.  Sorts by artist, then
         * album, then disc number, then track number, then title.
         * @param a a #RhythmDBEntry
         * @param b a #RhythmDBEntry
         * @param data nothing
         */
        static artist_sort_func(a: RhythmDBEntry, b: RhythmDBEntry, data?: any | null): number;
        /**
         * Sort function for sorting by bitrate.  Lossless encodings (as identified
         * by media type) are considered to have the highest possible bitrate.
         * Falls back to sorting by location for equal bitrates.
         * @param a a #RhythmDBEntry
         * @param b a #RhythmDBEntry
         * @param data nothing
         */
        static bitrate_sort_func(a: RhythmDBEntry, b: RhythmDBEntry, data?: any | null): number;
        /**
         * Sort function for sorting by composer.  Sorts by composer, then
         * album, then disc number, then track number, then title.
         * @param a a #RhythmDBEntry
         * @param b a #RhythmDBEntry
         * @param data nothing
         */
        static composer_sort_func(a: RhythmDBEntry, b: RhythmDBEntry, data?: any | null): number;
        /**
         * Sort function for sorting by release date.
         * Falls back to album sort order for equal dates.
         * @param a a #RhythmDBEntry
         * @param b a #RhythmDBEntry
         * @param data nothing
         */
        static date_sort_func(a: RhythmDBEntry, b: RhythmDBEntry, data?: any | null): number;
        /**
         * Sort function for sorting by a rounded floating point value.
         * The property value is rounded up to an integer value for sorting.
         * If the values are the same, falls back to sorting by location.
         * @param a a #RhythmDBEntry
         * @param b a #RhythmDBEntry
         * @param data property to sort on
         */
        static double_ceiling_sort_func(a: RhythmDBEntry, b: RhythmDBEntry, data?: any | null): number;
        /**
         * Sort function for sorting by genre.  Sorts by genre, then artist,
         * then album, then disc number, then track number, then title.
         * @param a a #RhythmDBEntry
         * @param b a #RhythmDBEntry
         * @param data nothing
         */
        static genre_sort_func(a: RhythmDBEntry, b: RhythmDBEntry, data?: any | null): number;
        /**
         * Sort function for sorting by location.
         * @param a a #RhythmDBEntry
         * @param b a #RhythmDBEntry
         * @param data nothing
         */
        static location_sort_func(a: RhythmDBEntry, b: RhythmDBEntry, data?: any | null): number;
        /**
         * Sort function for sorting by a single string property
         * Falls back to location sort order if the strings are equal.
         * @param a a #RhythmDBEntry
         * @param b a #RhythmDBEntry
         * @param data property to sort on
         */
        static string_sort_func(a: RhythmDBEntry, b: RhythmDBEntry, data?: any | null): number;
        /**
         * Sort function for sorting by title.  Falls back to sorting
         * by location if the titles are the same.
         * @param a a #RhythmDBEntry
         * @param b a #RhythmDBEntry
         * @param data nothing
         */
        static title_sort_func(a: RhythmDBEntry, b: RhythmDBEntry, data?: any | null): number;
        /**
         * Sort function for sorting by track.  Sorts by artist,
         * then album, then disc number, then track number, then title.
         * @param a a #RhythmDBEntry
         * @param b a #RhythmDBEntry
         * @param data nothing
         */
        static track_sort_func(a: RhythmDBEntry, b: RhythmDBEntry, data?: any | null): number;
        /**
         * Sort function for sorting by an unsigned integer property value.
         * If the values are the same, falls back to sorting by location.
         * @param a a #RhythmDBEntry
         * @param b a #RhythmDBEntry
         * @param data property to sort on
         */
        static ulong_sort_func(a: RhythmDBEntry, b: RhythmDBEntry, data?: any | null): number;

        // Virtual methods

        vfunc_complete(): void;
        vfunc_entry_prop_changed(
            entry: RhythmDBEntry,
            prop: RhythmDBPropType,
            old: GObject.Value | any,
            new_value: GObject.Value | any,
        ): void;
        vfunc_entry_removed(entry: RhythmDBEntry): void;
        vfunc_filter_entry_drop(entry: RhythmDBEntry): boolean;
        vfunc_non_entry_dropped(uri: string, position: number): void;
        vfunc_post_entry_delete(entry: RhythmDBEntry): void;

        // Methods

        /**
         * Adds an entry to the query model at the specified position.  Does not check
         * if the entry matches the query (if any).
         * @param entry a #RhythmDBEntry to add
         * @param index position at which to add it, or -1 to add at the end
         */
        add_entry(entry: RhythmDBEntry, index: number): void;
        /**
         * Chains `model` to `base`.  All changes made to the base model will be reflected in
         * the child model, and all changes made to the child model will be passed on to the
         * base model.
         * @param base the #RhythmDBQueryModel to chain it to
         * @param import_entries if %TRUE, copy all existing entries from @base to @model
         */
        chain(base: RhythmDBQueryModel, import_entries: boolean): void;
        /**
         * Constructs a status string describing the contents of the model.
         * @param singular singular form of the pattern describing the number of entries ("%d song")
         * @param plural plural form of the pattern describing the number of entries ("%d songs")
         * @returns allocated status string, to be freed by the caller.
         */
        compute_status_normal(singular: string, plural: string): string;
        /**
         * Copies all entries from `src` to `dest`.
         * @param src source #RhythmDBQueryModel
         */
        copy_contents(src: RhythmDBQueryModel): void;
        /**
         * Creates a #GtkTreeIter pointing to the specified entry in the model.
         * @param entry the #RhythmDBEntry to look up
         * @param iter holds the returned #GtkTreeIter
         * @returns %TRUE if the iterator now points to the entry
         */
        entry_to_iter(entry: RhythmDBEntry, iter: Gtk.TreeIter): boolean;
        /**
         * Returns the total duration of all entries in the model.
         * @returns the total duration (in seconds) of all entries in the model
         */
        get_duration(): number;
        /**
         * Locates and returns the next #RhythmDBEntry in the model after the specified
         * entry.  The caller owns a reference to the returned entry.
         * @param entry a #RhythmDBEntry
         * @returns the next #RhythmDBEntry in the model, if any
         */
        get_next_from_entry(entry: RhythmDBEntry): RhythmDBEntry;
        /**
         * Locates and returns the  #RhythmDBEntry in the model before the specified
         * entry.  The caller owns a reference to the returned entry.
         * @param entry a #RhythmDBEntry
         * @returns the previous #RhythmDBEntry in the model, if any
         */
        get_previous_from_entry(entry: RhythmDBEntry): RhythmDBEntry;
        /**
         * Returns the total size of all entries in the model.
         * @returns the total size (in bytes) of all entries in the model
         */
        get_size(): number;
        /**
         * Checks if a #RhythmDBQueryModel has any outstanding changes that are
         * yet to be processed.  This is not very useful.
         * @returns %TRUE if there are outstanding changes to the model
         */
        has_pending_changes(): boolean;
        /**
         * Locates and returns the #RhythmDBEntry pointed to by the specified iterator
         * in the model.  The caller owns a reference to the returned entry.
         * @param entry_iter a #GtkTreeIter to dereference
         * @returns the #RhythmDBEntry, if any
         */
        iter_to_entry(entry_iter: Gtk.TreeIter): RhythmDBEntry;
        /**
         * Moves an entry to a new position in the query model.
         * The position must be a between 0 and the number of entries in the model.
         * Specifying -1 does not move the entry to the end of the model.
         * @param entry the #RhythmDBEntry to move
         * @param index position to move to
         */
        move_entry(entry: RhythmDBEntry, index: number): void;
        /**
         * Reapplies the existing query to the entries in the model.  This
         * is mostly useful when the query contains relative time criteria
         * (such as 'not played in the last hour').  This will only remove
         * entries that are already in the model, it will not find entries
         * that previously did not match the query.
         *
         * The 'filter' parameter should be set to TRUE when the query is
         * being used as a filter, rather than to define a base set of entries.
         * @param filter if %FALSE, emit entry-removed signals
         */
        reapply_query(filter: boolean): void;
        /**
         * Removes an entry from the query model.
         * @param entry the #RhythmDBEntry to remove
         * @returns %TRUE if the entry was removed
         */
        remove_entry(entry: RhythmDBEntry): boolean;
        /**
         * Sets a new sort order on the model.  This reorders the entries
         * in the model to match the new sort order.
         * @param sort_func new sort function
         * @param sort_reverse if %TRUE, reverse the sort order
         */
        set_sort_order(sort_func: GLib.CompareDataFunc, sort_reverse: boolean): void;
        /**
         * Shuffles the entries in the model into a new random order.
         */
        shuffle_entries(): void;
        /**
         * Locates the #RhythmDBEntry identified by the specified path in the model.
         * The caller owns a reference to the returned entry.
         * @param path a #GtkTreePath
         * @returns the #RhythmDBEntry, if any
         */
        tree_path_to_entry(path: Gtk.TreePath): RhythmDBEntry;

        // Inherited methods
        /**
         * Creates a new #GtkTreeModel, with `child_model` as the child_model
         * and `root` as the virtual root.
         * @param root A #GtkTreePath or %NULL.
         * @returns A new #GtkTreeModel.
         */
        filter_new(root?: Gtk.TreePath | null): Gtk.TreeModel;
        /**
         * Calls func on each node in model in a depth-first fashion.
         *
         * If `func` returns %TRUE, then the tree ceases to be walked,
         * and gtk_tree_model_foreach() returns.
         * @param func a function to be called on each row
         */
        foreach(func: Gtk.TreeModelForeachFunc): void;
        /**
         * Returns the type of the column.
         * @param index_ the column index
         * @returns the type of the column
         */
        get_column_type(index_: number): GObject.GType;
        /**
         * Returns a set of flags supported by this interface.
         *
         * The flags are a bitwise combination of #GtkTreeModelFlags.
         * The flags supported should not change during the lifetime
         * of the `tree_model`.
         * @returns the flags supported by this interface
         */
        get_flags(): Gtk.TreeModelFlags;
        /**
         * Sets `iter` to a valid iterator pointing to `path`.  If `path` does
         * not exist, `iter` is set to an invalid iterator and %FALSE is returned.
         * @param path the #GtkTreePath-struct
         * @returns %TRUE, if @iter was set
         */
        get_iter(path: Gtk.TreePath): [boolean, Gtk.TreeIter];
        /**
         * Initializes `iter` with the first iterator in the tree
         * (the one at the path "0") and returns %TRUE. Returns
         * %FALSE if the tree is empty.
         * @returns %TRUE, if @iter was set
         */
        get_iter_first(): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to a valid iterator pointing to `path_string,` if it
         * exists. Otherwise, `iter` is left invalid and %FALSE is returned.
         * @param path_string a string representation of a #GtkTreePath-struct
         * @returns %TRUE, if @iter was set
         */
        get_iter_from_string(path_string: string): [boolean, Gtk.TreeIter];
        /**
         * Returns the number of columns supported by `tree_model`.
         * @returns the number of columns
         */
        get_n_columns(): number;
        /**
         * Returns a newly-created #GtkTreePath-struct referenced by `iter`.
         *
         * This path should be freed with gtk_tree_path_free().
         * @param iter the #GtkTreeIter-struct
         * @returns a newly-created #GtkTreePath-struct
         */
        get_path(iter: Gtk.TreeIter): Gtk.TreePath;
        /**
         * Generates a string representation of the iter.
         *
         * This string is a “:” separated list of numbers.
         * For example, “4:10:0:3” would be an acceptable
         * return value for this string.
         * @param iter a #GtkTreeIter-struct
         * @returns a newly-allocated string.     Must be freed with g_free().
         */
        get_string_from_iter(iter: Gtk.TreeIter): string;
        /**
         * Initializes and sets `value` to that at `column`.
         *
         * When done with `value,` g_value_unset() needs to be called
         * to free any allocated memory.
         * @param iter the #GtkTreeIter-struct
         * @param column the column to lookup the value at
         */
        get_value(iter: Gtk.TreeIter, column: number): unknown;
        /**
         * Sets `iter` to point to the first child of `parent`.
         *
         * If `parent` has no children, %FALSE is returned and `iter` is
         * set to be invalid. `parent` will remain a valid node after this
         * function has been called.
         *
         * If `parent` is %NULL returns the first node, equivalent to
         * `gtk_tree_model_get_iter_first (tree_model, iter);`
         * @param parent the #GtkTreeIter-struct, or %NULL
         * @returns %TRUE, if @iter has been set to the first child
         */
        iter_children(parent?: Gtk.TreeIter | null): [boolean, Gtk.TreeIter];
        /**
         * Returns %TRUE if `iter` has children, %FALSE otherwise.
         * @param iter the #GtkTreeIter-struct to test for children
         * @returns %TRUE if @iter has children
         */
        iter_has_child(iter: Gtk.TreeIter): boolean;
        /**
         * Returns the number of children that `iter` has.
         *
         * As a special case, if `iter` is %NULL, then the number
         * of toplevel nodes is returned.
         * @param iter the #GtkTreeIter-struct, or %NULL
         * @returns the number of children of @iter
         */
        iter_n_children(iter?: Gtk.TreeIter | null): number;
        /**
         * Sets `iter` to point to the node following it at the current level.
         *
         * If there is no next `iter,` %FALSE is returned and `iter` is set
         * to be invalid.
         * @param iter the #GtkTreeIter-struct
         * @returns %TRUE if @iter has been changed to the next node
         */
        iter_next(iter: Gtk.TreeIter): boolean;
        /**
         * Sets `iter` to be the child of `parent,` using the given index.
         *
         * The first index is 0. If `n` is too big, or `parent` has no children,
         * `iter` is set to an invalid iterator and %FALSE is returned. `parent`
         * will remain a valid node after this function has been called. As a
         * special case, if `parent` is %NULL, then the `n-th` root node
         * is set.
         * @param parent the #GtkTreeIter-struct to get the child from, or %NULL.
         * @param n the index of the desired child
         * @returns %TRUE, if @parent has an @n-th child
         */
        iter_nth_child(parent: Gtk.TreeIter | null, n: number): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to be the parent of `child`.
         *
         * If `child` is at the toplevel, and doesn’t have a parent, then
         * `iter` is set to an invalid iterator and %FALSE is returned.
         * `child` will remain a valid node after this function has been
         * called.
         *
         * `iter` will be initialized before the lookup is performed, so `child`
         * and `iter` cannot point to the same memory location.
         * @param child the #GtkTreeIter-struct
         * @returns %TRUE, if @iter is set to the parent of @child
         */
        iter_parent(child: Gtk.TreeIter): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to point to the previous node at the current level.
         *
         * If there is no previous `iter,` %FALSE is returned and `iter` is
         * set to be invalid.
         * @param iter the #GtkTreeIter-struct
         * @returns %TRUE if @iter has been changed to the previous node
         */
        iter_previous(iter: Gtk.TreeIter): boolean;
        /**
         * Lets the tree ref the node.
         *
         * This is an optional method for models to implement.
         * To be more specific, models may ignore this call as it exists
         * primarily for performance reasons.
         *
         * This function is primarily meant as a way for views to let
         * caching models know when nodes are being displayed (and hence,
         * whether or not to cache that node). Being displayed means a node
         * is in an expanded branch, regardless of whether the node is currently
         * visible in the viewport. For example, a file-system based model
         * would not want to keep the entire file-hierarchy in memory,
         * just the sections that are currently being displayed by
         * every current view.
         *
         * A model should be expected to be able to get an iter independent
         * of its reffed state.
         * @param iter the #GtkTreeIter-struct
         */
        ref_node(iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-changed signal on `tree_model`.
         * @param path a #GtkTreePath-struct pointing to the changed row
         * @param iter a valid #GtkTreeIter-struct pointing to the changed row
         */
        row_changed(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-deleted signal on `tree_model`.
         *
         * This should be called by models after a row has been removed.
         * The location pointed to by `path` should be the location that
         * the row previously was at. It may not be a valid location anymore.
         *
         * Nodes that are deleted are not unreffed, this means that any
         * outstanding references on the deleted node should not be released.
         * @param path a #GtkTreePath-struct pointing to the previous location of     the deleted row
         */
        row_deleted(path: Gtk.TreePath): void;
        /**
         * Emits the #GtkTreeModel::row-has-child-toggled signal on
         * `tree_model`. This should be called by models after the child
         * state of a node changes.
         * @param path a #GtkTreePath-struct pointing to the changed row
         * @param iter a valid #GtkTreeIter-struct pointing to the changed row
         */
        row_has_child_toggled(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-inserted signal on `tree_model`.
         * @param path a #GtkTreePath-struct pointing to the inserted row
         * @param iter a valid #GtkTreeIter-struct pointing to the inserted row
         */
        row_inserted(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::rows-reordered signal on `tree_model`.
         *
         * This should be called by models when their rows have been
         * reordered.
         * @param path a #GtkTreePath-struct pointing to the tree node whose children     have been reordered
         * @param iter a valid #GtkTreeIter-struct pointing to the node     whose children have been reordered, or %NULL if the depth     of @path is 0
         * @param new_order an array of integers     mapping the current position of each child to its old     position before the re-ordering,     i.e. @new_order`[newpos] = oldpos`
         */
        rows_reordered(path: Gtk.TreePath, iter: Gtk.TreeIter | null, new_order: number[]): void;
        /**
         * Lets the tree unref the node.
         *
         * This is an optional method for models to implement.
         * To be more specific, models may ignore this call as it exists
         * primarily for performance reasons. For more information on what
         * this means, see gtk_tree_model_ref_node().
         *
         * Please note that nodes that are deleted are not unreffed.
         * @param iter the #GtkTreeIter-struct
         */
        unref_node(iter: Gtk.TreeIter): void;
        /**
         * Returns the type of the column.
         * @param index_ the column index
         */
        vfunc_get_column_type(index_: number): GObject.GType;
        /**
         * Returns a set of flags supported by this interface.
         *
         * The flags are a bitwise combination of #GtkTreeModelFlags.
         * The flags supported should not change during the lifetime
         * of the `tree_model`.
         */
        vfunc_get_flags(): Gtk.TreeModelFlags;
        /**
         * Sets `iter` to a valid iterator pointing to `path`.  If `path` does
         * not exist, `iter` is set to an invalid iterator and %FALSE is returned.
         * @param path the #GtkTreePath-struct
         */
        vfunc_get_iter(path: Gtk.TreePath): [boolean, Gtk.TreeIter];
        /**
         * Returns the number of columns supported by `tree_model`.
         */
        vfunc_get_n_columns(): number;
        /**
         * Returns a newly-created #GtkTreePath-struct referenced by `iter`.
         *
         * This path should be freed with gtk_tree_path_free().
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_get_path(iter: Gtk.TreeIter): Gtk.TreePath;
        /**
         * Initializes and sets `value` to that at `column`.
         *
         * When done with `value,` g_value_unset() needs to be called
         * to free any allocated memory.
         * @param iter the #GtkTreeIter-struct
         * @param column the column to lookup the value at
         */
        vfunc_get_value(iter: Gtk.TreeIter, column: number): unknown;
        /**
         * Sets `iter` to point to the first child of `parent`.
         *
         * If `parent` has no children, %FALSE is returned and `iter` is
         * set to be invalid. `parent` will remain a valid node after this
         * function has been called.
         *
         * If `parent` is %NULL returns the first node, equivalent to
         * `gtk_tree_model_get_iter_first (tree_model, iter);`
         * @param parent the #GtkTreeIter-struct, or %NULL
         */
        vfunc_iter_children(parent?: Gtk.TreeIter | null): [boolean, Gtk.TreeIter];
        /**
         * Returns %TRUE if `iter` has children, %FALSE otherwise.
         * @param iter the #GtkTreeIter-struct to test for children
         */
        vfunc_iter_has_child(iter: Gtk.TreeIter): boolean;
        /**
         * Returns the number of children that `iter` has.
         *
         * As a special case, if `iter` is %NULL, then the number
         * of toplevel nodes is returned.
         * @param iter the #GtkTreeIter-struct, or %NULL
         */
        vfunc_iter_n_children(iter?: Gtk.TreeIter | null): number;
        /**
         * Sets `iter` to point to the node following it at the current level.
         *
         * If there is no next `iter,` %FALSE is returned and `iter` is set
         * to be invalid.
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_iter_next(iter: Gtk.TreeIter): boolean;
        /**
         * Sets `iter` to be the child of `parent,` using the given index.
         *
         * The first index is 0. If `n` is too big, or `parent` has no children,
         * `iter` is set to an invalid iterator and %FALSE is returned. `parent`
         * will remain a valid node after this function has been called. As a
         * special case, if `parent` is %NULL, then the `n-th` root node
         * is set.
         * @param parent the #GtkTreeIter-struct to get the child from, or %NULL.
         * @param n the index of the desired child
         */
        vfunc_iter_nth_child(parent: Gtk.TreeIter | null, n: number): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to be the parent of `child`.
         *
         * If `child` is at the toplevel, and doesn’t have a parent, then
         * `iter` is set to an invalid iterator and %FALSE is returned.
         * `child` will remain a valid node after this function has been
         * called.
         *
         * `iter` will be initialized before the lookup is performed, so `child`
         * and `iter` cannot point to the same memory location.
         * @param child the #GtkTreeIter-struct
         */
        vfunc_iter_parent(child: Gtk.TreeIter): [boolean, Gtk.TreeIter];
        /**
         * Sets `iter` to point to the previous node at the current level.
         *
         * If there is no previous `iter,` %FALSE is returned and `iter` is
         * set to be invalid.
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_iter_previous(iter: Gtk.TreeIter): boolean;
        /**
         * Lets the tree ref the node.
         *
         * This is an optional method for models to implement.
         * To be more specific, models may ignore this call as it exists
         * primarily for performance reasons.
         *
         * This function is primarily meant as a way for views to let
         * caching models know when nodes are being displayed (and hence,
         * whether or not to cache that node). Being displayed means a node
         * is in an expanded branch, regardless of whether the node is currently
         * visible in the viewport. For example, a file-system based model
         * would not want to keep the entire file-hierarchy in memory,
         * just the sections that are currently being displayed by
         * every current view.
         *
         * A model should be expected to be able to get an iter independent
         * of its reffed state.
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_ref_node(iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-changed signal on `tree_model`.
         * @param path a #GtkTreePath-struct pointing to the changed row
         * @param iter a valid #GtkTreeIter-struct pointing to the changed row
         */
        vfunc_row_changed(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-deleted signal on `tree_model`.
         *
         * This should be called by models after a row has been removed.
         * The location pointed to by `path` should be the location that
         * the row previously was at. It may not be a valid location anymore.
         *
         * Nodes that are deleted are not unreffed, this means that any
         * outstanding references on the deleted node should not be released.
         * @param path a #GtkTreePath-struct pointing to the previous location of     the deleted row
         */
        vfunc_row_deleted(path: Gtk.TreePath): void;
        /**
         * Emits the #GtkTreeModel::row-has-child-toggled signal on
         * `tree_model`. This should be called by models after the child
         * state of a node changes.
         * @param path a #GtkTreePath-struct pointing to the changed row
         * @param iter a valid #GtkTreeIter-struct pointing to the changed row
         */
        vfunc_row_has_child_toggled(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Emits the #GtkTreeModel::row-inserted signal on `tree_model`.
         * @param path a #GtkTreePath-struct pointing to the inserted row
         * @param iter a valid #GtkTreeIter-struct pointing to the inserted row
         */
        vfunc_row_inserted(path: Gtk.TreePath, iter: Gtk.TreeIter): void;
        /**
         * Lets the tree unref the node.
         *
         * This is an optional method for models to implement.
         * To be more specific, models may ignore this call as it exists
         * primarily for performance reasons. For more information on what
         * this means, see gtk_tree_model_ref_node().
         *
         * Please note that nodes that are deleted are not unreffed.
         * @param iter the #GtkTreeIter-struct
         */
        vfunc_unref_node(iter: Gtk.TreeIter): void;
        /**
         * Provides a new set of query results.  References must be taken on the
         * entries.
         * @param entries #GPtrArray containing #RhythmDBEntry results
         */
        add_results(entries: RhythmDBEntry[]): void;
        /**
         * Called when the query is complete and all entries that match the query
         * have been supplied to rhythmdb_query_results_add_results.  If the object
         * implementing this interface needs to identify newly added or changed entries
         * that match the query, it needs to use the entry-added, entry-deleted and
         * entry-changed signals from #RhythmDB.
         */
        query_complete(): void;
        /**
         * Provides a new set of query results.  References must be taken on the
         * entries.
         * @param entries #GPtrArray containing #RhythmDBEntry results
         */
        vfunc_add_results(entries: RhythmDBEntry[]): void;
        /**
         * Called when the query is complete and all entries that match the query
         * have been supplied to rhythmdb_query_results_add_results.  If the object
         * implementing this interface needs to identify newly added or changed entries
         * that match the query, it needs to use the entry-added, entry-deleted and
         * entry-changed signals from #RhythmDB.
         */
        vfunc_query_complete(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace RhythmDBQueryResultList {
        // Signal callback interfaces

        interface Complete {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, RhythmDBQueryResults.ConstructorProps {}
    }

    class RhythmDBQueryResultList extends GObject.Object implements RhythmDBQueryResults {
        static $gtype: GObject.GType<RhythmDBQueryResultList>;

        // Constructors

        constructor(properties?: Partial<RhythmDBQueryResultList.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): RhythmDBQueryResultList;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'complete', callback: (_source: this) => void): number;
        connect_after(signal: 'complete', callback: (_source: this) => void): number;
        emit(signal: 'complete'): void;

        // Virtual methods

        vfunc_complete(): void;

        // Methods

        /**
         * Returns the results from the query.
         * @returns list of results
         */
        get_results(): RhythmDBEntry[];

        // Inherited methods
        /**
         * Provides a new set of query results.  References must be taken on the
         * entries.
         * @param entries #GPtrArray containing #RhythmDBEntry results
         */
        add_results(entries: RhythmDBEntry[]): void;
        /**
         * Called when the query is complete and all entries that match the query
         * have been supplied to rhythmdb_query_results_add_results.  If the object
         * implementing this interface needs to identify newly added or changed entries
         * that match the query, it needs to use the entry-added, entry-deleted and
         * entry-changed signals from #RhythmDB.
         */
        query_complete(): void;
        /**
         * Provides a new set of query results.  References must be taken on the
         * entries.
         * @param entries #GPtrArray containing #RhythmDBEntry results
         */
        vfunc_add_results(entries: RhythmDBEntry[]): void;
        /**
         * Called when the query is complete and all entries that match the query
         * have been supplied to rhythmdb_query_results_add_results.  If the object
         * implementing this interface needs to identify newly added or changed entries
         * that match the query, it needs to use the entry-added, entry-deleted and
         * entry-changed signals from #RhythmDB.
         */
        vfunc_query_complete(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace SearchEntry {
        // Signal callback interfaces

        interface Activate {
            (text: string): void;
        }

        interface Search {
            (text: string): void;
        }

        interface ShowPopup {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Box.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {
            explicit_mode: boolean;
            explicitMode: boolean;
            has_popup: boolean;
            hasPopup: boolean;
        }
    }

    class SearchEntry extends Gtk.Box implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<SearchEntry>;

        // Properties

        /**
         * If TRUE, show a button and only emit the 'search' signal when
         * the user presses it rather than when they stop typing.
         */
        get explicit_mode(): boolean;
        set explicit_mode(val: boolean);
        /**
         * If TRUE, show a button and only emit the 'search' signal when
         * the user presses it rather than when they stop typing.
         */
        get explicitMode(): boolean;
        set explicitMode(val: boolean);
        /**
         * If TRUE, show a primary icon and emit the show-popup when clicked.
         */
        get has_popup(): boolean;
        /**
         * If TRUE, show a primary icon and emit the show-popup when clicked.
         */
        get hasPopup(): boolean;

        // Constructors

        constructor(properties?: Partial<SearchEntry.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](has_popup: boolean): SearchEntry;
        // Conflicted with Gtk.Box.new

        static ['new'](...args: never[]): any;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'activate', callback: (_source: this, text: string) => void): number;
        connect_after(signal: 'activate', callback: (_source: this, text: string) => void): number;
        emit(signal: 'activate', text: string): void;
        connect(signal: 'search', callback: (_source: this, text: string) => void): number;
        connect_after(signal: 'search', callback: (_source: this, text: string) => void): number;
        emit(signal: 'search', text: string): void;
        connect(signal: 'show-popup', callback: (_source: this) => void): number;
        connect_after(signal: 'show-popup', callback: (_source: this) => void): number;
        emit(signal: 'show-popup'): void;

        // Virtual methods

        vfunc_activate(text: string): void;
        vfunc_search(text: string): void;
        vfunc_show_popup(): void;

        // Methods

        /**
         * Clears the search entry text.  The 'search' signal will
         * be emitted.
         */
        clear(): void;
        /**
         * Grabs input focus for the text entry widget.
         */
        grab_focus(): void;
        /**
         * Returns %TRUE if there is search text in the entry widget.
         * @returns %TRUE if searching
         */
        searching(): boolean;
        /**
         * Adds or removes a mnemonic allowing the user to focus
         * the search entry.
         * @param enable if %TRUE, enable the mnemonic
         */
        set_mnemonic(enable: boolean): void;
        /**
         * Sets the placeholder text in the search entry box.
         * @param text placeholder text
         */
        set_placeholder(text: string): void;
        /**
         * Sets the text in the search entry box.
         * The 'search' signal will be emitted.
         * @param text new search text
         */
        set_text(text: string): void;

        // Inherited properties
        /**
         * The orientation of the orientable.
         */
        get orientation(): Gtk.Orientation;
        set orientation(val: Gtk.Orientation);

        // Inherited methods
        /**
         * Retrieves the orientation of the `orientable`.
         * @returns the orientation of the @orientable.
         */
        get_orientation(): Gtk.Orientation;
        /**
         * Sets the orientation of the `orientable`.
         * @param orientation the orientable’s new orientation.
         */
        set_orientation(orientation: Gtk.Orientation | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace SegmentedBar {
        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Widget.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps {
            bar_height: number;
            barHeight: number;
            show_labels: boolean;
            showLabels: boolean;
            show_reflection: boolean;
            showReflection: boolean;
        }
    }

    class SegmentedBar extends Gtk.Widget implements Atk.ImplementorIface, Gtk.Buildable {
        static $gtype: GObject.GType<SegmentedBar>;

        // Properties

        /**
         * Height of the segmented bar
         */
        get bar_height(): number;
        set bar_height(val: number);
        /**
         * Height of the segmented bar
         */
        get barHeight(): number;
        set barHeight(val: number);
        /**
         * Set to TRUE if you want labels describing the various segments
         * to be shown.
         */
        get show_labels(): boolean;
        set show_labels(val: boolean);
        /**
         * Set to TRUE if you want labels describing the various segments
         * to be shown.
         */
        get showLabels(): boolean;
        set showLabels(val: boolean);
        /**
         * Set to TRUE if you want a reflection to be shown below the segmented
         * bar.
         */
        get show_reflection(): boolean;
        set show_reflection(val: boolean);
        /**
         * Set to TRUE if you want a reflection to be shown below the segmented
         * bar.
         */
        get showReflection(): boolean;
        set showReflection(val: boolean);

        // Constructors

        constructor(properties?: Partial<SegmentedBar.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): SegmentedBar;

        // Methods

        add_segment(title: string, percent: number, red: number, green: number, blue: number, alpha: number): number;
        add_segment_default_color(title: string, percent: number): number;
        /**
         * Sets a value formatter function to use for the bar.
         * @param formatter the formatter function to use
         */
        set_value_formatter(formatter: SegmentedBarValueFormatter): void;
        update_segment(segment_index: number, percent: number): void;

        // Inherited methods
        /**
         * Adds a child to `buildable`. `type` is an optional string
         * describing how the child should be added.
         * @param builder a #GtkBuilder
         * @param child child to add
         * @param type kind of child or %NULL
         */
        add_child(builder: Gtk.Builder, child: GObject.Object, type?: string | null): void;
        /**
         * Constructs a child of `buildable` with the name `name`.
         *
         * #GtkBuilder calls this function if a “constructor” has been
         * specified in the UI definition.
         * @param builder #GtkBuilder used to construct this object
         * @param name name of child to construct
         * @returns the constructed child
         */
        construct_child<T = GObject.Object>(builder: Gtk.Builder, name: string): T;
        /**
         * This is similar to gtk_buildable_parser_finished() but is
         * called once for each custom tag handled by the `buildable`.
         * @param builder a #GtkBuilder
         * @param child child object or %NULL for non-child tags
         * @param tagname the name of the tag
         * @param data user data created in custom_tag_start
         */
        custom_finished(builder: Gtk.Builder, child: GObject.Object | null, tagname: string, data?: any | null): void;
        /**
         * This is called at the end of each custom element handled by
         * the buildable.
         * @param builder #GtkBuilder used to construct this object
         * @param child child object or %NULL for non-child tags
         * @param tagname name of tag
         * @param data user data that will be passed in to parser functions
         */
        custom_tag_end(builder: Gtk.Builder, child: GObject.Object | null, tagname: string, data?: any | null): void;
        /**
         * This is called for each unknown element under `<child>`.
         * @param builder a #GtkBuilder used to construct this object
         * @param child child object or %NULL for non-child tags
         * @param tagname name of tag
         * @returns %TRUE if a object has a custom implementation, %FALSE          if it doesn't.
         */
        custom_tag_start(
            builder: Gtk.Builder,
            child: GObject.Object | null,
            tagname: string,
        ): [boolean, GLib.MarkupParser, any];
        /**
         * Get the internal child called `childname` of the `buildable` object.
         * @param builder a #GtkBuilder
         * @param childname name of child
         * @returns the internal child of the buildable object
         */
        get_internal_child<T = GObject.Object>(builder: Gtk.Builder, childname: string): T;
        /**
         * Gets the name of the `buildable` object.
         *
         * #GtkBuilder sets the name based on the
         * [GtkBuilder UI definition][BUILDER-UI]
         * used to construct the `buildable`.
         * @returns the name set with gtk_buildable_set_name()
         */
        get_name(): string;
        /**
         * Called when the builder finishes the parsing of a
         * [GtkBuilder UI definition][BUILDER-UI].
         * Note that this will be called once for each time
         * gtk_builder_add_from_file() or gtk_builder_add_from_string()
         * is called on a builder.
         * @param builder a #GtkBuilder
         */
        parser_finished(builder: Gtk.Builder): void;
        /**
         * Sets the property name `name` to `value` on the `buildable` object.
         * @param builder a #GtkBuilder
         * @param name name of property
         * @param value value of property
         */
        set_buildable_property(builder: Gtk.Builder, name: string, value: GObject.Value | any): void;
        /**
         * Sets the name of the `buildable` object.
         * @param name name to set
         */
        set_name(name: string): void;
        /**
         * Adds a child to `buildable`. `type` is an optional string
         * describing how the child should be added.
         * @param builder a #GtkBuilder
         * @param child child to add
         * @param type kind of child or %NULL
         */
        vfunc_add_child(builder: Gtk.Builder, child: GObject.Object, type?: string | null): void;
        /**
         * Constructs a child of `buildable` with the name `name`.
         *
         * #GtkBuilder calls this function if a “constructor” has been
         * specified in the UI definition.
         * @param builder #GtkBuilder used to construct this object
         * @param name name of child to construct
         */
        vfunc_construct_child<T = GObject.Object>(builder: Gtk.Builder, name: string): T;
        /**
         * This is similar to gtk_buildable_parser_finished() but is
         * called once for each custom tag handled by the `buildable`.
         * @param builder a #GtkBuilder
         * @param child child object or %NULL for non-child tags
         * @param tagname the name of the tag
         * @param data user data created in custom_tag_start
         */
        vfunc_custom_finished(
            builder: Gtk.Builder,
            child: GObject.Object | null,
            tagname: string,
            data?: any | null,
        ): void;
        /**
         * This is called at the end of each custom element handled by
         * the buildable.
         * @param builder #GtkBuilder used to construct this object
         * @param child child object or %NULL for non-child tags
         * @param tagname name of tag
         * @param data user data that will be passed in to parser functions
         */
        vfunc_custom_tag_end(
            builder: Gtk.Builder,
            child: GObject.Object | null,
            tagname: string,
            data?: any | null,
        ): void;
        /**
         * This is called for each unknown element under `<child>`.
         * @param builder a #GtkBuilder used to construct this object
         * @param child child object or %NULL for non-child tags
         * @param tagname name of tag
         */
        vfunc_custom_tag_start(
            builder: Gtk.Builder,
            child: GObject.Object | null,
            tagname: string,
        ): [boolean, GLib.MarkupParser, any];
        /**
         * Get the internal child called `childname` of the `buildable` object.
         * @param builder a #GtkBuilder
         * @param childname name of child
         */
        vfunc_get_internal_child<T = GObject.Object>(builder: Gtk.Builder, childname: string): T;
        /**
         * Gets the name of the `buildable` object.
         *
         * #GtkBuilder sets the name based on the
         * [GtkBuilder UI definition][BUILDER-UI]
         * used to construct the `buildable`.
         */
        vfunc_get_name(): string;
        /**
         * Called when the builder finishes the parsing of a
         * [GtkBuilder UI definition][BUILDER-UI].
         * Note that this will be called once for each time
         * gtk_builder_add_from_file() or gtk_builder_add_from_string()
         * is called on a builder.
         * @param builder a #GtkBuilder
         */
        vfunc_parser_finished(builder: Gtk.Builder): void;
        /**
         * Sets the property name `name` to `value` on the `buildable` object.
         * @param builder a #GtkBuilder
         * @param name name of property
         * @param value value of property
         */
        vfunc_set_buildable_property(builder: Gtk.Builder, name: string, value: GObject.Value | any): void;
        /**
         * Sets the name of the `buildable` object.
         * @param name name to set
         */
        vfunc_set_name(name: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace Shell {
        // Signal callback interfaces

        interface CreateSongInfo {
            (song_info: SongInfo, multi: boolean): void;
        }

        interface NotifyCustom {
            (timeout: number, primary: string, secondary: string, image_uri: string, requested: boolean): void;
        }

        interface NotifyPlayingEntry {
            (requested: boolean): void;
        }

        interface VisibilityChanged {
            (visibile: boolean): void;
        }

        interface VisibilityChanging {
            (initial: boolean, visible: boolean): boolean;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            accel_group: Gtk.AccelGroup;
            accelGroup: Gtk.AccelGroup;
            application: Application;
            autostarted: boolean;
            db: RhythmDB;
            disable_plugins: boolean;
            disablePlugins: boolean;
            display_page_model: DisplayPageModel;
            displayPageModel: DisplayPageModel;
            display_page_tree: DisplayPageTree;
            displayPageTree: DisplayPageTree;
            dry_run: boolean;
            dryRun: boolean;
            no_registration: boolean;
            noRegistration: boolean;
            no_update: boolean;
            noUpdate: boolean;
            playlist_manager: PlaylistManager;
            playlistManager: PlaylistManager;
            playlists_file: string;
            playlistsFile: string;
            prefs: ShellPreferences;
            removable_media_manager: RemovableMediaManager;
            removableMediaManager: RemovableMediaManager;
            rhythmdb_file: string;
            rhythmdbFile: string;
            selected_page: DisplayPage;
            selectedPage: DisplayPage;
            shell_player: ShellPlayer;
            shellPlayer: ShellPlayer;
            task_list: TaskList;
            taskList: TaskList;
            track_transfer_queue: TrackTransferQueue;
            trackTransferQueue: TrackTransferQueue;
            visibility: boolean;
            window: Gtk.Window;
        }
    }

    class Shell extends GObject.Object {
        static $gtype: GObject.GType<Shell>;

        // Properties

        /**
         * A #GtkAccelGroup instance to use for additional accelerator keys
         */
        get accel_group(): Gtk.AccelGroup;
        /**
         * A #GtkAccelGroup instance to use for additional accelerator keys
         */
        get accelGroup(): Gtk.AccelGroup;
        get application(): Application;
        /**
         * Whether Rhythmbox was automatically started by the session manager
         */
        get autostarted(): boolean;
        /**
         * The #RhythmDB instance
         */
        get db(): RhythmDB;
        /**
         * If %TRUE, disable plugins
         */
        get disable_plugins(): boolean;
        /**
         * If %TRUE, disable plugins
         */
        get disablePlugins(): boolean;
        /**
         * The model underlying the display page tree
         */
        get display_page_model(): DisplayPageModel;
        /**
         * The model underlying the display page tree
         */
        get displayPageModel(): DisplayPageModel;
        /**
         * The #RBDisplayPageTree instance
         */
        get display_page_tree(): DisplayPageTree;
        /**
         * The #RBDisplayPageTree instance
         */
        get displayPageTree(): DisplayPageTree;
        /**
         * If TRUE, don't write back file metadata changes.
         */
        get dry_run(): boolean;
        /**
         * If TRUE, don't write back file metadata changes.
         */
        get dryRun(): boolean;
        /**
         * If %TRUE, disable single-instance features.
         */
        get no_registration(): boolean;
        /**
         * If %TRUE, disable single-instance features.
         */
        get noRegistration(): boolean;
        /**
         * If %TRUE, don't update the database.
         */
        get no_update(): boolean;
        /**
         * If %TRUE, don't update the database.
         */
        get noUpdate(): boolean;
        /**
         * The #RBPlaylistManager instance
         */
        get playlist_manager(): PlaylistManager;
        /**
         * The #RBPlaylistManager instance
         */
        get playlistManager(): PlaylistManager;
        /**
         * The path to the playlist file
         */
        get playlists_file(): string;
        /**
         * The path to the playlist file
         */
        get playlistsFile(): string;
        /**
         * The #RBShellPreferences instance
         */
        get prefs(): ShellPreferences;
        /**
         * The #RBRemovableMediaManager instance
         */
        get removable_media_manager(): RemovableMediaManager;
        /**
         * The #RBRemovableMediaManager instance
         */
        get removableMediaManager(): RemovableMediaManager;
        /**
         * The path to the rhythmdb file
         */
        get rhythmdb_file(): string;
        /**
         * The path to the rhythmdb file
         */
        get rhythmdbFile(): string;
        /**
         * The currently selected display page
         */
        get selected_page(): DisplayPage;
        /**
         * The currently selected display page
         */
        get selectedPage(): DisplayPage;
        /**
         * The #RBShellPlayer instance
         */
        get shell_player(): ShellPlayer;
        /**
         * The #RBShellPlayer instance
         */
        get shellPlayer(): ShellPlayer;
        /**
         * The #RBTaskList instance
         */
        get task_list(): TaskList;
        /**
         * The #RBTaskList instance
         */
        get taskList(): TaskList;
        /**
         * The #RBTrackTransferQueue instance
         */
        get track_transfer_queue(): TrackTransferQueue;
        /**
         * The #RBTrackTransferQueue instance
         */
        get trackTransferQueue(): TrackTransferQueue;
        /**
         * Whether the main window is currently visible.
         */
        get visibility(): boolean;
        set visibility(val: boolean);
        /**
         * The main Rhythmbox window.
         */
        get window(): Gtk.Window;

        // Constructors

        constructor(properties?: Partial<Shell.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'create-song-info',
            callback: (_source: this, song_info: SongInfo, multi: boolean) => void,
        ): number;
        connect_after(
            signal: 'create-song-info',
            callback: (_source: this, song_info: SongInfo, multi: boolean) => void,
        ): number;
        emit(signal: 'create-song-info', song_info: SongInfo, multi: boolean): void;
        connect(
            signal: 'notify-custom',
            callback: (
                _source: this,
                timeout: number,
                primary: string,
                secondary: string,
                image_uri: string,
                requested: boolean,
            ) => void,
        ): number;
        connect_after(
            signal: 'notify-custom',
            callback: (
                _source: this,
                timeout: number,
                primary: string,
                secondary: string,
                image_uri: string,
                requested: boolean,
            ) => void,
        ): number;
        emit(
            signal: 'notify-custom',
            timeout: number,
            primary: string,
            secondary: string,
            image_uri: string,
            requested: boolean,
        ): void;
        connect(signal: 'notify-playing-entry', callback: (_source: this, requested: boolean) => void): number;
        connect_after(signal: 'notify-playing-entry', callback: (_source: this, requested: boolean) => void): number;
        emit(signal: 'notify-playing-entry', requested: boolean): void;
        connect(signal: 'visibility-changed', callback: (_source: this, visibile: boolean) => void): number;
        connect_after(signal: 'visibility-changed', callback: (_source: this, visibile: boolean) => void): number;
        emit(signal: 'visibility-changed', visibile: boolean): void;
        connect(
            signal: 'visibility-changing',
            callback: (_source: this, initial: boolean, visible: boolean) => boolean,
        ): number;
        connect_after(
            signal: 'visibility-changing',
            callback: (_source: this, initial: boolean, visible: boolean) => boolean,
        ): number;
        emit(signal: 'visibility-changing', initial: boolean, visible: boolean): void;

        // Virtual methods

        vfunc_create_song_info(song_info: SongInfo, multi: boolean): void;
        vfunc_database_load_complete(): void;
        vfunc_removable_media_scan_finished(): void;
        vfunc_visibility_changed(visible: boolean): void;
        vfunc_visibility_changing(initial: boolean, visible: boolean): boolean;

        // Methods

        activate_source(source: Source, play: number): boolean;
        /**
         * Searches for a source matching `source_uri` and if found, selects it,
         * and depending on the value of `play,` may start playing from it.
         * Device-based sources will match the device node or mount point URI.
         * Other types of sources may have their own URI scheme or format.
         * This is part of the DBus interface.
         * @param source_uri URI for the source to activate
         * @param play 0: select source, 1: play source if not playing, 2: play source
         * @returns %TRUE if successful
         */
        activate_source_by_uri(source_uri: string, play: number): boolean;
        /**
         * Adds the specified URI to the Rhythmbox database.  Whether the
         * title and genre specified are actually used is up to the source
         * that handles the URI
         * @param uri the URI to add
         * @param title optional title value for the URI
         * @param genre optional genre value for the URI
         * @returns TRUE if the URI was added successfully
         */
        add_uri(uri: string, title: string, genre: string): boolean;
        /**
         * Adds a widget to the main Rhythmbox window.  See #gtk_box_pack_start for
         * details on how the expand and fill parameters work.
         * @param widget the #GtkWidget to insert into the main window
         * @param location the location at which to insert the widget
         * @param expand whether the widget should be given extra space
         * @param fill whether the widget should fill all space allocated to it
         */
        add_widget(widget: Gtk.Widget, location: ShellUILocation | null, expand: boolean, fill: boolean): void;
        /**
         * Adds a new display page to the shell.
         * @param page the new #RBDisplayPage
         * @param parent the parent page for the new page
         */
        append_display_page(page: DisplayPage, parent?: DisplayPage | null): void;
        /**
         * Displays a notification of the current playing track.
         * @param requested if %TRUE, the notification was requested by some explicit user action
         * @returns not important
         */
        do_notify(requested: boolean): boolean;
        /**
         * Gathers and returns all metadata (including extra metadata such as album
         * art URIs and lyrics) for the specified URI.
         * @param uri the URI to query
         * @returns %TRUE if the URI is found in the database
         */
        get_song_properties(uri: string): [boolean, GLib.HashTable<string, GObject.Value>];
        /**
         * Looks up and returns the source that owns entries of the specified
         * type.
         * @param type entry type for which to find a source
         * @returns source instance, if any
         */
        get_source_by_entry_type(type: RhythmDBEntryType): Source;
        /**
         * Attempts to locate the source that should handle the specified URI.
         * This iterates through all sources, calling #rb_source_want_uri,
         * returning the source that returns the highest value.
         * @param uri the URI to guess a source for
         * @returns the most appropriate #RBSource for the uri
         */
        guess_source_for_uri(uri: string): Source;
        /**
         * Loads a URI representing a single song, a directory, a playlist, or
         * an internet radio station, and optionally starts playing it.
         *
         * For playlists containing only stream URLs, we either add the playlist
         * itself (if it's remote) or each URL from it (if it's local).  The main
         * reason for this is so clicking on stream playlist links in web browsers
         * works properly - the playlist file will be downloaded to /tmp/, and
         * we can't add that to the database, so we need to add the stream URLs
         * instead.
         * @param uri the URI to load
         * @param play if TRUE, start playing the URI (if possible)
         * @returns TRUE if the URI was added successfully
         */
        load_uri(uri: string, play: boolean): boolean;
        notify_custom(timeout: number, primary: string, secondary: string, image_uri: string, requested: boolean): void;
        /**
         * Attempts to display the main window to the user.  See #gtk_window_present for details.
         * @param timestamp GTK timestamp to use (for focus-stealing prevention)
         * @returns not used.
         */
        present(timestamp: number): boolean;
        /**
         * Begins the process of shutting down Rhythmbox.  This function will
         * return.  The error parameter and return value only exist because this
         * function is part of the DBus interface.
         * @returns not important
         */
        quit(): boolean;
        /**
         * Registers a source as the owner of entries of the specified type.
         * The main effect of this is that calling #rb_shell_get_source_by_entry_type
         * with the same entry type will return the source.  A source should only
         * be registered as the owner of a single entry type.
         * @param source the #RBSource to register
         * @param type the #RhythmDBEntryType to register for
         */
        register_entry_type_for_source(source: Source, type: RhythmDBEntryType): void;
        /**
         * Removes a widget added with #rb_shell_add_widget from the main window.
         * @param widget the #GtkWidget to remove from the main window
         * @param location the UI location to which the widget was originally added
         */
        remove_widget(widget: Gtk.Widget, location: ShellUILocation | null): void;
        /**
         * Attempts to set a property of a database entry identified by its URI.
         * If the URI identifies a file and the property is one associated with a
         * file metadata tag, the new value will be written to the file.
         * @param uri the URI to modify
         * @param propname the name of the property to modify
         * @param value the new value to set
         * @returns %TRUE if the property was set successfully.
         */
        set_song_property(uri: string, propname: string, value: GObject.Value | any): boolean;
        /**
         * Toggles the visibility of the main Rhythmbox window.
         */
        toggle_visibility(): void;
    }

    namespace ShellPlayer {
        // Signal callback interfaces

        interface ElapsedChanged {
            (elapsed: number): void;
        }

        interface ElapsedNanoChanged {
            (elapsed: number): void;
        }

        interface PlayingChanged {
            (playing: boolean): void;
        }

        interface PlayingSongChanged {
            (entry: RhythmDBEntry): void;
        }

        interface PlayingSongPropertyChanged {
            (uri: string, property: string, old: GObject.Value | any, newvalue: GObject.Value | any): void;
        }

        interface PlayingSourceChanged {
            (source: Source): void;
        }

        interface PlayingUriChanged {
            (uri: string): void;
        }

        interface WindowTitleChanged {
            (title: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            db: RhythmDB;
            has_next: boolean;
            hasNext: boolean;
            has_prev: boolean;
            hasPrev: boolean;
            mute: boolean;
            play_order: string;
            playOrder: string;
            player: GObject.Object;
            playing: boolean;
            playing_from_queue: boolean;
            playingFromQueue: boolean;
            queue_only: boolean;
            queueOnly: boolean;
            queue_source: PlaylistSource;
            queueSource: PlaylistSource;
            source: Source;
            volume: number;
        }
    }

    class ShellPlayer extends GObject.Object {
        static $gtype: GObject.GType<ShellPlayer>;

        // Properties

        /**
         * The #RhythmDB
         */
        get db(): RhythmDB;
        /**
         * Whether there is a track to play after the current track.
         */
        get has_next(): boolean;
        /**
         * Whether there is a track to play after the current track.
         */
        get hasNext(): boolean;
        /**
         * Whether there was a previous track before the current track.
         */
        get has_prev(): boolean;
        /**
         * Whether there was a previous track before the current track.
         */
        get hasPrev(): boolean;
        /**
         * Whether playback is currently muted.
         */
        get mute(): boolean;
        set mute(val: boolean);
        /**
         * The current play order object.
         */
        get play_order(): string;
        /**
         * The current play order object.
         */
        get playOrder(): string;
        /**
         * The player backend object (an object implementing the #RBPlayer interface).
         */
        get player(): GObject.Object;
        /**
         * Whether Rhythmbox is currently playing something
         */
        get playing(): boolean;
        /**
         * If %TRUE, the current playing entry came from the play queue.
         */
        get playing_from_queue(): boolean;
        /**
         * If %TRUE, the current playing entry came from the play queue.
         */
        get playingFromQueue(): boolean;
        /**
         * If %TRUE, activating an entry should only add it to the play queue.
         */
        get queue_only(): boolean;
        set queue_only(val: boolean);
        /**
         * If %TRUE, activating an entry should only add it to the play queue.
         */
        get queueOnly(): boolean;
        set queueOnly(val: boolean);
        /**
         * The play queue source
         */
        get queue_source(): PlaylistSource;
        set queue_source(val: PlaylistSource);
        /**
         * The play queue source
         */
        get queueSource(): PlaylistSource;
        set queueSource(val: PlaylistSource);
        /**
         * The current source that is selected for playback.
         */
        get source(): Source;
        set source(val: Source);
        /**
         * The current playback volume (between 0.0 and 1.0)
         */
        get volume(): number;
        set volume(val: number);

        // Constructors

        constructor(properties?: Partial<ShellPlayer.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](db: RhythmDB): ShellPlayer;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'elapsed-changed', callback: (_source: this, elapsed: number) => void): number;
        connect_after(signal: 'elapsed-changed', callback: (_source: this, elapsed: number) => void): number;
        emit(signal: 'elapsed-changed', elapsed: number): void;
        connect(signal: 'elapsed-nano-changed', callback: (_source: this, elapsed: number) => void): number;
        connect_after(signal: 'elapsed-nano-changed', callback: (_source: this, elapsed: number) => void): number;
        emit(signal: 'elapsed-nano-changed', elapsed: number): void;
        connect(signal: 'playing-changed', callback: (_source: this, playing: boolean) => void): number;
        connect_after(signal: 'playing-changed', callback: (_source: this, playing: boolean) => void): number;
        emit(signal: 'playing-changed', playing: boolean): void;
        connect(signal: 'playing-song-changed', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        connect_after(signal: 'playing-song-changed', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        emit(signal: 'playing-song-changed', entry: RhythmDBEntry): void;
        connect(
            signal: 'playing-song-property-changed',
            callback: (
                _source: this,
                uri: string,
                property: string,
                old: GObject.Value,
                newvalue: GObject.Value,
            ) => void,
        ): number;
        connect_after(
            signal: 'playing-song-property-changed',
            callback: (
                _source: this,
                uri: string,
                property: string,
                old: GObject.Value,
                newvalue: GObject.Value,
            ) => void,
        ): number;
        emit(
            signal: 'playing-song-property-changed',
            uri: string,
            property: string,
            old: GObject.Value | any,
            newvalue: GObject.Value | any,
        ): void;
        connect(signal: 'playing-source-changed', callback: (_source: this, source: Source) => void): number;
        connect_after(signal: 'playing-source-changed', callback: (_source: this, source: Source) => void): number;
        emit(signal: 'playing-source-changed', source: Source): void;
        connect(signal: 'playing-uri-changed', callback: (_source: this, uri: string) => void): number;
        connect_after(signal: 'playing-uri-changed', callback: (_source: this, uri: string) => void): number;
        emit(signal: 'playing-uri-changed', uri: string): void;
        connect(signal: 'window-title-changed', callback: (_source: this, title: string) => void): number;
        connect_after(signal: 'window-title-changed', callback: (_source: this, title: string) => void): number;
        emit(signal: 'window-title-changed', title: string): void;

        // Virtual methods

        vfunc_elapsed_changed(elapsed: number): void;
        vfunc_elapsed_nano_changed(elapsed: number): void;
        vfunc_playing_changed(playing: boolean): void;
        vfunc_playing_song_changed(entry: RhythmDBEntry): void;
        vfunc_playing_song_property_changed(
            uri: string,
            property: string,
            old: GObject.Value | any,
            newValue: GObject.Value | any,
        ): void;
        vfunc_playing_source_changed(source: Source): void;
        vfunc_playing_uri_changed(uri: string): void;
        vfunc_window_title_changed(window_title: string): void;

        // Methods

        /**
         * Adds a new play order to the set of available play orders.
         * @param name name of the new play order
         * @param description description of the new play order
         * @param order_type the #GType of the play order class
         * @param hidden if %TRUE, don't display the play order in the UI
         */
        add_play_order(name: string, description: string, order_type: GObject.GType, hidden: boolean): void;
        /**
         * Skips to the next song.  Consults the play queue and handles
         * transitions between the play queue and the active source.
         * Fails if there is no entry to play after the current one.
         * @returns %TRUE if successful
         */
        do_next(): boolean;
        /**
         * If the current song has been playing for more than 3 seconds,
         * restarts it, otherwise, goes back to the previous song.
         * Fails if there is no current song, or if inside the first
         * 3 seconds of the first song in the play order.
         * @returns %TRUE if successful
         */
        do_previous(): boolean;
        /**
         * Retrieves the active source.  This is the source that the user
         * selected for playback.
         * @returns the active #RBSource
         */
        get_active_source(): Source;
        /**
         * Returns %TRUE if currently muted
         * @returns %TRUE if currently muted
         */
        get_mute(): [boolean, boolean];
        /**
         * Retrieves the current state of the shuffle and repeat settings.
         * @returns %TRUE if successful.
         */
        get_playback_state(): [boolean, boolean, boolean];
        /**
         * Reports whether playback is occuring by setting #playing.
         * @returns %TRUE if successful
         */
        get_playing(): [boolean, boolean];
        /**
         * Retrieves the currently playing #RhythmDBEntry, or NULL if
         * nothing is playing.  The caller must unref the entry
         * (using #rhythmdb_entry_unref) when it is no longer needed.
         * @returns the currently playing #RhythmDBEntry, or NULL
         */
        get_playing_entry(): RhythmDBEntry | null;
        /**
         * Retrieves the URI of the current playing entry.  The
         * caller must not free the returned string.
         * @returns %TRUE if successful
         */
        get_playing_path(): [boolean, string];
        /**
         * Retrieves the duration of the current playing song.
         * @returns duration, or -1 if not playing
         */
        get_playing_song_duration(): number;
        /**
         * Retrieves the current playing source.  That is, the source from
         * which the current song was drawn.  This differs from
         * #rb_shell_player_get_active_source when the current song came
         * from the play queue.
         * @returns the current playing #RBSource
         */
        get_playing_source(): Source;
        /**
         * Retrieves the current playback position.  Fails if
         * the player currently cannot provide the playback
         * position.
         * @returns %TRUE if successful
         */
        get_playing_time(): [boolean, number];
        /**
         * Constructs a string showing the current playback position,
         * taking the time display settings into account.
         * @returns allocated playing time string
         */
        get_playing_time_string(): string;
        /**
         * Returns the current volume level
         * @returns the current volume level.
         */
        get_volume(): [boolean, number];
        jump_to_current(): void;
        /**
         * Pauses playback if possible, completely stopping if not.
         * @returns whether playback is not occurring (TRUE when successfully paused/stopped or playback was not occurring).
         */
        pause(): boolean;
        /**
         * Starts playback, if it is not already playing.
         * @returns whether playback is now occurring (TRUE when successfully started or already playing).
         */
        play(): boolean;
        /**
         * Plays a specified entry.
         * @param entry the #RhythmDBEntry to play
         * @param source the new #RBSource to set as playing (or NULL to use the   selected source)
         */
        play_entry(entry: RhythmDBEntry, source: Source): void;
        /**
         * Toggles between playing and paused state.  If there is no playing
         * entry, chooses an entry from (in order of preference) the play queue,
         * the selection in the current source, or the play order.
         * @returns %TRUE if successful
         */
        playpause(): boolean;
        /**
         * Removes a play order previously added with #rb_shell_player_add_play_order
         * from the set of available play orders.
         * @param name name of the play order to remove
         */
        remove_play_order(name: string): void;
        /**
         * Seeks forwards or backwards in the current playing
         * song. Fails if the current song is not seekable.
         * @param offset relative seek target (in seconds)
         * @returns %TRUE if successful
         */
        seek(offset: number): boolean;
        /**
         * Updates the mute setting on the player.
         * @param mute %TRUE to mute playback
         * @returns %TRUE if successful
         */
        set_mute(mute: boolean): boolean;
        /**
         * Sets the state of the shuffle and repeat settings.
         * @param shuffle whether to enable the shuffle setting
         * @param repeat whether to enable the repeat setting
         */
        set_playback_state(shuffle: boolean, repeat: boolean): void;
        /**
         * Replaces the current playing source.
         * @param source the new playing #RBSource
         */
        set_playing_source(source: Source): void;
        /**
         * Attempts to set the playback position.  Fails if the
         * current song is not seekable.
         * @param time the target playback position (in seconds)
         * @returns %TRUE if successful
         */
        set_playing_time(time: number): boolean;
        /**
         * Updates the player to reflect a new source being selected.
         * @param source the #RBSource to select
         */
        set_selected_source(source: Source): void;
        /**
         * Sets the playback volume level.
         * @param volume the volume level (between 0 and 1)
         * @returns %TRUE on success
         */
        set_volume(volume: number): boolean;
        /**
         * Adds the specified value to the current volume level.
         * @param delta difference to apply to the volume level (between -1 and 1)
         * @returns %TRUE on success
         */
        set_volume_relative(delta: number): boolean;
        /**
         * Completely stops playback, freeing resources and unloading the file.
         *
         * In general rb_shell_player_pause() should be used instead, as it stops the
         * audio, but does not completely free resources.
         */
        stop(): void;
    }

    namespace ShellPreferences {
        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Dialog.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps {}
    }

    class ShellPreferences extends Gtk.Dialog implements Atk.ImplementorIface, Gtk.Buildable {
        static $gtype: GObject.GType<ShellPreferences>;

        // Constructors

        constructor(properties?: Partial<ShellPreferences.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](views: Source[]): ShellPreferences;
        // Conflicted with Gtk.Dialog.new

        static ['new'](...args: never[]): any;

        // Methods

        /**
         * Adds a widget to the preferences window.  See #gtk_box_pack_start for
         * details on how the expand and fill parameters work.  This function can be
         * used to add widgets to the 'general' and 'playback' pages.
         * @param widget the #GtkWidget to insert into the preferences window
         * @param location the location at which to insert the widget
         * @param expand whether the widget should be given extra space
         * @param fill whether the widget should fill all space allocated to it
         */
        add_widget(widget: Gtk.Widget, location: ShellPrefsUILocation | null, expand: boolean, fill: boolean): void;
        /**
         * Appends a new page to the preferences dialog notebook.
         * @param name name of the page to append
         * @param widget the #GtkWidget to use as the contents of the page
         */
        append_page(name: string, widget: Gtk.Widget): void;
        /**
         * Removes a widget added with #rb_shell_preferences_add_widget from the preferences window.
         * @param widget the #GtkWidget to remove from the preferences window
         * @param location the UI location to which the widget was originally added
         */
        remove_widget(widget: Gtk.Widget, location: ShellPrefsUILocation | null): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace SongInfo {
        // Signal callback interfaces

        interface PostMetadataChange {
            (entry: RhythmDBEntry): void;
        }

        interface PreMetadataChange {
            (entry: RhythmDBEntry): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Dialog.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps {
            current_entry: RhythmDBEntry;
            currentEntry: RhythmDBEntry;
            entry_view: EntryView;
            entryView: EntryView;
            selected_entries: any[];
            selectedEntries: any[];
            source: Source;
        }
    }

    class SongInfo extends Gtk.Dialog implements Atk.ImplementorIface, Gtk.Buildable {
        static $gtype: GObject.GType<SongInfo>;

        // Properties

        /**
         * The #RhythmDBEntry that is currently being displayed.  Will be NULL for
         * multiple-entry song properties windows.
         */
        get current_entry(): RhythmDBEntry;
        /**
         * The #RhythmDBEntry that is currently being displayed.  Will be NULL for
         * multiple-entry song properties windows.
         */
        get currentEntry(): RhythmDBEntry;
        /**
         * The #RBEntryView for the source that created the song properties window.  Used
         * find the set of selected entries, and to change the selection when the 'back' and
         * 'forward' buttons are pressed.
         */
        get entry_view(): EntryView;
        /**
         * The #RBEntryView for the source that created the song properties window.  Used
         * find the set of selected entries, and to change the selection when the 'back' and
         * 'forward' buttons are pressed.
         */
        get entryView(): EntryView;
        /**
         * The set of #RhythmDBEntry objects currently being displayed.  Valid for both
         * single-entry and multiple-entry song properties windows.
         */
        get selected_entries(): any[];
        /**
         * The set of #RhythmDBEntry objects currently being displayed.  Valid for both
         * single-entry and multiple-entry song properties windows.
         */
        get selectedEntries(): any[];
        /**
         * The #RBSource that created the song properties window.  Used to update
         * for track list changes, and to find the sets of albums, artist, and genres
         * to use for tag edit completion.
         */
        get source(): Source;

        // Constructors

        constructor(properties?: Partial<SongInfo.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](source: Source, entry_view: EntryView): SongInfo;
        // Conflicted with Gtk.Dialog.new

        static ['new'](...args: never[]): any;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'post-metadata-change', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        connect_after(signal: 'post-metadata-change', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        emit(signal: 'post-metadata-change', entry: RhythmDBEntry): void;
        connect(signal: 'pre-metadata-change', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        connect_after(signal: 'pre-metadata-change', callback: (_source: this, entry: RhythmDBEntry) => void): number;
        emit(signal: 'pre-metadata-change', entry: RhythmDBEntry): void;

        // Virtual methods

        vfunc_post_metadata_change(entry: RhythmDBEntry): void;
        vfunc_pre_metadata_change(entry: RhythmDBEntry): void;

        // Methods

        /**
         * Adds a new page to the song properties window.  Should be called
         * in a handler connected to the #RBShell 'create-song-info' signal.
         * @param title the title of the new page
         * @param page the page #GtkWidget
         * @returns the page number
         */
        append_page(title: string, page: Gtk.Widget): number;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace Source {
        // Signal callback interfaces

        interface FilterChanged {
            (): void;
        }

        interface PlaybackStatusChanged {
            (): void;
        }

        interface ResetFilters {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends DisplayPage.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {
            base_query_model: RhythmDBQueryModel;
            baseQueryModel: RhythmDBQueryModel;
            entry_type: RhythmDBEntryType;
            entryType: RhythmDBEntryType;
            hidden_when_empty: boolean;
            hiddenWhenEmpty: boolean;
            load_status: SourceLoadStatus;
            loadStatus: SourceLoadStatus;
            play_order: PlayOrder;
            playOrder: PlayOrder;
            playlist_menu: Gio.MenuModel;
            playlistMenu: Gio.MenuModel;
            query_model: RhythmDBQueryModel;
            queryModel: RhythmDBQueryModel;
            settings: Gio.Settings;
            show_browser: boolean;
            showBrowser: boolean;
            toolbar_menu: Gio.MenuModel;
            toolbarMenu: Gio.MenuModel;
        }
    }

    abstract class Source extends DisplayPage implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<Source>;

        // Properties

        /**
         * The unfiltered query model for the source, containing all entries in the source.
         * Source classes should override this if they perform filtering based on the search
         * box or a browser.
         */
        get base_query_model(): RhythmDBQueryModel;
        /**
         * The unfiltered query model for the source, containing all entries in the source.
         * Source classes should override this if they perform filtering based on the search
         * box or a browser.
         */
        get baseQueryModel(): RhythmDBQueryModel;
        /**
         * Entry type for entries in this source.
         */
        get entry_type(): RhythmDBEntryType;
        /**
         * Entry type for entries in this source.
         */
        get entryType(): RhythmDBEntryType;
        /**
         * If TRUE, the source will not be displayed in the source list
         * when it contains no entries.
         */
        get hidden_when_empty(): boolean;
        set hidden_when_empty(val: boolean);
        /**
         * If TRUE, the source will not be displayed in the source list
         * when it contains no entries.
         */
        get hiddenWhenEmpty(): boolean;
        set hiddenWhenEmpty(val: boolean);
        /**
         * Indicates whether the source is not loaded, is currently loading data, or is
         * fully loaded.
         */
        get load_status(): SourceLoadStatus;
        set load_status(val: SourceLoadStatus);
        /**
         * Indicates whether the source is not loaded, is currently loading data, or is
         * fully loaded.
         */
        get loadStatus(): SourceLoadStatus;
        set loadStatus(val: SourceLoadStatus);
        /**
         * If the source provides its own play order, it can override this property.
         */
        get play_order(): PlayOrder;
        /**
         * If the source provides its own play order, it can override this property.
         */
        get playOrder(): PlayOrder;
        /**
         * A GMenu instance to attach to the 'add to playlist' item in the edit menu.
         * If NULL, the item will be disabled.
         */
        get playlist_menu(): Gio.MenuModel;
        set playlist_menu(val: Gio.MenuModel);
        /**
         * A GMenu instance to attach to the 'add to playlist' item in the edit menu.
         * If NULL, the item will be disabled.
         */
        get playlistMenu(): Gio.MenuModel;
        set playlistMenu(val: Gio.MenuModel);
        /**
         * The current query model for the source.  This is used in
         * various places, including the play order, to find the
         * set of entries within the source.
         */
        get query_model(): RhythmDBQueryModel;
        set query_model(val: RhythmDBQueryModel);
        /**
         * The current query model for the source.  This is used in
         * various places, including the play order, to find the
         * set of entries within the source.
         */
        get queryModel(): RhythmDBQueryModel;
        set queryModel(val: RhythmDBQueryModel);
        /**
         * The #GSettings instance storing settings for the source.  The instance must
         * have a schema of org.gnome.Rhythmbox.Source.
         */
        get settings(): Gio.Settings;
        set settings(val: Gio.Settings);
        /**
         * Whether the browser widget for the source (if any) should be displayed.
         * This should be overridden in sources that include a browser widget.
         */
        get show_browser(): boolean;
        set show_browser(val: boolean);
        /**
         * Whether the browser widget for the source (if any) should be displayed.
         * This should be overridden in sources that include a browser widget.
         */
        get showBrowser(): boolean;
        set showBrowser(val: boolean);
        /**
         * A GMenu instance describing the contents of a toolbar to display at
         * the top of the source.  The #RBSource class doesn't actually display
         * the toolbar anywhere.  Adding the toolbar to a container is the
         * responsibility of a subclass such as #RBBrowserSource.
         */
        get toolbar_menu(): Gio.MenuModel;
        /**
         * A GMenu instance describing the contents of a toolbar to display at
         * the top of the source.  The #RBSource class doesn't actually display
         * the toolbar anywhere.  Adding the toolbar to a container is the
         * responsibility of a subclass such as #RBBrowserSource.
         */
        get toolbarMenu(): Gio.MenuModel;

        // Constructors

        constructor(properties?: Partial<Source.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'filter-changed', callback: (_source: this) => void): number;
        connect_after(signal: 'filter-changed', callback: (_source: this) => void): number;
        emit(signal: 'filter-changed'): void;
        connect(signal: 'playback-status-changed', callback: (_source: this) => void): number;
        connect_after(signal: 'playback-status-changed', callback: (_source: this) => void): number;
        emit(signal: 'playback-status-changed'): void;
        connect(signal: 'reset-filters', callback: (_source: this) => void): number;
        connect_after(signal: 'reset-filters', callback: (_source: this) => void): number;
        emit(signal: 'reset-filters'): void;

        // Virtual methods

        /**
         * Adds the currently selected entries to the end of the
         * play queue.
         * @param queue the #RBSource for the play queue
         */
        vfunc_add_to_queue(queue: Source): void;
        /**
         * Adds an entry corresponding to the URI to the source.  The
         * `title` and `genre` parameters are not really used.
         * @param uri a URI to add
         * @param title theoretically, the title of the entity the URI points to
         * @param genre theoretically, the genre of the entity the URI points to
         * @param callback a callback function to call when complete
         */
        vfunc_add_uri(uri: string, title: string, genre: string, callback: SourceAddCallback): void;
        /**
         * Determines whether the source can add the selected entries to
         * the play queue.
         */
        vfunc_can_add_to_queue(): boolean;
        /**
         * Determines whether the source supports the copy part
         * of a copy-and-paste operation.
         */
        vfunc_can_copy(): boolean;
        /**
         * Determines whether the source supporst the typical cut
         * (as in cut-and-paste) operation.
         */
        vfunc_can_cut(): boolean;
        /**
         * Determines whether the source allows the user to delete
         * a selected set of entries.
         */
        vfunc_can_delete(): boolean;
        /**
         * Determines whether the source allows the user to trash
         * the files backing a selected set of entries.
         */
        vfunc_can_move_to_trash(): boolean;
        /**
         * Determines whether the source supports paste operations.
         */
        vfunc_can_paste(): boolean;
        /**
         * Determines whether playback of entries from the source can
         * be paused.
         */
        vfunc_can_pause(): boolean;
        /**
         * Determines whether the source can be renamed.
         */
        vfunc_can_rename(): boolean;
        /**
         * Copies the selected entries to the clipboard.
         */
        vfunc_copy(): RhythmDBEntry[];
        /**
         * Removes the currently selected entries from the source and
         * returns them so they can be pasted into another source.
         */
        vfunc_cut(): RhythmDBEntry[];
        /**
         * Deletes the currently selected entries from the source.
         */
        vfunc_delete_selected(): void;
        vfunc_filter_changed(): void;
        /**
         * Returns a translated label for the 'delete' menu item, allowing
         * sources to better describe what happens to deleted entries.
         * Playlists, for example, return "Remove from Playlist" here.
         */
        vfunc_get_delete_label(): string;
        /**
         * Returns the entry view widget for the source.
         */
        vfunc_get_entry_view(): EntryView;
        /**
         * Retrieves playback status details, such as buffering progress.
         * @param text holds returned playback status text
         * @param progress holds returned playback status progress value
         */
        vfunc_get_playback_status(text: string, progress: number): [string, number];
        /**
         * Returns a list containing the #RBPropertyView instances for the
         * source, if any.
         */
        vfunc_get_property_views(): PropertyView[];
        /**
         * Determines how EOS events should be handled when playing entries
         * from the source.
         */
        vfunc_handle_eos(): SourceEOFType;
        /**
         * Trashes the files backing the currently selected set of entries.
         * In general, this should use #rhythmdb_entry_move_to_trash to
         * perform the actual trash operation.
         */
        vfunc_move_to_trash(): void;
        /**
         * Adds a list of entries previously cut or copied from another
         * source.  If the entries are not of the type used by the source,
         * the entries will be copied and possibly converted into an acceptable format.
         * This can be used for transfers to and from devices and network shares.
         *
         * If the transfer is performed using an #RBTrackTransferBatch, the batch object
         * is returned so the caller can monitor the transfer progress.  The caller does not
         * own a reference on the batch object.
         * @param entries a list of #RhythmDBEntry objects to paste in
         */
        vfunc_paste(entries: RhythmDBEntry[]): TrackTransferBatch;
        vfunc_reset_filters(): void;
        /**
         * Updates the source with new search text.  The source
         * should recreate the database query that feeds into the
         * browser (if any).
         * @param search the active #RBSourceSearch instance
         * @param cur_text the current search text
         * @param new_text the new search text
         */
        vfunc_search(search: SourceSearch | null, cur_text: string | null, new_text: string): void;
        /**
         * Displays a properties window for the currently selected entries.
         */
        vfunc_song_properties(): void;
        /**
         * Determines whether playback URIs for entries in the source should
         * be parsed as playlists rather than just played.
         */
        vfunc_try_playlist(): boolean;
        /**
         * Checks if the URI matches the source itself.  A source
         * should return TRUE here if the URI points to the device that
         * the source represents, for example.
         * @param uri a URI for the source to consider
         */
        vfunc_uri_is_source(uri: string): boolean;
        /**
         * Returns an indication of how much the source wants to handle
         * the specified URI.  100 is the highest usual value, and should
         * only be used when the URI can only be associated with this source.
         * 0 should be used when the URI does not match the source at all.
         * @param uri a URI for the source to consider
         */
        vfunc_want_uri(uri: string): number;

        // Methods

        /**
         * Adds the currently selected entries to the end of the
         * play queue.
         * @param queue the #RBSource for the play queue
         */
        add_to_queue(queue: Source): void;
        /**
         * Adds an entry corresponding to the URI to the source.  The
         * `title` and `genre` parameters are not really used.
         * @param uri a URI to add
         * @param title theoretically, the title of the entity the URI points to
         * @param genre theoretically, the genre of the entity the URI points to
         * @param callback a callback function to call when complete
         */
        add_uri(uri: string, title: string, genre: string, callback: SourceAddCallback): void;
        /**
         * Binds the source's #GSettings instance to the given widgets.  Should be called
         * from the source's constructed method.
         *
         * If the browser widget has a browser-views property, it will be bound to the
         * browser-views settings key.
         * @param entry_view the #RBEntryView for the source
         * @param paned the #GtkPaned containing the entry view and the browser
         * @param browser the browser (typically a #RBLibraryBrowser) for the source
         * @param sort_order whether to bind the entry view sort order
         */
        bind_settings(
            entry_view: Gtk.Widget | null,
            paned: Gtk.Widget | null,
            browser: Gtk.Widget | null,
            sort_order: boolean,
        ): void;
        /**
         * Determines whether the source can add the selected entries to
         * the play queue.
         * @returns TRUE if adding to the play queue is supported
         */
        can_add_to_queue(): boolean;
        /**
         * Determines whether the source supports the copy part
         * of a copy-and-paste operation.
         * @returns TRUE if copying is supported
         */
        can_copy(): boolean;
        /**
         * Determines whether the source supporst the typical cut
         * (as in cut-and-paste) operation.
         * @returns TRUE if cutting is supported
         */
        can_cut(): boolean;
        /**
         * Determines whether the source allows the user to delete
         * a selected set of entries.
         * @returns TRUE if deletion is supported
         */
        can_delete(): boolean;
        /**
         * Determines whether the source allows the user to trash
         * the files backing a selected set of entries.
         * @returns TRUE if trashing is supported
         */
        can_move_to_trash(): boolean;
        /**
         * Determines whether the source supports paste operations.
         * @returns TRUE if the pasting is supported
         */
        can_paste(): boolean;
        /**
         * Determines whether playback of entries from the source can
         * be paused.
         * @returns TRUE if pausing is supported
         */
        can_pause(): boolean;
        /**
         * Determines whether the source can be renamed.
         * @returns TRUE if this source can be renamed
         */
        can_rename(): boolean;
        /**
         * Determines whether the source can display a properties
         * window for the currently selected entry (or set of entries)
         * @returns TRUE if showing properties is supported
         */
        can_show_properties(): boolean;
        /**
         * Copies the selected entries to the clipboard.
         * @returns a list containing the currently selected entries from the source.
         */
        copy(): RhythmDBEntry[];
        /**
         * Creates a GAction representing the selected search type for `source`.
         * The action is stateful. Its state is a string containing the name of
         * a registered search instance.  If the source has a settings instance,
         * it will be updated when the state changes.  Changes coming from the
         * settings instance are ignored.  If the source doesn't have a settings
         * instance, it should set a default state on the action at some point.
         * @returns #GAction instance
         */
        create_search_action(): Gio.Action;
        /**
         * Removes the currently selected entries from the source and
         * returns them so they can be pasted into another source.
         * @returns entries cut from the source.
         */
        cut(): RhythmDBEntry[];
        /**
         * Deletes the currently selected entries from the source.
         */
        delete_selected(): void;
        /**
         * Returns a list containing the values of the specified
         * property from the selected entries in the source.
         * This is used to implement the 'browse this artist' (etc.)
         * actions.
         * @param prop property for which to gather selection
         * @returns list of property values
         */
        gather_selected_properties(prop: RhythmDBPropType | null): string[];
        /**
         * Returns a translated label for the 'delete' menu item, allowing
         * sources to better describe what happens to deleted entries.
         * Playlists, for example, return "Remove from Playlist" here.
         * @returns allocated string holding the label string
         */
        get_delete_label(): string;
        /**
         * Returns the entry view widget for the source.
         * @returns the #RBEntryView instance for the source
         */
        get_entry_view(): EntryView;
        /**
         * Retrieves playback status details, such as buffering progress.
         * @param text holds returned playback status text
         * @param progress holds returned playback status progress value
         */
        get_playback_status(text: string, progress: number): [string, number];
        /**
         * Returns a list containing the #RBPropertyView instances for the
         * source, if any.
         * @returns list of property views
         */
        get_property_views(): PropertyView[];
        /**
         * Determines how EOS events should be handled when playing entries
         * from the source.
         * @returns EOS event handling type
         */
        handle_eos(): SourceEOFType;
        /**
         * Trashes the files backing the currently selected set of entries.
         * In general, this should use #rhythmdb_entry_move_to_trash to
         * perform the actual trash operation.
         */
        move_to_trash(): void;
        /**
         * Source implementations call this when their filter state changes
         */
        notify_filter_changed(): void;
        /**
         * Source implementations call this when their playback status
         * changes.
         */
        notify_playback_status_changed(): void;
        /**
         * Adds a list of entries previously cut or copied from another
         * source.  If the entries are not of the type used by the source,
         * the entries will be copied and possibly converted into an acceptable format.
         * This can be used for transfers to and from devices and network shares.
         *
         * If the transfer is performed using an #RBTrackTransferBatch, the batch object
         * is returned so the caller can monitor the transfer progress.  The caller does not
         * own a reference on the batch object.
         * @param entries a list of #RhythmDBEntry objects to paste in
         * @returns the #RBTrackTransferBatch used to perform the transfer (if any)
         */
        paste(entries: RhythmDBEntry[]): TrackTransferBatch;
        /**
         * Updates the source with new search text.  The source
         * should recreate the database query that feeds into the
         * browser (if any).
         * @param search the active #RBSourceSearch instance
         * @param cur_text the current search text
         * @param new_text the new search text
         */
        search(search: SourceSearch | null, cur_text: string | null, new_text: string): void;
        /**
         * Enables or disables automatic hiding of the source when
         * there are no entries in it.
         * @param hidden if TRUE, automatically hide the source
         */
        set_hidden_when_empty(hidden: boolean): void;
        /**
         * Displays a properties window for the currently selected entries.
         */
        song_properties(): void;
        /**
         * Determines whether playback URIs for entries in the source should
         * be parsed as playlists rather than just played.
         * @returns TRUE to attempt playlist parsing
         */
        try_playlist(): boolean;
        /**
         * Updates play count and play time statistics for a database entry.
         * Sources containing entries that do not normally reach EOS should
         * call this for an entry when it is no longer being played.
         * @param db the #RhythmDB instance
         * @param entry the #RhythmDBEntry to update
         */
        update_play_statistics(db: RhythmDB, entry: RhythmDBEntry): void;
        /**
         * Checks if the URI matches the source itself.  A source
         * should return TRUE here if the URI points to the device that
         * the source represents, for example.
         * @param uri a URI for the source to consider
         * @returns TRUE if the URI identifies the source itself.
         */
        uri_is_source(uri: string): boolean;
        /**
         * Returns an indication of how much the source wants to handle
         * the specified URI.  100 is the highest usual value, and should
         * only be used when the URI can only be associated with this source.
         * 0 should be used when the URI does not match the source at all.
         * @param uri a URI for the source to consider
         * @returns value from 0 to 100 indicating how much the  source wants this URI.
         */
        want_uri(uri: string): number;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace SourceSearch {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class SourceSearch extends GObject.Object {
        static $gtype: GObject.GType<SourceSearch>;

        // Constructors

        constructor(properties?: Partial<SourceSearch.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Static methods

        /**
         * Adds a registered search instance to a search menu.
         * @param menu #GMenu instance to populate
         * @param action_namespace muxer namespace for the action ("app" or "win")
         * @param action search action to attach the menu item to
         * @param name name of the search instance to add
         */
        static add_to_menu(menu: Gio.Menu, action_namespace: string, action: Gio.Action, name: string): void;
        /**
         * Finds the registered search instance with the specified name
         * @param name name to look up
         */
        static get_by_name(name: string): SourceSearch;

        // Virtual methods

        /**
         * Creates a #RhythmDBQuery from the user's search text.
         * @param db the #RhythmDB
         * @param search_text the search text
         */
        vfunc_create_query(db: RhythmDB, search_text: string): RhythmDBQuery;
        /**
         * Returns a description of the search suitable for displaying in a menu
         */
        vfunc_get_description(): string;
        /**
         * Determines whether the new search text will result in a
         * subset of entries matched by the previous search.  This is
         * used to optimise the search query.
         * @param current the current search text (or NULL if the current search was done with a different    search implementation and so cannot be considered)
         * @param next the new search text
         */
        vfunc_is_subset(current: string, next: string): boolean;

        // Methods

        /**
         * Creates a #RhythmDBQuery from the user's search text.
         * @param db the #RhythmDB
         * @param search_text the search text
         * @returns #RhythmDBQuery for the source to use
         */
        create_query(db: RhythmDB, search_text: string): RhythmDBQuery;
        /**
         * Returns a description of the search suitable for displaying in a menu
         * @returns description string
         */
        get_description(): string;
        /**
         * Determines whether the new search text will result in a
         * subset of entries matched by the previous search.  This is
         * used to optimise the search query.
         * @param current the current search text (or NULL if the current search was done with a different    search implementation and so cannot be considered)
         * @param next the new search text
         * @returns TRUE iff the new search text will match a subset of those matched by the current search.
         */
        is_subset(current: string, next: string): boolean;
        /**
         * Registers a named search instance that can be used in menus and
         * search action states.
         * @param name name to register
         */
        register(name: string): void;
    }

    namespace SourceSearchBasic {
        // Constructor properties interface

        interface ConstructorProps extends SourceSearch.ConstructorProps {
            description: string;
            prop: number;
        }
    }

    class SourceSearchBasic extends SourceSearch {
        static $gtype: GObject.GType<SourceSearchBasic>;

        // Properties

        get description(): string;
        get prop(): number;

        // Fields

        search_prop: RhythmDBPropType;

        // Constructors

        constructor(properties?: Partial<SourceSearchBasic.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](prop: RhythmDBPropType, description: string): SourceSearchBasic;

        // Static methods

        /**
         * Adds an item to `menu` that will select a search based on the specified
         * property.  If there isn't already a registered search instance for the
         * property, one is created.
         * @param menu the #GMenu to populate
         * @param action_namespace action namespace to use for the action ("app" or "win")
         * @param search_action the search action to associate the search with
         * @param prop the property to search on
         * @param name short untranslated name for the search
         * @param label descriptive translatable label for the search
         */
        static add_to_menu(
            menu: Gio.Menu,
            action_namespace: string,
            search_action: Gio.Action,
            prop: RhythmDBPropType,
            name: string,
            label: string,
        ): void;
        // Conflicted with RB.SourceSearch.add_to_menu
        static add_to_menu(...args: never[]): any;
        /**
         * Ensures that a search instance is registered with the specified name.
         * @param prop the property to search on
         * @param name short non-translated name for the search instance
         * @param description user-visible description for the search
         */
        static register(prop: RhythmDBPropType, name: string, description: string): void;
    }

    namespace SourceToolbar {
        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Grid.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {
            accel_group: Gtk.AccelGroup;
            accelGroup: Gtk.AccelGroup;
            page: DisplayPage;
        }
    }

    class SourceToolbar extends Gtk.Grid implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<SourceToolbar>;

        // Properties

        /**
         * The #GtkAccelGroup to add accelerators to
         */
        get accel_group(): Gtk.AccelGroup;
        /**
         * The #GtkAccelGroup to add accelerators to
         */
        get accelGroup(): Gtk.AccelGroup;
        /**
         * The #RBDisplayPage the toolbar is associated with
         */
        get page(): DisplayPage;

        // Constructors

        constructor(properties?: Partial<SourceToolbar.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](page: DisplayPage, accel_group: Gtk.AccelGroup): SourceToolbar;
        // Conflicted with Gtk.Grid.new

        static ['new'](...args: never[]): any;

        // Methods

        /**
         * Adds a search entry with no search type menu.
         * @param placeholder the placeholder text for the search entry (or NULL)
         */
        add_search_entry(placeholder: string): void;
        /**
         * Adds a search entry to the toolbar.
         * @param search_menu a #GMenu containing search items
         * @param search_action the #GAction for search state
         */
        add_search_entry_menu(search_menu: Gio.MenuModel, search_action: Gio.Action): void;
        /**
         * Clears the search entry text.  Call this from RBSource:reset_filters.
         */
        clear_search_entry(): void;

        // Inherited properties
        /**
         * The orientation of the orientable.
         */
        get orientation(): Gtk.Orientation;
        set orientation(val: Gtk.Orientation);

        // Inherited methods
        /**
         * Retrieves the orientation of the `orientable`.
         * @returns the orientation of the @orientable.
         */
        get_orientation(): Gtk.Orientation;
        /**
         * Sets the orientation of the `orientable`.
         * @param orientation the orientable’s new orientation.
         */
        set_orientation(orientation: Gtk.Orientation | null): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace StaticPlaylistSource {
        // Constructor properties interface

        interface ConstructorProps
            extends PlaylistSource.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {}
    }

    class StaticPlaylistSource extends PlaylistSource implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<StaticPlaylistSource>;

        // Constructors

        constructor(properties?: Partial<StaticPlaylistSource.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            shell: Shell,
            name: string,
            settings: Gio.Settings,
            local: boolean,
            entry_type: RhythmDBEntryType,
        ): StaticPlaylistSource;
        // Conflicted with Gtk.Box.new

        static ['new'](...args: never[]): any;

        static new_from_xml(shell: Shell, name: string, node: libxml2.NodePtr): StaticPlaylistSource;
        // Conflicted with RB.PlaylistSource.new_from_xml

        static new_from_xml(...args: never[]): any;

        // Methods

        /**
         * Adds the specified entry to the playlist.
         * @param entry entry to add to the playlist
         * @param index position at which to add it (-1 to add at the end)
         */
        add_entry(entry: RhythmDBEntry, index: number): void;
        /**
         * If the location matches an entry in the database, the entry is added
         * to the playlist.  Otherwise, if it identifies a directory, the contents
         * of that directory are added.
         * @param location location (URI) to add to the playlist
         * @param index position at which to add the location (-1 to add at the end)
         */
        add_location(location: string, index: number): void;
        /**
         * Adds the locations specified in `locations` to the playlist.
         * See `rb_static_playlist_source_add_location` for details.
         * @param locations URI strings to add
         */
        add_locations(locations: string[]): void;
        /**
         * Loads the playlist contents from the specified XML document node.
         * @param node XML node to load from
         */
        load_from_xml(node: libxml2.NodePtr): void;
        /**
         * Moves an entry within the playlist.
         * @param entry the entry to move
         * @param index new location for the entry
         */
        move_entry(entry: RhythmDBEntry, index: number): void;
        /**
         * Removes the specified entry from the playlist.
         * @param entry the entry to remove
         */
        remove_entry(entry: RhythmDBEntry): void;
        /**
         * Removes the specified location from the playlist.  This affects both
         * the location map and the query model, whether an entry exists for the
         * location or not.
         * @param location location to remove
         */
        remove_location(location: string): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace StreamingSource {
        // Constructor properties interface

        interface ConstructorProps
            extends Source.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps,
                Gtk.Orientable.ConstructorProps {}
    }

    class StreamingSource extends Source implements Atk.ImplementorIface, Gtk.Buildable, Gtk.Orientable {
        static $gtype: GObject.GType<StreamingSource>;

        // Constructors

        constructor(properties?: Partial<StreamingSource.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Methods

        /**
         * Provides status text and progress fraction suitable for use in
         * a streaming source's `rb_source_get_status` method.
         */
        get_progress(): [string, number];
        /**
         * Updates the streaming song album name.  Call this when an updated
         * streaming song album name is received from the stream.
         * @param album the new streaming song album name
         */
        set_streaming_album(album: string): void;
        /**
         * Updates the streaming song artist name.  Call this when an updated
         * streaming song artist name is received from the stream.
         * @param artist the new streaming song artist name
         */
        set_streaming_artist(artist: string): void;
        /**
         * Updates the streaming song title.  Call this when an updated
         * streaming song title is received from the stream.
         * @param title the new streaming song title
         */
        set_streaming_title(title: string): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace StringValueMap {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    class StringValueMap extends GObject.Object {
        static $gtype: GObject.GType<StringValueMap>;

        // Constructors

        constructor(properties?: Partial<StringValueMap.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): StringValueMap;

        // Methods

        /**
         * Locates and copies the value associated with the key.
         * @param key key to retrieve
         * @param out returns a copy of the value in the map
         * @returns %TRUE if the value was found
         */
        get(key: string, out: GObject.Value | any): boolean;
        /**
         * Locates the value associated with the key.  This returns the
         * GValue stored in the map, so it cannot be modified.
         * @param key key to retrieve
         * @returns the GValue associated with the key
         */
        peek(key: string): unknown;
        /**
         * Removes a value from the map.
         * @param key key to remove
         * @returns %TRUE if the value was found and removed
         */
        remove(key: string): boolean;
        /**
         * Inserts a value into the map.  The value is copied.
         * @param key key to set
         * @param value value to store
         */
        set(key: string, value: GObject.Value | any): void;
        // Conflicted with GObject.Object.set
        set(...args: never[]): any;
        /**
         * Returns the number of entries in the map.
         * @returns number of entries
         */
        size(): number;
        /**
         * Extracts and returns the underlying hash table from the map,
         * and creates a new empty map.
         * @returns #GHashTable from the map
         */
        steal_hashtable(): GLib.HashTable<any, any>;
    }

    namespace TaskList {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            model: ListModel;
        }
    }

    class TaskList extends GObject.Object {
        static $gtype: GObject.GType<TaskList>;

        // Properties

        get model(): ListModel;

        // Constructors

        constructor(properties?: Partial<TaskList.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): TaskList;

        // Methods

        add_task(task: TaskProgress): void;
        /**
         * Returns the #RBListModel backing the list
         * @returns list model
         */
        get_model(): ListModel;
        remove_task(task: TaskProgress): void;
    }

    namespace TaskProgressSimple {
        // Signal callback interfaces

        interface CancelTask {
            (): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, TaskProgress.ConstructorProps {}
    }

    class TaskProgressSimple extends GObject.Object implements TaskProgress {
        static $gtype: GObject.GType<TaskProgressSimple>;

        // Constructors

        constructor(properties?: Partial<TaskProgressSimple.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'cancel-task', callback: (_source: this) => void): number;
        connect_after(signal: 'cancel-task', callback: (_source: this) => void): number;
        emit(signal: 'cancel-task'): void;

        // Static methods

        /**
         * Creates a new simple task progress object.
         */
        static ['new'](): TaskProgress;

        // Inherited properties
        get task_cancellable(): boolean;
        set task_cancellable(val: boolean);
        get taskCancellable(): boolean;
        set taskCancellable(val: boolean);
        get task_detail(): string;
        set task_detail(val: string);
        get taskDetail(): string;
        set taskDetail(val: string);
        get task_label(): string;
        set task_label(val: string);
        get taskLabel(): string;
        set taskLabel(val: string);
        get task_notify(): boolean;
        set task_notify(val: boolean);
        get taskNotify(): boolean;
        set taskNotify(val: boolean);
        get task_outcome(): TaskOutcome;
        set task_outcome(val: TaskOutcome);
        get taskOutcome(): TaskOutcome;
        set taskOutcome(val: TaskOutcome);
        get task_progress(): number;
        set task_progress(val: number);
        get taskProgress(): number;
        set taskProgress(val: number);

        // Inherited methods
        cancel(): void;
        vfunc_cancel(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace TrackTransferBatch {
        // Signal callback interfaces

        interface Cancelled {
            (): void;
        }

        interface Complete {
            (): void;
        }

        interface GetDestUri {
            (entry: RhythmDBEntry, mediatype: string, extension: string): string;
        }

        interface OverwritePrompt {
            (uri: string): void;
        }

        interface Started {
            (): void;
        }

        interface TrackDone {
            (entry: RhythmDBEntry, dest: string, dest_size: number, dest_mediatype: string, error?: any | null): void;
        }

        interface TrackPostprocess {
            (task: Gio.Task, entry: RhythmDBEntry, dest: string, dest_size: number, dest_mediatype: string): void;
        }

        interface TrackPrepare {
            (task: Gio.Task, entry: RhythmDBEntry, dest: string): void;
        }

        interface TrackProgress {
            (entry: RhythmDBEntry, dest: string, done: number, total: number, fraction: number): void;
        }

        interface TrackStarted {
            (entry: RhythmDBEntry, dest: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, TaskProgress.ConstructorProps {
            destination: Source;
            done_entries: number;
            doneEntries: number;
            encoding_target: GstPbutils.EncodingTarget;
            encodingTarget: GstPbutils.EncodingTarget;
            entry_list: any;
            entryList: any;
            progress: number;
            queue: TrackTransferQueue;
            settings: Gio.Settings;
            source: Source;
            total_entries: number;
            totalEntries: number;
        }
    }

    class TrackTransferBatch extends GObject.Object implements TaskProgress {
        static $gtype: GObject.GType<TrackTransferBatch>;

        // Properties

        /**
         * The RBSource to which the tracks are being transferred.
         */
        get destination(): Source;
        /**
         * Number of entries in the batch that have been transferred.
         */
        get done_entries(): number;
        /**
         * Number of entries in the batch that have been transferred.
         */
        get doneEntries(): number;
        /**
         * A GstEncodingTarget describing allowable target formats.
         * If NULL, the default set of profiles will be used.
         */
        get encoding_target(): GstPbutils.EncodingTarget;
        set encoding_target(val: GstPbutils.EncodingTarget);
        /**
         * A GstEncodingTarget describing allowable target formats.
         * If NULL, the default set of profiles will be used.
         */
        get encodingTarget(): GstPbutils.EncodingTarget;
        set encodingTarget(val: GstPbutils.EncodingTarget);
        /**
         * A list of all entries in the batch.
         */
        get entry_list(): any;
        /**
         * A list of all entries in the batch.
         */
        get entryList(): any;
        /**
         * Fraction of the transfer batch that has been processed.
         */
        get progress(): number;
        /**
         * The #RBTrackTransferQueue instance
         */
        get queue(): TrackTransferQueue;
        /**
         * GSettings instance holding profile preferences
         */
        get settings(): Gio.Settings;
        /**
         * The RBSource from which the tracks are being transferred.
         */
        get source(): Source;
        /**
         * Total number of entries in the transfer batch.
         */
        get total_entries(): number;
        /**
         * Total number of entries in the transfer batch.
         */
        get totalEntries(): number;

        // Constructors

        constructor(properties?: Partial<TrackTransferBatch.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            target: GstPbutils.EncodingTarget,
            settings: Gio.Settings,
            source: GObject.Object,
            destination: GObject.Object,
            queue: GObject.Object,
        ): TrackTransferBatch;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'cancelled', callback: (_source: this) => void): number;
        connect_after(signal: 'cancelled', callback: (_source: this) => void): number;
        emit(signal: 'cancelled'): void;
        connect(signal: 'complete', callback: (_source: this) => void): number;
        connect_after(signal: 'complete', callback: (_source: this) => void): number;
        emit(signal: 'complete'): void;
        connect(
            signal: 'get-dest-uri',
            callback: (_source: this, entry: RhythmDBEntry, mediatype: string, extension: string) => string,
        ): number;
        connect_after(
            signal: 'get-dest-uri',
            callback: (_source: this, entry: RhythmDBEntry, mediatype: string, extension: string) => string,
        ): number;
        emit(signal: 'get-dest-uri', entry: RhythmDBEntry, mediatype: string, extension: string): void;
        connect(signal: 'overwrite-prompt', callback: (_source: this, uri: string) => void): number;
        connect_after(signal: 'overwrite-prompt', callback: (_source: this, uri: string) => void): number;
        emit(signal: 'overwrite-prompt', uri: string): void;
        connect(signal: 'started', callback: (_source: this) => void): number;
        connect_after(signal: 'started', callback: (_source: this) => void): number;
        emit(signal: 'started'): void;
        connect(
            signal: 'track-done',
            callback: (
                _source: this,
                entry: RhythmDBEntry,
                dest: string,
                dest_size: number,
                dest_mediatype: string,
                error: any | null,
            ) => void,
        ): number;
        connect_after(
            signal: 'track-done',
            callback: (
                _source: this,
                entry: RhythmDBEntry,
                dest: string,
                dest_size: number,
                dest_mediatype: string,
                error: any | null,
            ) => void,
        ): number;
        emit(
            signal: 'track-done',
            entry: RhythmDBEntry,
            dest: string,
            dest_size: number,
            dest_mediatype: string,
            error?: any | null,
        ): void;
        connect(
            signal: 'track-postprocess',
            callback: (
                _source: this,
                task: Gio.Task,
                entry: RhythmDBEntry,
                dest: string,
                dest_size: number,
                dest_mediatype: string,
            ) => void,
        ): number;
        connect_after(
            signal: 'track-postprocess',
            callback: (
                _source: this,
                task: Gio.Task,
                entry: RhythmDBEntry,
                dest: string,
                dest_size: number,
                dest_mediatype: string,
            ) => void,
        ): number;
        emit(
            signal: 'track-postprocess',
            task: Gio.Task,
            entry: RhythmDBEntry,
            dest: string,
            dest_size: number,
            dest_mediatype: string,
        ): void;
        connect(
            signal: 'track-prepare',
            callback: (_source: this, task: Gio.Task, entry: RhythmDBEntry, dest: string) => void,
        ): number;
        connect_after(
            signal: 'track-prepare',
            callback: (_source: this, task: Gio.Task, entry: RhythmDBEntry, dest: string) => void,
        ): number;
        emit(signal: 'track-prepare', task: Gio.Task, entry: RhythmDBEntry, dest: string): void;
        connect(
            signal: 'track-progress',
            callback: (
                _source: this,
                entry: RhythmDBEntry,
                dest: string,
                done: number,
                total: number,
                fraction: number,
            ) => void,
        ): number;
        connect_after(
            signal: 'track-progress',
            callback: (
                _source: this,
                entry: RhythmDBEntry,
                dest: string,
                done: number,
                total: number,
                fraction: number,
            ) => void,
        ): number;
        emit(
            signal: 'track-progress',
            entry: RhythmDBEntry,
            dest: string,
            done: number,
            total: number,
            fraction: number,
        ): void;
        connect(signal: 'track-started', callback: (_source: this, entry: RhythmDBEntry, dest: string) => void): number;
        connect_after(
            signal: 'track-started',
            callback: (_source: this, entry: RhythmDBEntry, dest: string) => void,
        ): number;
        emit(signal: 'track-started', entry: RhythmDBEntry, dest: string): void;

        // Virtual methods

        vfunc_cancelled(): void;
        vfunc_complete(): void;
        vfunc_get_dest_uri(entry: RhythmDBEntry, mediatype: string, extension: string): string;
        vfunc_overwrite_prompt(dest_file: Gio.File): boolean;
        vfunc_started(): void;
        vfunc_track_done(
            entry: RhythmDBEntry,
            dest: string,
            dest_size: number,
            mediatype: string,
            error: GLib.Error,
        ): void;
        vfunc_track_postprocess(
            task: Gio.Task,
            entry: RhythmDBEntry,
            dest: string,
            dest_size: number,
            mediatype: string,
        ): void;
        vfunc_track_prepare(task: Gio.Task, entry: RhythmDBEntry, dest: string): void;
        vfunc_track_progress(entry: RhythmDBEntry, dest: string, done: number, total: number, fraction: number): void;
        vfunc_track_started(entry: RhythmDBEntry, dest: string): void;

        // Methods

        /**
         * Adds an entry to be transferred.
         * @param entry the source #RhythmDBEntry to transfer
         */
        add(entry: RhythmDBEntry): void;
        /**
         * Cancels the batch.
         */
        cancel(): void;
        /**
         * Checks that all entries in the batch can be transferred in a format
         * supported by the destination.  If no encoding profile is available for
         * some entries, but installing additional plugins could make a profile
         * available, a list of profiles that require additional plugins is returned.
         * @param error_count holds the number of entries that cannot be transferred on return
         * @returns %TRUE if some entries can be transferred without additional plugins
         */
        check_profiles(error_count: number): [boolean, GstPbutils.EncodingProfile[]];

        // Inherited properties
        get task_cancellable(): boolean;
        set task_cancellable(val: boolean);
        get taskCancellable(): boolean;
        set taskCancellable(val: boolean);
        get task_detail(): string;
        set task_detail(val: string);
        get taskDetail(): string;
        set taskDetail(val: string);
        get task_label(): string;
        set task_label(val: string);
        get taskLabel(): string;
        set taskLabel(val: string);
        get task_notify(): boolean;
        set task_notify(val: boolean);
        get taskNotify(): boolean;
        set taskNotify(val: boolean);
        get task_outcome(): TaskOutcome;
        set task_outcome(val: TaskOutcome);
        get taskOutcome(): TaskOutcome;
        set taskOutcome(val: TaskOutcome);
        get task_progress(): number;
        set task_progress(val: number);
        get taskProgress(): number;
        set taskProgress(val: number);

        // Inherited methods
        vfunc_cancel(): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    namespace TrackTransferQueue {
        // Signal callback interfaces

        interface MissingPlugins {
            (details: string[], descriptions: string[], closure: GObject.Closure): boolean;
        }

        interface TransferProgress {
            (done: number, total: number, fraction: number, time_left: number): void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            batch: TrackTransferBatch;
            shell: Shell;
        }
    }

    class TrackTransferQueue extends GObject.Object {
        static $gtype: GObject.GType<TrackTransferQueue>;

        // Properties

        /**
         * The current #RBTrackTransferBatch being processed
         */
        get batch(): TrackTransferBatch;
        /**
         * The #RBShell
         */
        get shell(): Shell;

        // Constructors

        constructor(properties?: Partial<TrackTransferQueue.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](shell: Shell): TrackTransferQueue;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(
            signal: 'missing-plugins',
            callback: (_source: this, details: string[], descriptions: string[], closure: GObject.Closure) => boolean,
        ): number;
        connect_after(
            signal: 'missing-plugins',
            callback: (_source: this, details: string[], descriptions: string[], closure: GObject.Closure) => boolean,
        ): number;
        emit(signal: 'missing-plugins', details: string[], descriptions: string[], closure: GObject.Closure): void;
        connect(
            signal: 'transfer-progress',
            callback: (_source: this, done: number, total: number, fraction: number, time_left: number) => void,
        ): number;
        connect_after(
            signal: 'transfer-progress',
            callback: (_source: this, done: number, total: number, fraction: number, time_left: number) => void,
        ): number;
        emit(signal: 'transfer-progress', done: number, total: number, fraction: number, time_left: number): void;

        // Virtual methods

        vfunc_transfer_progress(done: number, total: number, fraction: number, time_left: number): void;

        // Methods

        /**
         * Removes a transfer batch from the queue.  If an entry from the
         * batch is currently being transferred, the transfer will be
         * aborted.
         * @param batch the #RBTrackTransferBatch to cancel, or NULL for the current batch
         */
        cancel_batch(batch: TrackTransferBatch): void;
        /**
         * Cancels all transfers to or from a specified source.
         * @param source the #RBSource to cancel transfers to/from
         */
        cancel_for_source(source: Source): void;
        /**
         * Finds all transfer batches where `source` is the source or destination.
         * This should be used to wait for transfers to finish (or cancel them) before
         * ejecting a device.  The transfer batches are returned in the order they're
         * found in the queue, so waiting for the `RBTrackTransferBatch:`:complete signal
         * on the last one is sufficient to wait for them all to finish.
         * @param source the #RBSource to search for
         * @returns #GList of #RBTrackTransferBatch objects, not referenced
         */
        find_batch_by_source(source: Source): TrackTransferBatch[];
        /**
         * Adds a new transfer batch to the transfer queue; if the queue is currently
         * empty, the transfer will start immediately, but not before the call returns.
         * @param batch the #RBTrackTransferBatch to add to the queue
         */
        start_batch(batch: TrackTransferBatch): void;
    }

    namespace URIDialog {
        // Signal callback interfaces

        interface LocationAdded {
            (uri: string): void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Gtk.Dialog.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Gtk.Buildable.ConstructorProps {
            label: string;
        }
    }

    class URIDialog extends Gtk.Dialog implements Atk.ImplementorIface, Gtk.Buildable {
        static $gtype: GObject.GType<URIDialog>;

        // Properties

        /**
         * The label displayed in the dialog.
         */
        get label(): string;

        // Constructors

        constructor(properties?: Partial<URIDialog.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](title: string, label: string): URIDialog;
        // Conflicted with Gtk.Dialog.new

        static ['new'](...args: never[]): any;

        // Signals

        connect(id: string, callback: (...args: any[]) => any): number;
        connect_after(id: string, callback: (...args: any[]) => any): number;
        emit(id: string, ...args: any[]): void;
        connect(signal: 'location-added', callback: (_source: this, uri: string) => void): number;
        connect_after(signal: 'location-added', callback: (_source: this, uri: string) => void): number;
        emit(signal: 'location-added', uri: string): void;

        // Virtual methods

        vfunc_location_added(uri: string): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        get_property(property_name: string): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized) — so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        set_property(property_name: string, value: any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        disconnect(id: number): void;
        set(properties: { [key: string]: any }): void;
        block_signal_handler(id: number): any;
        unblock_signal_handler(id: number): any;
        stop_emission_by_name(detailedName: string): any;
    }

    type ApplicationClass = typeof Application;
    abstract class ApplicationPrivate {
        static $gtype: GObject.GType<ApplicationPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type AsyncCopyClass = typeof AsyncCopy;
    abstract class AsyncCopyPrivate {
        static $gtype: GObject.GType<AsyncCopyPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type AutoPlaylistSourceClass = typeof AutoPlaylistSource;
    type BrowserSourceClass = typeof BrowserSource;
    abstract class BrowserSourcePrivate {
        static $gtype: GObject.GType<BrowserSourcePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ButtonBarClass = typeof ButtonBar;
    abstract class ButtonBarPrivate {
        static $gtype: GObject.GType<ButtonBarPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CellRendererPixbufClass = typeof CellRendererPixbuf;
    type CellRendererRatingClass = typeof CellRendererRating;
    abstract class CellRendererRatingClassPrivate {
        static $gtype: GObject.GType<CellRendererRatingClassPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class CellRendererRatingPrivate {
        static $gtype: GObject.GType<CellRendererRatingPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ChunkLoaderClass = typeof ChunkLoader;
    abstract class ChunkLoaderPrivate {
        static $gtype: GObject.GType<ChunkLoaderPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DeviceSourceInterface = typeof DeviceSource;
    type DisplayPageClass = typeof DisplayPage;
    type DisplayPageGroupClass = typeof DisplayPageGroup;
    abstract class DisplayPageGroupPrivate {
        static $gtype: GObject.GType<DisplayPageGroupPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DisplayPageModelClass = typeof DisplayPageModel;
    abstract class DisplayPagePrivate {
        static $gtype: GObject.GType<DisplayPagePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DisplayPageTreeClass = typeof DisplayPageTree;
    abstract class DisplayPageTreePrivate {
        static $gtype: GObject.GType<DisplayPageTreePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type EncoderFactoryClass = typeof EncoderFactory;
    type EncoderIface = typeof Encoder;
    type EntryViewClass = typeof EntryView;
    abstract class EntryViewPrivate {
        static $gtype: GObject.GType<EntryViewPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ExtDBClass = typeof ExtDB;
    abstract class ExtDBKey {
        static $gtype: GObject.GType<ExtDBKey>;

        // Constructors

        _init(...args: any[]): void;

        // Static methods

        /**
         * Creates a new metadata lookup key with a single field.
         * Use `rb_ext_db_key_add_field` to add more.
         * @param field required field name
         * @param value value for field
         */
        static create_lookup(field: string, value: string): ExtDBKey;
        /**
         * Creates a new metadata storage key with a single field.
         * Use `rb_ext_db_key_add_field` to add more.
         * @param field required field name
         * @param value value for field
         */
        static create_storage(field: string, value: string): ExtDBKey;

        // Methods

        /**
         * Adds a field to the key, or an additional value to an existing field.
         * @param field name of the field to add
         * @param value field value
         */
        add_field(field: string, value: string): void;
        /**
         * Adds an information field to the key.
         * @param name name of the field to add
         * @param value field value
         */
        add_info(name: string, value: string): void;
        /**
         * Copies a key.
         * @returns copied key
         */
        copy(): ExtDBKey;
        /**
         * Checks whether a specified field in `key` matches a value.
         * This can be used to match keys against other types of data.
         * To match keys against each other, use `rb_ext_db_key_matches`.
         * @param field a field to check
         * @param value a value to match against
         * @returns %TRUE if the field matches the value
         */
        field_matches(field: string, value: string): boolean;
        /**
         * Frees a key
         */
        free(): void;
        /**
         * Extracts the value for a single-valued field.
         * @param field field to retrieve
         * @returns field value, or NULL
         */
        get_field(field: string): string;
        /**
         * Returns a NULL-terminated array containing the names of the fields
         * present in the key.
         * @returns array of field names
         */
        get_field_names(): string[];
        /**
         * Extracts the values for the specified field.
         * @param field field to retrieve
         * @returns field values, or NULL
         */
        get_field_values(field: string): string[];
        /**
         * Extracts the value for the specified info field.
         * @param name info field to retrieve
         * @returns field value, or NULL
         */
        get_info(name: string): string;
        /**
         * Returns a NULL-terminated array containing the names of the info
         * fields * present in the key.
         * @returns array of info field names
         */
        get_info_names(): string[];
        /**
         * Returns %TRUE if the key is a lookup key
         * @returns whether the key is a lookup key
         */
        is_lookup(): boolean;
        /**
         * Checks whether the fields specified in `a` match `b`.
         * For keys to match, they must have the same set of required fields,
         * and the values for all must match.  Optional fields must have the
         * same values if present in both.  Informational fields are ignored.
         * @param b second #RBExtDBKey
         * @returns %TRUE if the keys match
         */
        matches(b: ExtDBKey): boolean;
        /**
         * Generates a readable string format from the key.
         * @returns string form of the key
         */
        to_string(): string;
    }

    abstract class ExtDBPrivate {
        static $gtype: GObject.GType<ExtDBPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type FadingImageClass = typeof FadingImage;
    abstract class FadingImagePrivate {
        static $gtype: GObject.GType<FadingImagePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type HistoryClass = typeof History;
    abstract class HistoryPrivate {
        static $gtype: GObject.GType<HistoryPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type LibraryBrowserClass = typeof LibraryBrowser;
    type ListModelClass = typeof ListModel;
    abstract class ListModelPrivate {
        static $gtype: GObject.GType<ListModelPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type MediaPlayerEntryTypeClass = typeof MediaPlayerEntryType;
    type MediaPlayerSourceClass = typeof MediaPlayerSource;
    type MetaDataClass = typeof MetaData;
    abstract class MetaDataPrivate {
        static $gtype: GObject.GType<MetaDataPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type PlayOrderClass = typeof PlayOrder;
    abstract class PlayOrderPrivate {
        static $gtype: GObject.GType<PlayOrderPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type PlayerGstFilterIface = typeof PlayerGstFilter;
    type PlayerGstTeeIface = typeof PlayerGstTee;
    type PlayerIface = typeof Player;
    type PlaylistManagerClass = typeof PlaylistManager;
    abstract class PlaylistManagerPrivate {
        static $gtype: GObject.GType<PlaylistManagerPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type PlaylistSourceClass = typeof PlaylistSource;
    abstract class PlaylistSourcePrivate {
        static $gtype: GObject.GType<PlaylistSourcePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    class PodcastChannel {
        static $gtype: GObject.GType<PodcastChannel>;

        // Fields

        refcount: number;
        url: string;
        title: string;
        lang: string;
        description: string;
        author: string;
        contact: string;
        img: string;
        pub_date: number;
        copyright: string;
        is_opml: boolean;
        posts: any[];
        num_posts: number;
        status: PodcastParseStatus;

        // Constructors

        _init(...args: any[]): void;
    }

    class PodcastItem {
        static $gtype: GObject.GType<PodcastItem>;

        // Fields

        title: string;
        url: string;
        description: string;
        author: string;
        guid: string;
        pub_date: number;
        duration: number;
        filesize: number;

        // Constructors

        constructor(
            properties?: Partial<{
                title: string;
                url: string;
                description: string;
                author: string;
                guid: string;
                pub_date: number;
                duration: number;
                filesize: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    type PodcastManagerClass = typeof PodcastManager;
    abstract class PodcastManagerPrivate {
        static $gtype: GObject.GType<PodcastManagerPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type PodcastSearchClass = typeof PodcastSearch;
    abstract class Profiler {
        static $gtype: GObject.GType<Profiler>;

        // Constructors

        _init(...args: any[]): void;
    }

    type PropertyViewClass = typeof PropertyView;
    abstract class PropertyViewPrivate {
        static $gtype: GObject.GType<PropertyViewPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type RatingClass = typeof Rating;
    abstract class RatingPrivate {
        static $gtype: GObject.GType<RatingPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    class RefString {
        static $gtype: GObject.GType<RefString>;

        // Constructors

        constructor(init: string);
        _init(...args: any[]): void;

        static ['new'](init: string): RefString;

        // Static methods

        /**
         * Key equality function suitable for use with #GHashTable.
         * Equality checks for #RBRefString are just pointer comparisons,
         * since there can only be one refstring for a given string.
         * @param ap an #RBRefString
         * @param bp another #RBRefstring
         */
        static equal(ap?: any | null, bp?: any | null): boolean;
        /**
         * Returns an existing #RBRefString for `init` if one exists,
         * otherwise returns NULL.  If an existing refstring is found,
         * its reference count is increased.
         * @param init string to find
         */
        static find(init: string): RefString;
        /**
         * Hash function suitable for use with `GHashTable`.
         * @param p an #RBRefString
         */
        static hash(p?: any | null): number;
        /**
         * Sets up the refstring system.  Called on startup.
         */
        static system_init(): void;
        /**
         * Frees all data associated with the refstring system.
         * Only called on shutdown.
         */
        static system_shutdown(): void;

        // Methods

        /**
         * Returns the actual string for a #RBRefString.
         * @returns underlying string, must not be freed
         */
        get(): string;
        /**
         * Returns the case-folded version of the string underlying `val`.
         * The case-folded string is cached inside the #RBRefString for
         * speed.  See `rb_search_fold` for information on case-folding
         * strings.
         * @returns case-folded string, must not be freed
         */
        get_folded(): string;
        /**
         * Returns the sort key version of the string underlying `val`.
         * The sort key string is cached inside the #RBRefString for speed.
         * Sort key strings are not generally human readable, so don't display
         * them anywhere.  See `g_utf8`_collate_key_for_filename for information
         * on sort keys.
         * @returns sort key string, must not be freed.
         */
        get_sort_key(): string;
        /**
         * Increases the reference count for an existing #RBRefString.
         * The refstring is returned for convenience.
         * @returns the same refstring
         */
        ref(): RefString;
        /**
         * Drops a reference to an #RBRefString.  If this is the last
         * reference, the string will be freed.
         */
        unref(): void;
    }

    type RemovableMediaManagerClass = typeof RemovableMediaManager;
    type RhythmDBClass = typeof RhythmDB;
    class RhythmDBEntry {
        static $gtype: GObject.GType<RhythmDBEntry>;

        // Constructors

        constructor(db: RhythmDB, type: RhythmDBEntryType, uri: string);
        _init(...args: any[]): void;

        static example_new(db: RhythmDB, type: RhythmDBEntryType, uri: string): RhythmDBEntry;

        static ['new'](db: RhythmDB, type: RhythmDBEntryType, uri: string): RhythmDBEntry;

        // Methods

        /**
         * Applies a set of metadata properties to `entry`.  The metadata should be in the
         * form returned by `rhythmdb_entry_type_fetch_metadata`.
         * @param metadata cached metadata to apply
         */
        apply_cached_metadata(metadata: RhythmDBEntryChange[]): void;
        /**
         * Stores metadata for `entry` in the metadata cache (if any) for its entry type.
         */
        cache_metadata(): void;
        /**
         * Calls the entry type's method to check if it can sync metadata for `entry`.
         * Usually this is only true for entries backed by files, where tag-writing is
         * enabled, and the appropriate tag-writing facilities are available.
         * @returns %TRUE if the entry can be synced
         */
        can_sync_metadata(): boolean;
        /**
         * Creates a #RBExtDBKey for finding external metadata
         * for a given property.  This is mostly useful for finding album or
         * track related data.
         * @param prop the primary #RhythmDBPropType for metadata lookups
         * @returns the new #RBExtDBKey
         */
        create_ext_db_key(prop: RhythmDBPropType | null): ExtDBKey;
        /**
         * Calls the entry type's post-creation method for `entry`.
         */
        created(): void;
        dup_string(propid: RhythmDBPropType | null): string;
        /**
         * Returns the value of a boolean property of `entry`.
         * @param propid property to return
         * @returns property value
         */
        get_boolean(propid: RhythmDBPropType | null): boolean;
        /**
         * Returns the value of a double-precision floating point property of `value`.
         * @param propid the property to return
         * @returns property value
         */
        get_double(propid: RhythmDBPropType | null): number;
        /**
         * Returns the #RhythmDBEntryType for `entry`.  This is used to access
         * entry type properties, to check that entries are of the same type,
         * and to call entry type methods.
         * @returns the #RhythmDBEntryType for @entry
         */
        get_entry_type(): RhythmDBEntryType;
        /**
         * Returns the value of an object property of `entry`.
         * @param propid the property to return
         * @returns property value
         */
        get_object<T = GObject.Object>(propid: RhythmDBPropType | null): T;
        /**
         * Returns an allocated string containing the playback URI for `entry,`
         * or NULL if the entry cannot be played.
         * @returns playback URI or NULL
         */
        get_playback_uri(): string;
        /**
         * Returns an #RBRefString containing a string property of `entry`.
         * @param propid the property to return
         * @returns a #RBRefString, must be unreffed by caller.
         */
        get_refstring(propid: RhythmDBPropType | null): RefString;
        /**
         * Returns the value of a string property of #entry.
         * @param propid the #RhythmDBPropType to return
         * @returns property value, must not be freed
         */
        get_string(propid: RhythmDBPropType | null): string;
        /**
         * Retrieves a pointer to the entry's type-specific data, checking that
         * the size of the data structure matches what is expected.
         * Callers should use the RHYTHMDB_ENTRY_GET_TYPE_DATA macro for
         * a slightly more friendly interface to this functionality.
         * @param expected_size expected size of the type-specific data.
         * @returns type-specific data pointer
         */
        get_type_data(expected_size: number): any | null;
        /**
         * Returns the value of a 64bit unsigned integer property.
         * @param propid property to return
         * @returns property value
         */
        get_uint64(propid: RhythmDBPropType | null): number;
        /**
         * Returns the value of an unsigned long integer property of `entry`.
         * @param propid property to return
         * @returns property value
         */
        get_ulong(propid: RhythmDBPropType | null): number;
        /**
         * Checks if `entry` represents a file that is losslessly encoded.
         * An entry is considered lossless if it has no bitrate value and
         * its media type is "audio/x-flac".  Other lossless encoding types
         * may be added in the future.
         * @returns %TRUE if @entry is lossless
         */
        is_lossless(): boolean;
        /**
         * Calls the entry type's pre-deletion method for `entry`.
         */
        pre_destroy(): void;
        /**
         * Increase the reference count of the entry.
         * @returns the entry
         */
        ref(): RhythmDBEntry;
        /**
         * Calls the entry type's method to sync metadata changes for `entry`.
         * @param changes a list of #RhythmDBEntryChange structures
         */
        sync_metadata(changes: RhythmDBEntryChange[]): void;
        /**
         * Decrease the reference count of the entry, and destroys it if there are
         * no references left.
         */
        unref(): void;
        /**
         * Updates `entry` to reflect its new availability.
         * @param avail an availability event
         */
        update_availability(avail: RhythmDBEntryAvailability | null): void;
    }

    class RhythmDBEntryChange {
        static $gtype: GObject.GType<RhythmDBEntryChange>;

        // Fields

        prop: RhythmDBPropType;

        // Constructors

        _init(...args: any[]): void;
    }

    type RhythmDBEntryTypeClass = typeof RhythmDBEntryType;
    abstract class RhythmDBEntryTypePrivate {
        static $gtype: GObject.GType<RhythmDBEntryTypePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type RhythmDBImportJobClass = typeof RhythmDBImportJob;
    abstract class RhythmDBImportJobPrivate {
        static $gtype: GObject.GType<RhythmDBImportJobPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class RhythmDBPrivate {
        static $gtype: GObject.GType<RhythmDBPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type RhythmDBPropertyModelClass = typeof RhythmDBPropertyModel;
    abstract class RhythmDBPropertyModelPrivate {
        static $gtype: GObject.GType<RhythmDBPropertyModelPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    class RhythmDBQueryData {
        static $gtype: GObject.GType<RhythmDBQueryData>;

        // Fields

        type: number;
        propid: number;
        subquery: RhythmDBQuery;

        // Constructors

        _init(...args: any[]): void;
    }

    type RhythmDBQueryModelClass = typeof RhythmDBQueryModel;
    abstract class RhythmDBQueryModelPrivate {
        static $gtype: GObject.GType<RhythmDBQueryModelPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type RhythmDBQueryResultListClass = typeof RhythmDBQueryResultList;
    abstract class RhythmDBQueryResultListPrivate {
        static $gtype: GObject.GType<RhythmDBQueryResultListPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type RhythmDBQueryResultsIface = typeof RhythmDBQueryResults;
    type SearchEntryClass = typeof SearchEntry;
    abstract class SearchEntryPrivate {
        static $gtype: GObject.GType<SearchEntryPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SegmentedBarClass = typeof SegmentedBar;
    abstract class SegmentedBarPrivate {
        static $gtype: GObject.GType<SegmentedBarPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ShellClass = typeof Shell;
    type ShellPlayerClass = typeof ShellPlayer;
    abstract class ShellPlayerPrivate {
        static $gtype: GObject.GType<ShellPlayerPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ShellPreferencesClass = typeof ShellPreferences;
    abstract class ShellPreferencesPrivate {
        static $gtype: GObject.GType<ShellPreferencesPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class ShellPrivate {
        static $gtype: GObject.GType<ShellPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SongInfoClass = typeof SongInfo;
    abstract class SongInfoPrivate {
        static $gtype: GObject.GType<SongInfoPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SourceClass = typeof Source;
    abstract class SourcePrivate {
        static $gtype: GObject.GType<SourcePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SourceSearchBasicClass = typeof SourceSearchBasic;
    type SourceSearchClass = typeof SourceSearch;
    type SourceToolbarClass = typeof SourceToolbar;
    abstract class SourceToolbarPrivate {
        static $gtype: GObject.GType<SourceToolbarPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type StaticPlaylistSourceClass = typeof StaticPlaylistSource;
    type StreamingSourceClass = typeof StreamingSource;
    abstract class StreamingSourcePrivate {
        static $gtype: GObject.GType<StreamingSourcePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type StringValueMapClass = typeof StringValueMap;
    abstract class StringValueMapPrivate {
        static $gtype: GObject.GType<StringValueMapPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TaskListClass = typeof TaskList;
    abstract class TaskListPrivate {
        static $gtype: GObject.GType<TaskListPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TaskProgressInterface = typeof TaskProgress;
    type TaskProgressSimpleClass = typeof TaskProgressSimple;
    abstract class TaskProgressSimplePrivate {
        static $gtype: GObject.GType<TaskProgressSimplePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TrackTransferBatchClass = typeof TrackTransferBatch;
    abstract class TrackTransferBatchPrivate {
        static $gtype: GObject.GType<TrackTransferBatchPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TrackTransferQueueClass = typeof TrackTransferQueue;
    abstract class TrackTransferQueuePrivate {
        static $gtype: GObject.GType<TrackTransferQueuePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TransferTargetInterface = typeof TransferTarget;
    type URIDialogClass = typeof URIDialog;
    abstract class URIDialogPrivate {
        static $gtype: GObject.GType<URIDialogPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    namespace DeviceSource {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface DeviceSourceNamespace {
        $gtype: GObject.GType<DeviceSource>;
        prototype: DeviceSource;

        /**
         * Returns %TRUE if `uri` matches `source`.  This should be
         * used to implement the uri_is_source #RBSource method.
         * @param source a #RBDeviceSource
         * @param uri a URI to check
         */
        uri_is_source(source: Source, uri: string): boolean;
        /**
         * Checks whether `uri` identifies a path underneath the
         * device's mount point.  Should be used to implement
         * the #RBSource want_uri method.
         * @param source a #RBDeviceSource
         * @param uri a URI to consider
         */
        want_uri(source: Source, uri: string): number;
    }
    interface DeviceSource extends GObject.Object {
        // Methods

        can_eject(): boolean;
        /**
         * Default method for ejecting devices.  Implementations can
         * perform any required work before ejecting, then call this do
         * eject the device.
         */
        default_eject(): void;
        /**
         * Ejects the device that the source represents.
         */
        eject(): void;
        /**
         * Sets the icon and display name for a device-based source.
         * The details come from the mount and/or volume.  This should
         * be called in the source's constructed method.
         */
        set_display_details(): void;

        // Virtual methods

        vfunc_can_eject(): boolean;
        /**
         * Ejects the device that the source represents.
         */
        vfunc_eject(): void;
    }

    export const DeviceSource: DeviceSourceNamespace & {
        new (): DeviceSource; // This allows `obj instanceof DeviceSource`
    };

    namespace Encoder {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface EncoderNamespace {
        $gtype: GObject.GType<Encoder>;
        prototype: Encoder;

        /**
         * Creates a new #RBEncoder instance.
         */
        ['new'](): Encoder;
    }
    interface Encoder extends GObject.Object {
        // Methods

        /**
         * Attempts to cancel any in progress encoding.  The encoder should
         * delete the destination file, if it created one, and emit the
         * 'completed' signal.
         */
        cancel(): void;
        /**
         * Initiates encoding, transcoding to the specified profile if specified.
         *
         * Encoding and error reporting takes place asynchronously.  The caller should wait
         * for the 'completed' signal which indicates it has either completed or failed.
         * @param entry the #RhythmDBEntry to transcode
         * @param dest destination file URI
         * @param overwrite if %TRUE, overwrite @dest if it already exists
         * @param profile encoding profile to use, or NULL to just copy
         */
        encode(entry: RhythmDBEntry, dest: string, overwrite: boolean, profile: GstPbutils.EncodingProfile): void;
        /**
         * Retrieves the plugin installer detail strings and descriptions
         * for any missing plugins required to use the specified encoding profile.
         * @param profile an encoding profile
         * @returns %TRUE if some detail strings are returned, %FALSE otherwise
         */
        get_missing_plugins(profile: GstPbutils.EncodingProfile): [boolean, string, string];

        // Virtual methods

        /**
         * Attempts to cancel any in progress encoding.  The encoder should
         * delete the destination file, if it created one, and emit the
         * 'completed' signal.
         */
        vfunc_cancel(): void;
        vfunc_completed(dest_size: number, mediatype: string, error: GLib.Error): void;
        /**
         * Initiates encoding, transcoding to the specified profile if specified.
         *
         * Encoding and error reporting takes place asynchronously.  The caller should wait
         * for the 'completed' signal which indicates it has either completed or failed.
         * @param entry the #RhythmDBEntry to transcode
         * @param dest destination file URI
         * @param overwrite if %TRUE, overwrite @dest if it already exists
         * @param profile encoding profile to use, or NULL to just copy
         */
        vfunc_encode(entry: RhythmDBEntry, dest: string, overwrite: boolean, profile: GstPbutils.EncodingProfile): void;
        /**
         * Retrieves the plugin installer detail strings and descriptions
         * for any missing plugins required to use the specified encoding profile.
         * @param profile an encoding profile
         */
        vfunc_get_missing_plugins(profile: GstPbutils.EncodingProfile): [boolean, string, string];
        vfunc_progress(fraction: number): void;
    }

    export const Encoder: EncoderNamespace & {
        new (): Encoder; // This allows `obj instanceof Encoder`
    };

    namespace Player {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface PlayerNamespace {
        $gtype: GObject.GType<Player>;
        prototype: Player;

        /**
         * Finds an element inside `element` that has a property with the specified name.
         * @param element element to search
         * @param property name of property to search for
         */
        gst_find_element_with_property(element: Gst.Element, property: string): Gst.Element;
        /**
         * Creates and tests an instance of the specified audio sink.
         * @param plugin_name audio sink plugin name
         * @param name name to give to the element
         */
        gst_try_audio_sink(plugin_name: string, name: string): Gst.Element;
        /**
         * Creates a new player object.
         * @param want_crossfade if TRUE, try to use a backend that supports 		    crossfading and other track transitions.
         */
        ['new'](want_crossfade: boolean): Player;
    }
    interface Player extends GObject.Object {
        // Methods

        /**
         * If a URI is specified, this will close the stream corresponding
         * to that URI and free any resources related resources.  If `uri`
         * is NULL, this will close all streams.
         *
         * If no streams remain open after this call, the audio device will
         * be released.
         * @param uri optionally, the URI of the stream to close
         * @returns TRUE if a stream was found and closed
         */
        close(uri: string): boolean;
        /**
         * Returns the current playback for the current stream in nanoseconds.
         * @returns playback position
         */
        get_time(): number;
        /**
         * Returns the current volume level, between 0.0 and 1.0.
         * @returns current output volume level
         */
        get_volume(): number;
        /**
         * Determines whether the player supports multiple open streams.
         * @returns TRUE if multiple open is supported
         */
        multiple_open(): boolean;
        /**
         * Prepares a stream for playback.  Depending on the player
         * implementation, this may stop any existing stream being
         * played.  The stream preparation process may continue
         * asynchronously, in which case errors may be reported from
         * #rb_player_play or using the 'error' signal.
         * @param uri URI to open
         * @param stream_data arbitrary data to associate with the stream
         * @returns TRUE if the stream preparation was not unsuccessful
         */
        open(uri: string, stream_data?: any | null): boolean;
        /**
         * Determines whether a stream has been prepared for playback.
         * @returns TRUE if a stream is prepared for playback
         */
        opened(): boolean;
        /**
         * Pauses playback of the most recently started stream.  Any
         * streams being faded out may continue until the fade is
         * complete.
         */
        pause(): void;
        /**
         * Starts playback of the most recently opened stream.
         * if `play_type` is #RB_PLAYER_PLAY_CROSSFADE, the player
         * may attempt to crossfade the new stream with any existing
         * streams.  If it does this, the it will use `crossfade` as the
         * duration of the fade.
         *
         * If `play_type` is #RB_PLAYER_PLAY_AFTER_EOS, the player may
         * attempt to start the stream immediately after the current
         * playing stream reaches EOS.  This may or may not result in
         * the phenomemon known as 'gapless playback'.
         *
         * If `play_type` is #RB_PLAYER_PLAY_REPLACE, the player will stop any
         * existing stream before starting the new stream. It may do
         * this anyway, regardless of the value of `play_type`.
         *
         * The 'playing-stream' signal will be emitted when the new stream
         * is actually playing. This may be before or after control returns
         * to the caller.
         * @param play_type requested playback start type
         * @param crossfade requested crossfade duration (nanoseconds)
         * @returns %TRUE if playback started successfully
         */
        play(play_type: PlayerPlayType | null, crossfade: number): boolean;
        /**
         * Determines whether the player is currently playing a stream.
         * A stream is playing if it's not paused or being faded out.
         * @returns TRUE if playing
         */
        playing(): boolean;
        /**
         * Determines whether seeking is supported for the current stream.
         * @returns TRUE if the current stream is seekable
         */
        seekable(): boolean;
        /**
         * Attempts to seek in the current stream.  The player
         * may ignore this if the stream is not seekable.
         * The seek may take place asynchronously.
         * @param newtime seek target position in seconds
         */
        set_time(newtime: number): void;
        /**
         * Adjusts the output volume level.  This affects all streams.
         * The player may use a hardware volume control to implement
         * this volume adjustment.
         * @param volume new output volume level
         */
        set_volume(volume: number): void;

        // Virtual methods

        vfunc_buffering(stream_data: any | null, progress: number): void;
        /**
         * If a URI is specified, this will close the stream corresponding
         * to that URI and free any resources related resources.  If `uri`
         * is NULL, this will close all streams.
         *
         * If no streams remain open after this call, the audio device will
         * be released.
         * @param uri optionally, the URI of the stream to close
         */
        vfunc_close(uri: string): boolean;
        vfunc_eos(stream_data: any | null, early: boolean): void;
        vfunc_error(stream_data: any | null, error: GLib.Error): void;
        vfunc_event(stream_data?: any | null, data?: any | null): void;
        /**
         * Returns the current playback for the current stream in nanoseconds.
         */
        vfunc_get_time(): number;
        /**
         * Returns the current volume level, between 0.0 and 1.0.
         */
        vfunc_get_volume(): number;
        vfunc_image(stream_data: any | null, image: GdkPixbuf.Pixbuf): void;
        vfunc_info(stream_data: any | null, field: MetaDataField, value: GObject.Value | any): void;
        /**
         * Determines whether the player supports multiple open streams.
         */
        vfunc_multiple_open(): boolean;
        /**
         * Prepares a stream for playback.  Depending on the player
         * implementation, this may stop any existing stream being
         * played.  The stream preparation process may continue
         * asynchronously, in which case errors may be reported from
         * #rb_player_play or using the 'error' signal.
         * @param uri URI to open
         * @param stream_data arbitrary data to associate with the stream
         */
        vfunc_open(uri: string, stream_data?: any | null): boolean;
        /**
         * Determines whether a stream has been prepared for playback.
         */
        vfunc_opened(): boolean;
        /**
         * Pauses playback of the most recently started stream.  Any
         * streams being faded out may continue until the fade is
         * complete.
         */
        vfunc_pause(): void;
        /**
         * Starts playback of the most recently opened stream.
         * if `play_type` is #RB_PLAYER_PLAY_CROSSFADE, the player
         * may attempt to crossfade the new stream with any existing
         * streams.  If it does this, the it will use `crossfade` as the
         * duration of the fade.
         *
         * If `play_type` is #RB_PLAYER_PLAY_AFTER_EOS, the player may
         * attempt to start the stream immediately after the current
         * playing stream reaches EOS.  This may or may not result in
         * the phenomemon known as 'gapless playback'.
         *
         * If `play_type` is #RB_PLAYER_PLAY_REPLACE, the player will stop any
         * existing stream before starting the new stream. It may do
         * this anyway, regardless of the value of `play_type`.
         *
         * The 'playing-stream' signal will be emitted when the new stream
         * is actually playing. This may be before or after control returns
         * to the caller.
         * @param play_type requested playback start type
         * @param crossfade requested crossfade duration (nanoseconds)
         */
        vfunc_play(play_type: PlayerPlayType, crossfade: number): boolean;
        /**
         * Determines whether the player is currently playing a stream.
         * A stream is playing if it's not paused or being faded out.
         */
        vfunc_playing(): boolean;
        vfunc_playing_stream(stream_data?: any | null): void;
        vfunc_redirect(stream_data: any | null, uri: string): void;
        /**
         * Determines whether seeking is supported for the current stream.
         */
        vfunc_seekable(): boolean;
        /**
         * Attempts to seek in the current stream.  The player
         * may ignore this if the stream is not seekable.
         * The seek may take place asynchronously.
         * @param newtime seek target position in seconds
         */
        vfunc_set_time(newtime: number): void;
        /**
         * Adjusts the output volume level.  This affects all streams.
         * The player may use a hardware volume control to implement
         * this volume adjustment.
         * @param volume new output volume level
         */
        vfunc_set_volume(volume: number): void;
        vfunc_tick(stream_data: any | null, elapsed: number, duration: number): void;
        vfunc_volume_changed(volume: number): void;
    }

    export const Player: PlayerNamespace & {
        new (): Player; // This allows `obj instanceof Player`
    };

    namespace PlayerGstFilter {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface PlayerGstFilterNamespace {
        $gtype: GObject.GType<PlayerGstFilter>;
        prototype: PlayerGstFilter;
    }
    interface PlayerGstFilter extends GObject.Object {
        // Methods

        /**
         * Adds a new filter to the playback pipeline.  The filter may not be
         * inserted immediately.  The 'filter-inserted' signal will be emitted
         * when this actually happens.
         * @param element new filter element (or bin) to add
         * @returns TRUE if the filter will be added
         */
        add_filter(element: Gst.Element): boolean;
        /**
         * Removes a filter from the playback pipeline.  The filter may not be
         * removed immediately.  The 'filter-pre-remove' signal will be emitted
         * immediately before this actually happens.
         * @param element the filter element (or bin) to remove
         * @returns TRUE if the filter was found and will be removed
         */
        remove_filter(element: Gst.Element): boolean;

        // Virtual methods

        /**
         * Adds a new filter to the playback pipeline.  The filter may not be
         * inserted immediately.  The 'filter-inserted' signal will be emitted
         * when this actually happens.
         * @param element new filter element (or bin) to add
         */
        vfunc_add_filter(element: Gst.Element): boolean;
        vfunc_filter_inserted(filter: Gst.Element): void;
        vfunc_filter_pre_remove(filter: Gst.Element): void;
        /**
         * Removes a filter from the playback pipeline.  The filter may not be
         * removed immediately.  The 'filter-pre-remove' signal will be emitted
         * immediately before this actually happens.
         * @param element the filter element (or bin) to remove
         */
        vfunc_remove_filter(element: Gst.Element): boolean;
    }

    export const PlayerGstFilter: PlayerGstFilterNamespace & {
        new (): PlayerGstFilter; // This allows `obj instanceof PlayerGstFilter`
    };

    namespace PlayerGstTee {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface PlayerGstTeeNamespace {
        $gtype: GObject.GType<PlayerGstTee>;
        prototype: PlayerGstTee;
    }
    interface PlayerGstTee extends GObject.Object {
        // Methods

        /**
         * Adds a new sink to the playback pipeline.  The sink may not be
         * inserted immediately.  The 'tee-inserted' signal will be emitted
         * when this actually happens.
         * @param element new sink element (or bin) to add
         * @returns TRUE if the sink will be added
         */
        add_tee(element: Gst.Element): boolean;
        /**
         * Removes a sink from the playback pipeline.  The sink may not be
         * removed immediately.  The 'tee-pre-remove' signal will be emitted
         * immediately before this actually happens.
         * @param element the sink element (or bin) to remove
         * @returns TRUE if the sink was found and will be removed
         */
        remove_tee(element: Gst.Element): boolean;

        // Virtual methods

        /**
         * Adds a new sink to the playback pipeline.  The sink may not be
         * inserted immediately.  The 'tee-inserted' signal will be emitted
         * when this actually happens.
         * @param element new sink element (or bin) to add
         */
        vfunc_add_tee(element: Gst.Element): boolean;
        /**
         * Removes a sink from the playback pipeline.  The sink may not be
         * removed immediately.  The 'tee-pre-remove' signal will be emitted
         * immediately before this actually happens.
         * @param element the sink element (or bin) to remove
         */
        vfunc_remove_tee(element: Gst.Element): boolean;
        vfunc_tee_inserted(tee: Gst.Element): void;
        vfunc_tee_pre_remove(tee: Gst.Element): void;
    }

    export const PlayerGstTee: PlayerGstTeeNamespace & {
        new (): PlayerGstTee; // This allows `obj instanceof PlayerGstTee`
    };

    namespace RhythmDBQueryResults {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface RhythmDBQueryResultsNamespace {
        $gtype: GObject.GType<RhythmDBQueryResults>;
        prototype: RhythmDBQueryResults;
    }
    interface RhythmDBQueryResults extends GObject.Object {
        // Methods

        /**
         * Provides a new set of query results.  References must be taken on the
         * entries.
         * @param entries #GPtrArray containing #RhythmDBEntry results
         */
        add_results(entries: RhythmDBEntry[]): void;
        /**
         * Called when the query is complete and all entries that match the query
         * have been supplied to rhythmdb_query_results_add_results.  If the object
         * implementing this interface needs to identify newly added or changed entries
         * that match the query, it needs to use the entry-added, entry-deleted and
         * entry-changed signals from #RhythmDB.
         */
        query_complete(): void;

        // Virtual methods

        /**
         * Provides a new set of query results.  References must be taken on the
         * entries.
         * @param entries #GPtrArray containing #RhythmDBEntry results
         */
        vfunc_add_results(entries: RhythmDBEntry[]): void;
        /**
         * Called when the query is complete and all entries that match the query
         * have been supplied to rhythmdb_query_results_add_results.  If the object
         * implementing this interface needs to identify newly added or changed entries
         * that match the query, it needs to use the entry-added, entry-deleted and
         * entry-changed signals from #RhythmDB.
         */
        vfunc_query_complete(): void;
    }

    export const RhythmDBQueryResults: RhythmDBQueryResultsNamespace & {
        new (): RhythmDBQueryResults; // This allows `obj instanceof RhythmDBQueryResults`
    };

    namespace TaskProgress {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            task_cancellable: boolean;
            taskCancellable: boolean;
            task_detail: string;
            taskDetail: string;
            task_label: string;
            taskLabel: string;
            task_notify: boolean;
            taskNotify: boolean;
            task_outcome: TaskOutcome;
            taskOutcome: TaskOutcome;
            task_progress: number;
            taskProgress: number;
        }
    }

    export interface TaskProgressNamespace {
        $gtype: GObject.GType<TaskProgress>;
        prototype: TaskProgress;
    }
    interface TaskProgress extends GObject.Object {
        // Properties

        get task_cancellable(): boolean;
        set task_cancellable(val: boolean);
        get taskCancellable(): boolean;
        set taskCancellable(val: boolean);
        get task_detail(): string;
        set task_detail(val: string);
        get taskDetail(): string;
        set taskDetail(val: string);
        get task_label(): string;
        set task_label(val: string);
        get taskLabel(): string;
        set taskLabel(val: string);
        get task_notify(): boolean;
        set task_notify(val: boolean);
        get taskNotify(): boolean;
        set taskNotify(val: boolean);
        get task_outcome(): TaskOutcome;
        set task_outcome(val: TaskOutcome);
        get taskOutcome(): TaskOutcome;
        set taskOutcome(val: TaskOutcome);
        get task_progress(): number;
        set task_progress(val: number);
        get taskProgress(): number;
        set taskProgress(val: number);

        // Methods

        cancel(): void;

        // Virtual methods

        vfunc_cancel(): void;
    }

    export const TaskProgress: TaskProgressNamespace & {
        new (): TaskProgress; // This allows `obj instanceof TaskProgress`
    };

    namespace TransferTarget {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            encoding_target: GstPbutils.EncodingTarget;
            encodingTarget: GstPbutils.EncodingTarget;
        }
    }

    export interface TransferTargetNamespace {
        $gtype: GObject.GType<TransferTarget>;
        prototype: TransferTarget;
    }
    interface TransferTarget extends GObject.Object {
        // Properties

        get encoding_target(): GstPbutils.EncodingTarget;
        set encoding_target(val: GstPbutils.EncodingTarget);
        get encodingTarget(): GstPbutils.EncodingTarget;
        set encodingTarget(val: GstPbutils.EncodingTarget);

        // Methods

        /**
         * Constructs a URI to use as the destination for a transfer or transcoding
         * operation.  The URI may be on the device itself, if the device is mounted
         * into the normal filesystem or through gvfs, or it may be a temporary
         * location used to store the file before uploading it to the device.
         *
         * The destination URI should conform to the device's normal URI format,
         * and should use the provided extension instead of the extension from
         * the source entry.
         * @param entry a #RhythmDBEntry being transferred
         * @param media_type destination media type
         * @param extension extension associated with destination media type
         * @returns constructed URI
         */
        build_dest_uri(entry: RhythmDBEntry, media_type: string, extension: string): string;
        /**
         * This checks that the entry type of `entry` is in a suitable
         * category for transfer.  This can be used to implement
         * `should_transfer`.
         * @param entry a #RhythmDBEntry to check
         * @returns %TRUE if the entry is in a suitable category
         */
        check_category(entry: RhythmDBEntry): boolean;
        /**
         * This checks for an existing entry in the target that matches
         * the title, album, artist, and track number of the entry being
         * considered.  This can be used to implement `should_transfer`.
         * @param entry a #RhythmDBEntry to check
         * @returns %TRUE if the entry already exists on the target.
         */
        check_duplicate(entry: RhythmDBEntry): boolean;
        /**
         * Returns a #GList of allocated media format descriptions for
         * the formats supported by the target.  The list and the strings
         * it holds must be freed by the caller.
         * @returns list of descriptions.
         */
        get_format_descriptions(): string[];
        /**
         * Checks whether `entry` should be transferred to the target.
         * The target can check whether a matching entry already exists on the device,
         * for instance.  `rb_transfer_target_check_duplicate` may form part of
         * an implementation.  If this method returns %FALSE, the entry
         * will be skipped.
         * @param entry a #RhythmDBEntry to consider transferring
         * @returns %TRUE if the entry should be transferred to the target
         */
        should_transfer(entry: RhythmDBEntry): boolean;
        /**
         * This is called when a transfer fails.  If the source's
         * impl_track_add_error implementation returns %TRUE, an error dialog
         * will be displayed to the user containing the error message, unless
         * the error indicates that the destination file already exists.
         * @param entry the source #RhythmDBEntry for the transfer
         * @param uri the destination URI
         * @param error the transfer error information
         */
        track_add_error(entry: RhythmDBEntry, uri: string, error: GLib.Error): void;
        /**
         * This is called when a transfer to the target has completed.
         * If the source's `track_added` method returns %TRUE, the destination
         * URI will be added to the database using the entry type for the device.
         *
         * If the target uses a temporary area as the destination for transfers,
         * it can instead upload the destination file to the device and create an
         * entry for it, then return %FALSE.
         * @param entry the source #RhythmDBEntry for the transfer
         * @param uri the destination URI
         * @param filesize size of the destination file
         * @param media_type media type of the destination file
         */
        track_added(entry: RhythmDBEntry, uri: string, filesize: number, media_type: string): void;
        /**
         * Performs any preparation necessary before starting the transfer.
         * This is called on a task thread, so no UI interaction is possible.
         * @param entry the source #RhythmDBEntry for the transfer
         * @param uri the destination URI
         */
        track_prepare(entry: RhythmDBEntry, uri: string): void;
        /**
         * This is called after a transfer to a temporary file has finished,
         * allowing the transfer target to upload the file to a device or a
         * remote service.
         * @param entry the source #RhythmDBEntry for the transfer
         * @param uri the destination URI
         * @param dest_size the size of the destination file
         * @param media_type the media type of the destination file
         */
        track_upload(entry: RhythmDBEntry, uri: string, dest_size: number, media_type: string): void;
        /**
         * Starts tranferring `entries` to the target.  This returns the
         * #RBTrackTransferBatch that it starts, so the caller can track
         * the progress of the transfer, or NULL if the target doesn't
         * want any of the entries.
         * @param settings #GSettings instance holding encoding settings
         * @param entries a #GList of entries to transfer
         * @param defer if %TRUE, don't start the transfer until
         * @returns an #RBTrackTransferBatch, or NULL
         */
        transfer(settings: Gio.Settings, entries: RhythmDBEntry[], defer: boolean): TrackTransferBatch;

        // Virtual methods

        /**
         * Constructs a URI to use as the destination for a transfer or transcoding
         * operation.  The URI may be on the device itself, if the device is mounted
         * into the normal filesystem or through gvfs, or it may be a temporary
         * location used to store the file before uploading it to the device.
         *
         * The destination URI should conform to the device's normal URI format,
         * and should use the provided extension instead of the extension from
         * the source entry.
         * @param entry a #RhythmDBEntry being transferred
         * @param media_type destination media type
         * @param extension extension associated with destination media type
         */
        vfunc_build_dest_uri(entry: RhythmDBEntry, media_type: string, extension: string): string;
        /**
         * Checks whether `entry` should be transferred to the target.
         * The target can check whether a matching entry already exists on the device,
         * for instance.  `rb_transfer_target_check_duplicate` may form part of
         * an implementation.  If this method returns %FALSE, the entry
         * will be skipped.
         * @param entry a #RhythmDBEntry to consider transferring
         */
        vfunc_should_transfer(entry: RhythmDBEntry): boolean;
        vfunc_track_add_error(entry: RhythmDBEntry, uri: string, error: GLib.Error): boolean;
        vfunc_track_added(entry: RhythmDBEntry, uri: string, dest_size: number, media_type: string): boolean;
        /**
         * Performs any preparation necessary before starting the transfer.
         * This is called on a task thread, so no UI interaction is possible.
         * @param entry the source #RhythmDBEntry for the transfer
         * @param uri the destination URI
         */
        vfunc_track_prepare(entry: RhythmDBEntry, uri: string): void;
        /**
         * This is called after a transfer to a temporary file has finished,
         * allowing the transfer target to upload the file to a device or a
         * remote service.
         * @param entry the source #RhythmDBEntry for the transfer
         * @param uri the destination URI
         * @param dest_size the size of the destination file
         * @param media_type the media type of the destination file
         */
        vfunc_track_upload(entry: RhythmDBEntry, uri: string, dest_size: number, media_type: string): void;
    }

    export const TransferTarget: TransferTargetNamespace & {
        new (): TransferTarget; // This allows `obj instanceof TransferTarget`
    };

    type RhythmDBQuery = GLib.PtrArray;
    /**
     * Name of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
     */
    const __name__: string;
    /**
     * Version of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
     */
    const __version__: string;
}

export default RB;

// END
