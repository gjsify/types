
/*
 * Type Definitions for node-gtk (https://github.com/romgrk/node-gtk)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in ts-for-gir itself or create a bug report on https://github.com/gjsify/ts-for-gir
 */

import './node-modemmanager-1.0-import.d.ts';
    
/**
 * ModemManager-1.0
 */

import type Gio from '@girs/node-gio-2.0';
import type GObject from '@girs/node-gobject-2.0';
import type GLib from '@girs/node-glib-2.0';

export enum BearerAccessTypePreference {
    NONE,
    TODO_3GPP_ONLY,
    TODO_3GPP_PREFERRED,
    NON_3GPP_ONLY,
}
export enum BearerIpMethod {
    UNKNOWN,
    PPP,
    STATIC,
    DHCP,
}
export enum BearerMultiplexSupport {
    UNKNOWN,
    NONE,
    REQUESTED,
    REQUIRED,
}
export enum BearerProfileSource {
    UNKNOWN,
    ADMIN,
    USER,
    OPERATOR,
    MODEM,
    DEVICE,
}
export enum BearerType {
    UNKNOWN,
    DEFAULT,
    DEFAULT_ATTACH,
    DEDICATED,
}
export enum CallDirection {
    UNKNOWN,
    INCOMING,
    OUTGOING,
}
export enum CallState {
    UNKNOWN,
    DIALING,
    RINGING_OUT,
    RINGING_IN,
    ACTIVE,
    HELD,
    WAITING,
    TERMINATED,
}
export enum CallStateReason {
    UNKNOWN,
    OUTGOING_STARTED,
    INCOMING_NEW,
    ACCEPTED,
    TERMINATED,
    REFUSED_OR_BUSY,
    ERROR,
    AUDIO_SETUP_FAILED,
    TRANSFERRED,
    DEFLECTED,
}
export enum CdmaActivationError {
    NONE,
    UNKNOWN,
    ROAMING,
    WRONGRADIOINTERFACE,
    COULDNOTCONNECT,
    SECURITYAUTHENTICATIONFAILED,
    PROVISIONINGFAILED,
    NOSIGNAL,
    TIMEDOUT,
    STARTFAILED,
}
export enum CellType {
    UNKNOWN,
    CDMA,
    GSM,
    UMTS,
    TDSCDMA,
    LTE,
    TODO_5GNR,
}
export enum ConnectionError {
    UNKNOWN,
    NOCARRIER,
    NODIALTONE,
    BUSY,
    NOANSWER,
}
export enum CoreError {
    FAILED,
    CANCELLED,
    ABORTED,
    UNSUPPORTED,
    NOPLUGINS,
    UNAUTHORIZED,
    INVALIDARGS,
    INPROGRESS,
    WRONGSTATE,
    CONNECTED,
    TOOMANY,
    NOTFOUND,
    RETRY,
    EXISTS,
    WRONGSIMSTATE,
    RESETRETRY,
}
export enum FirmwareImageType {
    UNKNOWN,
    GENERIC,
    GOBI,
}
export enum MessageError {
    MEFAILURE,
    SMSSERVICERESERVED,
    NOTALLOWED,
    NOTSUPPORTED,
    INVALIDPDUPARAMETER,
    INVALIDTEXTPARAMETER,
    SIMNOTINSERTED,
    SIMPIN,
    PHSIMPIN,
    SIMFAILURE,
    SIMBUSY,
    SIMWRONG,
    SIMPUK,
    SIMPIN2,
    SIMPUK2,
    MEMORYFAILURE,
    INVALIDINDEX,
    MEMORYFULL,
    SMSCADDRESSUNKNOWN,
    NONETWORK,
    NETWORKTIMEOUT,
    NOCNMAACKEXPECTED,
    UNKNOWN,
}
export enum MobileEquipmentError {
    PHONEFAILURE,
    NOCONNECTION,
    LINKRESERVED,
    NOTALLOWED,
    NOTSUPPORTED,
    PHSIMPIN,
    PHFSIMPIN,
    PHFSIMPUK,
    SIMNOTINSERTED,
    SIMPIN,
    SIMPUK,
    SIMFAILURE,
    SIMBUSY,
    SIMWRONG,
    INCORRECTPASSWORD,
    SIMPIN2,
    SIMPUK2,
    MEMORYFULL,
    INVALIDINDEX,
    NOTFOUND,
    MEMORYFAILURE,
    TEXTTOOLONG,
    INVALIDCHARS,
    DIALSTRINGTOOLONG,
    DIALSTRINGINVALID,
    NONETWORK,
    NETWORKTIMEOUT,
    NETWORKNOTALLOWED,
    NETWORKPIN,
    NETWORKPUK,
    NETWORKSUBSETPIN,
    NETWORKSUBSETPUK,
    SERVICEPIN,
    SERVICEPUK,
    CORPPIN,
    CORPPUK,
    HIDDENKEYREQUIRED,
    EAPMETHODNOTSUPPORTED,
    INCORRECTPARAMETERS,
    COMMANDDISABLED,
    COMMANDABORTED,
    NOTATTACHEDRESTRICTED,
    NOTALLOWEDEMERGENCYONLY,
    NOTALLOWEDRESTRICTED,
    FIXEDDIALNUMBERONLY,
    TEMPORARILYOUTOFSERVICE,
    LANGUAGEORALPHABETNOTSUPPORTED,
    UNEXPECTEDDATAVALUE,
    SYSTEMFAILURE,
    DATAMISSING,
    CALLBARRED,
    MESSAGEWAITINGINDICATIONSUBSCRIPTIONFAILURE,
    UNKNOWN,
    IMSIUNKNOWNINHSS,
    ILLEGALUE,
    IMSIUNKNOWNINVLR,
    IMEINOTACCEPTED,
    ILLEGALME,
    PSSERVICESNOTALLOWED,
    PSANDNONPSSERVICESNOTALLOWED,
    UEIDENTITYNOTDERIVEDFROMNETWORK,
    IMPLICITLYDETACHED,
    PLMNNOTALLOWED,
    AREANOTALLOWED,
    ROAMINGNOTALLOWEDINAREA,
    PSSERVICESNOTALLOWEDINPLMN,
    NOCELLSINAREA,
    MSCTEMPORARILYNOTREACHABLE,
    NETWORKFAILUREATTACH,
    CSDOMAINUNAVAILABLE,
    ESMFAILURE,
    CONGESTION,
    MBMSBEARERCAPABILITIESINSUFFICIENTFORSERVICE,
    NOTAUTHORIZEDFORCSG,
    INSUFFICIENTRESOURCES,
    MISSINGORUNKNOWNAPN,
    UNKNOWNPDPADDRESSORTYPE,
    USERAUTHENTICATIONFAILED,
    ACTIVATIONREJECTEDBYGGSNORGW,
    ACTIVATIONREJECTEDUNSPECIFIED,
    SERVICEOPTIONNOTSUPPORTED,
    SERVICEOPTIONNOTSUBSCRIBED,
    SERVICEOPTIONOUTOFORDER,
    NSAPIORPTIALREADYINUSE,
    REGULARDEACTIVATION,
    QOSNOTACCEPTED,
    CALLCANNOTBEIDENTIFIED,
    CSSERVICETEMPORARILYUNAVAILABLE,
    FEATURENOTSUPPORTED,
    SEMANTICERRORINTFTOPERATION,
    SYNTACTICALERRORINTFTOPERATION,
    UNKNOWNPDPCONTEXT,
    SEMANTICERRORSINPACKETFILTER,
    SYNTACTICALERRORSINPACKETFILTER,
    PDPCONTEXTWITHOUTTFTALREADYACTIVATED,
    MULTICASTGROUPMEMBERSHIPTIMEOUT,
    GPRSUNKNOWN,
    PDPAUTHFAILURE,
    INVALIDMOBILECLASS,
    LASTPDNDISCONNECTIONNOTALLOWEDLEGACY,
    LASTPDNDISCONNECTIONNOTALLOWED,
    SEMANTICALLYINCORRECTMESSAGE,
    INVALIDMANDATORYINFORMATION,
    MESSAGETYPENOTIMPLEMENTED,
    CONDITIONALIEERROR,
    UNSPECIFIEDPROTOCOLERROR,
    OPERATORDETERMINEDBARRING,
    MAXIMUMNUMBEROFBEARERSREACHED,
    REQUESTEDAPNNOTSUPPORTED,
    REQUESTREJECTEDBCMVIOLATION,
    UNSUPPORTEDQCIOR5QIVALUE,
    USERDATAVIACONTROLPLANECONGESTED,
    SMSPROVIDEDVIAGPRSINROUTINGAREA,
    INVALIDPTIVALUE,
    NOBEARERACTIVATED,
    MESSAGENOTCOMPATIBLEWITHPROTOCOLSTATE,
    RECOVERYONTIMEREXPIRY,
    INVALIDTRANSACTIONIDVALUE,
    SERVICEOPTIONNOTAUTHORIZEDINPLMN,
    NETWORKFAILUREACTIVATION,
    REACTIVATIONREQUESTED,
    IPV4ONLYALLOWED,
    IPV6ONLYALLOWED,
    SINGLEADDRESSBEARERSONLYALLOWED,
    COLLISIONWITHNETWORKINITIATEDREQUEST,
    IPV4V6ONLYALLOWED,
    NONIPONLYALLOWED,
    BEARERHANDLINGUNSUPPORTED,
    APNRESTRICTIONINCOMPATIBLE,
    MULTIPLEACCESSTOPDNCONNECTIONNOTALLOWED,
    ESMINFORMATIONNOTRECEIVED,
    PDNCONNECTIONNONEXISTENT,
    MULTIPLEPDNCONNECTIONSAMEAPNNOTALLOWED,
    SEVERENETWORKFAILURE,
    INSUFFICIENTRESOURCESFORSLICEANDDNN,
    UNSUPPORTEDSSCMODE,
    INSUFFICIENTRESOURCESFORSLICE,
    MESSAGETYPENOTCOMPATIBLEWITHPROTOCOLSTATE,
    IENOTIMPLEMENTED,
    N1MODENOTALLOWED,
    RESTRICTEDSERVICEAREA,
    LADNUNAVAILABLE,
    MISSINGORUNKNOWNDNNINSLICE,
    NKGSIALREADYINUSE,
    PAYLOADNOTFORWARDED,
    NON3GPPACCESSTO5GCNNOTALLOWED,
    SERVINGNETWORKNOTAUTHORIZED,
    DNNNOTSUPPORTEDINSLICE,
    INSUFFICIENTUSERPLANERESOURCESFORPDUSESSION,
    OUTOFLADNSERVICEAREA,
    PTIMISMATCH,
    MAXDATARATEFORUSERPLANEINTEGRITYTOOLOW,
    SEMANTICERRORINQOSOPERATION,
    SYNTACTICALERRORINQOSOPERATION,
    INVALIDMAPPEDEPSBEARERIDENTITY,
    REDIRECTIONTO5GCNREQUIRED,
    REDIRECTIONTOEPCREQUIRED,
    TEMPORARILYUNAUTHORIZEDFORSNPN,
    PERMANENTLYUNAUTHORIZEDFORSNPN,
    ETHERNETONLYALLOWED,
    UNAUTHORIZEDFORCAG,
    NONETWORKSLICESAVAILABLE,
    WIRELINEACCESSAREANOTALLOWED,
}
export enum Modem3gppDrxCycle {
    UNKNOWN,
    UNSUPPORTED,
    TODO_32,
    TODO_64,
    TODO_128,
    TODO_256,
}
export enum Modem3gppEpsUeModeOperation {
    UNKNOWN,
    PS_1,
    PS_2,
    CSPS_1,
    CSPS_2,
}
export enum Modem3gppMicoMode {
    UNKNOWN,
    UNSUPPORTED,
    DISABLED,
    ENABLED,
}
export enum Modem3gppNetworkAvailability {
    UNKNOWN,
    AVAILABLE,
    CURRENT,
    FORBIDDEN,
}
export enum Modem3gppPacketServiceState {
    UNKNOWN,
    DETACHED,
    ATTACHED,
}
export enum Modem3gppRegistrationState {
    IDLE,
    HOME,
    SEARCHING,
    DENIED,
    UNKNOWN,
    ROAMING,
    HOME_SMS_ONLY,
    ROAMING_SMS_ONLY,
    EMERGENCY_ONLY,
    HOME_CSFB_NOT_PREFERRED,
    ROAMING_CSFB_NOT_PREFERRED,
    ATTACHED_RLOS,
}
export enum Modem3gppSubscriptionState {
    UNKNOWN,
    UNPROVISIONED,
    PROVISIONED,
    OUT_OF_DATA,
}
export enum Modem3gppUssdSessionState {
    UNKNOWN,
    IDLE,
    ACTIVE,
    USER_RESPONSE,
}
export enum ModemBand {
    UNKNOWN,
    EGSM,
    DCS,
    PCS,
    G850,
    UTRAN_1,
    UTRAN_3,
    UTRAN_4,
    UTRAN_6,
    UTRAN_5,
    UTRAN_8,
    UTRAN_9,
    UTRAN_2,
    UTRAN_7,
    G450,
    G480,
    G750,
    G380,
    G410,
    G710,
    G810,
    EUTRAN_1,
    EUTRAN_2,
    EUTRAN_3,
    EUTRAN_4,
    EUTRAN_5,
    EUTRAN_6,
    EUTRAN_7,
    EUTRAN_8,
    EUTRAN_9,
    EUTRAN_10,
    EUTRAN_11,
    EUTRAN_12,
    EUTRAN_13,
    EUTRAN_14,
    EUTRAN_17,
    EUTRAN_18,
    EUTRAN_19,
    EUTRAN_20,
    EUTRAN_21,
    EUTRAN_22,
    EUTRAN_23,
    EUTRAN_24,
    EUTRAN_25,
    EUTRAN_26,
    EUTRAN_27,
    EUTRAN_28,
    EUTRAN_29,
    EUTRAN_30,
    EUTRAN_31,
    EUTRAN_32,
    EUTRAN_33,
    EUTRAN_34,
    EUTRAN_35,
    EUTRAN_36,
    EUTRAN_37,
    EUTRAN_38,
    EUTRAN_39,
    EUTRAN_40,
    EUTRAN_41,
    EUTRAN_42,
    EUTRAN_43,
    EUTRAN_44,
    EUTRAN_45,
    EUTRAN_46,
    EUTRAN_47,
    EUTRAN_48,
    EUTRAN_49,
    EUTRAN_50,
    EUTRAN_51,
    EUTRAN_52,
    EUTRAN_53,
    EUTRAN_54,
    EUTRAN_55,
    EUTRAN_56,
    EUTRAN_57,
    EUTRAN_58,
    EUTRAN_59,
    EUTRAN_60,
    EUTRAN_61,
    EUTRAN_62,
    EUTRAN_63,
    EUTRAN_64,
    EUTRAN_65,
    EUTRAN_66,
    EUTRAN_67,
    EUTRAN_68,
    EUTRAN_69,
    EUTRAN_70,
    EUTRAN_71,
    EUTRAN_85,
    CDMA_BC0,
    CDMA_BC1,
    CDMA_BC2,
    CDMA_BC3,
    CDMA_BC4,
    CDMA_BC5,
    CDMA_BC6,
    CDMA_BC7,
    CDMA_BC8,
    CDMA_BC9,
    CDMA_BC10,
    CDMA_BC11,
    CDMA_BC12,
    CDMA_BC13,
    CDMA_BC14,
    CDMA_BC15,
    CDMA_BC16,
    CDMA_BC17,
    CDMA_BC18,
    CDMA_BC19,
    UTRAN_10,
    UTRAN_11,
    UTRAN_12,
    UTRAN_13,
    UTRAN_14,
    UTRAN_19,
    UTRAN_20,
    UTRAN_21,
    UTRAN_22,
    UTRAN_25,
    UTRAN_26,
    UTRAN_32,
    ANY,
    NGRAN_1,
    NGRAN_2,
    NGRAN_3,
    NGRAN_5,
    NGRAN_7,
    NGRAN_8,
    NGRAN_12,
    NGRAN_13,
    NGRAN_14,
    NGRAN_18,
    NGRAN_20,
    NGRAN_25,
    NGRAN_26,
    NGRAN_28,
    NGRAN_29,
    NGRAN_30,
    NGRAN_34,
    NGRAN_38,
    NGRAN_39,
    NGRAN_40,
    NGRAN_41,
    NGRAN_48,
    NGRAN_50,
    NGRAN_51,
    NGRAN_53,
    NGRAN_65,
    NGRAN_66,
    NGRAN_70,
    NGRAN_71,
    NGRAN_74,
    NGRAN_75,
    NGRAN_76,
    NGRAN_77,
    NGRAN_78,
    NGRAN_79,
    NGRAN_80,
    NGRAN_81,
    NGRAN_82,
    NGRAN_83,
    NGRAN_84,
    NGRAN_86,
    NGRAN_89,
    NGRAN_90,
    NGRAN_91,
    NGRAN_92,
    NGRAN_93,
    NGRAN_94,
    NGRAN_95,
    NGRAN_257,
    NGRAN_258,
    NGRAN_260,
    NGRAN_261,
}
export enum ModemCdmaActivationState {
    UNKNOWN,
    NOT_ACTIVATED,
    ACTIVATING,
    PARTIALLY_ACTIVATED,
    ACTIVATED,
}
export enum ModemCdmaRegistrationState {
    UNKNOWN,
    REGISTERED,
    HOME,
    ROAMING,
}
export enum ModemCdmaRmProtocol {
    UNKNOWN,
    ASYNC,
    PACKET_RELAY,
    PACKET_NETWORK_PPP,
    PACKET_NETWORK_SLIP,
    STU_III,
}
export enum ModemContactsStorage {
    UNKNOWN,
    ME,
    SM,
    MT,
}
export enum ModemLock {
    UNKNOWN,
    NONE,
    SIM_PIN,
    SIM_PIN2,
    SIM_PUK,
    SIM_PUK2,
    PH_SP_PIN,
    PH_SP_PUK,
    PH_NET_PIN,
    PH_NET_PUK,
    PH_SIM_PIN,
    PH_CORP_PIN,
    PH_CORP_PUK,
    PH_FSIM_PIN,
    PH_FSIM_PUK,
    PH_NETSUB_PIN,
    PH_NETSUB_PUK,
}
export enum ModemPortType {
    UNKNOWN,
    NET,
    AT,
    QCDM,
    GPS,
    QMI,
    MBIM,
    AUDIO,
    IGNORED,
}
export enum ModemPowerState {
    UNKNOWN,
    OFF,
    LOW,
    ON,
}
export enum ModemState {
    FAILED,
    UNKNOWN,
    INITIALIZING,
    LOCKED,
    DISABLED,
    DISABLING,
    ENABLING,
    ENABLED,
    SEARCHING,
    REGISTERED,
    DISCONNECTING,
    CONNECTING,
    CONNECTED,
}
export enum ModemStateChangeReason {
    UNKNOWN,
    USER_REQUESTED,
    SUSPEND,
    FAILURE,
}
export enum ModemStateFailedReason {
    NONE,
    UNKNOWN,
    SIM_MISSING,
    SIM_ERROR,
    UNKNOWN_CAPABILITIES,
    ESIM_WITHOUT_PROFILES,
}
export enum OmaSessionState {
    FAILED,
    UNKNOWN,
    STARTED,
    RETRYING,
    CONNECTING,
    CONNECTED,
    AUTHENTICATED,
    MDN_DOWNLOADED,
    MSID_DOWNLOADED,
    PRL_DOWNLOADED,
    MIP_PROFILE_DOWNLOADED,
    COMPLETED,
}
export enum OmaSessionStateFailedReason {
    UNKNOWN,
    NETWORK_UNAVAILABLE,
    SERVER_UNAVAILABLE,
    AUTHENTICATION_FAILED,
    MAX_RETRY_EXCEEDED,
    SESSION_CANCELLED,
}
export enum OmaSessionType {
    UNKNOWN,
    CLIENT_INITIATED_DEVICE_CONFIGURE,
    CLIENT_INITIATED_PRL_UPDATE,
    CLIENT_INITIATED_HANDS_FREE_ACTIVATION,
    NETWORK_INITIATED_DEVICE_CONFIGURE,
    NETWORK_INITIATED_PRL_UPDATE,
    DEVICE_INITIATED_PRL_UPDATE,
    DEVICE_INITIATED_HANDS_FREE_ACTIVATION,
}
export enum SerialError {
    UNKNOWN,
    OPENFAILED,
    SENDFAILED,
    RESPONSETIMEOUT,
    OPENFAILEDNODEVICE,
    FLASHFAILED,
    NOTOPEN,
    PARSEFAILED,
    FRAMENOTFOUND,
}
export enum ServingCellType {
    UNKNOWN,
    PCELL,
    SCELL,
    PSCELL,
    SSCELL,
    INVALID,
}
export enum SimEsimStatus {
    UNKNOWN,
    NO_PROFILES,
    WITH_PROFILES,
}
export enum SimRemovability {
    UNKNOWN,
    REMOVABLE,
    NOT_REMOVABLE,
}
export enum SimType {
    UNKNOWN,
    PHYSICAL,
    ESIM,
}
export enum SmsCdmaServiceCategory {
    UNKNOWN,
    EMERGENCY_BROADCAST,
    ADMINISTRATIVE,
    MAINTENANCE,
    GENERAL_NEWS_LOCAL,
    GENERAL_NEWS_REGIONAL,
    GENERAL_NEWS_NATIONAL,
    GENERAL_NEWS_INTERNATIONAL,
    BUSINESS_NEWS_LOCAL,
    BUSINESS_NEWS_REGIONAL,
    BUSINESS_NEWS_NATIONAL,
    BUSINESS_NEWS_INTERNATIONAL,
    SPORTS_NEWS_LOCAL,
    SPORTS_NEWS_REGIONAL,
    SPORTS_NEWS_NATIONAL,
    SPORTS_NEWS_INTERNATIONAL,
    ENTERTAINMENT_NEWS_LOCAL,
    ENTERTAINMENT_NEWS_REGIONAL,
    ENTERTAINMENT_NEWS_NATIONAL,
    ENTERTAINMENT_NEWS_INTERNATIONAL,
    LOCAL_WEATHER,
    TRAFFIC_REPORT,
    FLIGHT_SCHEDULES,
    RESTAURANTS,
    LODGINGS,
    RETAIL_DIRECTORY,
    ADVERTISEMENTS,
    STOCK_QUOTES,
    EMPLOYMENT,
    HOSPITALS,
    TECHNOLOGY_NEWS,
    MULTICATEGORY,
    CMAS_PRESIDENTIAL_ALERT,
    CMAS_EXTREME_THREAT,
    CMAS_SEVERE_THREAT,
    CMAS_CHILD_ABDUCTION_EMERGENCY,
    CMAS_TEST,
}
export enum SmsCdmaTeleserviceId {
    UNKNOWN,
    CMT91,
    WPT,
    WMT,
    VMN,
    WAP,
    WEMT,
    SCPT,
    CATPT,
}
export enum SmsDeliveryState {
    COMPLETED_RECEIVED,
    COMPLETED_FORWARDED_UNCONFIRMED,
    COMPLETED_REPLACED_BY_SC,
    TEMPORARY_ERROR_CONGESTION,
    TEMPORARY_ERROR_SME_BUSY,
    TEMPORARY_ERROR_NO_RESPONSE_FROM_SME,
    TEMPORARY_ERROR_SERVICE_REJECTED,
    TEMPORARY_ERROR_QOS_NOT_AVAILABLE,
    TEMPORARY_ERROR_IN_SME,
    ERROR_REMOTE_PROCEDURE,
    ERROR_INCOMPATIBLE_DESTINATION,
    ERROR_CONNECTION_REJECTED,
    ERROR_NOT_OBTAINABLE,
    ERROR_QOS_NOT_AVAILABLE,
    ERROR_NO_INTERWORKING_AVAILABLE,
    ERROR_VALIDITY_PERIOD_EXPIRED,
    ERROR_DELETED_BY_ORIGINATING_SME,
    ERROR_DELETED_BY_SC_ADMINISTRATION,
    ERROR_MESSAGE_DOES_NOT_EXIST,
    TEMPORARY_FATAL_ERROR_CONGESTION,
    TEMPORARY_FATAL_ERROR_SME_BUSY,
    TEMPORARY_FATAL_ERROR_NO_RESPONSE_FROM_SME,
    TEMPORARY_FATAL_ERROR_SERVICE_REJECTED,
    TEMPORARY_FATAL_ERROR_QOS_NOT_AVAILABLE,
    TEMPORARY_FATAL_ERROR_IN_SME,
    UNKNOWN,
    NETWORK_PROBLEM_ADDRESS_VACANT,
    NETWORK_PROBLEM_ADDRESS_TRANSLATION_FAILURE,
    NETWORK_PROBLEM_NETWORK_RESOURCE_OUTAGE,
    NETWORK_PROBLEM_NETWORK_FAILURE,
    NETWORK_PROBLEM_INVALID_TELESERVICE_ID,
    NETWORK_PROBLEM_OTHER,
    TERMINAL_PROBLEM_NO_PAGE_RESPONSE,
    TERMINAL_PROBLEM_DESTINATION_BUSY,
    TERMINAL_PROBLEM_NO_ACKNOWLEDGMENT,
    TERMINAL_PROBLEM_DESTINATION_RESOURCE_SHORTAGE,
    TERMINAL_PROBLEM_SMS_DELIVERY_POSTPONED,
    TERMINAL_PROBLEM_DESTINATION_OUT_OF_SERVICE,
    TERMINAL_PROBLEM_DESTINATION_NO_LONGER_AT_THIS_ADDRESS,
    TERMINAL_PROBLEM_OTHER,
    RADIO_INTERFACE_PROBLEM_RESOURCE_SHORTAGE,
    RADIO_INTERFACE_PROBLEM_INCOMPATIBILITY,
    RADIO_INTERFACE_PROBLEM_OTHER,
    GENERAL_PROBLEM_ENCODING,
    GENERAL_PROBLEM_SMS_ORIGINATION_DENIED,
    GENERAL_PROBLEM_SMS_TERMINATION_DENIED,
    GENERAL_PROBLEM_SUPPLEMENTARY_SERVICE_NOT_SUPPORTED,
    GENERAL_PROBLEM_SMS_NOT_SUPPORTED,
    GENERAL_PROBLEM_MISSING_EXPECTED_PARAMETER,
    GENERAL_PROBLEM_MISSING_MANDATORY_PARAMETER,
    GENERAL_PROBLEM_UNRECOGNIZED_PARAMETER_VALUE,
    GENERAL_PROBLEM_UNEXPECTED_PARAMETER_VALUE,
    GENERAL_PROBLEM_USER_DATA_SIZE_ERROR,
    GENERAL_PROBLEM_OTHER,
    TEMPORARY_NETWORK_PROBLEM_ADDRESS_VACANT,
    TEMPORARY_NETWORK_PROBLEM_ADDRESS_TRANSLATION_FAILURE,
    TEMPORARY_NETWORK_PROBLEM_NETWORK_RESOURCE_OUTAGE,
    TEMPORARY_NETWORK_PROBLEM_NETWORK_FAILURE,
    TEMPORARY_NETWORK_PROBLEM_INVALID_TELESERVICE_ID,
    TEMPORARY_NETWORK_PROBLEM_OTHER,
    TEMPORARY_TERMINAL_PROBLEM_NO_PAGE_RESPONSE,
    TEMPORARY_TERMINAL_PROBLEM_DESTINATION_BUSY,
    TEMPORARY_TERMINAL_PROBLEM_NO_ACKNOWLEDGMENT,
    TEMPORARY_TERMINAL_PROBLEM_DESTINATION_RESOURCE_SHORTAGE,
    TEMPORARY_TERMINAL_PROBLEM_SMS_DELIVERY_POSTPONED,
    TEMPORARY_TERMINAL_PROBLEM_DESTINATION_OUT_OF_SERVICE,
    TEMPORARY_TERMINAL_PROBLEM_DESTINATION_NO_LONGER_AT_THIS_ADDRESS,
    TEMPORARY_TERMINAL_PROBLEM_OTHER,
    TEMPORARY_RADIO_INTERFACE_PROBLEM_RESOURCE_SHORTAGE,
    TEMPORARY_RADIO_INTERFACE_PROBLEM_INCOMPATIBILITY,
    TEMPORARY_RADIO_INTERFACE_PROBLEM_OTHER,
    TEMPORARY_GENERAL_PROBLEM_ENCODING,
    TEMPORARY_GENERAL_PROBLEM_SMS_ORIGINATION_DENIED,
    TEMPORARY_GENERAL_PROBLEM_SMS_TERMINATION_DENIED,
    TEMPORARY_GENERAL_PROBLEM_SUPPLEMENTARY_SERVICE_NOT_SUPPORTED,
    TEMPORARY_GENERAL_PROBLEM_SMS_NOT_SUPPORTED,
    TEMPORARY_GENERAL_PROBLEM_MISSING_EXPECTED_PARAMETER,
    TEMPORARY_GENERAL_PROBLEM_MISSING_MANDATORY_PARAMETER,
    TEMPORARY_GENERAL_PROBLEM_UNRECOGNIZED_PARAMETER_VALUE,
    TEMPORARY_GENERAL_PROBLEM_UNEXPECTED_PARAMETER_VALUE,
    TEMPORARY_GENERAL_PROBLEM_USER_DATA_SIZE_ERROR,
    TEMPORARY_GENERAL_PROBLEM_OTHER,
}
export enum SmsPduType {
    UNKNOWN,
    DELIVER,
    SUBMIT,
    STATUS_REPORT,
    CDMA_DELIVER,
    CDMA_SUBMIT,
    CDMA_CANCELLATION,
    CDMA_DELIVERY_ACKNOWLEDGEMENT,
    CDMA_USER_ACKNOWLEDGEMENT,
    CDMA_READ_ACKNOWLEDGEMENT,
}
export enum SmsState {
    UNKNOWN,
    STORED,
    RECEIVING,
    RECEIVED,
    SENDING,
    SENT,
}
export enum SmsStorage {
    UNKNOWN,
    SM,
    ME,
    MT,
    SR,
    BM,
    TA,
}
export enum SmsValidityType {
    UNKNOWN,
    RELATIVE,
    ABSOLUTE,
    ENHANCED,
}
export enum TODO_3gppProfileCmpFlags {
    NONE,
    NO_PROFILE_ID,
    NO_PROFILE_NAME,
    NO_AUTH,
    NO_APN_TYPE,
    NO_IP_TYPE,
    NO_ACCESS_TYPE_PREFERENCE,
    NO_ENABLED,
    NO_ROAMING_ALLOWANCE,
    NO_PROFILE_SOURCE,
}
export enum BearerAllowedAuth {
    UNKNOWN,
    NONE,
    PAP,
    CHAP,
    MSCHAP,
    MSCHAPV2,
    EAP,
}
export enum BearerApnType {
    NONE,
    INITIAL,
    DEFAULT,
    IMS,
    MMS,
    MANAGEMENT,
    VOICE,
    EMERGENCY,
    PRIVATE,
    PURCHASE,
    VIDEO_SHARE,
    LOCAL,
    APP,
    XCAP,
    TETHERING,
}
export enum BearerIpFamily {
    NONE,
    IPV4,
    IPV6,
    IPV4V6,
    NON_IP,
    ANY,
}
export enum BearerPropertiesCmpFlags {
    NONE,
    LOOSE,
    NO_PASSWORD,
    NO_ALLOW_ROAMING,
    NO_RM_PROTOCOL,
    NO_APN_TYPE,
    NO_PROFILE_ID,
    NO_PROFILE_NAME,
    NO_ACCESS_TYPE_PREFERENCE,
    NO_ROAMING_ALLOWANCE,
}
export enum BearerRoamingAllowance {
    NONE,
    HOME,
    PARTNER,
    NON_PARTNER,
}
export enum Modem3gppFacility {
    NONE,
    SIM,
    FIXED_DIALING,
    PH_SIM,
    PH_FSIM,
    NET_PERS,
    NET_SUB_PERS,
    PROVIDER_PERS,
    CORP_PERS,
}
export enum ModemAccessTechnology {
    UNKNOWN,
    POTS,
    GSM,
    GSM_COMPACT,
    GPRS,
    EDGE,
    UMTS,
    HSDPA,
    HSUPA,
    HSPA,
    HSPA_PLUS,
    TODO_1XRTT,
    EVDO0,
    EVDOA,
    EVDOB,
    LTE,
    TODO_5GNR,
    LTE_CAT_M,
    LTE_NB_IOT,
    ANY,
}
export enum ModemCapability {
    NONE,
    POTS,
    CDMA_EVDO,
    GSM_UMTS,
    LTE,
    IRIDIUM,
    TODO_5GNR,
    TDS,
    ANY,
}
export enum ModemFirmwareUpdateMethod {
    NONE,
    FASTBOOT,
    QMI_PDC,
    MBIM_QDU,
    FIREHOSE,
    SAHARA,
}
export enum ModemLocationAssistanceDataType {
    NONE,
    XTRA,
}
export enum ModemLocationSource {
    NONE,
    TODO_3GPP_LAC_CI,
    GPS_RAW,
    GPS_NMEA,
    CDMA_BS,
    GPS_UNMANAGED,
    AGPS_MSA,
    AGPS_MSB,
}
export enum ModemMode {
    NONE,
    CS,
    TODO_2G,
    TODO_3G,
    TODO_4G,
    TODO_5G,
    ANY,
}
export enum OmaFeature {
    NONE,
    DEVICE_PROVISIONING,
    PRL_UPDATE,
    HANDS_FREE_ACTIVATION,
}
/**
 * This value may be specified in the 'profile-id' property When the user
 * creates a new #MM3gppProfile, to indicate that the real profile id should
 * be assigned by the device.
 */
export const TODO_3GPP_PROFILE_ID_UNKNOWN: number
export const BEARER_METHOD_CONNECT: string | null
export const BEARER_METHOD_DISCONNECT: string | null
export const BEARER_PROPERTY_BEARERTYPE: string | null
export const BEARER_PROPERTY_CONNECTED: string | null
export const BEARER_PROPERTY_CONNECTIONERROR: string | null
export const BEARER_PROPERTY_INTERFACE: string | null
export const BEARER_PROPERTY_IP4CONFIG: string | null
export const BEARER_PROPERTY_IP6CONFIG: string | null
export const BEARER_PROPERTY_IPTIMEOUT: string | null
export const BEARER_PROPERTY_MULTIPLEXED: string | null
export const BEARER_PROPERTY_PROFILEID: string | null
export const BEARER_PROPERTY_PROPERTIES: string | null
export const BEARER_PROPERTY_RELOADSTATSSUPPORTED: string | null
export const BEARER_PROPERTY_STATS: string | null
export const BEARER_PROPERTY_SUSPENDED: string | null
export const CALL_METHOD_ACCEPT: string | null
export const CALL_METHOD_DEFLECT: string | null
export const CALL_METHOD_HANGUP: string | null
export const CALL_METHOD_JOINMULTIPARTY: string | null
export const CALL_METHOD_LEAVEMULTIPARTY: string | null
export const CALL_METHOD_SENDDTMF: string | null
export const CALL_METHOD_START: string | null
export const CALL_PROPERTY_AUDIOFORMAT: string | null
export const CALL_PROPERTY_AUDIOPORT: string | null
export const CALL_PROPERTY_DIRECTION: string | null
export const CALL_PROPERTY_MULTIPARTY: string | null
export const CALL_PROPERTY_NUMBER: string | null
export const CALL_PROPERTY_STATE: string | null
export const CALL_PROPERTY_STATEREASON: string | null
export const CALL_SIGNAL_DTMFRECEIVED: string | null
export const CALL_SIGNAL_STATECHANGED: string | null
export const DBUS_ERROR_PREFIX: string | null
export const DBUS_INTERFACE: string | null
export const DBUS_INTERFACE_BEARER: string | null
export const DBUS_INTERFACE_CALL: string | null
export const DBUS_INTERFACE_MODEM: string | null
export const DBUS_INTERFACE_MODEM_FIRMWARE: string | null
export const DBUS_INTERFACE_MODEM_LOCATION: string | null
export const DBUS_INTERFACE_MODEM_MESSAGING: string | null
export const DBUS_INTERFACE_MODEM_MODEM3GPP: string | null
export const DBUS_INTERFACE_MODEM_MODEM3GPP_PROFILEMANAGER: string | null
export const DBUS_INTERFACE_MODEM_MODEM3GPP_USSD: string | null
export const DBUS_INTERFACE_MODEM_MODEMCDMA: string | null
export const DBUS_INTERFACE_MODEM_OMA: string | null
export const DBUS_INTERFACE_MODEM_SAR: string | null
export const DBUS_INTERFACE_MODEM_SIGNAL: string | null
export const DBUS_INTERFACE_MODEM_SIMPLE: string | null
export const DBUS_INTERFACE_MODEM_TIME: string | null
export const DBUS_INTERFACE_MODEM_VOICE: string | null
export const DBUS_INTERFACE_SIM: string | null
export const DBUS_INTERFACE_SMS: string | null
export const DBUS_PATH: string | null
export const DBUS_SERVICE: string | null
/**
 * Evaluates to the major version number of ModemManager which this source
 * is compiled against.
 */
export const MAJOR_VERSION: number
export const MANAGER_METHOD_INHIBITDEVICE: string | null
export const MANAGER_METHOD_REPORTKERNELEVENT: string | null
export const MANAGER_METHOD_SCANDEVICES: string | null
export const MANAGER_METHOD_SETLOGGING: string | null
export const MANAGER_PROPERTY_VERSION: string | null
/**
 * Evaluates to the micro version number of ModemManager which this source
 * compiled against.
 */
export const MICRO_VERSION: number
/**
 * Evaluates to the minor version number of ModemManager which this source
 * is compiled against.
 */
export const MINOR_VERSION: number
/**
 * Identifier for an unknown NID.
 */
export const MODEM_CDMA_NID_UNKNOWN: number
/**
 * Identifier for an unknown SID.
 */
export const MODEM_CDMA_SID_UNKNOWN: number
export const MODEM_FIRMWARE_METHOD_LIST: string | null
export const MODEM_FIRMWARE_METHOD_SELECT: string | null
export const MODEM_FIRMWARE_PROPERTY_UPDATESETTINGS: string | null
export const MODEM_LOCATION_METHOD_GETLOCATION: string | null
export const MODEM_LOCATION_METHOD_INJECTASSISTANCEDATA: string | null
export const MODEM_LOCATION_METHOD_SETGPSREFRESHRATE: string | null
export const MODEM_LOCATION_METHOD_SETSUPLSERVER: string | null
export const MODEM_LOCATION_METHOD_SETUP: string | null
export const MODEM_LOCATION_PROPERTY_ASSISTANCEDATASERVERS: string | null
export const MODEM_LOCATION_PROPERTY_CAPABILITIES: string | null
export const MODEM_LOCATION_PROPERTY_ENABLED: string | null
export const MODEM_LOCATION_PROPERTY_GPSREFRESHRATE: string | null
export const MODEM_LOCATION_PROPERTY_LOCATION: string | null
export const MODEM_LOCATION_PROPERTY_SIGNALSLOCATION: string | null
export const MODEM_LOCATION_PROPERTY_SUPLSERVER: string | null
export const MODEM_LOCATION_PROPERTY_SUPPORTEDASSISTANCEDATA: string | null
export const MODEM_MESSAGING_METHOD_CREATE: string | null
export const MODEM_MESSAGING_METHOD_DELETE: string | null
export const MODEM_MESSAGING_METHOD_LIST: string | null
export const MODEM_MESSAGING_PROPERTY_DEFAULTSTORAGE: string | null
export const MODEM_MESSAGING_PROPERTY_MESSAGES: string | null
export const MODEM_MESSAGING_PROPERTY_SUPPORTEDSTORAGES: string | null
export const MODEM_MESSAGING_SIGNAL_ADDED: string | null
export const MODEM_MESSAGING_SIGNAL_DELETED: string | null
export const MODEM_METHOD_COMMAND: string | null
export const MODEM_METHOD_CREATEBEARER: string | null
export const MODEM_METHOD_DELETEBEARER: string | null
export const MODEM_METHOD_ENABLE: string | null
export const MODEM_METHOD_FACTORYRESET: string | null
export const MODEM_METHOD_GETCELLINFO: string | null
export const MODEM_METHOD_LISTBEARERS: string | null
export const MODEM_METHOD_RESET: string | null
export const MODEM_METHOD_SETCURRENTBANDS: string | null
export const MODEM_METHOD_SETCURRENTCAPABILITIES: string | null
export const MODEM_METHOD_SETCURRENTMODES: string | null
export const MODEM_METHOD_SETPOWERSTATE: string | null
export const MODEM_METHOD_SETPRIMARYSIMSLOT: string | null
export const MODEM_MODEM3GPP_METHOD_DISABLEFACILITYLOCK: string | null
export const MODEM_MODEM3GPP_METHOD_REGISTER: string | null
export const MODEM_MODEM3GPP_METHOD_SCAN: string | null
export const MODEM_MODEM3GPP_METHOD_SETCARRIERLOCK: string | null
export const MODEM_MODEM3GPP_METHOD_SETEPSUEMODEOPERATION: string | null
export const MODEM_MODEM3GPP_METHOD_SETINITIALEPSBEARERSETTINGS: string | null
export const MODEM_MODEM3GPP_METHOD_SETNR5GREGISTRATIONSETTINGS: string | null
export const MODEM_MODEM3GPP_METHOD_SETPACKETSERVICESTATE: string | null
export const MODEM_MODEM3GPP_PROFILEMANAGER_METHOD_DELETE: string | null
export const MODEM_MODEM3GPP_PROFILEMANAGER_METHOD_LIST: string | null
export const MODEM_MODEM3GPP_PROFILEMANAGER_METHOD_SET: string | null
export const MODEM_MODEM3GPP_PROFILEMANAGER_PROPERTY_INDEXFIELD: string | null
export const MODEM_MODEM3GPP_PROFILEMANAGER_SIGNAL_UPDATED: string | null
export const MODEM_MODEM3GPP_PROPERTY_ENABLEDFACILITYLOCKS: string | null
export const MODEM_MODEM3GPP_PROPERTY_EPSUEMODEOPERATION: string | null
export const MODEM_MODEM3GPP_PROPERTY_IMEI: string | null
export const MODEM_MODEM3GPP_PROPERTY_INITIALEPSBEARER: string | null
export const MODEM_MODEM3GPP_PROPERTY_INITIALEPSBEARERSETTINGS: string | null
export const MODEM_MODEM3GPP_PROPERTY_NR5GREGISTRATIONSETTINGS: string | null
export const MODEM_MODEM3GPP_PROPERTY_OPERATORCODE: string | null
export const MODEM_MODEM3GPP_PROPERTY_OPERATORNAME: string | null
export const MODEM_MODEM3GPP_PROPERTY_PACKETSERVICESTATE: string | null
export const MODEM_MODEM3GPP_PROPERTY_PCO: string | null
export const MODEM_MODEM3GPP_PROPERTY_REGISTRATIONSTATE: string | null
export const MODEM_MODEM3GPP_PROPERTY_SUBSCRIPTIONSTATE: string | null
export const MODEM_MODEM3GPP_USSD_METHOD_CANCEL: string | null
export const MODEM_MODEM3GPP_USSD_METHOD_INITIATE: string | null
export const MODEM_MODEM3GPP_USSD_METHOD_RESPOND: string | null
export const MODEM_MODEM3GPP_USSD_PROPERTY_NETWORKNOTIFICATION: string | null
export const MODEM_MODEM3GPP_USSD_PROPERTY_NETWORKREQUEST: string | null
export const MODEM_MODEM3GPP_USSD_PROPERTY_STATE: string | null
export const MODEM_MODEMCDMA_METHOD_ACTIVATE: string | null
export const MODEM_MODEMCDMA_METHOD_ACTIVATEMANUAL: string | null
export const MODEM_MODEMCDMA_PROPERTY_ACTIVATIONSTATE: string | null
export const MODEM_MODEMCDMA_PROPERTY_CDMA1XREGISTRATIONSTATE: string | null
export const MODEM_MODEMCDMA_PROPERTY_ESN: string | null
export const MODEM_MODEMCDMA_PROPERTY_EVDOREGISTRATIONSTATE: string | null
export const MODEM_MODEMCDMA_PROPERTY_MEID: string | null
export const MODEM_MODEMCDMA_PROPERTY_NID: string | null
export const MODEM_MODEMCDMA_PROPERTY_SID: string | null
export const MODEM_MODEMCDMA_SIGNAL_ACTIVATIONSTATECHANGED: string | null
export const MODEM_OMA_METHOD_ACCEPTNETWORKINITIATEDSESSION: string | null
export const MODEM_OMA_METHOD_CANCELSESSION: string | null
export const MODEM_OMA_METHOD_SETUP: string | null
export const MODEM_OMA_METHOD_STARTCLIENTINITIATEDSESSION: string | null
export const MODEM_OMA_PROPERTY_FEATURES: string | null
export const MODEM_OMA_PROPERTY_PENDINGNETWORKINITIATEDSESSIONS: string | null
export const MODEM_OMA_PROPERTY_SESSIONSTATE: string | null
export const MODEM_OMA_PROPERTY_SESSIONTYPE: string | null
export const MODEM_OMA_SIGNAL_SESSIONSTATECHANGED: string | null
export const MODEM_PROPERTY_ACCESSTECHNOLOGIES: string | null
export const MODEM_PROPERTY_BEARERS: string | null
export const MODEM_PROPERTY_CARRIERCONFIGURATION: string | null
export const MODEM_PROPERTY_CARRIERCONFIGURATIONREVISION: string | null
export const MODEM_PROPERTY_CURRENTBANDS: string | null
export const MODEM_PROPERTY_CURRENTCAPABILITIES: string | null
export const MODEM_PROPERTY_CURRENTMODES: string | null
export const MODEM_PROPERTY_DEVICE: string | null
export const MODEM_PROPERTY_DEVICEIDENTIFIER: string | null
export const MODEM_PROPERTY_DRIVERS: string | null
export const MODEM_PROPERTY_EQUIPMENTIDENTIFIER: string | null
export const MODEM_PROPERTY_HARDWAREREVISION: string | null
export const MODEM_PROPERTY_MANUFACTURER: string | null
export const MODEM_PROPERTY_MAXACTIVEBEARERS: string | null
export const MODEM_PROPERTY_MAXACTIVEMULTIPLEXEDBEARERS: string | null
export const MODEM_PROPERTY_MAXBEARERS: string | null
export const MODEM_PROPERTY_MODEL: string | null
export const MODEM_PROPERTY_OWNNUMBERS: string | null
export const MODEM_PROPERTY_PLUGIN: string | null
export const MODEM_PROPERTY_PORTS: string | null
export const MODEM_PROPERTY_POWERSTATE: string | null
export const MODEM_PROPERTY_PRIMARYPORT: string | null
export const MODEM_PROPERTY_PRIMARYSIMSLOT: string | null
export const MODEM_PROPERTY_REVISION: string | null
export const MODEM_PROPERTY_SIGNALQUALITY: string | null
export const MODEM_PROPERTY_SIM: string | null
export const MODEM_PROPERTY_SIMSLOTS: string | null
export const MODEM_PROPERTY_STATE: string | null
export const MODEM_PROPERTY_STATEFAILEDREASON: string | null
export const MODEM_PROPERTY_SUPPORTEDBANDS: string | null
export const MODEM_PROPERTY_SUPPORTEDCAPABILITIES: string | null
export const MODEM_PROPERTY_SUPPORTEDIPFAMILIES: string | null
export const MODEM_PROPERTY_SUPPORTEDMODES: string | null
export const MODEM_PROPERTY_UNLOCKREQUIRED: string | null
export const MODEM_PROPERTY_UNLOCKRETRIES: string | null
export const MODEM_SAR_METHOD_ENABLE: string | null
export const MODEM_SAR_METHOD_SETPOWERLEVEL: string | null
export const MODEM_SAR_PROPERTY_POWERLEVEL: string | null
export const MODEM_SAR_PROPERTY_STATE: string | null
export const MODEM_SIGNAL_METHOD_SETUP: string | null
export const MODEM_SIGNAL_METHOD_SETUPTHRESHOLDS: string | null
export const MODEM_SIGNAL_PROPERTY_CDMA: string | null
export const MODEM_SIGNAL_PROPERTY_ERRORRATETHRESHOLD: string | null
export const MODEM_SIGNAL_PROPERTY_EVDO: string | null
export const MODEM_SIGNAL_PROPERTY_GSM: string | null
export const MODEM_SIGNAL_PROPERTY_LTE: string | null
export const MODEM_SIGNAL_PROPERTY_NR5G: string | null
export const MODEM_SIGNAL_PROPERTY_RATE: string | null
export const MODEM_SIGNAL_PROPERTY_RSSITHRESHOLD: string | null
export const MODEM_SIGNAL_PROPERTY_UMTS: string | null
export const MODEM_SIGNAL_STATECHANGED: string | null
export const MODEM_SIMPLE_METHOD_CONNECT: string | null
export const MODEM_SIMPLE_METHOD_DISCONNECT: string | null
export const MODEM_SIMPLE_METHOD_GETSTATUS: string | null
export const MODEM_TIME_METHOD_GETNETWORKTIME: string | null
export const MODEM_TIME_PROPERTY_NETWORKTIMEZONE: string | null
export const MODEM_TIME_SIGNAL_NETWORKTIMECHANGED: string | null
export const MODEM_VOICE_METHOD_CALLWAITINGQUERY: string | null
export const MODEM_VOICE_METHOD_CALLWAITINGSETUP: string | null
export const MODEM_VOICE_METHOD_CREATECALL: string | null
export const MODEM_VOICE_METHOD_DELETECALL: string | null
export const MODEM_VOICE_METHOD_HANGUPALL: string | null
export const MODEM_VOICE_METHOD_HANGUPANDACCEPT: string | null
export const MODEM_VOICE_METHOD_HOLDANDACCEPT: string | null
export const MODEM_VOICE_METHOD_LISTCALLS: string | null
export const MODEM_VOICE_METHOD_TRANSFER: string | null
export const MODEM_VOICE_PROPERTY_CALLS: string | null
export const MODEM_VOICE_PROPERTY_EMERGENCYONLY: string | null
export const MODEM_VOICE_SIGNAL_CALLADDED: string | null
export const MODEM_VOICE_SIGNAL_CALLDELETED: string | null
export const SIMPLE_PROPERTY_3GPP_OPERATOR_CODE: string | null
export const SIMPLE_PROPERTY_3GPP_OPERATOR_NAME: string | null
export const SIMPLE_PROPERTY_3GPP_REGISTRATION_STATE: string | null
export const SIMPLE_PROPERTY_3GPP_SUBSCRIPTION_STATE: string | null
export const SIMPLE_PROPERTY_ACCESS_TECHNOLOGIES: string | null
export const SIMPLE_PROPERTY_CDMA_CDMA1X_REGISTRATION_STATE: string | null
export const SIMPLE_PROPERTY_CDMA_EVDO_REGISTRATION_STATE: string | null
export const SIMPLE_PROPERTY_CDMA_NID: string | null
export const SIMPLE_PROPERTY_CDMA_SID: string | null
export const SIMPLE_PROPERTY_CURRENT_BANDS: string | null
export const SIMPLE_PROPERTY_SIGNAL_QUALITY: string | null
export const SIMPLE_PROPERTY_STATE: string | null
export const SIM_METHOD_CHANGEPIN: string | null
export const SIM_METHOD_ENABLEPIN: string | null
export const SIM_METHOD_SENDPIN: string | null
export const SIM_METHOD_SENDPUK: string | null
export const SIM_METHOD_SETPREFERREDNETWORKS: string | null
export const SIM_PROPERTY_ACTIVE: string | null
export const SIM_PROPERTY_EID: string | null
export const SIM_PROPERTY_EMERGENCYNUMBERS: string | null
export const SIM_PROPERTY_ESIMSTATUS: string | null
export const SIM_PROPERTY_GID1: string | null
export const SIM_PROPERTY_GID2: string | null
export const SIM_PROPERTY_IMSI: string | null
export const SIM_PROPERTY_OPERATORIDENTIFIER: string | null
export const SIM_PROPERTY_OPERATORNAME: string | null
export const SIM_PROPERTY_PREFERREDNETWORKS: string | null
export const SIM_PROPERTY_REMOVABILITY: string | null
export const SIM_PROPERTY_SIMIDENTIFIER: string | null
export const SIM_PROPERTY_SIMTYPE: string | null
export const SMS_METHOD_SEND: string | null
export const SMS_METHOD_STORE: string | null
export const SMS_PROPERTY_CLASS: string | null
export const SMS_PROPERTY_DATA: string | null
export const SMS_PROPERTY_DELIVERYREPORTREQUEST: string | null
export const SMS_PROPERTY_DELIVERYSTATE: string | null
export const SMS_PROPERTY_DISCHARGETIMESTAMP: string | null
export const SMS_PROPERTY_MESSAGEREFERENCE: string | null
export const SMS_PROPERTY_NUMBER: string | null
export const SMS_PROPERTY_PDUTYPE: string | null
export const SMS_PROPERTY_SERVICECATEGORY: string | null
export const SMS_PROPERTY_SMSC: string | null
export const SMS_PROPERTY_STATE: string | null
export const SMS_PROPERTY_STORAGE: string | null
export const SMS_PROPERTY_TELESERVICEID: string | null
export const SMS_PROPERTY_TEXT: string | null
export const SMS_PROPERTY_TIMESTAMP: string | null
export const SMS_PROPERTY_VALIDITY: string | null
/**
 * Identifier for reporting unknown unlock retries.
 */
export const UNLOCK_RETRIES_UNKNOWN: number
/**
 * Gets the nickname string for the #MMBearerAccessTypePreference specified at `val`.
 * @param val a MMBearerAccessTypePreference.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function bearerAccessTypePreferenceGetString(val: BearerAccessTypePreference): string | null
/**
 * Builds a string containing a comma-separated list of nicknames for
 * each #MMBearerAllowedAuth in `mask`.
 * @param mask bitmask of MMBearerAllowedAuth values.
 * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
 */
export function bearerAllowedAuthBuildStringFromMask(mask: BearerAllowedAuth): string | null
/**
 * Builds a string containing a comma-separated list of nicknames for
 * each #MMBearerApnType in `mask`.
 * @param mask bitmask of MMBearerApnType values.
 * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
 */
export function bearerApnTypeBuildStringFromMask(mask: BearerApnType): string | null
/**
 * Builds a string containing a comma-separated list of nicknames for
 * each #MMBearerIpFamily in `mask`.
 * @param mask bitmask of MMBearerIpFamily values.
 * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
 */
export function bearerIpFamilyBuildStringFromMask(mask: BearerIpFamily): string | null
/**
 * Gets the nickname string for the #MMBearerIpMethod specified at `val`.
 * @param val a MMBearerIpMethod.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function bearerIpMethodGetString(val: BearerIpMethod): string | null
/**
 * Gets the nickname string for the #MMBearerMultiplexSupport specified at `val`.
 * @param val a MMBearerMultiplexSupport.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function bearerMultiplexSupportGetString(val: BearerMultiplexSupport): string | null
/**
 * Gets the nickname string for the #MMBearerProfileSource specified at `val`.
 * @param val a MMBearerProfileSource.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function bearerProfileSourceGetString(val: BearerProfileSource): string | null
/**
 * Builds a string containing a comma-separated list of nicknames for
 * each #MMBearerRoamingAllowance in `mask`.
 * @param mask bitmask of MMBearerRoamingAllowance values.
 * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
 */
export function bearerRoamingAllowanceBuildStringFromMask(mask: BearerRoamingAllowance): string | null
/**
 * Gets the nickname string for the #MMBearerType specified at `val`.
 * @param val a MMBearerType.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function bearerTypeGetString(val: BearerType): string | null
/**
 * Gets the nickname string for the #MMCallDirection specified at `val`.
 * @param val a MMCallDirection.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function callDirectionGetString(val: CallDirection): string | null
/**
 * Gets the nickname string for the #MMCallState specified at `val`.
 * @param val a MMCallState.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function callStateGetString(val: CallState): string | null
/**
 * Gets the nickname string for the #MMCallStateReason specified at `val`.
 * @param val a MMCallStateReason.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function callStateReasonGetString(val: CallStateReason): string | null
export function cdmaActivationErrorQuark(): GLib.Quark
/**
 * Gets the nickname string for the #MMCellType specified at `val`.
 * @param val a MMCellType.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function cellTypeGetString(val: CellType): string | null
export function connectionErrorQuark(): GLib.Quark
export function coreErrorQuark(): GLib.Quark
/**
 * Gets the nickname string for the #MMFirmwareImageType specified at `val`.
 * @param val a MMFirmwareImageType.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function firmwareImageTypeGetString(val: FirmwareImageType): string | null
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Bearer.top_of_page">org.freedesktop.ModemManager1.Bearer</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusBearerInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusBearer interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusBearerOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Call.top_of_page">org.freedesktop.ModemManager1.Call</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusCallInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusCall interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusCallOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModem3gppInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModem3gpp interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModem3gppOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModem3gppProfileManagerInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModem3gppProfileManager interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModem3gppProfileManagerOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModem3gppUssdInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModem3gppUssd interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModem3gppUssdOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModemCdmaInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModemCdma interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModemCdmaOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModemFirmwareInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModemFirmware interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModemFirmwareOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModemInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModemLocationInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModemLocation interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModemLocationOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModemMessagingInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModemMessaging interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModemMessagingOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModemOmaInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModemOma interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModemOmaOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Overrides all #GObject properties in the #MmGdbusModem interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModemOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModemSarInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModemSar interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModemSarOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModemSignalInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModemSignal interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModemSignalOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModemSimpleInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModemSimple interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModemSimpleOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModemTimeInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModemTime interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModemTimeOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusModemVoiceInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusModemVoice interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusModemVoiceOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1.top_of_page">org.freedesktop.ModemManager1</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusOrgFreedesktopModemManager1InterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusOrgFreedesktopModemManager1 interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusOrgFreedesktopModemManager1OverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sim.top_of_page">org.freedesktop.ModemManager1.Sim</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusSimInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusSim interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusSimOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
/**
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sms.top_of_page">org.freedesktop.ModemManager1.Sms</link> D-Bus interface.
 * @returns A #GDBusInterfaceInfo. Do not free.
 */
export function gdbusSmsInterfaceInfo(): Gio.DBusInterfaceInfo
/**
 * Overrides all #GObject properties in the #MmGdbusSms interface for a concrete class.
 * The properties are overridden in the order they are defined.
 * @param klass The class structure for a #GObject derived class.
 * @param propertyIdBegin The property id to assign to the first overridden property.
 * @returns The last property id.
 */
export function gdbusSmsOverrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
export function messageErrorQuark(): GLib.Quark
export function mobileEquipmentErrorQuark(): GLib.Quark
/**
 * Gets the nickname string for the #MMModem3gppDrxCycle specified at `val`.
 * @param val a MMModem3gppDrxCycle.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modem3gppDrxCycleGetString(val: Modem3gppDrxCycle): string | null
/**
 * Gets the nickname string for the #MMModem3gppEpsUeModeOperation specified at `val`.
 * @param val a MMModem3gppEpsUeModeOperation.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modem3gppEpsUeModeOperationGetString(val: Modem3gppEpsUeModeOperation): string | null
/**
 * Builds a string containing a comma-separated list of nicknames for
 * each #MMModem3gppFacility in `mask`.
 * @param mask bitmask of MMModem3gppFacility values.
 * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
 */
export function modem3gppFacilityBuildStringFromMask(mask: Modem3gppFacility): string | null
/**
 * Gets the nickname string for the #MMModem3gppMicoMode specified at `val`.
 * @param val a MMModem3gppMicoMode.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modem3gppMicoModeGetString(val: Modem3gppMicoMode): string | null
/**
 * Gets the nickname string for the #MMModem3gppNetworkAvailability specified at `val`.
 * @param val a MMModem3gppNetworkAvailability.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modem3gppNetworkAvailabilityGetString(val: Modem3gppNetworkAvailability): string | null
/**
 * Gets the nickname string for the #MMModem3gppPacketServiceState specified at `val`.
 * @param val a MMModem3gppPacketServiceState.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modem3gppPacketServiceStateGetString(val: Modem3gppPacketServiceState): string | null
/**
 * Gets the nickname string for the #MMModem3gppRegistrationState specified at `val`.
 * @param val a MMModem3gppRegistrationState.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modem3gppRegistrationStateGetString(val: Modem3gppRegistrationState): string | null
/**
 * Gets the nickname string for the #MMModem3gppSubscriptionState specified at `val`.
 * @param val a MMModem3gppSubscriptionState.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modem3gppSubscriptionStateGetString(val: Modem3gppSubscriptionState): string | null
/**
 * Gets the nickname string for the #MMModem3gppUssdSessionState specified at `val`.
 * @param val a MMModem3gppUssdSessionState.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modem3gppUssdSessionStateGetString(val: Modem3gppUssdSessionState): string | null
/**
 * Builds a string containing a comma-separated list of nicknames for
 * each #MMModemAccessTechnology in `mask`.
 * @param mask bitmask of MMModemAccessTechnology values.
 * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
 */
export function modemAccessTechnologyBuildStringFromMask(mask: ModemAccessTechnology): string | null
/**
 * Gets the nickname string for the #MMModemBand specified at `val`.
 * @param val a MMModemBand.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modemBandGetString(val: ModemBand): string | null
/**
 * Builds a string containing a comma-separated list of nicknames for
 * each #MMModemCapability in `mask`.
 * @param mask bitmask of MMModemCapability values.
 * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
 */
export function modemCapabilityBuildStringFromMask(mask: ModemCapability): string | null
/**
 * Gets the nickname string for the #MMModemCdmaActivationState specified at `val`.
 * @param val a MMModemCdmaActivationState.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modemCdmaActivationStateGetString(val: ModemCdmaActivationState): string | null
/**
 * Gets the nickname string for the #MMModemCdmaRegistrationState specified at `val`.
 * @param val a MMModemCdmaRegistrationState.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modemCdmaRegistrationStateGetString(val: ModemCdmaRegistrationState): string | null
/**
 * Gets the nickname string for the #MMModemCdmaRmProtocol specified at `val`.
 * @param val a MMModemCdmaRmProtocol.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modemCdmaRmProtocolGetString(val: ModemCdmaRmProtocol): string | null
/**
 * Gets the nickname string for the #MMModemContactsStorage specified at `val`.
 * @param val a MMModemContactsStorage.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modemContactsStorageGetString(val: ModemContactsStorage): string | null
/**
 * Builds a string containing a comma-separated list of nicknames for
 * each #MMModemFirmwareUpdateMethod in `mask`.
 * @param mask bitmask of MMModemFirmwareUpdateMethod values.
 * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
 */
export function modemFirmwareUpdateMethodBuildStringFromMask(mask: ModemFirmwareUpdateMethod): string | null
/**
 * Builds a string containing a comma-separated list of nicknames for
 * each #MMModemLocationAssistanceDataType in `mask`.
 * @param mask bitmask of MMModemLocationAssistanceDataType values.
 * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
 */
export function modemLocationAssistanceDataTypeBuildStringFromMask(mask: ModemLocationAssistanceDataType): string | null
/**
 * Builds a string containing a comma-separated list of nicknames for
 * each #MMModemLocationSource in `mask`.
 * @param mask bitmask of MMModemLocationSource values.
 * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
 */
export function modemLocationSourceBuildStringFromMask(mask: ModemLocationSource): string | null
/**
 * Gets the nickname string for the #MMModemLock specified at `val`.
 * @param val a MMModemLock.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modemLockGetString(val: ModemLock): string | null
/**
 * Builds a string containing a comma-separated list of nicknames for
 * each #MMModemMode in `mask`.
 * @param mask bitmask of MMModemMode values.
 * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
 */
export function modemModeBuildStringFromMask(mask: ModemMode): string | null
/**
 * Gets the nickname string for the #MMModemPortType specified at `val`.
 * @param val a MMModemPortType.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modemPortTypeGetString(val: ModemPortType): string | null
/**
 * Gets the nickname string for the #MMModemPowerState specified at `val`.
 * @param val a MMModemPowerState.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modemPowerStateGetString(val: ModemPowerState): string | null
/**
 * Gets the nickname string for the #MMModemStateChangeReason specified at `val`.
 * @param val a MMModemStateChangeReason.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modemStateChangeReasonGetString(val: ModemStateChangeReason): string | null
/**
 * Gets the nickname string for the #MMModemStateFailedReason specified at `val`.
 * @param val a MMModemStateFailedReason.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modemStateFailedReasonGetString(val: ModemStateFailedReason): string | null
/**
 * Gets the nickname string for the #MMModemState specified at `val`.
 * @param val a MMModemState.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function modemStateGetString(val: ModemState): string | null
/**
 * Builds a string containing a comma-separated list of nicknames for
 * each #MMOmaFeature in `mask`.
 * @param mask bitmask of MMOmaFeature values.
 * @returns a string with the list of nicknames, or %NULL if none given. The returned value should be freed with g_free().
 */
export function omaFeatureBuildStringFromMask(mask: OmaFeature): string | null
/**
 * Gets the nickname string for the #MMOmaSessionStateFailedReason specified at `val`.
 * @param val a MMOmaSessionStateFailedReason.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function omaSessionStateFailedReasonGetString(val: OmaSessionStateFailedReason): string | null
/**
 * Gets the nickname string for the #MMOmaSessionState specified at `val`.
 * @param val a MMOmaSessionState.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function omaSessionStateGetString(val: OmaSessionState): string | null
/**
 * Gets the nickname string for the #MMOmaSessionType specified at `val`.
 * @param val a MMOmaSessionType.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function omaSessionTypeGetString(val: OmaSessionType): string | null
export function serialErrorQuark(): GLib.Quark
/**
 * Gets the nickname string for the #MMServingCellType specified at `val`.
 * @param val a MMServingCellType.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function servingCellTypeGetString(val: ServingCellType): string | null
/**
 * Gets the nickname string for the #MMSimEsimStatus specified at `val`.
 * @param val a MMSimEsimStatus.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function simEsimStatusGetString(val: SimEsimStatus): string | null
/**
 * Gets the nickname string for the #MMSimRemovability specified at `val`.
 * @param val a MMSimRemovability.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function simRemovabilityGetString(val: SimRemovability): string | null
/**
 * Gets the nickname string for the #MMSimType specified at `val`.
 * @param val a MMSimType.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function simTypeGetString(val: SimType): string | null
/**
 * Gets the nickname string for the #MMSmsCdmaServiceCategory specified at `val`.
 * @param val a MMSmsCdmaServiceCategory.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function smsCdmaServiceCategoryGetString(val: SmsCdmaServiceCategory): string | null
/**
 * Gets the nickname string for the #MMSmsCdmaTeleserviceId specified at `val`.
 * @param val a MMSmsCdmaTeleserviceId.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function smsCdmaTeleserviceIdGetString(val: SmsCdmaTeleserviceId): string | null
/**
 * Gets the nickname string for the #MMSmsDeliveryState specified at `val`.
 * @param val a MMSmsDeliveryState.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function smsDeliveryStateGetString(val: SmsDeliveryState): string | null
/**
 * Gets the nickname string for the #MMSmsPduType specified at `val`.
 * @param val a MMSmsPduType.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function smsPduTypeGetString(val: SmsPduType): string | null
/**
 * Gets the nickname string for the #MMSmsState specified at `val`.
 * @param val a MMSmsState.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function smsStateGetString(val: SmsState): string | null
/**
 * Gets the nickname string for the #MMSmsStorage specified at `val`.
 * @param val a MMSmsStorage.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function smsStorageGetString(val: SmsStorage): string | null
/**
 * Gets the nickname string for the #MMSmsValidityType specified at `val`.
 * @param val a MMSmsValidityType.
 * @returns a string with the nickname, or %NULL if not found. Do not free the returned value.
 */
export function smsValidityTypeGetString(val: SmsValidityType): string | null
/**
 * Specifies the type of function passed to mm_unlock_retries_foreach().
 * @callback 
 * @param lock a #MMModemLock.
 * @param count the number of retries left for `lock`.
 */
export interface UnlockRetriesForeachCb {
    (lock: ModemLock, count: number): void
}
export module GdbusBearer {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-connect`
     */
    export interface HandleConnectSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-disconnect`
     */
    export interface HandleDisconnectSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusBearer

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.BearerType">"BearerType"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        bearerType?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Connected">"Connected"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        connected?: boolean | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.ConnectionError">"ConnectionError"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        connectionError?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Interface">"Interface"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        interface?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.IpTimeout">"IpTimeout"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        ipTimeout?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Ip4Config">"Ip4Config"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        ip4Config?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Ip6Config">"Ip6Config"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        ip6Config?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Multiplexed">"Multiplexed"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        multiplexed?: boolean | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.ProfileId">"ProfileId"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        profileId?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Properties">"Properties"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        properties?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.ReloadStatsSupported">"ReloadStatsSupported"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        reloadStatsSupported?: boolean | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Stats">"Stats"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        stats?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Suspended">"Suspended"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        suspended?: boolean | null
    }

}

export interface GdbusBearer {

    // Own properties of ModemManager-1.0.ModemManager.GdbusBearer

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.BearerType">"BearerType"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    bearerType: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Connected">"Connected"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    connected: boolean
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.ConnectionError">"ConnectionError"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    connectionError: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Interface">"Interface"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    interface: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.IpTimeout">"IpTimeout"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    ipTimeout: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Ip4Config">"Ip4Config"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    ip4Config: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Ip6Config">"Ip6Config"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    ip6Config: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Multiplexed">"Multiplexed"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    multiplexed: boolean
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.ProfileId">"ProfileId"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    profileId: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Properties">"Properties"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    properties: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.ReloadStatsSupported">"ReloadStatsSupported"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    reloadStatsSupported: boolean
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Stats">"Stats"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    stats: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Bearer.Suspended">"Suspended"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    suspended: boolean
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusBearer

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Bearer.Connect">Connect()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_bearer_call_connect_finish() to get the result of the operation.
     * 
     * See mm_gdbus_bearer_call_connect_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callConnect(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_bearer_call_connect().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_bearer_call_connect().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callConnectFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Bearer.Connect">Connect()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_bearer_call_connect() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callConnectSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Bearer.Disconnect">Disconnect()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_bearer_call_disconnect_finish() to get the result of the operation.
     * 
     * See mm_gdbus_bearer_call_disconnect_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callDisconnect(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_bearer_call_disconnect().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_bearer_call_disconnect().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDisconnectFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Bearer.Disconnect">Disconnect()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_bearer_call_disconnect() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDisconnectSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Bearer.Connect">Connect()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeConnect(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Bearer.Disconnect">Disconnect()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeDisconnect(invocation: Gio.DBusMethodInvocation): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusBearer

    handleConnect(invocation: Gio.DBusMethodInvocation): boolean
    handleDisconnect(invocation: Gio.DBusMethodInvocation): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusBearer

    connect(sigName: "handle-connect", callback: GdbusBearer.HandleConnectSignalCallback): number
    on(sigName: "handle-connect", callback: GdbusBearer.HandleConnectSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-connect", callback: GdbusBearer.HandleConnectSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-connect", callback: GdbusBearer.HandleConnectSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-connect", ...args: any[]): void
    connect(sigName: "handle-disconnect", callback: GdbusBearer.HandleDisconnectSignalCallback): number
    on(sigName: "handle-disconnect", callback: GdbusBearer.HandleDisconnectSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-disconnect", callback: GdbusBearer.HandleDisconnectSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-disconnect", callback: GdbusBearer.HandleDisconnectSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-disconnect", ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusBearer

    connect(sigName: "notify::bearer-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::bearer-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::bearer-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::bearer-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::bearer-type", ...args: any[]): void
    connect(sigName: "notify::connected", callback: (...args: any[]) => void): number
    on(sigName: "notify::connected", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::connected", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::connected", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::connected", ...args: any[]): void
    connect(sigName: "notify::connection-error", callback: (...args: any[]) => void): number
    on(sigName: "notify::connection-error", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::connection-error", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::connection-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::connection-error", ...args: any[]): void
    connect(sigName: "notify::interface", callback: (...args: any[]) => void): number
    on(sigName: "notify::interface", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::interface", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::interface", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::interface", ...args: any[]): void
    connect(sigName: "notify::ip-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::ip-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ip-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ip-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ip-timeout", ...args: any[]): void
    connect(sigName: "notify::ip4-config", callback: (...args: any[]) => void): number
    on(sigName: "notify::ip4-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ip4-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ip4-config", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ip4-config", ...args: any[]): void
    connect(sigName: "notify::ip6-config", callback: (...args: any[]) => void): number
    on(sigName: "notify::ip6-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ip6-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ip6-config", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ip6-config", ...args: any[]): void
    connect(sigName: "notify::multiplexed", callback: (...args: any[]) => void): number
    on(sigName: "notify::multiplexed", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::multiplexed", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::multiplexed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::multiplexed", ...args: any[]): void
    connect(sigName: "notify::profile-id", callback: (...args: any[]) => void): number
    on(sigName: "notify::profile-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::profile-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::profile-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::profile-id", ...args: any[]): void
    connect(sigName: "notify::properties", callback: (...args: any[]) => void): number
    on(sigName: "notify::properties", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::properties", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::properties", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::properties", ...args: any[]): void
    connect(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void): number
    on(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::reload-stats-supported", ...args: any[]): void
    connect(sigName: "notify::stats", callback: (...args: any[]) => void): number
    on(sigName: "notify::stats", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::stats", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::stats", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::stats", ...args: any[]): void
    connect(sigName: "notify::suspended", callback: (...args: any[]) => void): number
    on(sigName: "notify::suspended", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::suspended", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::suspended", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::suspended", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Bearer.top_of_page">org.freedesktop.ModemManager1.Bearer</link>.
 * @interface 
 */
export class GdbusBearer extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusBearer

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusBearer

    constructor(config?: GdbusBearer.ConstructorProperties) 
    _init(config?: GdbusBearer.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Bearer.top_of_page">org.freedesktop.ModemManager1.Bearer</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusBearer interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusCall {

    // Signal callback interfaces

    /**
     * Signal callback interface for `dtmf-received`
     */
    export interface DtmfReceivedSignalCallback {
        (argDtmf: string | null): void
    }

    /**
     * Signal callback interface for `handle-accept`
     */
    export interface HandleAcceptSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-deflect`
     */
    export interface HandleDeflectSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argNumber: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-hangup`
     */
    export interface HandleHangupSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-join-multiparty`
     */
    export interface HandleJoinMultipartySignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-leave-multiparty`
     */
    export interface HandleLeaveMultipartySignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-send-dtmf`
     */
    export interface HandleSendDtmfSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argDtmf: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-start`
     */
    export interface HandleStartSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `state-changed`
     */
    export interface StateChangedSignalCallback {
        (argOld: number, argNew: number, argReason: number): void
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusCall

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.AudioFormat">"AudioFormat"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        audioFormat?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.AudioPort">"AudioPort"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        audioPort?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.Direction">"Direction"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        direction?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.Multiparty">"Multiparty"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        multiparty?: boolean | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.Number">"Number"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        number?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.State">"State"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        state?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.StateReason">"StateReason"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        stateReason?: number | null
    }

}

export interface GdbusCall {

    // Own properties of ModemManager-1.0.ModemManager.GdbusCall

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.AudioFormat">"AudioFormat"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    audioFormat: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.AudioPort">"AudioPort"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    audioPort: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.Direction">"Direction"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    direction: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.Multiparty">"Multiparty"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    multiparty: boolean
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.Number">"Number"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    number: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.State">"State"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    state: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Call.StateReason">"StateReason"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    stateReason: number
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusCall

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.Accept">Accept()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_call_call_accept_finish() to get the result of the operation.
     * 
     * See mm_gdbus_call_call_accept_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callAccept(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_call_call_accept().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_call_call_accept().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callAcceptFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.Accept">Accept()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_call_call_accept() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callAcceptSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.Deflect">Deflect()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_call_call_deflect_finish() to get the result of the operation.
     * 
     * See mm_gdbus_call_call_deflect_sync() for the synchronous, blocking version of this method.
     * @param argNumber Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callDeflect(argNumber: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_call_call_deflect().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_call_call_deflect().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDeflectFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.Deflect">Deflect()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_call_call_deflect() for the asynchronous version of this method.
     * @param argNumber Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDeflectSync(argNumber: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.Hangup">Hangup()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_call_call_hangup_finish() to get the result of the operation.
     * 
     * See mm_gdbus_call_call_hangup_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callHangup(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_call_call_hangup().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_call_call_hangup().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callHangupFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.Hangup">Hangup()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_call_call_hangup() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callHangupSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.JoinMultiparty">JoinMultiparty()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_call_call_join_multiparty_finish() to get the result of the operation.
     * 
     * See mm_gdbus_call_call_join_multiparty_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callJoinMultiparty(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_call_call_join_multiparty().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_call_call_join_multiparty().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callJoinMultipartyFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.JoinMultiparty">JoinMultiparty()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_call_call_join_multiparty() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callJoinMultipartySync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.LeaveMultiparty">LeaveMultiparty()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_call_call_leave_multiparty_finish() to get the result of the operation.
     * 
     * See mm_gdbus_call_call_leave_multiparty_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callLeaveMultiparty(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_call_call_leave_multiparty().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_call_call_leave_multiparty().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callLeaveMultipartyFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.LeaveMultiparty">LeaveMultiparty()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_call_call_leave_multiparty() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callLeaveMultipartySync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.SendDtmf">SendDtmf()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_call_call_send_dtmf_finish() to get the result of the operation.
     * 
     * See mm_gdbus_call_call_send_dtmf_sync() for the synchronous, blocking version of this method.
     * @param argDtmf Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSendDtmf(argDtmf: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_call_call_send_dtmf().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_call_call_send_dtmf().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSendDtmfFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.SendDtmf">SendDtmf()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_call_call_send_dtmf() for the asynchronous version of this method.
     * @param argDtmf Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSendDtmfSync(argDtmf: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.Start">Start()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_call_call_start_finish() to get the result of the operation.
     * 
     * See mm_gdbus_call_call_start_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callStart(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_call_call_start().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_call_call_start().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callStartFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.Start">Start()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_call_call_start() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callStartSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.Accept">Accept()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeAccept(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.Deflect">Deflect()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeDeflect(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.Hangup">Hangup()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeHangup(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.JoinMultiparty">JoinMultiparty()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeJoinMultiparty(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.LeaveMultiparty">LeaveMultiparty()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeLeaveMultiparty(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.SendDtmf">SendDtmf()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSendDtmf(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Call.Start">Start()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeStart(invocation: Gio.DBusMethodInvocation): void
    /**
     * Emits the <link linkend="gdbus-signal-org-freedesktop-ModemManager1-Call.DtmfReceived">"DtmfReceived"</link> D-Bus signal.
     * @param argDtmf Argument to pass with the signal.
     */
    emitDtmfReceived(argDtmf: string | null): void
    /**
     * Emits the <link linkend="gdbus-signal-org-freedesktop-ModemManager1-Call.StateChanged">"StateChanged"</link> D-Bus signal.
     * @param argOld Argument to pass with the signal.
     * @param argNew Argument to pass with the signal.
     * @param argReason Argument to pass with the signal.
     */
    emitStateChanged(argOld: number, argNew: number, argReason: number): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusCall

    dtmfReceived(argDtmf: string | null): void
    handleAccept(invocation: Gio.DBusMethodInvocation): boolean
    handleDeflect(invocation: Gio.DBusMethodInvocation, argNumber: string | null): boolean
    handleHangup(invocation: Gio.DBusMethodInvocation): boolean
    handleJoinMultiparty(invocation: Gio.DBusMethodInvocation): boolean
    handleLeaveMultiparty(invocation: Gio.DBusMethodInvocation): boolean
    handleSendDtmf(invocation: Gio.DBusMethodInvocation, argDtmf: string | null): boolean
    handleStart(invocation: Gio.DBusMethodInvocation): boolean
    stateChanged(argOld: number, argNew: number, argReason: number): void

    // Own signals of ModemManager-1.0.ModemManager.GdbusCall

    connect(sigName: "dtmf-received", callback: GdbusCall.DtmfReceivedSignalCallback): number
    on(sigName: "dtmf-received", callback: GdbusCall.DtmfReceivedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "dtmf-received", callback: GdbusCall.DtmfReceivedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "dtmf-received", callback: GdbusCall.DtmfReceivedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "dtmf-received", ...args: any[]): void
    connect(sigName: "handle-accept", callback: GdbusCall.HandleAcceptSignalCallback): number
    on(sigName: "handle-accept", callback: GdbusCall.HandleAcceptSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-accept", callback: GdbusCall.HandleAcceptSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-accept", callback: GdbusCall.HandleAcceptSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-accept", ...args: any[]): void
    connect(sigName: "handle-deflect", callback: GdbusCall.HandleDeflectSignalCallback): number
    on(sigName: "handle-deflect", callback: GdbusCall.HandleDeflectSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-deflect", callback: GdbusCall.HandleDeflectSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-deflect", callback: GdbusCall.HandleDeflectSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-deflect", argNumber: string | null, ...args: any[]): void
    connect(sigName: "handle-hangup", callback: GdbusCall.HandleHangupSignalCallback): number
    on(sigName: "handle-hangup", callback: GdbusCall.HandleHangupSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-hangup", callback: GdbusCall.HandleHangupSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-hangup", callback: GdbusCall.HandleHangupSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-hangup", ...args: any[]): void
    connect(sigName: "handle-join-multiparty", callback: GdbusCall.HandleJoinMultipartySignalCallback): number
    on(sigName: "handle-join-multiparty", callback: GdbusCall.HandleJoinMultipartySignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-join-multiparty", callback: GdbusCall.HandleJoinMultipartySignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-join-multiparty", callback: GdbusCall.HandleJoinMultipartySignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-join-multiparty", ...args: any[]): void
    connect(sigName: "handle-leave-multiparty", callback: GdbusCall.HandleLeaveMultipartySignalCallback): number
    on(sigName: "handle-leave-multiparty", callback: GdbusCall.HandleLeaveMultipartySignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-leave-multiparty", callback: GdbusCall.HandleLeaveMultipartySignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-leave-multiparty", callback: GdbusCall.HandleLeaveMultipartySignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-leave-multiparty", ...args: any[]): void
    connect(sigName: "handle-send-dtmf", callback: GdbusCall.HandleSendDtmfSignalCallback): number
    on(sigName: "handle-send-dtmf", callback: GdbusCall.HandleSendDtmfSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-send-dtmf", callback: GdbusCall.HandleSendDtmfSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-send-dtmf", callback: GdbusCall.HandleSendDtmfSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-send-dtmf", argDtmf: string | null, ...args: any[]): void
    connect(sigName: "handle-start", callback: GdbusCall.HandleStartSignalCallback): number
    on(sigName: "handle-start", callback: GdbusCall.HandleStartSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-start", callback: GdbusCall.HandleStartSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-start", callback: GdbusCall.HandleStartSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-start", ...args: any[]): void
    connect(sigName: "state-changed", callback: GdbusCall.StateChangedSignalCallback): number
    on(sigName: "state-changed", callback: GdbusCall.StateChangedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "state-changed", callback: GdbusCall.StateChangedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "state-changed", callback: GdbusCall.StateChangedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "state-changed", argNew: number, argReason: number, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusCall

    connect(sigName: "notify::audio-format", callback: (...args: any[]) => void): number
    on(sigName: "notify::audio-format", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::audio-format", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::audio-format", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::audio-format", ...args: any[]): void
    connect(sigName: "notify::audio-port", callback: (...args: any[]) => void): number
    on(sigName: "notify::audio-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::audio-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::audio-port", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::audio-port", ...args: any[]): void
    connect(sigName: "notify::direction", callback: (...args: any[]) => void): number
    on(sigName: "notify::direction", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::direction", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::direction", ...args: any[]): void
    connect(sigName: "notify::multiparty", callback: (...args: any[]) => void): number
    on(sigName: "notify::multiparty", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::multiparty", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::multiparty", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::multiparty", ...args: any[]): void
    connect(sigName: "notify::number", callback: (...args: any[]) => void): number
    on(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::number", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::number", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::state-reason", callback: (...args: any[]) => void): number
    on(sigName: "notify::state-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state-reason", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Call.top_of_page">org.freedesktop.ModemManager1.Call</link>.
 * @interface 
 */
export class GdbusCall extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusCall

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusCall

    constructor(config?: GdbusCall.ConstructorProperties) 
    _init(config?: GdbusCall.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Call.top_of_page">org.freedesktop.ModemManager1.Call</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusCall interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModem {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-command`
     */
    export interface HandleCommandSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argCmd: string | null, argTimeout: number): boolean
    }

    /**
     * Signal callback interface for `handle-create-bearer`
     */
    export interface HandleCreateBearerSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-delete-bearer`
     */
    export interface HandleDeleteBearerSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argBearer: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-enable`
     */
    export interface HandleEnableSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argEnable: boolean): boolean
    }

    /**
     * Signal callback interface for `handle-factory-reset`
     */
    export interface HandleFactoryResetSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argCode: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-get-cell-info`
     */
    export interface HandleGetCellInfoSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-list-bearers`
     */
    export interface HandleListBearersSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-reset`
     */
    export interface HandleResetSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-set-current-bands`
     */
    export interface HandleSetCurrentBandsSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argBands: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-set-current-capabilities`
     */
    export interface HandleSetCurrentCapabilitiesSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argCapabilities: number): boolean
    }

    /**
     * Signal callback interface for `handle-set-current-modes`
     */
    export interface HandleSetCurrentModesSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argModes: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-set-power-state`
     */
    export interface HandleSetPowerStateSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argState: number): boolean
    }

    /**
     * Signal callback interface for `handle-set-primary-sim-slot`
     */
    export interface HandleSetPrimarySimSlotSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argSimSlot: number): boolean
    }

    /**
     * Signal callback interface for `state-changed`
     */
    export interface StateChangedSignalCallback {
        (argOld: number, argNew: number, argReason: number): void
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModem

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.AccessTechnologies">"AccessTechnologies"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        accessTechnologies?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Bearers">"Bearers"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        bearers?: string[] | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.CarrierConfiguration">"CarrierConfiguration"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        carrierConfiguration?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.CarrierConfigurationRevision">"CarrierConfigurationRevision"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        carrierConfigurationRevision?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.CurrentBands">"CurrentBands"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        currentBands?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.CurrentCapabilities">"CurrentCapabilities"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        currentCapabilities?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.CurrentModes">"CurrentModes"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        currentModes?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Device">"Device"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        device?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.DeviceIdentifier">"DeviceIdentifier"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        deviceIdentifier?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Drivers">"Drivers"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        drivers?: string[] | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.EquipmentIdentifier">"EquipmentIdentifier"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        equipmentIdentifier?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.HardwareRevision">"HardwareRevision"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        hardwareRevision?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Manufacturer">"Manufacturer"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        manufacturer?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.MaxActiveBearers">"MaxActiveBearers"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        maxActiveBearers?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.MaxActiveMultiplexedBearers">"MaxActiveMultiplexedBearers"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        maxActiveMultiplexedBearers?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.MaxBearers">"MaxBearers"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        maxBearers?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Model">"Model"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        model?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.OwnNumbers">"OwnNumbers"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        ownNumbers?: string[] | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Plugin">"Plugin"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        plugin?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Ports">"Ports"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        ports?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.PowerState">"PowerState"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        powerState?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.PrimaryPort">"PrimaryPort"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        primaryPort?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.PrimarySimSlot">"PrimarySimSlot"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        primarySimSlot?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Revision">"Revision"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        revision?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.SignalQuality">"SignalQuality"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        signalQuality?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Sim">"Sim"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        sim?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.SimSlots">"SimSlots"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        simSlots?: string[] | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.State">"State"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        state?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.StateFailedReason">"StateFailedReason"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        stateFailedReason?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.SupportedBands">"SupportedBands"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        supportedBands?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.SupportedCapabilities">"SupportedCapabilities"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        supportedCapabilities?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.SupportedIpFamilies">"SupportedIpFamilies"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        supportedIpFamilies?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.SupportedModes">"SupportedModes"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        supportedModes?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.UnlockRequired">"UnlockRequired"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        unlockRequired?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.UnlockRetries">"UnlockRetries"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        unlockRetries?: GLib.Variant | null
    }

}

export interface GdbusModem {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.AccessTechnologies">"AccessTechnologies"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    accessTechnologies: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Bearers">"Bearers"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    bearers: string[]
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.CarrierConfiguration">"CarrierConfiguration"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    carrierConfiguration: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.CarrierConfigurationRevision">"CarrierConfigurationRevision"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    carrierConfigurationRevision: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.CurrentBands">"CurrentBands"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    currentBands: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.CurrentCapabilities">"CurrentCapabilities"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    currentCapabilities: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.CurrentModes">"CurrentModes"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    currentModes: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Device">"Device"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    device: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.DeviceIdentifier">"DeviceIdentifier"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    deviceIdentifier: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Drivers">"Drivers"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    drivers: string[]
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.EquipmentIdentifier">"EquipmentIdentifier"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    equipmentIdentifier: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.HardwareRevision">"HardwareRevision"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    hardwareRevision: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Manufacturer">"Manufacturer"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    manufacturer: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.MaxActiveBearers">"MaxActiveBearers"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    maxActiveBearers: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.MaxActiveMultiplexedBearers">"MaxActiveMultiplexedBearers"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    maxActiveMultiplexedBearers: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.MaxBearers">"MaxBearers"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    maxBearers: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Model">"Model"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    model: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.OwnNumbers">"OwnNumbers"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    ownNumbers: string[]
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Plugin">"Plugin"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    plugin: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Ports">"Ports"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    ports: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.PowerState">"PowerState"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    powerState: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.PrimaryPort">"PrimaryPort"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    primaryPort: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.PrimarySimSlot">"PrimarySimSlot"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    primarySimSlot: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Revision">"Revision"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    revision: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.SignalQuality">"SignalQuality"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    signalQuality: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.Sim">"Sim"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    sim: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.SimSlots">"SimSlots"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    simSlots: string[]
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.State">"State"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    state: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.StateFailedReason">"StateFailedReason"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    stateFailedReason: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.SupportedBands">"SupportedBands"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    supportedBands: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.SupportedCapabilities">"SupportedCapabilities"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    supportedCapabilities: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.SupportedIpFamilies">"SupportedIpFamilies"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    supportedIpFamilies: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.SupportedModes">"SupportedModes"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    supportedModes: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.UnlockRequired">"UnlockRequired"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    unlockRequired: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem.UnlockRetries">"UnlockRetries"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    unlockRetries: GLib.Variant
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModem

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.Command">Command()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_command_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_command_sync() for the synchronous, blocking version of this method.
     * @param argCmd Argument to pass with the method invocation.
     * @param argTimeout Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callCommand(argCmd: string | null, argTimeout: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_command().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_command().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCommandFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outResponse */ string | null ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.Command">Command()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_command() for the asynchronous version of this method.
     * @param argCmd Argument to pass with the method invocation.
     * @param argTimeout Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCommandSync(argCmd: string | null, argTimeout: number, cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outResponse */ string | null ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.CreateBearer">CreateBearer()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_create_bearer_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_create_bearer_sync() for the synchronous, blocking version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callCreateBearer(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_create_bearer().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_create_bearer().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCreateBearerFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outPath */ string | null ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.CreateBearer">CreateBearer()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_create_bearer() for the asynchronous version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCreateBearerSync(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outPath */ string | null ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.DeleteBearer">DeleteBearer()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_delete_bearer_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_delete_bearer_sync() for the synchronous, blocking version of this method.
     * @param argBearer Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callDeleteBearer(argBearer: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_delete_bearer().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_delete_bearer().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDeleteBearerFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.DeleteBearer">DeleteBearer()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_delete_bearer() for the asynchronous version of this method.
     * @param argBearer Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDeleteBearerSync(argBearer: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.Enable">Enable()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_enable_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_enable_sync() for the synchronous, blocking version of this method.
     * @param argEnable Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callEnable(argEnable: boolean, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_enable().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_enable().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callEnableFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.Enable">Enable()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_enable() for the asynchronous version of this method.
     * @param argEnable Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callEnableSync(argEnable: boolean, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.FactoryReset">FactoryReset()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_factory_reset_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_factory_reset_sync() for the synchronous, blocking version of this method.
     * @param argCode Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callFactoryReset(argCode: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_factory_reset().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_factory_reset().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callFactoryResetFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.FactoryReset">FactoryReset()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_factory_reset() for the asynchronous version of this method.
     * @param argCode Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callFactoryResetSync(argCode: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.GetCellInfo">GetCellInfo()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_get_cell_info_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_get_cell_info_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callGetCellInfo(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_get_cell_info().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_get_cell_info().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callGetCellInfoFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outCellInfo */ GLib.Variant ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.GetCellInfo">GetCellInfo()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_get_cell_info() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callGetCellInfoSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outCellInfo */ GLib.Variant ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.ListBearers">ListBearers()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_list_bearers_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_list_bearers_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callListBearers(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_list_bearers().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_list_bearers().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callListBearersFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outBearers */ string[] ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.ListBearers">ListBearers()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_list_bearers() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callListBearersSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outBearers */ string[] ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.Reset">Reset()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_reset_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_reset_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callReset(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_reset().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_reset().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callResetFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.Reset">Reset()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_reset() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callResetSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetCurrentBands">SetCurrentBands()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_set_current_bands_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_set_current_bands_sync() for the synchronous, blocking version of this method.
     * @param argBands Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetCurrentBands(argBands: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_set_current_bands().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_set_current_bands().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetCurrentBandsFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetCurrentBands">SetCurrentBands()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_set_current_bands() for the asynchronous version of this method.
     * @param argBands Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetCurrentBandsSync(argBands: GLib.Variant, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetCurrentCapabilities">SetCurrentCapabilities()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_set_current_capabilities_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_set_current_capabilities_sync() for the synchronous, blocking version of this method.
     * @param argCapabilities Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetCurrentCapabilities(argCapabilities: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_set_current_capabilities().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_set_current_capabilities().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetCurrentCapabilitiesFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetCurrentCapabilities">SetCurrentCapabilities()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_set_current_capabilities() for the asynchronous version of this method.
     * @param argCapabilities Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetCurrentCapabilitiesSync(argCapabilities: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetCurrentModes">SetCurrentModes()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_set_current_modes_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_set_current_modes_sync() for the synchronous, blocking version of this method.
     * @param argModes Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetCurrentModes(argModes: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_set_current_modes().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_set_current_modes().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetCurrentModesFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetCurrentModes">SetCurrentModes()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_set_current_modes() for the asynchronous version of this method.
     * @param argModes Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetCurrentModesSync(argModes: GLib.Variant, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetPowerState">SetPowerState()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_set_power_state_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_set_power_state_sync() for the synchronous, blocking version of this method.
     * @param argState Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetPowerState(argState: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_set_power_state().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_set_power_state().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetPowerStateFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetPowerState">SetPowerState()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_set_power_state() for the asynchronous version of this method.
     * @param argState Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetPowerStateSync(argState: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetPrimarySimSlot">SetPrimarySimSlot()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_call_set_primary_sim_slot_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_call_set_primary_sim_slot_sync() for the synchronous, blocking version of this method.
     * @param argSimSlot Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetPrimarySimSlot(argSimSlot: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_call_set_primary_sim_slot().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_call_set_primary_sim_slot().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetPrimarySimSlotFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetPrimarySimSlot">SetPrimarySimSlot()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_call_set_primary_sim_slot() for the asynchronous version of this method.
     * @param argSimSlot Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetPrimarySimSlotSync(argSimSlot: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.Command">Command()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param response Parameter to return.
     */
    completeCommand(invocation: Gio.DBusMethodInvocation, response: string | null): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.CreateBearer">CreateBearer()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param path Parameter to return.
     */
    completeCreateBearer(invocation: Gio.DBusMethodInvocation, path: string | null): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.DeleteBearer">DeleteBearer()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeDeleteBearer(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.Enable">Enable()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeEnable(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.FactoryReset">FactoryReset()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeFactoryReset(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.GetCellInfo">GetCellInfo()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param cellInfo Parameter to return.
     */
    completeGetCellInfo(invocation: Gio.DBusMethodInvocation, cellInfo: GLib.Variant): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.ListBearers">ListBearers()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param bearers Parameter to return.
     */
    completeListBearers(invocation: Gio.DBusMethodInvocation, bearers: string | null): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.Reset">Reset()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeReset(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetCurrentBands">SetCurrentBands()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetCurrentBands(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetCurrentCapabilities">SetCurrentCapabilities()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetCurrentCapabilities(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetCurrentModes">SetCurrentModes()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetCurrentModes(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetPowerState">SetPowerState()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetPowerState(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.SetPrimarySimSlot">SetPrimarySimSlot()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetPrimarySimSlot(invocation: Gio.DBusMethodInvocation): void
    /**
     * Emits the <link linkend="gdbus-signal-org-freedesktop-ModemManager1-Modem.StateChanged">"StateChanged"</link> D-Bus signal.
     * @param argOld Argument to pass with the signal.
     * @param argNew Argument to pass with the signal.
     * @param argReason Argument to pass with the signal.
     */
    emitStateChanged(argOld: number, argNew: number, argReason: number): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModem

    handleCommand(invocation: Gio.DBusMethodInvocation, argCmd: string | null, argTimeout: number): boolean
    handleCreateBearer(invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    handleDeleteBearer(invocation: Gio.DBusMethodInvocation, argBearer: string | null): boolean
    handleEnable(invocation: Gio.DBusMethodInvocation, argEnable: boolean): boolean
    handleFactoryReset(invocation: Gio.DBusMethodInvocation, argCode: string | null): boolean
    handleGetCellInfo(invocation: Gio.DBusMethodInvocation): boolean
    handleListBearers(invocation: Gio.DBusMethodInvocation): boolean
    handleReset(invocation: Gio.DBusMethodInvocation): boolean
    handleSetCurrentBands(invocation: Gio.DBusMethodInvocation, argBands: GLib.Variant): boolean
    handleSetCurrentCapabilities(invocation: Gio.DBusMethodInvocation, argCapabilities: number): boolean
    handleSetCurrentModes(invocation: Gio.DBusMethodInvocation, argModes: GLib.Variant): boolean
    handleSetPowerState(invocation: Gio.DBusMethodInvocation, argState: number): boolean
    handleSetPrimarySimSlot(invocation: Gio.DBusMethodInvocation, argSimSlot: number): boolean
    stateChanged(argOld: number, argNew: number, argReason: number): void

    // Own signals of ModemManager-1.0.ModemManager.GdbusModem

    connect(sigName: "handle-command", callback: GdbusModem.HandleCommandSignalCallback): number
    on(sigName: "handle-command", callback: GdbusModem.HandleCommandSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-command", callback: GdbusModem.HandleCommandSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-command", callback: GdbusModem.HandleCommandSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-command", argCmd: string | null, argTimeout: number, ...args: any[]): void
    connect(sigName: "handle-create-bearer", callback: GdbusModem.HandleCreateBearerSignalCallback): number
    on(sigName: "handle-create-bearer", callback: GdbusModem.HandleCreateBearerSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-create-bearer", callback: GdbusModem.HandleCreateBearerSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-create-bearer", callback: GdbusModem.HandleCreateBearerSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-create-bearer", argProperties: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-delete-bearer", callback: GdbusModem.HandleDeleteBearerSignalCallback): number
    on(sigName: "handle-delete-bearer", callback: GdbusModem.HandleDeleteBearerSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-delete-bearer", callback: GdbusModem.HandleDeleteBearerSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-delete-bearer", callback: GdbusModem.HandleDeleteBearerSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-delete-bearer", argBearer: string | null, ...args: any[]): void
    connect(sigName: "handle-enable", callback: GdbusModem.HandleEnableSignalCallback): number
    on(sigName: "handle-enable", callback: GdbusModem.HandleEnableSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-enable", callback: GdbusModem.HandleEnableSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-enable", callback: GdbusModem.HandleEnableSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-enable", argEnable: boolean, ...args: any[]): void
    connect(sigName: "handle-factory-reset", callback: GdbusModem.HandleFactoryResetSignalCallback): number
    on(sigName: "handle-factory-reset", callback: GdbusModem.HandleFactoryResetSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-factory-reset", callback: GdbusModem.HandleFactoryResetSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-factory-reset", callback: GdbusModem.HandleFactoryResetSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-factory-reset", argCode: string | null, ...args: any[]): void
    connect(sigName: "handle-get-cell-info", callback: GdbusModem.HandleGetCellInfoSignalCallback): number
    on(sigName: "handle-get-cell-info", callback: GdbusModem.HandleGetCellInfoSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-get-cell-info", callback: GdbusModem.HandleGetCellInfoSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-get-cell-info", callback: GdbusModem.HandleGetCellInfoSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-get-cell-info", ...args: any[]): void
    connect(sigName: "handle-list-bearers", callback: GdbusModem.HandleListBearersSignalCallback): number
    on(sigName: "handle-list-bearers", callback: GdbusModem.HandleListBearersSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-list-bearers", callback: GdbusModem.HandleListBearersSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-list-bearers", callback: GdbusModem.HandleListBearersSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-list-bearers", ...args: any[]): void
    connect(sigName: "handle-reset", callback: GdbusModem.HandleResetSignalCallback): number
    on(sigName: "handle-reset", callback: GdbusModem.HandleResetSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-reset", callback: GdbusModem.HandleResetSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-reset", callback: GdbusModem.HandleResetSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-reset", ...args: any[]): void
    connect(sigName: "handle-set-current-bands", callback: GdbusModem.HandleSetCurrentBandsSignalCallback): number
    on(sigName: "handle-set-current-bands", callback: GdbusModem.HandleSetCurrentBandsSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-current-bands", callback: GdbusModem.HandleSetCurrentBandsSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-current-bands", callback: GdbusModem.HandleSetCurrentBandsSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-current-bands", argBands: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-set-current-capabilities", callback: GdbusModem.HandleSetCurrentCapabilitiesSignalCallback): number
    on(sigName: "handle-set-current-capabilities", callback: GdbusModem.HandleSetCurrentCapabilitiesSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-current-capabilities", callback: GdbusModem.HandleSetCurrentCapabilitiesSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-current-capabilities", callback: GdbusModem.HandleSetCurrentCapabilitiesSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-current-capabilities", argCapabilities: number, ...args: any[]): void
    connect(sigName: "handle-set-current-modes", callback: GdbusModem.HandleSetCurrentModesSignalCallback): number
    on(sigName: "handle-set-current-modes", callback: GdbusModem.HandleSetCurrentModesSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-current-modes", callback: GdbusModem.HandleSetCurrentModesSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-current-modes", callback: GdbusModem.HandleSetCurrentModesSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-current-modes", argModes: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-set-power-state", callback: GdbusModem.HandleSetPowerStateSignalCallback): number
    on(sigName: "handle-set-power-state", callback: GdbusModem.HandleSetPowerStateSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-power-state", callback: GdbusModem.HandleSetPowerStateSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-power-state", callback: GdbusModem.HandleSetPowerStateSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-power-state", argState: number, ...args: any[]): void
    connect(sigName: "handle-set-primary-sim-slot", callback: GdbusModem.HandleSetPrimarySimSlotSignalCallback): number
    on(sigName: "handle-set-primary-sim-slot", callback: GdbusModem.HandleSetPrimarySimSlotSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-primary-sim-slot", callback: GdbusModem.HandleSetPrimarySimSlotSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-primary-sim-slot", callback: GdbusModem.HandleSetPrimarySimSlotSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-primary-sim-slot", argSimSlot: number, ...args: any[]): void
    connect(sigName: "state-changed", callback: GdbusModem.StateChangedSignalCallback): number
    on(sigName: "state-changed", callback: GdbusModem.StateChangedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "state-changed", callback: GdbusModem.StateChangedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "state-changed", callback: GdbusModem.StateChangedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "state-changed", argNew: number, argReason: number, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModem

    connect(sigName: "notify::access-technologies", callback: (...args: any[]) => void): number
    on(sigName: "notify::access-technologies", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::access-technologies", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::access-technologies", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::access-technologies", ...args: any[]): void
    connect(sigName: "notify::bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::bearers", ...args: any[]): void
    connect(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void): number
    on(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::carrier-configuration", ...args: any[]): void
    connect(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void): number
    on(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::carrier-configuration-revision", ...args: any[]): void
    connect(sigName: "notify::current-bands", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-bands", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-bands", ...args: any[]): void
    connect(sigName: "notify::current-capabilities", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-capabilities", ...args: any[]): void
    connect(sigName: "notify::current-modes", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-modes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-modes", ...args: any[]): void
    connect(sigName: "notify::device", callback: (...args: any[]) => void): number
    on(sigName: "notify::device", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::device", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::device", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::device", ...args: any[]): void
    connect(sigName: "notify::device-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::device-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::device-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::device-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::device-identifier", ...args: any[]): void
    connect(sigName: "notify::drivers", callback: (...args: any[]) => void): number
    on(sigName: "notify::drivers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::drivers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::drivers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::drivers", ...args: any[]): void
    connect(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::equipment-identifier", ...args: any[]): void
    connect(sigName: "notify::hardware-revision", callback: (...args: any[]) => void): number
    on(sigName: "notify::hardware-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::hardware-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::hardware-revision", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::hardware-revision", ...args: any[]): void
    connect(sigName: "notify::manufacturer", callback: (...args: any[]) => void): number
    on(sigName: "notify::manufacturer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::manufacturer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::manufacturer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::manufacturer", ...args: any[]): void
    connect(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::max-active-bearers", ...args: any[]): void
    connect(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::max-active-multiplexed-bearers", ...args: any[]): void
    connect(sigName: "notify::max-bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::max-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::max-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::max-bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::max-bearers", ...args: any[]): void
    connect(sigName: "notify::model", callback: (...args: any[]) => void): number
    on(sigName: "notify::model", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::model", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::model", ...args: any[]): void
    connect(sigName: "notify::own-numbers", callback: (...args: any[]) => void): number
    on(sigName: "notify::own-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::own-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::own-numbers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::own-numbers", ...args: any[]): void
    connect(sigName: "notify::plugin", callback: (...args: any[]) => void): number
    on(sigName: "notify::plugin", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::plugin", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::plugin", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::plugin", ...args: any[]): void
    connect(sigName: "notify::ports", callback: (...args: any[]) => void): number
    on(sigName: "notify::ports", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ports", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ports", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ports", ...args: any[]): void
    connect(sigName: "notify::power-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::power-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::power-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::power-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::power-state", ...args: any[]): void
    connect(sigName: "notify::primary-port", callback: (...args: any[]) => void): number
    on(sigName: "notify::primary-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::primary-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::primary-port", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::primary-port", ...args: any[]): void
    connect(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void): number
    on(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::primary-sim-slot", ...args: any[]): void
    connect(sigName: "notify::revision", callback: (...args: any[]) => void): number
    on(sigName: "notify::revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::revision", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::revision", ...args: any[]): void
    connect(sigName: "notify::signal-quality", callback: (...args: any[]) => void): number
    on(sigName: "notify::signal-quality", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::signal-quality", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::signal-quality", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::signal-quality", ...args: any[]): void
    connect(sigName: "notify::sim", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim", ...args: any[]): void
    connect(sigName: "notify::sim-slots", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim-slots", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim-slots", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim-slots", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim-slots", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void): number
    on(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state-failed-reason", ...args: any[]): void
    connect(sigName: "notify::supported-bands", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-bands", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-bands", ...args: any[]): void
    connect(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-capabilities", ...args: any[]): void
    connect(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-ip-families", ...args: any[]): void
    connect(sigName: "notify::supported-modes", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-modes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-modes", ...args: any[]): void
    connect(sigName: "notify::unlock-required", callback: (...args: any[]) => void): number
    on(sigName: "notify::unlock-required", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::unlock-required", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::unlock-required", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::unlock-required", ...args: any[]): void
    connect(sigName: "notify::unlock-retries", callback: (...args: any[]) => void): number
    on(sigName: "notify::unlock-retries", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::unlock-retries", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::unlock-retries", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::unlock-retries", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link>.
 * @interface 
 */
export class GdbusModem extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModem

    constructor(config?: GdbusModem.ConstructorProperties) 
    _init(config?: GdbusModem.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModem interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModem3gpp {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-disable-facility-lock`
     */
    export interface HandleDisableFacilityLockSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-register`
     */
    export interface HandleRegisterSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argOperatorId: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-scan`
     */
    export interface HandleScanSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-set-carrier-lock`
     */
    export interface HandleSetCarrierLockSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argData: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-set-eps-ue-mode-operation`
     */
    export interface HandleSetEpsUeModeOperationSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argMode: number): boolean
    }

    /**
     * Signal callback interface for `handle-set-initial-eps-bearer-settings`
     */
    export interface HandleSetInitialEpsBearerSettingsSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argSettings: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-set-nr5g-registration-settings`
     */
    export interface HandleSetNr5gRegistrationSettingsSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-set-packet-service-state`
     */
    export interface HandleSetPacketServiceStateSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argState: number): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModem3gpp

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.EnabledFacilityLocks">"EnabledFacilityLocks"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        enabledFacilityLocks?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.EpsUeModeOperation">"EpsUeModeOperation"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        epsUeModeOperation?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.Imei">"Imei"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        imei?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.InitialEpsBearer">"InitialEpsBearer"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        initialEpsBearer?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.InitialEpsBearerSettings">"InitialEpsBearerSettings"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        initialEpsBearerSettings?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.Nr5gRegistrationSettings">"Nr5gRegistrationSettings"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        nr5gRegistrationSettings?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.OperatorCode">"OperatorCode"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        operatorCode?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.OperatorName">"OperatorName"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        operatorName?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.PacketServiceState">"PacketServiceState"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        packetServiceState?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.Pco">"Pco"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        pco?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.RegistrationState">"RegistrationState"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        registrationState?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.SubscriptionState">"SubscriptionState"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        subscriptionState?: number | null
    }

}

export interface GdbusModem3gpp {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gpp

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.EnabledFacilityLocks">"EnabledFacilityLocks"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    enabledFacilityLocks: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.EpsUeModeOperation">"EpsUeModeOperation"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    epsUeModeOperation: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.Imei">"Imei"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    imei: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.InitialEpsBearer">"InitialEpsBearer"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    initialEpsBearer: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.InitialEpsBearerSettings">"InitialEpsBearerSettings"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    initialEpsBearerSettings: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.Nr5gRegistrationSettings">"Nr5gRegistrationSettings"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    nr5gRegistrationSettings: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.OperatorCode">"OperatorCode"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    operatorCode: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.OperatorName">"OperatorName"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    operatorName: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.PacketServiceState">"PacketServiceState"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    packetServiceState: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.Pco">"Pco"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    pco: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.RegistrationState">"RegistrationState"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    registrationState: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp.SubscriptionState">"SubscriptionState"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    subscriptionState: number
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModem3gpp

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.DisableFacilityLock">DisableFacilityLock()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_call_disable_facility_lock_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_call_disable_facility_lock_sync() for the synchronous, blocking version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callDisableFacilityLock(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_call_disable_facility_lock().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_call_disable_facility_lock().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDisableFacilityLockFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.DisableFacilityLock">DisableFacilityLock()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_call_disable_facility_lock() for the asynchronous version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDisableFacilityLockSync(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.Register">Register()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_call_register_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_call_register_sync() for the synchronous, blocking version of this method.
     * @param argOperatorId Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callRegister(argOperatorId: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_call_register().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_call_register().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callRegisterFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.Register">Register()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_call_register() for the asynchronous version of this method.
     * @param argOperatorId Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callRegisterSync(argOperatorId: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.Scan">Scan()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_call_scan_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_call_scan_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callScan(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_call_scan().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_call_scan().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callScanFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outResults */ GLib.Variant ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.Scan">Scan()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_call_scan() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callScanSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outResults */ GLib.Variant ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetCarrierLock">SetCarrierLock()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_call_set_carrier_lock_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_call_set_carrier_lock_sync() for the synchronous, blocking version of this method.
     * @param argData Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetCarrierLock(argData: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_call_set_carrier_lock().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_call_set_carrier_lock().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetCarrierLockFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetCarrierLock">SetCarrierLock()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_call_set_carrier_lock() for the asynchronous version of this method.
     * @param argData Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetCarrierLockSync(argData: GLib.Variant, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetEpsUeModeOperation">SetEpsUeModeOperation()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_call_set_eps_ue_mode_operation_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_call_set_eps_ue_mode_operation_sync() for the synchronous, blocking version of this method.
     * @param argMode Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetEpsUeModeOperation(argMode: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_call_set_eps_ue_mode_operation().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_call_set_eps_ue_mode_operation().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetEpsUeModeOperationFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetEpsUeModeOperation">SetEpsUeModeOperation()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_call_set_eps_ue_mode_operation() for the asynchronous version of this method.
     * @param argMode Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetEpsUeModeOperationSync(argMode: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetInitialEpsBearerSettings">SetInitialEpsBearerSettings()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_call_set_initial_eps_bearer_settings_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_call_set_initial_eps_bearer_settings_sync() for the synchronous, blocking version of this method.
     * @param argSettings Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetInitialEpsBearerSettings(argSettings: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_call_set_initial_eps_bearer_settings().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_call_set_initial_eps_bearer_settings().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetInitialEpsBearerSettingsFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetInitialEpsBearerSettings">SetInitialEpsBearerSettings()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_call_set_initial_eps_bearer_settings() for the asynchronous version of this method.
     * @param argSettings Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetInitialEpsBearerSettingsSync(argSettings: GLib.Variant, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetNr5gRegistrationSettings">SetNr5gRegistrationSettings()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_call_set_nr5g_registration_settings_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_call_set_nr5g_registration_settings_sync() for the synchronous, blocking version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetNr5gRegistrationSettings(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_call_set_nr5g_registration_settings().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_call_set_nr5g_registration_settings().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetNr5gRegistrationSettingsFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetNr5gRegistrationSettings">SetNr5gRegistrationSettings()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_call_set_nr5g_registration_settings() for the asynchronous version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetNr5gRegistrationSettingsSync(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetPacketServiceState">SetPacketServiceState()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_call_set_packet_service_state_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_call_set_packet_service_state_sync() for the synchronous, blocking version of this method.
     * @param argState Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetPacketServiceState(argState: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_call_set_packet_service_state().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_call_set_packet_service_state().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetPacketServiceStateFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetPacketServiceState">SetPacketServiceState()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_call_set_packet_service_state() for the asynchronous version of this method.
     * @param argState Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetPacketServiceStateSync(argState: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.DisableFacilityLock">DisableFacilityLock()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeDisableFacilityLock(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.Register">Register()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeRegister(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.Scan">Scan()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param results Parameter to return.
     */
    completeScan(invocation: Gio.DBusMethodInvocation, results: GLib.Variant): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetCarrierLock">SetCarrierLock()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetCarrierLock(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetEpsUeModeOperation">SetEpsUeModeOperation()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetEpsUeModeOperation(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetInitialEpsBearerSettings">SetInitialEpsBearerSettings()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetInitialEpsBearerSettings(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetNr5gRegistrationSettings">SetNr5gRegistrationSettings()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetNr5gRegistrationSettings(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp.SetPacketServiceState">SetPacketServiceState()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetPacketServiceState(invocation: Gio.DBusMethodInvocation): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModem3gpp

    handleDisableFacilityLock(invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    handleRegister(invocation: Gio.DBusMethodInvocation, argOperatorId: string | null): boolean
    handleScan(invocation: Gio.DBusMethodInvocation): boolean
    handleSetCarrierLock(invocation: Gio.DBusMethodInvocation, argData: GLib.Variant): boolean
    handleSetEpsUeModeOperation(invocation: Gio.DBusMethodInvocation, argMode: number): boolean
    handleSetInitialEpsBearerSettings(invocation: Gio.DBusMethodInvocation, argSettings: GLib.Variant): boolean
    handleSetNr5gRegistrationSettings(invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    handleSetPacketServiceState(invocation: Gio.DBusMethodInvocation, argState: number): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusModem3gpp

    connect(sigName: "handle-disable-facility-lock", callback: GdbusModem3gpp.HandleDisableFacilityLockSignalCallback): number
    on(sigName: "handle-disable-facility-lock", callback: GdbusModem3gpp.HandleDisableFacilityLockSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-disable-facility-lock", callback: GdbusModem3gpp.HandleDisableFacilityLockSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-disable-facility-lock", callback: GdbusModem3gpp.HandleDisableFacilityLockSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-disable-facility-lock", argProperties: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-register", callback: GdbusModem3gpp.HandleRegisterSignalCallback): number
    on(sigName: "handle-register", callback: GdbusModem3gpp.HandleRegisterSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-register", callback: GdbusModem3gpp.HandleRegisterSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-register", callback: GdbusModem3gpp.HandleRegisterSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-register", argOperatorId: string | null, ...args: any[]): void
    connect(sigName: "handle-scan", callback: GdbusModem3gpp.HandleScanSignalCallback): number
    on(sigName: "handle-scan", callback: GdbusModem3gpp.HandleScanSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-scan", callback: GdbusModem3gpp.HandleScanSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-scan", callback: GdbusModem3gpp.HandleScanSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-scan", ...args: any[]): void
    connect(sigName: "handle-set-carrier-lock", callback: GdbusModem3gpp.HandleSetCarrierLockSignalCallback): number
    on(sigName: "handle-set-carrier-lock", callback: GdbusModem3gpp.HandleSetCarrierLockSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-carrier-lock", callback: GdbusModem3gpp.HandleSetCarrierLockSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-carrier-lock", callback: GdbusModem3gpp.HandleSetCarrierLockSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-carrier-lock", argData: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-set-eps-ue-mode-operation", callback: GdbusModem3gpp.HandleSetEpsUeModeOperationSignalCallback): number
    on(sigName: "handle-set-eps-ue-mode-operation", callback: GdbusModem3gpp.HandleSetEpsUeModeOperationSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-eps-ue-mode-operation", callback: GdbusModem3gpp.HandleSetEpsUeModeOperationSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-eps-ue-mode-operation", callback: GdbusModem3gpp.HandleSetEpsUeModeOperationSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-eps-ue-mode-operation", argMode: number, ...args: any[]): void
    connect(sigName: "handle-set-initial-eps-bearer-settings", callback: GdbusModem3gpp.HandleSetInitialEpsBearerSettingsSignalCallback): number
    on(sigName: "handle-set-initial-eps-bearer-settings", callback: GdbusModem3gpp.HandleSetInitialEpsBearerSettingsSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-initial-eps-bearer-settings", callback: GdbusModem3gpp.HandleSetInitialEpsBearerSettingsSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-initial-eps-bearer-settings", callback: GdbusModem3gpp.HandleSetInitialEpsBearerSettingsSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-initial-eps-bearer-settings", argSettings: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-set-nr5g-registration-settings", callback: GdbusModem3gpp.HandleSetNr5gRegistrationSettingsSignalCallback): number
    on(sigName: "handle-set-nr5g-registration-settings", callback: GdbusModem3gpp.HandleSetNr5gRegistrationSettingsSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-nr5g-registration-settings", callback: GdbusModem3gpp.HandleSetNr5gRegistrationSettingsSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-nr5g-registration-settings", callback: GdbusModem3gpp.HandleSetNr5gRegistrationSettingsSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-nr5g-registration-settings", argProperties: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-set-packet-service-state", callback: GdbusModem3gpp.HandleSetPacketServiceStateSignalCallback): number
    on(sigName: "handle-set-packet-service-state", callback: GdbusModem3gpp.HandleSetPacketServiceStateSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-packet-service-state", callback: GdbusModem3gpp.HandleSetPacketServiceStateSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-packet-service-state", callback: GdbusModem3gpp.HandleSetPacketServiceStateSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-packet-service-state", argState: number, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModem3gpp

    connect(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void): number
    on(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::enabled-facility-locks", ...args: any[]): void
    connect(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void): number
    on(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::eps-ue-mode-operation", ...args: any[]): void
    connect(sigName: "notify::imei", callback: (...args: any[]) => void): number
    on(sigName: "notify::imei", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::imei", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::imei", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::imei", ...args: any[]): void
    connect(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void): number
    on(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::initial-eps-bearer", ...args: any[]): void
    connect(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void): number
    on(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::initial-eps-bearer-settings", ...args: any[]): void
    connect(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void): number
    on(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::nr5g-registration-settings", ...args: any[]): void
    connect(sigName: "notify::operator-code", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-code", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-code", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-code", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-code", ...args: any[]): void
    connect(sigName: "notify::operator-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-name", ...args: any[]): void
    connect(sigName: "notify::packet-service-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::packet-service-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::packet-service-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::packet-service-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::packet-service-state", ...args: any[]): void
    connect(sigName: "notify::pco", callback: (...args: any[]) => void): number
    on(sigName: "notify::pco", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::pco", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::pco", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::pco", ...args: any[]): void
    connect(sigName: "notify::registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::registration-state", ...args: any[]): void
    connect(sigName: "notify::subscription-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::subscription-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::subscription-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::subscription-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::subscription-state", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link>.
 * @interface 
 */
export class GdbusModem3gpp extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gpp

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModem3gpp

    constructor(config?: GdbusModem3gpp.ConstructorProperties) 
    _init(config?: GdbusModem3gpp.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModem3gpp interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModem3gppProfileManager {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-delete`
     */
    export interface HandleDeleteSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-list`
     */
    export interface HandleListSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-set`
     */
    export interface HandleSetSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argRequestedProperties: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `updated`
     */
    export interface UpdatedSignalCallback {
        (): void
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManager

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.IndexField">"IndexField"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        indexField?: string | null
    }

}

export interface GdbusModem3gppProfileManager {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManager

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.IndexField">"IndexField"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    indexField: string | null
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManager

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.Delete">Delete()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_profile_manager_call_delete_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_profile_manager_call_delete_sync() for the synchronous, blocking version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callDelete(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_profile_manager_call_delete().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_profile_manager_call_delete().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDeleteFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.Delete">Delete()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_profile_manager_call_delete() for the asynchronous version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDeleteSync(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.List">List()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_profile_manager_call_list_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_profile_manager_call_list_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callList(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_profile_manager_call_list().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_profile_manager_call_list().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callListFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outProfiles */ GLib.Variant ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.List">List()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_profile_manager_call_list() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callListSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outProfiles */ GLib.Variant ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.Set">Set()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_profile_manager_call_set_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_profile_manager_call_set_sync() for the synchronous, blocking version of this method.
     * @param argRequestedProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSet(argRequestedProperties: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_profile_manager_call_set().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_profile_manager_call_set().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outStoredProperties */ GLib.Variant ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.Set">Set()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_profile_manager_call_set() for the asynchronous version of this method.
     * @param argRequestedProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetSync(argRequestedProperties: GLib.Variant, cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outStoredProperties */ GLib.Variant ]
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.Delete">Delete()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeDelete(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.List">List()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param profiles Parameter to return.
     */
    completeList(invocation: Gio.DBusMethodInvocation, profiles: GLib.Variant): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.Set">Set()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param storedProperties Parameter to return.
     */
    completeSet(invocation: Gio.DBusMethodInvocation, storedProperties: GLib.Variant): void
    /**
     * Emits the <link linkend="gdbus-signal-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.Updated">"Updated"</link> D-Bus signal.
     */
    emitUpdated(): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManager

    handleDelete(invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    handleList(invocation: Gio.DBusMethodInvocation): boolean
    handleSet(invocation: Gio.DBusMethodInvocation, argRequestedProperties: GLib.Variant): boolean
    updated(): void

    // Own signals of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManager

    connect(sigName: "handle-delete", callback: GdbusModem3gppProfileManager.HandleDeleteSignalCallback): number
    on(sigName: "handle-delete", callback: GdbusModem3gppProfileManager.HandleDeleteSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-delete", callback: GdbusModem3gppProfileManager.HandleDeleteSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-delete", callback: GdbusModem3gppProfileManager.HandleDeleteSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-delete", argProperties: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-list", callback: GdbusModem3gppProfileManager.HandleListSignalCallback): number
    on(sigName: "handle-list", callback: GdbusModem3gppProfileManager.HandleListSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-list", callback: GdbusModem3gppProfileManager.HandleListSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-list", callback: GdbusModem3gppProfileManager.HandleListSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-list", ...args: any[]): void
    connect(sigName: "handle-set", callback: GdbusModem3gppProfileManager.HandleSetSignalCallback): number
    on(sigName: "handle-set", callback: GdbusModem3gppProfileManager.HandleSetSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set", callback: GdbusModem3gppProfileManager.HandleSetSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set", callback: GdbusModem3gppProfileManager.HandleSetSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set", argRequestedProperties: GLib.Variant, ...args: any[]): void
    connect(sigName: "updated", callback: GdbusModem3gppProfileManager.UpdatedSignalCallback): number
    on(sigName: "updated", callback: GdbusModem3gppProfileManager.UpdatedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "updated", callback: GdbusModem3gppProfileManager.UpdatedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "updated", callback: GdbusModem3gppProfileManager.UpdatedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "updated", ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManager

    connect(sigName: "notify::index-field", callback: (...args: any[]) => void): number
    on(sigName: "notify::index-field", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::index-field", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::index-field", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::index-field", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link>.
 * @interface 
 */
export class GdbusModem3gppProfileManager extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManager

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManager

    constructor(config?: GdbusModem3gppProfileManager.ConstructorProperties) 
    _init(config?: GdbusModem3gppProfileManager.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModem3gppProfileManager interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModem3gppUssd {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-cancel`
     */
    export interface HandleCancelSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-initiate`
     */
    export interface HandleInitiateSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argCommand: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-respond`
     */
    export interface HandleRespondSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argResponse: string | null): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModem3gppUssd

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.NetworkNotification">"NetworkNotification"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        networkNotification?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.NetworkRequest">"NetworkRequest"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        networkRequest?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.State">"State"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        state?: number | null
    }

}

export interface GdbusModem3gppUssd {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppUssd

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.NetworkNotification">"NetworkNotification"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    networkNotification: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.NetworkRequest">"NetworkRequest"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    networkRequest: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.State">"State"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    state: number
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModem3gppUssd

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.Cancel">Cancel()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_ussd_call_cancel_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_ussd_call_cancel_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callCancel(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_ussd_call_cancel().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_ussd_call_cancel().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCancelFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.Cancel">Cancel()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_ussd_call_cancel() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCancelSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.Initiate">Initiate()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_ussd_call_initiate_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_ussd_call_initiate_sync() for the synchronous, blocking version of this method.
     * @param argCommand Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callInitiate(argCommand: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_ussd_call_initiate().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_ussd_call_initiate().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callInitiateFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outReply */ string | null ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.Initiate">Initiate()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_ussd_call_initiate() for the asynchronous version of this method.
     * @param argCommand Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callInitiateSync(argCommand: string | null, cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outReply */ string | null ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.Respond">Respond()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_ussd_call_respond_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_ussd_call_respond_sync() for the synchronous, blocking version of this method.
     * @param argResponse Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callRespond(argResponse: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_ussd_call_respond().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_ussd_call_respond().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callRespondFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outReply */ string | null ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.Respond">Respond()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_ussd_call_respond() for the asynchronous version of this method.
     * @param argResponse Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callRespondSync(argResponse: string | null, cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outReply */ string | null ]
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.Cancel">Cancel()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeCancel(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.Initiate">Initiate()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param reply Parameter to return.
     */
    completeInitiate(invocation: Gio.DBusMethodInvocation, reply: string | null): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.Respond">Respond()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param reply Parameter to return.
     */
    completeRespond(invocation: Gio.DBusMethodInvocation, reply: string | null): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModem3gppUssd

    handleCancel(invocation: Gio.DBusMethodInvocation): boolean
    handleInitiate(invocation: Gio.DBusMethodInvocation, argCommand: string | null): boolean
    handleRespond(invocation: Gio.DBusMethodInvocation, argResponse: string | null): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusModem3gppUssd

    connect(sigName: "handle-cancel", callback: GdbusModem3gppUssd.HandleCancelSignalCallback): number
    on(sigName: "handle-cancel", callback: GdbusModem3gppUssd.HandleCancelSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-cancel", callback: GdbusModem3gppUssd.HandleCancelSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-cancel", callback: GdbusModem3gppUssd.HandleCancelSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-cancel", ...args: any[]): void
    connect(sigName: "handle-initiate", callback: GdbusModem3gppUssd.HandleInitiateSignalCallback): number
    on(sigName: "handle-initiate", callback: GdbusModem3gppUssd.HandleInitiateSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-initiate", callback: GdbusModem3gppUssd.HandleInitiateSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-initiate", callback: GdbusModem3gppUssd.HandleInitiateSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-initiate", argCommand: string | null, ...args: any[]): void
    connect(sigName: "handle-respond", callback: GdbusModem3gppUssd.HandleRespondSignalCallback): number
    on(sigName: "handle-respond", callback: GdbusModem3gppUssd.HandleRespondSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-respond", callback: GdbusModem3gppUssd.HandleRespondSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-respond", callback: GdbusModem3gppUssd.HandleRespondSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-respond", argResponse: string | null, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModem3gppUssd

    connect(sigName: "notify::network-notification", callback: (...args: any[]) => void): number
    on(sigName: "notify::network-notification", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::network-notification", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::network-notification", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::network-notification", ...args: any[]): void
    connect(sigName: "notify::network-request", callback: (...args: any[]) => void): number
    on(sigName: "notify::network-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::network-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::network-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::network-request", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link>.
 * @interface 
 */
export class GdbusModem3gppUssd extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppUssd

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModem3gppUssd

    constructor(config?: GdbusModem3gppUssd.ConstructorProperties) 
    _init(config?: GdbusModem3gppUssd.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModem3gppUssd interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModemCdma {

    // Signal callback interfaces

    /**
     * Signal callback interface for `activation-state-changed`
     */
    export interface ActivationStateChangedSignalCallback {
        (argActivationState: number, argActivationError: number, argStatusChanges: GLib.Variant): void
    }

    /**
     * Signal callback interface for `handle-activate`
     */
    export interface HandleActivateSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argCarrierCode: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-activate-manual`
     */
    export interface HandleActivateManualSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModemCdma

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.ActivationState">"ActivationState"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        activationState?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.Cdma1xRegistrationState">"Cdma1xRegistrationState"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        cdma1xRegistrationState?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.Esn">"Esn"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        esn?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.EvdoRegistrationState">"EvdoRegistrationState"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        evdoRegistrationState?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.Meid">"Meid"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        meid?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.Nid">"Nid"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        nid?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.Sid">"Sid"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        sid?: number | null
    }

}

export interface GdbusModemCdma {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemCdma

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.ActivationState">"ActivationState"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    activationState: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.Cdma1xRegistrationState">"Cdma1xRegistrationState"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    cdma1xRegistrationState: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.Esn">"Esn"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    esn: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.EvdoRegistrationState">"EvdoRegistrationState"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    evdoRegistrationState: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.Meid">"Meid"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    meid: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.Nid">"Nid"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    nid: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-ModemCdma.Sid">"Sid"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    sid: number
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModemCdma

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-ModemCdma.Activate">Activate()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_cdma_call_activate_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_cdma_call_activate_sync() for the synchronous, blocking version of this method.
     * @param argCarrierCode Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callActivate(argCarrierCode: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_cdma_call_activate().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_cdma_call_activate().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callActivateFinish(res: Gio.AsyncResult): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-ModemCdma.ActivateManual">ActivateManual()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_cdma_call_activate_manual_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_cdma_call_activate_manual_sync() for the synchronous, blocking version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callActivateManual(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_cdma_call_activate_manual().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_cdma_call_activate_manual().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callActivateManualFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-ModemCdma.ActivateManual">ActivateManual()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_cdma_call_activate_manual() for the asynchronous version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callActivateManualSync(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-ModemCdma.Activate">Activate()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_cdma_call_activate() for the asynchronous version of this method.
     * @param argCarrierCode Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callActivateSync(argCarrierCode: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-ModemCdma.Activate">Activate()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeActivate(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-ModemCdma.ActivateManual">ActivateManual()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeActivateManual(invocation: Gio.DBusMethodInvocation): void
    /**
     * Emits the <link linkend="gdbus-signal-org-freedesktop-ModemManager1-Modem-ModemCdma.ActivationStateChanged">"ActivationStateChanged"</link> D-Bus signal.
     * @param argActivationState Argument to pass with the signal.
     * @param argActivationError Argument to pass with the signal.
     * @param argStatusChanges Argument to pass with the signal.
     */
    emitActivationStateChanged(argActivationState: number, argActivationError: number, argStatusChanges: GLib.Variant): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModemCdma

    activationStateChanged(argActivationState: number, argActivationError: number, argStatusChanges: GLib.Variant): void
    handleActivate(invocation: Gio.DBusMethodInvocation, argCarrierCode: string | null): boolean
    handleActivateManual(invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusModemCdma

    connect(sigName: "activation-state-changed", callback: GdbusModemCdma.ActivationStateChangedSignalCallback): number
    on(sigName: "activation-state-changed", callback: GdbusModemCdma.ActivationStateChangedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "activation-state-changed", callback: GdbusModemCdma.ActivationStateChangedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "activation-state-changed", callback: GdbusModemCdma.ActivationStateChangedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "activation-state-changed", argActivationError: number, argStatusChanges: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-activate", callback: GdbusModemCdma.HandleActivateSignalCallback): number
    on(sigName: "handle-activate", callback: GdbusModemCdma.HandleActivateSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-activate", callback: GdbusModemCdma.HandleActivateSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-activate", callback: GdbusModemCdma.HandleActivateSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-activate", argCarrierCode: string | null, ...args: any[]): void
    connect(sigName: "handle-activate-manual", callback: GdbusModemCdma.HandleActivateManualSignalCallback): number
    on(sigName: "handle-activate-manual", callback: GdbusModemCdma.HandleActivateManualSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-activate-manual", callback: GdbusModemCdma.HandleActivateManualSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-activate-manual", callback: GdbusModemCdma.HandleActivateManualSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-activate-manual", argProperties: GLib.Variant, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemCdma

    connect(sigName: "notify::activation-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::activation-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::activation-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::activation-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::activation-state", ...args: any[]): void
    connect(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cdma1x-registration-state", ...args: any[]): void
    connect(sigName: "notify::esn", callback: (...args: any[]) => void): number
    on(sigName: "notify::esn", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::esn", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::esn", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::esn", ...args: any[]): void
    connect(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::evdo-registration-state", ...args: any[]): void
    connect(sigName: "notify::meid", callback: (...args: any[]) => void): number
    on(sigName: "notify::meid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::meid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::meid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::meid", ...args: any[]): void
    connect(sigName: "notify::nid", callback: (...args: any[]) => void): number
    on(sigName: "notify::nid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::nid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::nid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::nid", ...args: any[]): void
    connect(sigName: "notify::sid", callback: (...args: any[]) => void): number
    on(sigName: "notify::sid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sid", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link>.
 * @interface 
 */
export class GdbusModemCdma extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemCdma

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemCdma

    constructor(config?: GdbusModemCdma.ConstructorProperties) 
    _init(config?: GdbusModemCdma.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModemCdma interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModemFirmware {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-list`
     */
    export interface HandleListSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-select`
     */
    export interface HandleSelectSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argUniqueid: string | null): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModemFirmware

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Firmware.UpdateSettings">"UpdateSettings"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        updateSettings?: GLib.Variant | null
    }

}

export interface GdbusModemFirmware {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemFirmware

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Firmware.UpdateSettings">"UpdateSettings"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    updateSettings: GLib.Variant
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModemFirmware

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Firmware.List">List()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_firmware_call_list_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_firmware_call_list_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callList(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_firmware_call_list().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_firmware_call_list().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callListFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outSelected */ string | null, /* outInstalled */ GLib.Variant ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Firmware.List">List()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_firmware_call_list() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callListSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outSelected */ string | null, /* outInstalled */ GLib.Variant ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Firmware.Select">Select()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_firmware_call_select_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_firmware_call_select_sync() for the synchronous, blocking version of this method.
     * @param argUniqueid Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSelect(argUniqueid: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_firmware_call_select().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_firmware_call_select().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSelectFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Firmware.Select">Select()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_firmware_call_select() for the asynchronous version of this method.
     * @param argUniqueid Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSelectSync(argUniqueid: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Firmware.List">List()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param selected Parameter to return.
     * @param installed Parameter to return.
     */
    completeList(invocation: Gio.DBusMethodInvocation, selected: string | null, installed: GLib.Variant): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Firmware.Select">Select()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSelect(invocation: Gio.DBusMethodInvocation): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModemFirmware

    handleList(invocation: Gio.DBusMethodInvocation): boolean
    handleSelect(invocation: Gio.DBusMethodInvocation, argUniqueid: string | null): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusModemFirmware

    connect(sigName: "handle-list", callback: GdbusModemFirmware.HandleListSignalCallback): number
    on(sigName: "handle-list", callback: GdbusModemFirmware.HandleListSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-list", callback: GdbusModemFirmware.HandleListSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-list", callback: GdbusModemFirmware.HandleListSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-list", ...args: any[]): void
    connect(sigName: "handle-select", callback: GdbusModemFirmware.HandleSelectSignalCallback): number
    on(sigName: "handle-select", callback: GdbusModemFirmware.HandleSelectSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-select", callback: GdbusModemFirmware.HandleSelectSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-select", callback: GdbusModemFirmware.HandleSelectSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-select", argUniqueid: string | null, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemFirmware

    connect(sigName: "notify::update-settings", callback: (...args: any[]) => void): number
    on(sigName: "notify::update-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::update-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::update-settings", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::update-settings", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link>.
 * @interface 
 */
export class GdbusModemFirmware extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemFirmware

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemFirmware

    constructor(config?: GdbusModemFirmware.ConstructorProperties) 
    _init(config?: GdbusModemFirmware.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModemFirmware interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModemLocation {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-get-location`
     */
    export interface HandleGetLocationSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-inject-assistance-data`
     */
    export interface HandleInjectAssistanceDataSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argData: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-set-gps-refresh-rate`
     */
    export interface HandleSetGpsRefreshRateSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argRate: number): boolean
    }

    /**
     * Signal callback interface for `handle-set-supl-server`
     */
    export interface HandleSetSuplServerSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argSupl: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-setup`
     */
    export interface HandleSetupSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argSources: number, argSignalLocation: boolean): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModemLocation

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.AssistanceDataServers">"AssistanceDataServers"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        assistanceDataServers?: string[] | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.Capabilities">"Capabilities"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        capabilities?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.Enabled">"Enabled"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        enabled?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.GpsRefreshRate">"GpsRefreshRate"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        gpsRefreshRate?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.Location">"Location"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        location?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.SignalsLocation">"SignalsLocation"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        signalsLocation?: boolean | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.SuplServer">"SuplServer"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        suplServer?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.SupportedAssistanceData">"SupportedAssistanceData"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        supportedAssistanceData?: number | null
    }

}

export interface GdbusModemLocation {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemLocation

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.AssistanceDataServers">"AssistanceDataServers"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    assistanceDataServers: string[]
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.Capabilities">"Capabilities"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    capabilities: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.Enabled">"Enabled"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    enabled: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.GpsRefreshRate">"GpsRefreshRate"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    gpsRefreshRate: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.Location">"Location"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    location: GLib.Variant
    // Has conflict: signalsLocation: boolean
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.SuplServer">"SuplServer"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    suplServer: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Location.SupportedAssistanceData">"SupportedAssistanceData"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    supportedAssistanceData: number
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModemLocation

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.GetLocation">GetLocation()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_location_call_get_location_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_location_call_get_location_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callGetLocation(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_location_call_get_location().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_location_call_get_location().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callGetLocationFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outLocation */ GLib.Variant ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.GetLocation">GetLocation()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_location_call_get_location() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callGetLocationSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outLocation */ GLib.Variant ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.InjectAssistanceData">InjectAssistanceData()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_location_call_inject_assistance_data_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_location_call_inject_assistance_data_sync() for the synchronous, blocking version of this method.
     * @param argData Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callInjectAssistanceData(argData: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_location_call_inject_assistance_data().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_location_call_inject_assistance_data().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callInjectAssistanceDataFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.InjectAssistanceData">InjectAssistanceData()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_location_call_inject_assistance_data() for the asynchronous version of this method.
     * @param argData Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callInjectAssistanceDataSync(argData: GLib.Variant, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.SetGpsRefreshRate">SetGpsRefreshRate()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_location_call_set_gps_refresh_rate_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_location_call_set_gps_refresh_rate_sync() for the synchronous, blocking version of this method.
     * @param argRate Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetGpsRefreshRate(argRate: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_location_call_set_gps_refresh_rate().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_location_call_set_gps_refresh_rate().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetGpsRefreshRateFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.SetGpsRefreshRate">SetGpsRefreshRate()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_location_call_set_gps_refresh_rate() for the asynchronous version of this method.
     * @param argRate Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetGpsRefreshRateSync(argRate: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.SetSuplServer">SetSuplServer()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_location_call_set_supl_server_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_location_call_set_supl_server_sync() for the synchronous, blocking version of this method.
     * @param argSupl Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetSuplServer(argSupl: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_location_call_set_supl_server().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_location_call_set_supl_server().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetSuplServerFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.SetSuplServer">SetSuplServer()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_location_call_set_supl_server() for the asynchronous version of this method.
     * @param argSupl Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetSuplServerSync(argSupl: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.Setup">Setup()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_location_call_setup_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_location_call_setup_sync() for the synchronous, blocking version of this method.
     * @param argSources Argument to pass with the method invocation.
     * @param argSignalLocation Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetup(argSources: number, argSignalLocation: boolean, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_location_call_setup().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_location_call_setup().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetupFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.Setup">Setup()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_location_call_setup() for the asynchronous version of this method.
     * @param argSources Argument to pass with the method invocation.
     * @param argSignalLocation Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetupSync(argSources: number, argSignalLocation: boolean, cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.GetLocation">GetLocation()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param location Parameter to return.
     */
    completeGetLocation(invocation: Gio.DBusMethodInvocation, location: GLib.Variant): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.InjectAssistanceData">InjectAssistanceData()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeInjectAssistanceData(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.SetGpsRefreshRate">SetGpsRefreshRate()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetGpsRefreshRate(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.SetSuplServer">SetSuplServer()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetSuplServer(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Location.Setup">Setup()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetup(invocation: Gio.DBusMethodInvocation): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModemLocation

    handleGetLocation(invocation: Gio.DBusMethodInvocation): boolean
    handleInjectAssistanceData(invocation: Gio.DBusMethodInvocation, argData: GLib.Variant): boolean
    handleSetGpsRefreshRate(invocation: Gio.DBusMethodInvocation, argRate: number): boolean
    handleSetSuplServer(invocation: Gio.DBusMethodInvocation, argSupl: string | null): boolean
    handleSetup(invocation: Gio.DBusMethodInvocation, argSources: number, argSignalLocation: boolean): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusModemLocation

    connect(sigName: "handle-get-location", callback: GdbusModemLocation.HandleGetLocationSignalCallback): number
    on(sigName: "handle-get-location", callback: GdbusModemLocation.HandleGetLocationSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-get-location", callback: GdbusModemLocation.HandleGetLocationSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-get-location", callback: GdbusModemLocation.HandleGetLocationSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-get-location", ...args: any[]): void
    connect(sigName: "handle-inject-assistance-data", callback: GdbusModemLocation.HandleInjectAssistanceDataSignalCallback): number
    on(sigName: "handle-inject-assistance-data", callback: GdbusModemLocation.HandleInjectAssistanceDataSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-inject-assistance-data", callback: GdbusModemLocation.HandleInjectAssistanceDataSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-inject-assistance-data", callback: GdbusModemLocation.HandleInjectAssistanceDataSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-inject-assistance-data", argData: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-set-gps-refresh-rate", callback: GdbusModemLocation.HandleSetGpsRefreshRateSignalCallback): number
    on(sigName: "handle-set-gps-refresh-rate", callback: GdbusModemLocation.HandleSetGpsRefreshRateSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-gps-refresh-rate", callback: GdbusModemLocation.HandleSetGpsRefreshRateSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-gps-refresh-rate", callback: GdbusModemLocation.HandleSetGpsRefreshRateSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-gps-refresh-rate", argRate: number, ...args: any[]): void
    connect(sigName: "handle-set-supl-server", callback: GdbusModemLocation.HandleSetSuplServerSignalCallback): number
    on(sigName: "handle-set-supl-server", callback: GdbusModemLocation.HandleSetSuplServerSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-supl-server", callback: GdbusModemLocation.HandleSetSuplServerSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-supl-server", callback: GdbusModemLocation.HandleSetSuplServerSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-supl-server", argSupl: string | null, ...args: any[]): void
    connect(sigName: "handle-setup", callback: GdbusModemLocation.HandleSetupSignalCallback): number
    on(sigName: "handle-setup", callback: GdbusModemLocation.HandleSetupSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-setup", callback: GdbusModemLocation.HandleSetupSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-setup", callback: GdbusModemLocation.HandleSetupSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-setup", argSources: number, argSignalLocation: boolean, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemLocation

    connect(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void): number
    on(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::assistance-data-servers", ...args: any[]): void
    connect(sigName: "notify::capabilities", callback: (...args: any[]) => void): number
    on(sigName: "notify::capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::capabilities", ...args: any[]): void
    connect(sigName: "notify::enabled", callback: (...args: any[]) => void): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::enabled", ...args: any[]): void
    connect(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void): number
    on(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gps-refresh-rate", ...args: any[]): void
    connect(sigName: "notify::location", callback: (...args: any[]) => void): number
    on(sigName: "notify::location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::location", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::location", ...args: any[]): void
    connect(sigName: "notify::signals-location", callback: (...args: any[]) => void): number
    on(sigName: "notify::signals-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::signals-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::signals-location", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::signals-location", ...args: any[]): void
    connect(sigName: "notify::supl-server", callback: (...args: any[]) => void): number
    on(sigName: "notify::supl-server", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supl-server", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supl-server", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supl-server", ...args: any[]): void
    connect(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-assistance-data", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link>.
 * @interface 
 */
export class GdbusModemLocation extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemLocation

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemLocation

    constructor(config?: GdbusModemLocation.ConstructorProperties) 
    _init(config?: GdbusModemLocation.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModemLocation interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModemMessaging {

    // Signal callback interfaces

    /**
     * Signal callback interface for `added`
     */
    export interface AddedSignalCallback {
        (argPath: string | null, argReceived: boolean): void
    }

    /**
     * Signal callback interface for `deleted`
     */
    export interface DeletedSignalCallback {
        (argPath: string | null): void
    }

    /**
     * Signal callback interface for `handle-create`
     */
    export interface HandleCreateSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-delete`
     */
    export interface HandleDeleteSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argPath: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-list`
     */
    export interface HandleListSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModemMessaging

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Messaging.DefaultStorage">"DefaultStorage"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        defaultStorage?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Messaging.Messages">"Messages"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        messages?: string[] | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Messaging.SupportedStorages">"SupportedStorages"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        supportedStorages?: GLib.Variant | null
    }

}

export interface GdbusModemMessaging {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemMessaging

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Messaging.DefaultStorage">"DefaultStorage"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    defaultStorage: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Messaging.Messages">"Messages"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    messages: string[]
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Messaging.SupportedStorages">"SupportedStorages"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    supportedStorages: GLib.Variant
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModemMessaging

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Messaging.Create">Create()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_messaging_call_create_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_messaging_call_create_sync() for the synchronous, blocking version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callCreate(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_messaging_call_create().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_messaging_call_create().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCreateFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outPath */ string | null ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Messaging.Create">Create()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_messaging_call_create() for the asynchronous version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCreateSync(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outPath */ string | null ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Messaging.Delete">Delete()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_messaging_call_delete_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_messaging_call_delete_sync() for the synchronous, blocking version of this method.
     * @param argPath Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callDelete(argPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_messaging_call_delete().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_messaging_call_delete().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDeleteFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Messaging.Delete">Delete()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_messaging_call_delete() for the asynchronous version of this method.
     * @param argPath Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDeleteSync(argPath: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Messaging.List">List()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_messaging_call_list_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_messaging_call_list_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callList(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_messaging_call_list().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_messaging_call_list().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callListFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outResult */ string[] ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Messaging.List">List()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_messaging_call_list() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callListSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outResult */ string[] ]
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Messaging.Create">Create()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param path Parameter to return.
     */
    completeCreate(invocation: Gio.DBusMethodInvocation, path: string | null): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Messaging.Delete">Delete()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeDelete(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Messaging.List">List()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param result Parameter to return.
     */
    completeList(invocation: Gio.DBusMethodInvocation, result: string | null): void
    /**
     * Emits the <link linkend="gdbus-signal-org-freedesktop-ModemManager1-Modem-Messaging.Added">"Added"</link> D-Bus signal.
     * @param argPath Argument to pass with the signal.
     * @param argReceived Argument to pass with the signal.
     */
    emitAdded(argPath: string | null, argReceived: boolean): void
    /**
     * Emits the <link linkend="gdbus-signal-org-freedesktop-ModemManager1-Modem-Messaging.Deleted">"Deleted"</link> D-Bus signal.
     * @param argPath Argument to pass with the signal.
     */
    emitDeleted(argPath: string | null): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModemMessaging

    added(argPath: string | null, argReceived: boolean): void
    deleted(argPath: string | null): void
    handleCreate(invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    handleDelete(invocation: Gio.DBusMethodInvocation, argPath: string | null): boolean
    handleList(invocation: Gio.DBusMethodInvocation): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusModemMessaging

    connect(sigName: "added", callback: GdbusModemMessaging.AddedSignalCallback): number
    on(sigName: "added", callback: GdbusModemMessaging.AddedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "added", callback: GdbusModemMessaging.AddedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "added", callback: GdbusModemMessaging.AddedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "added", argReceived: boolean, ...args: any[]): void
    connect(sigName: "deleted", callback: GdbusModemMessaging.DeletedSignalCallback): number
    on(sigName: "deleted", callback: GdbusModemMessaging.DeletedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "deleted", callback: GdbusModemMessaging.DeletedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "deleted", callback: GdbusModemMessaging.DeletedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "deleted", ...args: any[]): void
    connect(sigName: "handle-create", callback: GdbusModemMessaging.HandleCreateSignalCallback): number
    on(sigName: "handle-create", callback: GdbusModemMessaging.HandleCreateSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-create", callback: GdbusModemMessaging.HandleCreateSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-create", callback: GdbusModemMessaging.HandleCreateSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-create", argProperties: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-delete", callback: GdbusModemMessaging.HandleDeleteSignalCallback): number
    on(sigName: "handle-delete", callback: GdbusModemMessaging.HandleDeleteSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-delete", callback: GdbusModemMessaging.HandleDeleteSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-delete", callback: GdbusModemMessaging.HandleDeleteSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-delete", argPath: string | null, ...args: any[]): void
    connect(sigName: "handle-list", callback: GdbusModemMessaging.HandleListSignalCallback): number
    on(sigName: "handle-list", callback: GdbusModemMessaging.HandleListSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-list", callback: GdbusModemMessaging.HandleListSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-list", callback: GdbusModemMessaging.HandleListSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-list", ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemMessaging

    connect(sigName: "notify::default-storage", callback: (...args: any[]) => void): number
    on(sigName: "notify::default-storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::default-storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::default-storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::default-storage", ...args: any[]): void
    connect(sigName: "notify::messages", callback: (...args: any[]) => void): number
    on(sigName: "notify::messages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::messages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::messages", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::messages", ...args: any[]): void
    connect(sigName: "notify::supported-storages", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-storages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-storages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-storages", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-storages", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link>.
 * @interface 
 */
export class GdbusModemMessaging extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemMessaging

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemMessaging

    constructor(config?: GdbusModemMessaging.ConstructorProperties) 
    _init(config?: GdbusModemMessaging.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModemMessaging interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModemOma {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-accept-network-initiated-session`
     */
    export interface HandleAcceptNetworkInitiatedSessionSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argSessionId: number, argAccept: boolean): boolean
    }

    /**
     * Signal callback interface for `handle-cancel-session`
     */
    export interface HandleCancelSessionSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-setup`
     */
    export interface HandleSetupSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argFeatures: number): boolean
    }

    /**
     * Signal callback interface for `handle-start-client-initiated-session`
     */
    export interface HandleStartClientInitiatedSessionSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argSessionType: number): boolean
    }

    /**
     * Signal callback interface for `session-state-changed`
     */
    export interface SessionStateChangedSignalCallback {
        (argOldSessionState: number, argNewSessionState: number, argSessionStateFailedReason: number): void
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModemOma

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Oma.Features">"Features"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        features?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Oma.PendingNetworkInitiatedSessions">"PendingNetworkInitiatedSessions"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        pendingNetworkInitiatedSessions?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Oma.SessionState">"SessionState"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        sessionState?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Oma.SessionType">"SessionType"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        sessionType?: number | null
    }

}

export interface GdbusModemOma {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemOma

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Oma.Features">"Features"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    features: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Oma.PendingNetworkInitiatedSessions">"PendingNetworkInitiatedSessions"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    pendingNetworkInitiatedSessions: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Oma.SessionState">"SessionState"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    sessionState: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Oma.SessionType">"SessionType"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    sessionType: number
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModemOma

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Oma.AcceptNetworkInitiatedSession">AcceptNetworkInitiatedSession()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_oma_call_accept_network_initiated_session_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_oma_call_accept_network_initiated_session_sync() for the synchronous, blocking version of this method.
     * @param argSessionId Argument to pass with the method invocation.
     * @param argAccept Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callAcceptNetworkInitiatedSession(argSessionId: number, argAccept: boolean, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_oma_call_accept_network_initiated_session().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_oma_call_accept_network_initiated_session().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callAcceptNetworkInitiatedSessionFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Oma.AcceptNetworkInitiatedSession">AcceptNetworkInitiatedSession()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_oma_call_accept_network_initiated_session() for the asynchronous version of this method.
     * @param argSessionId Argument to pass with the method invocation.
     * @param argAccept Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callAcceptNetworkInitiatedSessionSync(argSessionId: number, argAccept: boolean, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Oma.CancelSession">CancelSession()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_oma_call_cancel_session_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_oma_call_cancel_session_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callCancelSession(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_oma_call_cancel_session().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_oma_call_cancel_session().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCancelSessionFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Oma.CancelSession">CancelSession()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_oma_call_cancel_session() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCancelSessionSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Oma.Setup">Setup()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_oma_call_setup_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_oma_call_setup_sync() for the synchronous, blocking version of this method.
     * @param argFeatures Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetup(argFeatures: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_oma_call_setup().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_oma_call_setup().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetupFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Oma.Setup">Setup()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_oma_call_setup() for the asynchronous version of this method.
     * @param argFeatures Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetupSync(argFeatures: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Oma.StartClientInitiatedSession">StartClientInitiatedSession()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_oma_call_start_client_initiated_session_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_oma_call_start_client_initiated_session_sync() for the synchronous, blocking version of this method.
     * @param argSessionType Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callStartClientInitiatedSession(argSessionType: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_oma_call_start_client_initiated_session().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_oma_call_start_client_initiated_session().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callStartClientInitiatedSessionFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Oma.StartClientInitiatedSession">StartClientInitiatedSession()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_oma_call_start_client_initiated_session() for the asynchronous version of this method.
     * @param argSessionType Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callStartClientInitiatedSessionSync(argSessionType: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Oma.AcceptNetworkInitiatedSession">AcceptNetworkInitiatedSession()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeAcceptNetworkInitiatedSession(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Oma.CancelSession">CancelSession()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeCancelSession(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Oma.Setup">Setup()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetup(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Oma.StartClientInitiatedSession">StartClientInitiatedSession()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeStartClientInitiatedSession(invocation: Gio.DBusMethodInvocation): void
    /**
     * Emits the <link linkend="gdbus-signal-org-freedesktop-ModemManager1-Modem-Oma.SessionStateChanged">"SessionStateChanged"</link> D-Bus signal.
     * @param argOldSessionState Argument to pass with the signal.
     * @param argNewSessionState Argument to pass with the signal.
     * @param argSessionStateFailedReason Argument to pass with the signal.
     */
    emitSessionStateChanged(argOldSessionState: number, argNewSessionState: number, argSessionStateFailedReason: number): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModemOma

    handleAcceptNetworkInitiatedSession(invocation: Gio.DBusMethodInvocation, argSessionId: number, argAccept: boolean): boolean
    handleCancelSession(invocation: Gio.DBusMethodInvocation): boolean
    handleSetup(invocation: Gio.DBusMethodInvocation, argFeatures: number): boolean
    handleStartClientInitiatedSession(invocation: Gio.DBusMethodInvocation, argSessionType: number): boolean
    sessionStateChanged(argOldSessionState: number, argNewSessionState: number, argSessionStateFailedReason: number): void

    // Own signals of ModemManager-1.0.ModemManager.GdbusModemOma

    connect(sigName: "handle-accept-network-initiated-session", callback: GdbusModemOma.HandleAcceptNetworkInitiatedSessionSignalCallback): number
    on(sigName: "handle-accept-network-initiated-session", callback: GdbusModemOma.HandleAcceptNetworkInitiatedSessionSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-accept-network-initiated-session", callback: GdbusModemOma.HandleAcceptNetworkInitiatedSessionSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-accept-network-initiated-session", callback: GdbusModemOma.HandleAcceptNetworkInitiatedSessionSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-accept-network-initiated-session", argSessionId: number, argAccept: boolean, ...args: any[]): void
    connect(sigName: "handle-cancel-session", callback: GdbusModemOma.HandleCancelSessionSignalCallback): number
    on(sigName: "handle-cancel-session", callback: GdbusModemOma.HandleCancelSessionSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-cancel-session", callback: GdbusModemOma.HandleCancelSessionSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-cancel-session", callback: GdbusModemOma.HandleCancelSessionSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-cancel-session", ...args: any[]): void
    connect(sigName: "handle-setup", callback: GdbusModemOma.HandleSetupSignalCallback): number
    on(sigName: "handle-setup", callback: GdbusModemOma.HandleSetupSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-setup", callback: GdbusModemOma.HandleSetupSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-setup", callback: GdbusModemOma.HandleSetupSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-setup", argFeatures: number, ...args: any[]): void
    connect(sigName: "handle-start-client-initiated-session", callback: GdbusModemOma.HandleStartClientInitiatedSessionSignalCallback): number
    on(sigName: "handle-start-client-initiated-session", callback: GdbusModemOma.HandleStartClientInitiatedSessionSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-start-client-initiated-session", callback: GdbusModemOma.HandleStartClientInitiatedSessionSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-start-client-initiated-session", callback: GdbusModemOma.HandleStartClientInitiatedSessionSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-start-client-initiated-session", argSessionType: number, ...args: any[]): void
    connect(sigName: "session-state-changed", callback: GdbusModemOma.SessionStateChangedSignalCallback): number
    on(sigName: "session-state-changed", callback: GdbusModemOma.SessionStateChangedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "session-state-changed", callback: GdbusModemOma.SessionStateChangedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "session-state-changed", callback: GdbusModemOma.SessionStateChangedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "session-state-changed", argNewSessionState: number, argSessionStateFailedReason: number, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemOma

    connect(sigName: "notify::features", callback: (...args: any[]) => void): number
    on(sigName: "notify::features", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::features", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::features", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::features", ...args: any[]): void
    connect(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void): number
    on(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::pending-network-initiated-sessions", ...args: any[]): void
    connect(sigName: "notify::session-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::session-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::session-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::session-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::session-state", ...args: any[]): void
    connect(sigName: "notify::session-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::session-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::session-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::session-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::session-type", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link>.
 * @interface 
 */
export class GdbusModemOma extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemOma

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemOma

    constructor(config?: GdbusModemOma.ConstructorProperties) 
    _init(config?: GdbusModemOma.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModemOma interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModemSar {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-enable`
     */
    export interface HandleEnableSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argEnable: boolean): boolean
    }

    /**
     * Signal callback interface for `handle-set-power-level`
     */
    export interface HandleSetPowerLevelSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argLevel: number): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModemSar

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Sar.PowerLevel">"PowerLevel"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        powerLevel?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Sar.State">"State"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        state?: boolean | null
    }

}

export interface GdbusModemSar {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSar

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Sar.PowerLevel">"PowerLevel"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    powerLevel: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Sar.State">"State"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    state: boolean
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModemSar

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Sar.Enable">Enable()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_sar_call_enable_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_sar_call_enable_sync() for the synchronous, blocking version of this method.
     * @param argEnable Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callEnable(argEnable: boolean, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_sar_call_enable().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_sar_call_enable().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callEnableFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Sar.Enable">Enable()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_sar_call_enable() for the asynchronous version of this method.
     * @param argEnable Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callEnableSync(argEnable: boolean, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Sar.SetPowerLevel">SetPowerLevel()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_sar_call_set_power_level_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_sar_call_set_power_level_sync() for the synchronous, blocking version of this method.
     * @param argLevel Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetPowerLevel(argLevel: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_sar_call_set_power_level().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_sar_call_set_power_level().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetPowerLevelFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Sar.SetPowerLevel">SetPowerLevel()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_sar_call_set_power_level() for the asynchronous version of this method.
     * @param argLevel Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetPowerLevelSync(argLevel: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Sar.Enable">Enable()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeEnable(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Sar.SetPowerLevel">SetPowerLevel()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetPowerLevel(invocation: Gio.DBusMethodInvocation): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModemSar

    handleEnable(invocation: Gio.DBusMethodInvocation, argEnable: boolean): boolean
    handleSetPowerLevel(invocation: Gio.DBusMethodInvocation, argLevel: number): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusModemSar

    connect(sigName: "handle-enable", callback: GdbusModemSar.HandleEnableSignalCallback): number
    on(sigName: "handle-enable", callback: GdbusModemSar.HandleEnableSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-enable", callback: GdbusModemSar.HandleEnableSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-enable", callback: GdbusModemSar.HandleEnableSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-enable", argEnable: boolean, ...args: any[]): void
    connect(sigName: "handle-set-power-level", callback: GdbusModemSar.HandleSetPowerLevelSignalCallback): number
    on(sigName: "handle-set-power-level", callback: GdbusModemSar.HandleSetPowerLevelSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-power-level", callback: GdbusModemSar.HandleSetPowerLevelSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-power-level", callback: GdbusModemSar.HandleSetPowerLevelSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-power-level", argLevel: number, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemSar

    connect(sigName: "notify::power-level", callback: (...args: any[]) => void): number
    on(sigName: "notify::power-level", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::power-level", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::power-level", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::power-level", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link>.
 * @interface 
 */
export class GdbusModemSar extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSar

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemSar

    constructor(config?: GdbusModemSar.ConstructorProperties) 
    _init(config?: GdbusModemSar.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModemSar interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModemSignal {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-setup`
     */
    export interface HandleSetupSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argRate: number): boolean
    }

    /**
     * Signal callback interface for `handle-setup-thresholds`
     */
    export interface HandleSetupThresholdsSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argSettings: GLib.Variant): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModemSignal

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Cdma">"Cdma"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        cdma?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.ErrorRateThreshold">"ErrorRateThreshold"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        errorRateThreshold?: boolean | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Evdo">"Evdo"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        evdo?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Gsm">"Gsm"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        gsm?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Lte">"Lte"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        lte?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Nr5g">"Nr5g"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        nr5g?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Rate">"Rate"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        rate?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.RssiThreshold">"RssiThreshold"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        rssiThreshold?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Umts">"Umts"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        umts?: GLib.Variant | null
    }

}

export interface GdbusModemSignal {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSignal

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Cdma">"Cdma"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    cdma: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.ErrorRateThreshold">"ErrorRateThreshold"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    errorRateThreshold: boolean
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Evdo">"Evdo"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    evdo: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Gsm">"Gsm"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    gsm: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Lte">"Lte"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    lte: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Nr5g">"Nr5g"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    nr5g: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Rate">"Rate"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    rate: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.RssiThreshold">"RssiThreshold"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    rssiThreshold: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Signal.Umts">"Umts"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    umts: GLib.Variant
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModemSignal

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Signal.Setup">Setup()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_signal_call_setup_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_signal_call_setup_sync() for the synchronous, blocking version of this method.
     * @param argRate Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetup(argRate: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_signal_call_setup().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_signal_call_setup().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetupFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Signal.Setup">Setup()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_signal_call_setup() for the asynchronous version of this method.
     * @param argRate Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetupSync(argRate: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Signal.SetupThresholds">SetupThresholds()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_signal_call_setup_thresholds_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_signal_call_setup_thresholds_sync() for the synchronous, blocking version of this method.
     * @param argSettings Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetupThresholds(argSettings: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_signal_call_setup_thresholds().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_signal_call_setup_thresholds().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetupThresholdsFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Signal.SetupThresholds">SetupThresholds()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_signal_call_setup_thresholds() for the asynchronous version of this method.
     * @param argSettings Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetupThresholdsSync(argSettings: GLib.Variant, cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Signal.Setup">Setup()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetup(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Signal.SetupThresholds">SetupThresholds()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetupThresholds(invocation: Gio.DBusMethodInvocation): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModemSignal

    handleSetup(invocation: Gio.DBusMethodInvocation, argRate: number): boolean
    handleSetupThresholds(invocation: Gio.DBusMethodInvocation, argSettings: GLib.Variant): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusModemSignal

    connect(sigName: "handle-setup", callback: GdbusModemSignal.HandleSetupSignalCallback): number
    on(sigName: "handle-setup", callback: GdbusModemSignal.HandleSetupSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-setup", callback: GdbusModemSignal.HandleSetupSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-setup", callback: GdbusModemSignal.HandleSetupSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-setup", argRate: number, ...args: any[]): void
    connect(sigName: "handle-setup-thresholds", callback: GdbusModemSignal.HandleSetupThresholdsSignalCallback): number
    on(sigName: "handle-setup-thresholds", callback: GdbusModemSignal.HandleSetupThresholdsSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-setup-thresholds", callback: GdbusModemSignal.HandleSetupThresholdsSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-setup-thresholds", callback: GdbusModemSignal.HandleSetupThresholdsSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-setup-thresholds", argSettings: GLib.Variant, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemSignal

    connect(sigName: "notify::cdma", callback: (...args: any[]) => void): number
    on(sigName: "notify::cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cdma", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cdma", ...args: any[]): void
    connect(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void): number
    on(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::error-rate-threshold", ...args: any[]): void
    connect(sigName: "notify::evdo", callback: (...args: any[]) => void): number
    on(sigName: "notify::evdo", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::evdo", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::evdo", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::evdo", ...args: any[]): void
    connect(sigName: "notify::gsm", callback: (...args: any[]) => void): number
    on(sigName: "notify::gsm", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gsm", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gsm", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gsm", ...args: any[]): void
    connect(sigName: "notify::lte", callback: (...args: any[]) => void): number
    on(sigName: "notify::lte", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::lte", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::lte", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::lte", ...args: any[]): void
    connect(sigName: "notify::nr5g", callback: (...args: any[]) => void): number
    on(sigName: "notify::nr5g", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::nr5g", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::nr5g", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::nr5g", ...args: any[]): void
    connect(sigName: "notify::rate", callback: (...args: any[]) => void): number
    on(sigName: "notify::rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::rate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::rate", ...args: any[]): void
    connect(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void): number
    on(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::rssi-threshold", ...args: any[]): void
    connect(sigName: "notify::umts", callback: (...args: any[]) => void): number
    on(sigName: "notify::umts", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::umts", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::umts", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::umts", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link>.
 * @interface 
 */
export class GdbusModemSignal extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSignal

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemSignal

    constructor(config?: GdbusModemSignal.ConstructorProperties) 
    _init(config?: GdbusModemSignal.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModemSignal interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModemSimple {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-connect`
     */
    export interface HandleConnectSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-disconnect`
     */
    export interface HandleDisconnectSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argBearer: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-get-status`
     */
    export interface HandleGetStatusSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface GdbusModemSimple {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSimple

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModemSimple

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Simple.Connect">Connect()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_simple_call_connect_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_simple_call_connect_sync() for the synchronous, blocking version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callConnect(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_simple_call_connect().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_simple_call_connect().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callConnectFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outBearer */ string | null ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Simple.Connect">Connect()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_simple_call_connect() for the asynchronous version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callConnectSync(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outBearer */ string | null ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Simple.Disconnect">Disconnect()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_simple_call_disconnect_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_simple_call_disconnect_sync() for the synchronous, blocking version of this method.
     * @param argBearer Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callDisconnect(argBearer: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_simple_call_disconnect().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_simple_call_disconnect().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDisconnectFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Simple.Disconnect">Disconnect()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_simple_call_disconnect() for the asynchronous version of this method.
     * @param argBearer Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDisconnectSync(argBearer: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Simple.GetStatus">GetStatus()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_simple_call_get_status_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_simple_call_get_status_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callGetStatus(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_simple_call_get_status().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_simple_call_get_status().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callGetStatusFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outProperties */ GLib.Variant ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Simple.GetStatus">GetStatus()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_simple_call_get_status() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callGetStatusSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outProperties */ GLib.Variant ]
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Simple.Connect">Connect()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param bearer Parameter to return.
     */
    completeConnect(invocation: Gio.DBusMethodInvocation, bearer: string | null): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Simple.Disconnect">Disconnect()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeDisconnect(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Simple.GetStatus">GetStatus()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param properties Parameter to return.
     */
    completeGetStatus(invocation: Gio.DBusMethodInvocation, properties: GLib.Variant): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModemSimple

    handleConnect(invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    handleDisconnect(invocation: Gio.DBusMethodInvocation, argBearer: string | null): boolean
    handleGetStatus(invocation: Gio.DBusMethodInvocation): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusModemSimple

    connect(sigName: "handle-connect", callback: GdbusModemSimple.HandleConnectSignalCallback): number
    on(sigName: "handle-connect", callback: GdbusModemSimple.HandleConnectSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-connect", callback: GdbusModemSimple.HandleConnectSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-connect", callback: GdbusModemSimple.HandleConnectSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-connect", argProperties: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-disconnect", callback: GdbusModemSimple.HandleDisconnectSignalCallback): number
    on(sigName: "handle-disconnect", callback: GdbusModemSimple.HandleDisconnectSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-disconnect", callback: GdbusModemSimple.HandleDisconnectSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-disconnect", callback: GdbusModemSimple.HandleDisconnectSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-disconnect", argBearer: string | null, ...args: any[]): void
    connect(sigName: "handle-get-status", callback: GdbusModemSimple.HandleGetStatusSignalCallback): number
    on(sigName: "handle-get-status", callback: GdbusModemSimple.HandleGetStatusSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-get-status", callback: GdbusModemSimple.HandleGetStatusSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-get-status", callback: GdbusModemSimple.HandleGetStatusSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-get-status", ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemSimple

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link>.
 * @interface 
 */
export class GdbusModemSimple extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSimple

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemSimple

    constructor(config?: GdbusModemSimple.ConstructorProperties) 
    _init(config?: GdbusModemSimple.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModemSimple interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModemTime {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-get-network-time`
     */
    export interface HandleGetNetworkTimeSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `network-time-changed`
     */
    export interface NetworkTimeChangedSignalCallback {
        (argTime: string | null): void
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModemTime

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Time.NetworkTimezone">"NetworkTimezone"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        networkTimezone?: GLib.Variant | null
    }

}

export interface GdbusModemTime {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemTime

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Time.NetworkTimezone">"NetworkTimezone"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    networkTimezone: GLib.Variant
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModemTime

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Time.GetNetworkTime">GetNetworkTime()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_time_call_get_network_time_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_time_call_get_network_time_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callGetNetworkTime(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_time_call_get_network_time().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_time_call_get_network_time().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callGetNetworkTimeFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outTime */ string | null ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Time.GetNetworkTime">GetNetworkTime()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_time_call_get_network_time() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callGetNetworkTimeSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outTime */ string | null ]
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Time.GetNetworkTime">GetNetworkTime()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param time Parameter to return.
     */
    completeGetNetworkTime(invocation: Gio.DBusMethodInvocation, time: string | null): void
    /**
     * Emits the <link linkend="gdbus-signal-org-freedesktop-ModemManager1-Modem-Time.NetworkTimeChanged">"NetworkTimeChanged"</link> D-Bus signal.
     * @param argTime Argument to pass with the signal.
     */
    emitNetworkTimeChanged(argTime: string | null): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModemTime

    handleGetNetworkTime(invocation: Gio.DBusMethodInvocation): boolean
    networkTimeChanged(argTime: string | null): void

    // Own signals of ModemManager-1.0.ModemManager.GdbusModemTime

    connect(sigName: "handle-get-network-time", callback: GdbusModemTime.HandleGetNetworkTimeSignalCallback): number
    on(sigName: "handle-get-network-time", callback: GdbusModemTime.HandleGetNetworkTimeSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-get-network-time", callback: GdbusModemTime.HandleGetNetworkTimeSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-get-network-time", callback: GdbusModemTime.HandleGetNetworkTimeSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-get-network-time", ...args: any[]): void
    connect(sigName: "network-time-changed", callback: GdbusModemTime.NetworkTimeChangedSignalCallback): number
    on(sigName: "network-time-changed", callback: GdbusModemTime.NetworkTimeChangedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "network-time-changed", callback: GdbusModemTime.NetworkTimeChangedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "network-time-changed", callback: GdbusModemTime.NetworkTimeChangedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "network-time-changed", ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemTime

    connect(sigName: "notify::network-timezone", callback: (...args: any[]) => void): number
    on(sigName: "notify::network-timezone", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::network-timezone", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::network-timezone", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::network-timezone", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link>.
 * @interface 
 */
export class GdbusModemTime extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemTime

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemTime

    constructor(config?: GdbusModemTime.ConstructorProperties) 
    _init(config?: GdbusModemTime.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModemTime interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusModemVoice {

    // Signal callback interfaces

    /**
     * Signal callback interface for `call-added`
     */
    export interface CallAddedSignalCallback {
        (argPath: string | null): void
    }

    /**
     * Signal callback interface for `call-deleted`
     */
    export interface CallDeletedSignalCallback {
        (argPath: string | null): void
    }

    /**
     * Signal callback interface for `handle-call-waiting-query`
     */
    export interface HandleCallWaitingQuerySignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-call-waiting-setup`
     */
    export interface HandleCallWaitingSetupSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argEnable: boolean): boolean
    }

    /**
     * Signal callback interface for `handle-create-call`
     */
    export interface HandleCreateCallSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-delete-call`
     */
    export interface HandleDeleteCallSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argPath: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-hangup-all`
     */
    export interface HandleHangupAllSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-hangup-and-accept`
     */
    export interface HandleHangupAndAcceptSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-hold-and-accept`
     */
    export interface HandleHoldAndAcceptSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-list-calls`
     */
    export interface HandleListCallsSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-transfer`
     */
    export interface HandleTransferSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusModemVoice

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Voice.Calls">"Calls"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        calls?: string[] | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Voice.EmergencyOnly">"EmergencyOnly"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        emergencyOnly?: boolean | null
    }

}

export interface GdbusModemVoice {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemVoice

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Voice.Calls">"Calls"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    calls: string[]
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Modem-Voice.EmergencyOnly">"EmergencyOnly"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    emergencyOnly: boolean
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusModemVoice

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.CallWaitingQuery">CallWaitingQuery()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_call_call_waiting_query_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_call_call_waiting_query_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callCallWaitingQuery(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_voice_call_call_waiting_query().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_voice_call_call_waiting_query().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCallWaitingQueryFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outStatus */ boolean ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.CallWaitingQuery">CallWaitingQuery()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_voice_call_call_waiting_query() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCallWaitingQuerySync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outStatus */ boolean ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.CallWaitingSetup">CallWaitingSetup()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_call_call_waiting_setup_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_call_call_waiting_setup_sync() for the synchronous, blocking version of this method.
     * @param argEnable Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callCallWaitingSetup(argEnable: boolean, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_voice_call_call_waiting_setup().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_voice_call_call_waiting_setup().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCallWaitingSetupFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.CallWaitingSetup">CallWaitingSetup()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_voice_call_call_waiting_setup() for the asynchronous version of this method.
     * @param argEnable Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCallWaitingSetupSync(argEnable: boolean, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.CreateCall">CreateCall()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_call_create_call_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_call_create_call_sync() for the synchronous, blocking version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callCreateCall(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_voice_call_create_call().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_voice_call_create_call().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCreateCallFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outPath */ string | null ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.CreateCall">CreateCall()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_voice_call_create_call() for the asynchronous version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callCreateCallSync(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outPath */ string | null ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.DeleteCall">DeleteCall()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_call_delete_call_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_call_delete_call_sync() for the synchronous, blocking version of this method.
     * @param argPath Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callDeleteCall(argPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_voice_call_delete_call().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_voice_call_delete_call().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDeleteCallFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.DeleteCall">DeleteCall()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_voice_call_delete_call() for the asynchronous version of this method.
     * @param argPath Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callDeleteCallSync(argPath: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.HangupAll">HangupAll()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_call_hangup_all_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_call_hangup_all_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callHangupAll(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_voice_call_hangup_all().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_voice_call_hangup_all().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callHangupAllFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.HangupAll">HangupAll()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_voice_call_hangup_all() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callHangupAllSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.HangupAndAccept">HangupAndAccept()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_call_hangup_and_accept_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_call_hangup_and_accept_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callHangupAndAccept(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_voice_call_hangup_and_accept().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_voice_call_hangup_and_accept().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callHangupAndAcceptFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.HangupAndAccept">HangupAndAccept()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_voice_call_hangup_and_accept() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callHangupAndAcceptSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.HoldAndAccept">HoldAndAccept()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_call_hold_and_accept_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_call_hold_and_accept_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callHoldAndAccept(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_voice_call_hold_and_accept().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_voice_call_hold_and_accept().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callHoldAndAcceptFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.HoldAndAccept">HoldAndAccept()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_voice_call_hold_and_accept() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callHoldAndAcceptSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.ListCalls">ListCalls()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_call_list_calls_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_call_list_calls_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callListCalls(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_voice_call_list_calls().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_voice_call_list_calls().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callListCallsFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* outResult */ string[] ]
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.ListCalls">ListCalls()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_voice_call_list_calls() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callListCallsSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* outResult */ string[] ]
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.Transfer">Transfer()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_call_transfer_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_call_transfer_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callTransfer(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_modem_voice_call_transfer().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_voice_call_transfer().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callTransferFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.Transfer">Transfer()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_voice_call_transfer() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callTransferSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.CallWaitingQuery">CallWaitingQuery()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param status Parameter to return.
     */
    completeCallWaitingQuery(invocation: Gio.DBusMethodInvocation, status: boolean): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.CallWaitingSetup">CallWaitingSetup()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeCallWaitingSetup(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.CreateCall">CreateCall()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param path Parameter to return.
     */
    completeCreateCall(invocation: Gio.DBusMethodInvocation, path: string | null): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.DeleteCall">DeleteCall()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeDeleteCall(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.HangupAll">HangupAll()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeHangupAll(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.HangupAndAccept">HangupAndAccept()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeHangupAndAccept(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.HoldAndAccept">HoldAndAccept()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeHoldAndAccept(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.ListCalls">ListCalls()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     * @param result Parameter to return.
     */
    completeListCalls(invocation: Gio.DBusMethodInvocation, result: string | null): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem-Voice.Transfer">Transfer()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeTransfer(invocation: Gio.DBusMethodInvocation): void
    /**
     * Emits the <link linkend="gdbus-signal-org-freedesktop-ModemManager1-Modem-Voice.CallAdded">"CallAdded"</link> D-Bus signal.
     * @param argPath Argument to pass with the signal.
     */
    emitCallAdded(argPath: string | null): void
    /**
     * Emits the <link linkend="gdbus-signal-org-freedesktop-ModemManager1-Modem-Voice.CallDeleted">"CallDeleted"</link> D-Bus signal.
     * @param argPath Argument to pass with the signal.
     */
    emitCallDeleted(argPath: string | null): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusModemVoice

    callAdded(argPath: string | null): void
    callDeleted(argPath: string | null): void
    handleCallWaitingQuery(invocation: Gio.DBusMethodInvocation): boolean
    handleCallWaitingSetup(invocation: Gio.DBusMethodInvocation, argEnable: boolean): boolean
    handleCreateCall(invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    handleDeleteCall(invocation: Gio.DBusMethodInvocation, argPath: string | null): boolean
    handleHangupAll(invocation: Gio.DBusMethodInvocation): boolean
    handleHangupAndAccept(invocation: Gio.DBusMethodInvocation): boolean
    handleHoldAndAccept(invocation: Gio.DBusMethodInvocation): boolean
    handleListCalls(invocation: Gio.DBusMethodInvocation): boolean
    handleTransfer(invocation: Gio.DBusMethodInvocation): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusModemVoice

    connect(sigName: "call-added", callback: GdbusModemVoice.CallAddedSignalCallback): number
    on(sigName: "call-added", callback: GdbusModemVoice.CallAddedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "call-added", callback: GdbusModemVoice.CallAddedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "call-added", callback: GdbusModemVoice.CallAddedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "call-added", ...args: any[]): void
    connect(sigName: "call-deleted", callback: GdbusModemVoice.CallDeletedSignalCallback): number
    on(sigName: "call-deleted", callback: GdbusModemVoice.CallDeletedSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "call-deleted", callback: GdbusModemVoice.CallDeletedSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "call-deleted", callback: GdbusModemVoice.CallDeletedSignalCallback): NodeJS.EventEmitter
    emit(sigName: "call-deleted", ...args: any[]): void
    connect(sigName: "handle-call-waiting-query", callback: GdbusModemVoice.HandleCallWaitingQuerySignalCallback): number
    on(sigName: "handle-call-waiting-query", callback: GdbusModemVoice.HandleCallWaitingQuerySignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-call-waiting-query", callback: GdbusModemVoice.HandleCallWaitingQuerySignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-call-waiting-query", callback: GdbusModemVoice.HandleCallWaitingQuerySignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-call-waiting-query", ...args: any[]): void
    connect(sigName: "handle-call-waiting-setup", callback: GdbusModemVoice.HandleCallWaitingSetupSignalCallback): number
    on(sigName: "handle-call-waiting-setup", callback: GdbusModemVoice.HandleCallWaitingSetupSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-call-waiting-setup", callback: GdbusModemVoice.HandleCallWaitingSetupSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-call-waiting-setup", callback: GdbusModemVoice.HandleCallWaitingSetupSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-call-waiting-setup", argEnable: boolean, ...args: any[]): void
    connect(sigName: "handle-create-call", callback: GdbusModemVoice.HandleCreateCallSignalCallback): number
    on(sigName: "handle-create-call", callback: GdbusModemVoice.HandleCreateCallSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-create-call", callback: GdbusModemVoice.HandleCreateCallSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-create-call", callback: GdbusModemVoice.HandleCreateCallSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-create-call", argProperties: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-delete-call", callback: GdbusModemVoice.HandleDeleteCallSignalCallback): number
    on(sigName: "handle-delete-call", callback: GdbusModemVoice.HandleDeleteCallSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-delete-call", callback: GdbusModemVoice.HandleDeleteCallSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-delete-call", callback: GdbusModemVoice.HandleDeleteCallSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-delete-call", argPath: string | null, ...args: any[]): void
    connect(sigName: "handle-hangup-all", callback: GdbusModemVoice.HandleHangupAllSignalCallback): number
    on(sigName: "handle-hangup-all", callback: GdbusModemVoice.HandleHangupAllSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-hangup-all", callback: GdbusModemVoice.HandleHangupAllSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-hangup-all", callback: GdbusModemVoice.HandleHangupAllSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-hangup-all", ...args: any[]): void
    connect(sigName: "handle-hangup-and-accept", callback: GdbusModemVoice.HandleHangupAndAcceptSignalCallback): number
    on(sigName: "handle-hangup-and-accept", callback: GdbusModemVoice.HandleHangupAndAcceptSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-hangup-and-accept", callback: GdbusModemVoice.HandleHangupAndAcceptSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-hangup-and-accept", callback: GdbusModemVoice.HandleHangupAndAcceptSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-hangup-and-accept", ...args: any[]): void
    connect(sigName: "handle-hold-and-accept", callback: GdbusModemVoice.HandleHoldAndAcceptSignalCallback): number
    on(sigName: "handle-hold-and-accept", callback: GdbusModemVoice.HandleHoldAndAcceptSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-hold-and-accept", callback: GdbusModemVoice.HandleHoldAndAcceptSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-hold-and-accept", callback: GdbusModemVoice.HandleHoldAndAcceptSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-hold-and-accept", ...args: any[]): void
    connect(sigName: "handle-list-calls", callback: GdbusModemVoice.HandleListCallsSignalCallback): number
    on(sigName: "handle-list-calls", callback: GdbusModemVoice.HandleListCallsSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-list-calls", callback: GdbusModemVoice.HandleListCallsSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-list-calls", callback: GdbusModemVoice.HandleListCallsSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-list-calls", ...args: any[]): void
    connect(sigName: "handle-transfer", callback: GdbusModemVoice.HandleTransferSignalCallback): number
    on(sigName: "handle-transfer", callback: GdbusModemVoice.HandleTransferSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-transfer", callback: GdbusModemVoice.HandleTransferSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-transfer", callback: GdbusModemVoice.HandleTransferSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-transfer", ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemVoice

    connect(sigName: "notify::calls", callback: (...args: any[]) => void): number
    on(sigName: "notify::calls", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::calls", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::calls", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::calls", ...args: any[]): void
    connect(sigName: "notify::emergency-only", callback: (...args: any[]) => void): number
    on(sigName: "notify::emergency-only", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::emergency-only", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::emergency-only", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::emergency-only", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link>.
 * @interface 
 */
export class GdbusModemVoice extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemVoice

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemVoice

    constructor(config?: GdbusModemVoice.ConstructorProperties) 
    _init(config?: GdbusModemVoice.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusModemVoice interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusObject {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusObject.ConstructorProperties, GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusObject

        /**
         * The #MmGdbusModem instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modem?: GdbusModem | null
        /**
         * The #MmGdbusModemCdma instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modemCdma?: GdbusModemCdma | null
        /**
         * The #MmGdbusModemFirmware instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modemFirmware?: GdbusModemFirmware | null
        /**
         * The #MmGdbusModemLocation instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modemLocation?: GdbusModemLocation | null
        /**
         * The #MmGdbusModemMessaging instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modemMessaging?: GdbusModemMessaging | null
        /**
         * The #MmGdbusModemOma instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modemOma?: GdbusModemOma | null
        /**
         * The #MmGdbusModemSar instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modemSar?: GdbusModemSar | null
        /**
         * The #MmGdbusModemSignal instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modemSignal?: GdbusModemSignal | null
        /**
         * The #MmGdbusModemSimple instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modemSimple?: GdbusModemSimple | null
        /**
         * The #MmGdbusModemTime instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modemTime?: GdbusModemTime | null
        /**
         * The #MmGdbusModemVoice instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modemVoice?: GdbusModemVoice | null
        /**
         * The #MmGdbusModem3gpp instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modem3gpp?: GdbusModem3gpp | null
        /**
         * The #MmGdbusModem3gppProfileManager instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modem3gppProfileManager?: GdbusModem3gppProfileManager | null
        /**
         * The #MmGdbusModem3gppUssd instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link>, if any.
         * 
         * Connect to the #GObject::notify signal to get informed of property changes.
         */
        modem3gppUssd?: GdbusModem3gppUssd | null
    }

}

export interface GdbusObject extends Gio.DBusObject {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObject

    /**
     * The #MmGdbusModem instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modem: GdbusModem
    /**
     * The #MmGdbusModemCdma instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modemCdma: GdbusModemCdma
    /**
     * The #MmGdbusModemFirmware instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modemFirmware: GdbusModemFirmware
    /**
     * The #MmGdbusModemLocation instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modemLocation: GdbusModemLocation
    /**
     * The #MmGdbusModemMessaging instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modemMessaging: GdbusModemMessaging
    /**
     * The #MmGdbusModemOma instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modemOma: GdbusModemOma
    /**
     * The #MmGdbusModemSar instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modemSar: GdbusModemSar
    /**
     * The #MmGdbusModemSignal instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modemSignal: GdbusModemSignal
    /**
     * The #MmGdbusModemSimple instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modemSimple: GdbusModemSimple
    /**
     * The #MmGdbusModemTime instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modemTime: GdbusModemTime
    /**
     * The #MmGdbusModemVoice instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modemVoice: GdbusModemVoice
    /**
     * The #MmGdbusModem3gpp instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modem3gpp: GdbusModem3gpp
    /**
     * The #MmGdbusModem3gppProfileManager instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modem3gppProfileManager: GdbusModem3gppProfileManager
    /**
     * The #MmGdbusModem3gppUssd instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link>, if any.
     * 
     * Connect to the #GObject::notify signal to get informed of property changes.
     */
    modem3gppUssd: GdbusModem3gppUssd
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusObject

    /**
     * Gets the #MmGdbusModem instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link> on `object,` if any.
     * @returns A #MmGdbusModem that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModem(): GdbusModem | null
    /**
     * Gets the #MmGdbusModem3gpp instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link> on `object,` if any.
     * @returns A #MmGdbusModem3gpp that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModem3gpp(): GdbusModem3gpp | null
    /**
     * Gets the #MmGdbusModem3gppProfileManager instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link> on `object,` if any.
     * @returns A #MmGdbusModem3gppProfileManager that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModem3gppProfileManager(): GdbusModem3gppProfileManager | null
    /**
     * Gets the #MmGdbusModem3gppUssd instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link> on `object,` if any.
     * @returns A #MmGdbusModem3gppUssd that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModem3gppUssd(): GdbusModem3gppUssd | null
    /**
     * Gets the #MmGdbusModemCdma instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link> on `object,` if any.
     * @returns A #MmGdbusModemCdma that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemCdma(): GdbusModemCdma | null
    /**
     * Gets the #MmGdbusModemFirmware instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link> on `object,` if any.
     * @returns A #MmGdbusModemFirmware that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemFirmware(): GdbusModemFirmware | null
    /**
     * Gets the #MmGdbusModemLocation instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link> on `object,` if any.
     * @returns A #MmGdbusModemLocation that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemLocation(): GdbusModemLocation | null
    /**
     * Gets the #MmGdbusModemMessaging instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link> on `object,` if any.
     * @returns A #MmGdbusModemMessaging that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemMessaging(): GdbusModemMessaging | null
    /**
     * Gets the #MmGdbusModemOma instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link> on `object,` if any.
     * @returns A #MmGdbusModemOma that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemOma(): GdbusModemOma | null
    /**
     * Gets the #MmGdbusModemSar instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link> on `object,` if any.
     * @returns A #MmGdbusModemSar that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemSar(): GdbusModemSar | null
    /**
     * Gets the #MmGdbusModemSignal instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link> on `object,` if any.
     * @returns A #MmGdbusModemSignal that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemSignal(): GdbusModemSignal | null
    /**
     * Gets the #MmGdbusModemSimple instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link> on `object,` if any.
     * @returns A #MmGdbusModemSimple that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemSimple(): GdbusModemSimple | null
    /**
     * Gets the #MmGdbusModemTime instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link> on `object,` if any.
     * @returns A #MmGdbusModemTime that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemTime(): GdbusModemTime | null
    /**
     * Gets the #MmGdbusModemVoice instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link> on `object,` if any.
     * @returns A #MmGdbusModemVoice that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemVoice(): GdbusModemVoice | null

    // Class property signals of ModemManager-1.0.ModemManager.GdbusObject

    connect(sigName: "notify::modem", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem", ...args: any[]): void
    connect(sigName: "notify::modem-cdma", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-cdma", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-cdma", ...args: any[]): void
    connect(sigName: "notify::modem-firmware", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-firmware", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-firmware", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-firmware", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-firmware", ...args: any[]): void
    connect(sigName: "notify::modem-location", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-location", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-location", ...args: any[]): void
    connect(sigName: "notify::modem-messaging", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-messaging", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-messaging", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-messaging", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-messaging", ...args: any[]): void
    connect(sigName: "notify::modem-oma", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-oma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-oma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-oma", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-oma", ...args: any[]): void
    connect(sigName: "notify::modem-sar", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-sar", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-sar", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-sar", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-sar", ...args: any[]): void
    connect(sigName: "notify::modem-signal", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-signal", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-signal", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-signal", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-signal", ...args: any[]): void
    connect(sigName: "notify::modem-simple", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-simple", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-simple", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-simple", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-simple", ...args: any[]): void
    connect(sigName: "notify::modem-time", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-time", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-time", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-time", ...args: any[]): void
    connect(sigName: "notify::modem-voice", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-voice", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-voice", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-voice", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-voice", ...args: any[]): void
    connect(sigName: "notify::modem3gpp", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem3gpp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem3gpp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem3gpp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem3gpp", ...args: any[]): void
    connect(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem3gpp-profile-manager", ...args: any[]): void
    connect(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem3gpp-ussd", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusObject type is a specialized container of interfaces.
 * @interface 
 */
export class GdbusObject extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObject

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusObject

    constructor(config?: GdbusObject.ConstructorProperties) 
    _init(config?: GdbusObject.ConstructorProperties): void
}

export module GdbusOrgFreedesktopModemManager1 {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-inhibit-device`
     */
    export interface HandleInhibitDeviceSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argUid: string | null, argInhibit: boolean): boolean
    }

    /**
     * Signal callback interface for `handle-report-kernel-event`
     */
    export interface HandleReportKernelEventSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    }

    /**
     * Signal callback interface for `handle-scan-devices`
     */
    export interface HandleScanDevicesSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-set-logging`
     */
    export interface HandleSetLoggingSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argLevel: string | null): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1.Version">"Version"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        version?: string | null
    }

}

export interface GdbusOrgFreedesktopModemManager1 {

    // Own properties of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1.Version">"Version"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    version: string | null
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1.InhibitDevice">InhibitDevice()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_org_freedesktop_modem_manager1_call_inhibit_device_finish() to get the result of the operation.
     * 
     * See mm_gdbus_org_freedesktop_modem_manager1_call_inhibit_device_sync() for the synchronous, blocking version of this method.
     * @param argUid Argument to pass with the method invocation.
     * @param argInhibit Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callInhibitDevice(argUid: string | null, argInhibit: boolean, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_org_freedesktop_modem_manager1_call_inhibit_device().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_org_freedesktop_modem_manager1_call_inhibit_device().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callInhibitDeviceFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1.InhibitDevice">InhibitDevice()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_org_freedesktop_modem_manager1_call_inhibit_device() for the asynchronous version of this method.
     * @param argUid Argument to pass with the method invocation.
     * @param argInhibit Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callInhibitDeviceSync(argUid: string | null, argInhibit: boolean, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1.ReportKernelEvent">ReportKernelEvent()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_org_freedesktop_modem_manager1_call_report_kernel_event_finish() to get the result of the operation.
     * 
     * See mm_gdbus_org_freedesktop_modem_manager1_call_report_kernel_event_sync() for the synchronous, blocking version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callReportKernelEvent(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_org_freedesktop_modem_manager1_call_report_kernel_event().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_org_freedesktop_modem_manager1_call_report_kernel_event().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callReportKernelEventFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1.ReportKernelEvent">ReportKernelEvent()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_org_freedesktop_modem_manager1_call_report_kernel_event() for the asynchronous version of this method.
     * @param argProperties Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callReportKernelEventSync(argProperties: GLib.Variant, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1.ScanDevices">ScanDevices()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_org_freedesktop_modem_manager1_call_scan_devices_finish() to get the result of the operation.
     * 
     * See mm_gdbus_org_freedesktop_modem_manager1_call_scan_devices_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callScanDevices(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_org_freedesktop_modem_manager1_call_scan_devices().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_org_freedesktop_modem_manager1_call_scan_devices().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callScanDevicesFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1.ScanDevices">ScanDevices()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_org_freedesktop_modem_manager1_call_scan_devices() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callScanDevicesSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1.SetLogging">SetLogging()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_org_freedesktop_modem_manager1_call_set_logging_finish() to get the result of the operation.
     * 
     * See mm_gdbus_org_freedesktop_modem_manager1_call_set_logging_sync() for the synchronous, blocking version of this method.
     * @param argLevel Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetLogging(argLevel: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_org_freedesktop_modem_manager1_call_set_logging().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_org_freedesktop_modem_manager1_call_set_logging().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetLoggingFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1.SetLogging">SetLogging()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_org_freedesktop_modem_manager1_call_set_logging() for the asynchronous version of this method.
     * @param argLevel Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetLoggingSync(argLevel: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1.InhibitDevice">InhibitDevice()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeInhibitDevice(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1.ReportKernelEvent">ReportKernelEvent()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeReportKernelEvent(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1.ScanDevices">ScanDevices()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeScanDevices(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1.SetLogging">SetLogging()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetLogging(invocation: Gio.DBusMethodInvocation): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1

    handleInhibitDevice(invocation: Gio.DBusMethodInvocation, argUid: string | null, argInhibit: boolean): boolean
    handleReportKernelEvent(invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant): boolean
    handleScanDevices(invocation: Gio.DBusMethodInvocation): boolean
    handleSetLogging(invocation: Gio.DBusMethodInvocation, argLevel: string | null): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1

    connect(sigName: "handle-inhibit-device", callback: GdbusOrgFreedesktopModemManager1.HandleInhibitDeviceSignalCallback): number
    on(sigName: "handle-inhibit-device", callback: GdbusOrgFreedesktopModemManager1.HandleInhibitDeviceSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-inhibit-device", callback: GdbusOrgFreedesktopModemManager1.HandleInhibitDeviceSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-inhibit-device", callback: GdbusOrgFreedesktopModemManager1.HandleInhibitDeviceSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-inhibit-device", argUid: string | null, argInhibit: boolean, ...args: any[]): void
    connect(sigName: "handle-report-kernel-event", callback: GdbusOrgFreedesktopModemManager1.HandleReportKernelEventSignalCallback): number
    on(sigName: "handle-report-kernel-event", callback: GdbusOrgFreedesktopModemManager1.HandleReportKernelEventSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-report-kernel-event", callback: GdbusOrgFreedesktopModemManager1.HandleReportKernelEventSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-report-kernel-event", callback: GdbusOrgFreedesktopModemManager1.HandleReportKernelEventSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-report-kernel-event", argProperties: GLib.Variant, ...args: any[]): void
    connect(sigName: "handle-scan-devices", callback: GdbusOrgFreedesktopModemManager1.HandleScanDevicesSignalCallback): number
    on(sigName: "handle-scan-devices", callback: GdbusOrgFreedesktopModemManager1.HandleScanDevicesSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-scan-devices", callback: GdbusOrgFreedesktopModemManager1.HandleScanDevicesSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-scan-devices", callback: GdbusOrgFreedesktopModemManager1.HandleScanDevicesSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-scan-devices", ...args: any[]): void
    connect(sigName: "handle-set-logging", callback: GdbusOrgFreedesktopModemManager1.HandleSetLoggingSignalCallback): number
    on(sigName: "handle-set-logging", callback: GdbusOrgFreedesktopModemManager1.HandleSetLoggingSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-logging", callback: GdbusOrgFreedesktopModemManager1.HandleSetLoggingSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-logging", callback: GdbusOrgFreedesktopModemManager1.HandleSetLoggingSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-logging", argLevel: string | null, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1

    connect(sigName: "notify::version", callback: (...args: any[]) => void): number
    on(sigName: "notify::version", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::version", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::version", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::version", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1.top_of_page">org.freedesktop.ModemManager1</link>.
 * @interface 
 */
export class GdbusOrgFreedesktopModemManager1 extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1

    constructor(config?: GdbusOrgFreedesktopModemManager1.ConstructorProperties) 
    _init(config?: GdbusOrgFreedesktopModemManager1.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1.top_of_page">org.freedesktop.ModemManager1</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusOrgFreedesktopModemManager1 interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusSim {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-change-pin`
     */
    export interface HandleChangePinSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argOldPin: string | null, argNewPin: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-enable-pin`
     */
    export interface HandleEnablePinSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argPin: string | null, argEnabled: boolean): boolean
    }

    /**
     * Signal callback interface for `handle-send-pin`
     */
    export interface HandleSendPinSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argPin: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-send-puk`
     */
    export interface HandleSendPukSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argPuk: string | null, argPin: string | null): boolean
    }

    /**
     * Signal callback interface for `handle-set-preferred-networks`
     */
    export interface HandleSetPreferredNetworksSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argPreferredNetworks: GLib.Variant): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusSim

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.Active">"Active"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        active?: boolean | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.Eid">"Eid"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        eid?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.EmergencyNumbers">"EmergencyNumbers"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        emergencyNumbers?: string[] | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.EsimStatus">"EsimStatus"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        esimStatus?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.Gid1">"Gid1"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        gid1?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.Gid2">"Gid2"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        gid2?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.Imsi">"Imsi"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        imsi?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.OperatorIdentifier">"OperatorIdentifier"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        operatorIdentifier?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.OperatorName">"OperatorName"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        operatorName?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.PreferredNetworks">"PreferredNetworks"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        preferredNetworks?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.Removability">"Removability"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        removability?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.SimIdentifier">"SimIdentifier"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        simIdentifier?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.SimType">"SimType"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        simType?: number | null
    }

}

export interface GdbusSim {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSim

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.Active">"Active"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    active: boolean
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.Eid">"Eid"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    eid: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.EmergencyNumbers">"EmergencyNumbers"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    emergencyNumbers: string[]
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.EsimStatus">"EsimStatus"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    esimStatus: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.Gid1">"Gid1"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    gid1: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.Gid2">"Gid2"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    gid2: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.Imsi">"Imsi"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    imsi: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.OperatorIdentifier">"OperatorIdentifier"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    operatorIdentifier: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.OperatorName">"OperatorName"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    operatorName: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.PreferredNetworks">"PreferredNetworks"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    preferredNetworks: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.Removability">"Removability"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    removability: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.SimIdentifier">"SimIdentifier"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    simIdentifier: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sim.SimType">"SimType"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    simType: number
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusSim

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.ChangePin">ChangePin()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sim_call_change_pin_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sim_call_change_pin_sync() for the synchronous, blocking version of this method.
     * @param argOldPin Argument to pass with the method invocation.
     * @param argNewPin Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callChangePin(argOldPin: string | null, argNewPin: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_sim_call_change_pin().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_sim_call_change_pin().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callChangePinFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.ChangePin">ChangePin()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_sim_call_change_pin() for the asynchronous version of this method.
     * @param argOldPin Argument to pass with the method invocation.
     * @param argNewPin Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callChangePinSync(argOldPin: string | null, argNewPin: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.EnablePin">EnablePin()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sim_call_enable_pin_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sim_call_enable_pin_sync() for the synchronous, blocking version of this method.
     * @param argPin Argument to pass with the method invocation.
     * @param argEnabled Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callEnablePin(argPin: string | null, argEnabled: boolean, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_sim_call_enable_pin().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_sim_call_enable_pin().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callEnablePinFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.EnablePin">EnablePin()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_sim_call_enable_pin() for the asynchronous version of this method.
     * @param argPin Argument to pass with the method invocation.
     * @param argEnabled Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callEnablePinSync(argPin: string | null, argEnabled: boolean, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.SendPin">SendPin()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sim_call_send_pin_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sim_call_send_pin_sync() for the synchronous, blocking version of this method.
     * @param argPin Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSendPin(argPin: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_sim_call_send_pin().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_sim_call_send_pin().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSendPinFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.SendPin">SendPin()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_sim_call_send_pin() for the asynchronous version of this method.
     * @param argPin Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSendPinSync(argPin: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.SendPuk">SendPuk()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sim_call_send_puk_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sim_call_send_puk_sync() for the synchronous, blocking version of this method.
     * @param argPuk Argument to pass with the method invocation.
     * @param argPin Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSendPuk(argPuk: string | null, argPin: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_sim_call_send_puk().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_sim_call_send_puk().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSendPukFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.SendPuk">SendPuk()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_sim_call_send_puk() for the asynchronous version of this method.
     * @param argPuk Argument to pass with the method invocation.
     * @param argPin Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSendPukSync(argPuk: string | null, argPin: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.SetPreferredNetworks">SetPreferredNetworks()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sim_call_set_preferred_networks_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sim_call_set_preferred_networks_sync() for the synchronous, blocking version of this method.
     * @param argPreferredNetworks Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSetPreferredNetworks(argPreferredNetworks: GLib.Variant, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_sim_call_set_preferred_networks().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_sim_call_set_preferred_networks().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetPreferredNetworksFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.SetPreferredNetworks">SetPreferredNetworks()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_sim_call_set_preferred_networks() for the asynchronous version of this method.
     * @param argPreferredNetworks Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSetPreferredNetworksSync(argPreferredNetworks: GLib.Variant, cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.ChangePin">ChangePin()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeChangePin(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.EnablePin">EnablePin()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeEnablePin(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.SendPin">SendPin()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSendPin(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.SendPuk">SendPuk()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSendPuk(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sim.SetPreferredNetworks">SetPreferredNetworks()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSetPreferredNetworks(invocation: Gio.DBusMethodInvocation): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusSim

    handleChangePin(invocation: Gio.DBusMethodInvocation, argOldPin: string | null, argNewPin: string | null): boolean
    handleEnablePin(invocation: Gio.DBusMethodInvocation, argPin: string | null, argEnabled: boolean): boolean
    handleSendPin(invocation: Gio.DBusMethodInvocation, argPin: string | null): boolean
    handleSendPuk(invocation: Gio.DBusMethodInvocation, argPuk: string | null, argPin: string | null): boolean
    handleSetPreferredNetworks(invocation: Gio.DBusMethodInvocation, argPreferredNetworks: GLib.Variant): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusSim

    connect(sigName: "handle-change-pin", callback: GdbusSim.HandleChangePinSignalCallback): number
    on(sigName: "handle-change-pin", callback: GdbusSim.HandleChangePinSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-change-pin", callback: GdbusSim.HandleChangePinSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-change-pin", callback: GdbusSim.HandleChangePinSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-change-pin", argOldPin: string | null, argNewPin: string | null, ...args: any[]): void
    connect(sigName: "handle-enable-pin", callback: GdbusSim.HandleEnablePinSignalCallback): number
    on(sigName: "handle-enable-pin", callback: GdbusSim.HandleEnablePinSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-enable-pin", callback: GdbusSim.HandleEnablePinSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-enable-pin", callback: GdbusSim.HandleEnablePinSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-enable-pin", argPin: string | null, argEnabled: boolean, ...args: any[]): void
    connect(sigName: "handle-send-pin", callback: GdbusSim.HandleSendPinSignalCallback): number
    on(sigName: "handle-send-pin", callback: GdbusSim.HandleSendPinSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-send-pin", callback: GdbusSim.HandleSendPinSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-send-pin", callback: GdbusSim.HandleSendPinSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-send-pin", argPin: string | null, ...args: any[]): void
    connect(sigName: "handle-send-puk", callback: GdbusSim.HandleSendPukSignalCallback): number
    on(sigName: "handle-send-puk", callback: GdbusSim.HandleSendPukSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-send-puk", callback: GdbusSim.HandleSendPukSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-send-puk", callback: GdbusSim.HandleSendPukSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-send-puk", argPuk: string | null, argPin: string | null, ...args: any[]): void
    connect(sigName: "handle-set-preferred-networks", callback: GdbusSim.HandleSetPreferredNetworksSignalCallback): number
    on(sigName: "handle-set-preferred-networks", callback: GdbusSim.HandleSetPreferredNetworksSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-set-preferred-networks", callback: GdbusSim.HandleSetPreferredNetworksSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-set-preferred-networks", callback: GdbusSim.HandleSetPreferredNetworksSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-set-preferred-networks", argPreferredNetworks: GLib.Variant, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusSim

    connect(sigName: "notify::active", callback: (...args: any[]) => void): number
    on(sigName: "notify::active", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::active", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::active", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::active", ...args: any[]): void
    connect(sigName: "notify::eid", callback: (...args: any[]) => void): number
    on(sigName: "notify::eid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::eid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::eid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::eid", ...args: any[]): void
    connect(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void): number
    on(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::emergency-numbers", ...args: any[]): void
    connect(sigName: "notify::esim-status", callback: (...args: any[]) => void): number
    on(sigName: "notify::esim-status", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::esim-status", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::esim-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::esim-status", ...args: any[]): void
    connect(sigName: "notify::gid1", callback: (...args: any[]) => void): number
    on(sigName: "notify::gid1", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gid1", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gid1", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gid1", ...args: any[]): void
    connect(sigName: "notify::gid2", callback: (...args: any[]) => void): number
    on(sigName: "notify::gid2", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gid2", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gid2", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gid2", ...args: any[]): void
    connect(sigName: "notify::imsi", callback: (...args: any[]) => void): number
    on(sigName: "notify::imsi", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::imsi", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::imsi", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::imsi", ...args: any[]): void
    connect(sigName: "notify::operator-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-identifier", ...args: any[]): void
    connect(sigName: "notify::operator-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-name", ...args: any[]): void
    connect(sigName: "notify::preferred-networks", callback: (...args: any[]) => void): number
    on(sigName: "notify::preferred-networks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::preferred-networks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::preferred-networks", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::preferred-networks", ...args: any[]): void
    connect(sigName: "notify::removability", callback: (...args: any[]) => void): number
    on(sigName: "notify::removability", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::removability", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::removability", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::removability", ...args: any[]): void
    connect(sigName: "notify::sim-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim-identifier", ...args: any[]): void
    connect(sigName: "notify::sim-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim-type", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sim.top_of_page">org.freedesktop.ModemManager1.Sim</link>.
 * @interface 
 */
export class GdbusSim extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSim

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusSim

    constructor(config?: GdbusSim.ConstructorProperties) 
    _init(config?: GdbusSim.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sim.top_of_page">org.freedesktop.ModemManager1.Sim</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusSim interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module GdbusSms {

    // Signal callback interfaces

    /**
     * Signal callback interface for `handle-send`
     */
    export interface HandleSendSignalCallback {
        (invocation: Gio.DBusMethodInvocation): boolean
    }

    /**
     * Signal callback interface for `handle-store`
     */
    export interface HandleStoreSignalCallback {
        (invocation: Gio.DBusMethodInvocation, argStorage: number): boolean
    }


    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.GdbusSms

        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Class">"Class"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        "class"?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Data">"Data"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        data?: GLib.Variant | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.DeliveryReportRequest">"DeliveryReportRequest"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        deliveryReportRequest?: boolean | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.DeliveryState">"DeliveryState"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        deliveryState?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.DischargeTimestamp">"DischargeTimestamp"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        dischargeTimestamp?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.MessageReference">"MessageReference"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        messageReference?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Number">"Number"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        number?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.PduType">"PduType"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        pduType?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.ServiceCategory">"ServiceCategory"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        serviceCategory?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.SMSC">"SMSC"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        smsc?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.State">"State"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        state?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Storage">"Storage"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        storage?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.TeleserviceId">"TeleserviceId"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        teleserviceId?: number | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Text">"Text"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        text?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Timestamp">"Timestamp"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        timestamp?: string | null
        /**
         * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Validity">"Validity"</link>.
         * 
         * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
         */
        validity?: GLib.Variant | null
    }

}

export interface GdbusSms {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSms

    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Class">"Class"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    "class": number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Data">"Data"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    data: GLib.Variant
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.DeliveryReportRequest">"DeliveryReportRequest"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    deliveryReportRequest: boolean
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.DeliveryState">"DeliveryState"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    deliveryState: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.DischargeTimestamp">"DischargeTimestamp"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    dischargeTimestamp: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.MessageReference">"MessageReference"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    messageReference: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Number">"Number"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    number: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.PduType">"PduType"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    pduType: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.ServiceCategory">"ServiceCategory"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    serviceCategory: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.SMSC">"SMSC"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    smsc: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.State">"State"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    state: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Storage">"Storage"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    storage: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.TeleserviceId">"TeleserviceId"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    teleserviceId: number
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Text">"Text"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    text: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Timestamp">"Timestamp"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    timestamp: string | null
    /**
     * Represents the D-Bus property <link linkend="gdbus-property-org-freedesktop-ModemManager1-Sms.Validity">"Validity"</link>.
     * 
     * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
     */
    validity: GLib.Variant
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusSms

    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sms.Send">Send()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sms_call_send_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sms_call_send_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callSend(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_sms_call_send().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_sms_call_send().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSendFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sms.Send">Send()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_sms_call_send() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callSendSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sms.Store">Store()</link> D-Bus method on `proxy`.
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sms_call_store_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sms_call_store_sync() for the synchronous, blocking version of this method.
     * @param argStorage Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    callStore(argStorage: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_gdbus_sms_call_store().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_sms_call_store().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callStoreFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sms.Store">Store()</link> D-Bus method on `proxy`. The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_sms_call_store() for the asynchronous version of this method.
     * @param argStorage Argument to pass with the method invocation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    callStoreSync(argStorage: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sms.Send">Send()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeSend(invocation: Gio.DBusMethodInvocation): void
    /**
     * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-ModemManager1-Sms.Store">Store()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
     * 
     * This method will free `invocation,` you cannot use it afterwards.
     * @param invocation A #GDBusMethodInvocation.
     */
    completeStore(invocation: Gio.DBusMethodInvocation): void

    // Own virtual methods of ModemManager-1.0.ModemManager.GdbusSms

    handleSend(invocation: Gio.DBusMethodInvocation): boolean
    handleStore(invocation: Gio.DBusMethodInvocation, argStorage: number): boolean

    // Own signals of ModemManager-1.0.ModemManager.GdbusSms

    connect(sigName: "handle-send", callback: GdbusSms.HandleSendSignalCallback): number
    on(sigName: "handle-send", callback: GdbusSms.HandleSendSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-send", callback: GdbusSms.HandleSendSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-send", callback: GdbusSms.HandleSendSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-send", ...args: any[]): void
    connect(sigName: "handle-store", callback: GdbusSms.HandleStoreSignalCallback): number
    on(sigName: "handle-store", callback: GdbusSms.HandleStoreSignalCallback, after?: boolean): NodeJS.EventEmitter
    once(sigName: "handle-store", callback: GdbusSms.HandleStoreSignalCallback, after?: boolean): NodeJS.EventEmitter
    off(sigName: "handle-store", callback: GdbusSms.HandleStoreSignalCallback): NodeJS.EventEmitter
    emit(sigName: "handle-store", argStorage: number, ...args: any[]): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusSms

    connect(sigName: "notify::class", callback: (...args: any[]) => void): number
    on(sigName: "notify::class", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::class", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::class", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::class", ...args: any[]): void
    connect(sigName: "notify::data", callback: (...args: any[]) => void): number
    on(sigName: "notify::data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::data", ...args: any[]): void
    connect(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void): number
    on(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::delivery-report-request", ...args: any[]): void
    connect(sigName: "notify::delivery-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::delivery-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::delivery-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::delivery-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::delivery-state", ...args: any[]): void
    connect(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void): number
    on(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::discharge-timestamp", ...args: any[]): void
    connect(sigName: "notify::message-reference", callback: (...args: any[]) => void): number
    on(sigName: "notify::message-reference", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::message-reference", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::message-reference", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::message-reference", ...args: any[]): void
    connect(sigName: "notify::number", callback: (...args: any[]) => void): number
    on(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::number", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::number", ...args: any[]): void
    connect(sigName: "notify::pdu-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::pdu-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::pdu-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::pdu-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::pdu-type", ...args: any[]): void
    connect(sigName: "notify::service-category", callback: (...args: any[]) => void): number
    on(sigName: "notify::service-category", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::service-category", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::service-category", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::service-category", ...args: any[]): void
    connect(sigName: "notify::smsc", callback: (...args: any[]) => void): number
    on(sigName: "notify::smsc", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::smsc", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::smsc", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::smsc", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::storage", callback: (...args: any[]) => void): number
    on(sigName: "notify::storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::storage", ...args: any[]): void
    connect(sigName: "notify::teleservice-id", callback: (...args: any[]) => void): number
    on(sigName: "notify::teleservice-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::teleservice-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::teleservice-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::teleservice-id", ...args: any[]): void
    connect(sigName: "notify::text", callback: (...args: any[]) => void): number
    on(sigName: "notify::text", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::text", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::text", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::text", ...args: any[]): void
    connect(sigName: "notify::timestamp", callback: (...args: any[]) => void): number
    on(sigName: "notify::timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::timestamp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::timestamp", ...args: any[]): void
    connect(sigName: "notify::validity", callback: (...args: any[]) => void): number
    on(sigName: "notify::validity", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::validity", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::validity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::validity", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sms.top_of_page">org.freedesktop.ModemManager1.Sms</link>.
 * @interface 
 */
export class GdbusSms extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSms

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusSms

    constructor(config?: GdbusSms.ConstructorProperties) 
    _init(config?: GdbusSms.ConstructorProperties): void
    /**
     * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sms.top_of_page">org.freedesktop.ModemManager1.Sms</link> D-Bus interface.
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    static interfaceInfo(): Gio.DBusInterfaceInfo
    /**
     * Overrides all #GObject properties in the #MmGdbusSms interface for a concrete class.
     * The properties are overridden in the order they are defined.
     * @param klass The class structure for a #GObject derived class.
     * @param propertyIdBegin The property id to assign to the first overridden property.
     * @returns The last property id.
     */
    static overrideProperties(klass: GObject.ObjectClass, propertyIdBegin: number): number
}

export module TODO_3gppProfile {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface TODO_3gppProfile {

    // Own properties of ModemManager-1.0.ModemManager.3gppProfile

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.3gppProfile

    consumeString(key: string | null, value: string | null): boolean
    consumeVariant(key: string | null, value: GLib.Variant): boolean
    /**
     * Gets 5G network access type preference.
     * @returns a #MMBearerAccessTypePreference.
     */
    getAccessTypePreference(): BearerAccessTypePreference
    /**
     * Gets the methods allowed to use when authenticating with the access point.
     * @returns a bitmask of #MMBearerAllowedAuth values, or %MM_BEARER_ALLOWED_AUTH_UNKNOWN to request the modem-default method.
     */
    getAllowedAuth(): BearerAllowedAuth
    /**
     * Gets the name of the access point.
     * @returns the access point, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getApn(): string | null
    /**
     * Gets the APN types to use.
     * @returns a mask of #MMBearerApnType values.
     */
    getApnType(): BearerApnType
    /**
     * Checks whether the profile is enabled or disabled.
     * @returns %TRUE if the profile is enabled, %FALSE otherwise.
     */
    getEnabled(): boolean
    /**
     * Gets the IP type to use.
     * @returns a #MMBearerIpFamily.
     */
    getIpType(): BearerIpFamily
    /**
     * Gets the password used to authenticate with the access point.
     * @returns the password, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getPassword(): string | null
    /**
     * Gets the profile id.
     * @returns the profile id..
     */
    getProfileId(): number
    /**
     * Gets the name of the profile.
     * @returns the profile name, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getProfileName(): string | null
    /**
     * Gets the profile source.
     * @returns a #MMBearerProfileSource.
     */
    getProfileSource(): BearerProfileSource
    /**
     * Gets the roaming allowance rules.
     * @returns a mask of #MMBearerRoamingAllowance values.
     */
    getRoamingAllowance(): BearerRoamingAllowance
    /**
     * Gets the username used to authenticate with the access point.
     * @returns the username, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getUser(): string | null
    /**
     * Sets the 5G network access type preference.
     * @param accessTypePreference a #MMBearerAccessTypePreference.
     */
    setAccessTypePreference(accessTypePreference: BearerAccessTypePreference): void
    /**
     * Sets the method to use when authenticating with the access point.
     * @param allowedAuth a bitmask of #MMBearerAllowedAuth values.  %MM_BEARER_ALLOWED_AUTH_UNKNOWN may be given to request the modem-default  method.
     */
    setAllowedAuth(allowedAuth: BearerAllowedAuth): void
    /**
     * Sets the name of the access point to use.
     * @param apn Name of the access point.
     */
    setApn(apn: string | null): void
    /**
     * Sets the APN types to use.
     * @param apnType a mask of #MMBearerApnType values.
     */
    setApnType(apnType: BearerApnType): void
    /**
     * Sets the flag to indicate whether the profile is enabled or disabled.
     * @param enabled boolean value.
     */
    setEnabled(enabled: boolean): void
    /**
     * Sets the IP type to use.
     * @param ipType a #MMBearerIpFamily.
     */
    setIpType(ipType: BearerIpFamily): void
    /**
     * Sets the password used to authenticate with the access point.
     * @param password the password
     */
    setPassword(password: string | null): void
    /**
     * Sets the profile id to use.
     * 
     * If none specified explicitly, #MM_3GPP_PROFILE_ID_UNKNOWN is assumed.
     * @param profileId Numeric profile id to use, or #MM_3GPP_PROFILE_ID_UNKNOWN.
     */
    setProfileId(profileId: number): void
    /**
     * Sets the name of the profile.
     * @param profileName Name of the profile.
     */
    setProfileName(profileName: string | null): void
    /**
     * Sets profile source.
     * @param profileSource a #MMBearerProfileSource.
     */
    setProfileSource(profileSource: BearerProfileSource): void
    /**
     * Sets the roaming allowance rules.
     * @param roamingAllowance a mask of #MMBearerRoamingAllowance values.
     */
    setRoamingAllowance(roamingAllowance: BearerRoamingAllowance): void
    /**
     * Sets the username used to authenticate with the access point.
     * @param user the username
     */
    setUser(user: string | null): void

    // Class property signals of ModemManager-1.0.ModemManager.3gppProfile

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MM3gppProfile structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class TODO_3gppProfile extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.3gppProfile

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.3gppProfile

    constructor(config?: TODO_3gppProfile.ConstructorProperties) 
    /**
     * Creates a new empty #MM3gppProfile.
     * @constructor 
     * @returns a #MM3gppProfile. The returned value should be freed with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new empty #MM3gppProfile.
     * @constructor 
     * @returns a #MM3gppProfile. The returned value should be freed with g_object_unref().
     */
    static new(): TODO_3gppProfile
    _init(config?: TODO_3gppProfile.ConstructorProperties): void
}

export module Bearer {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusBearer.ConstructorProperties, GdbusBearerProxy.ConstructorProperties {
    }

}

export interface Bearer extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusBearer {

    // Own properties of ModemManager-1.0.ModemManager.Bearer

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Bearer

    /**
     * Asynchronously requests activation of a packet data connection with the
     * network using this #MMBearer properties.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_bearer_connect_finish() to get the result of the operation.
     * 
     * See mm_bearer_connect_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    connect(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_bearer_connect().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_bearer_connect().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    connectFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests activation of a packet data connection with the
     * network using this #MMBearer properties.
     * 
     * The calling thread is blocked until a reply is received.
     * See mm_bearer_connect() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    connectSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Synchronously requests disconnection and deactivation of the packet data
     * connection.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_bearer_disconnect_finish() to get the result of the operation.
     * 
     * See mm_bearer_disconnect_sync() for the synchronous, blocking version of this
     * method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    disconnect(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_bearer_disconnect().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_bearer_disconnect().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    disconnectFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests disconnection and deactivation of the packet data
     * connection.
     * 
     * The calling thread is blocked until a reply is received.
     * See mm_bearer_disconnect() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    disconnectSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a copy of the operating system name for the network data interface that
     * provides packet data using this #MMBearer. This will only be available once
     * the #MMBearer is in connected state.
     * @returns The name of the interface, or %NULL if it couldn't be retrieved. The returned value should be freed with g_free().
     */
    dupInterface(): string | null
    /**
     * Gets a copy of the DBus path of the #MMBearer object.
     * @returns The DBus path of the #MMBearer object. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets the type of bearer.
     * @returns a #MMBearerType.
     */
    getBearerType(): BearerType
    /**
     * Checks whether or not the #MMBearer is connected and thus whether packet data
     * communication is possible.
     * @returns %TRUE if the #MMBearer is connected, #FALSE otherwise.
     */
    getConnected(): boolean
    /**
     * Gets a #GError specifying the connection error details, if any.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_bearer_get_connection_error() again to get a new #GError with the
     * new values.</warning>
     * @returns A #GError that must be freed with g_error_free() or %NULL if none.
     */
    getConnectionError(): GLib.Error
    /**
     * Gets the operating system name for the network data interface that provides
     * packet data using this #MMBearer. This will only be available once the #MMBearer
     * is in connected state.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_bearer_dup_interface() if on another
     * thread.</warning>
     * @returns The name of the interface, or %NULL if it couldn't be retrieved.
     */
    getInterface(): string | null
    /**
     * Gets the maximum time to wait for the bearer to retrieve a valid IP address.
     * @returns The IP timeout, or 0 if no specific one given.
     */
    getIpTimeout(): number
    /**
     * Gets a #MMBearerIpConfig object specifying the IPv4 configuration to use in
     * the bearer.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_bearer_get_ipv4_config() again to get a new #MMBearerIpConfig with the
     * new values.</warning>
     * @returns A #MMBearerIpConfig that must be freed with g_object_unref() or %NULL if unknown.
     */
    getIpv4Config(): BearerIpConfig
    /**
     * Gets a #MMBearerIpConfig object specifying the IPv6 configuration to use in
     * the bearer.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_bearer_get_ipv6_config() again to get a new #MMBearerIpConfig with the
     * new values.</warning>
     * @returns A #MMBearerIpConfig that must be freed with g_object_unref() or %NULL if unknown.
     */
    getIpv6Config(): BearerIpConfig
    /**
     * Checks whether or not the #MMBearer is connected through a multiplexed
     * network likn.
     * @returns %TRUE if packet data service is connected via a multiplexed network link in the #MMBearer, #FALSE otherwise.
     */
    getMultiplexed(): boolean
    /**
     * Gets the DBus path of the #MMBearer object.
     * @returns The DBus path of the #MMBearer object.
     */
    getPath(): string | null
    /**
     * Gets profile ID associated to the bearer connection, if known.
     * 
     * If the bearer is disconnected or the modem doesn't support profile management
     * features, %MM_3GPP_PROFILE_ID_UNKNOWN.
     * @returns a profile id.
     */
    getProfileId(): number
    /**
     * Gets a #MMBearerProperties object specifying the properties which were used
     * to create the bearer.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_bearer_get_properties() again to get a new #MMBearerProperties with the
     * new values.</warning>
     * @returns A #MMBearerProperties that must be freed with g_object_unref() or %NULL if unknown.
     */
    getProperties(): BearerProperties
    /**
     * Checks whether or not the #MMBearer supporting stats reload (to have
     * RX and TX bytes of the ongoing connection).
     * @returns %TRUE if the #MMBearer supports these stats, #FALSE otherwise.
     */
    getReloadStatsSupported(): boolean
    /**
     * Gets a #MMBearerStats object specifying the statistics of the current bearer
     * connection.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_bearer_get_stats() again to get a new #MMBearerStats with the
     * new values.</warning>
     * @returns A #MMBearerStats that must be freed with g_object_unref() or %NULL if unknown.
     */
    getStats(): BearerStats
    /**
     * Checks whether or not the #MMBearer is suspended (but not deactivated) while
     * the device is handling other communications, like a voice call.
     * @returns %TRUE if packet data service is suspended in the #MMBearer, #FALSE otherwise.
     */
    getSuspended(): boolean
    /**
     * Gets a #GError specifying the connection error details, if any.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_bearer_get_connection_error() if on another
     * thread.</warning>
     * @returns A #GError, or %NULL if none. Do not free the returned value, it belongs to @self.
     */
    peekConnectionError(): GLib.Error
    /**
     * Gets a #MMBearerIpConfig object specifying the IPv4 configuration to use in
     * the bearer.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_bearer_get_ipv4_config() if on another
     * thread.</warning>
     * @returns A #MMBearerIpConfig. Do not free the returned value, it belongs to @self.
     */
    peekIpv4Config(): BearerIpConfig
    /**
     * Gets a #MMBearerIpConfig object specifying the IPv6 configuration to use in
     * the bearer.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_bearer_get_ipv6_config() if on another
     * thread.</warning>
     * @returns A #MMBearerIpConfig. Do not free the returned value, it belongs to @self.
     */
    peekIpv6Config(): BearerIpConfig
    /**
     * Gets a #MMBearerProperties object specifying the properties which were used
     * to create the bearer.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_bearer_get_properties() if on another
     * thread.</warning>
     * @returns A #MMBearerProperties. Do not free the returned value, it belongs to @self.
     */
    peekProperties(): BearerProperties
    /**
     * Gets a #MMBearerStats object specifying the statistics of the current bearer
     * connection.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_bearer_get_stats() if on another
     * thread.</warning>
     * @returns A #MMBearerStats. Do not free the returned value, it belongs to @self.
     */
    peekStats(): BearerStats

    // Class property signals of ModemManager-1.0.ModemManager.Bearer

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::bearer-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::bearer-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::bearer-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::bearer-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::bearer-type", ...args: any[]): void
    connect(sigName: "notify::connected", callback: (...args: any[]) => void): number
    on(sigName: "notify::connected", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::connected", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::connected", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::connected", ...args: any[]): void
    connect(sigName: "notify::connection-error", callback: (...args: any[]) => void): number
    on(sigName: "notify::connection-error", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::connection-error", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::connection-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::connection-error", ...args: any[]): void
    connect(sigName: "notify::interface", callback: (...args: any[]) => void): number
    on(sigName: "notify::interface", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::interface", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::interface", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::interface", ...args: any[]): void
    connect(sigName: "notify::ip-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::ip-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ip-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ip-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ip-timeout", ...args: any[]): void
    connect(sigName: "notify::ip4-config", callback: (...args: any[]) => void): number
    on(sigName: "notify::ip4-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ip4-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ip4-config", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ip4-config", ...args: any[]): void
    connect(sigName: "notify::ip6-config", callback: (...args: any[]) => void): number
    on(sigName: "notify::ip6-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ip6-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ip6-config", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ip6-config", ...args: any[]): void
    connect(sigName: "notify::multiplexed", callback: (...args: any[]) => void): number
    on(sigName: "notify::multiplexed", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::multiplexed", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::multiplexed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::multiplexed", ...args: any[]): void
    connect(sigName: "notify::profile-id", callback: (...args: any[]) => void): number
    on(sigName: "notify::profile-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::profile-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::profile-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::profile-id", ...args: any[]): void
    connect(sigName: "notify::properties", callback: (...args: any[]) => void): number
    on(sigName: "notify::properties", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::properties", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::properties", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::properties", ...args: any[]): void
    connect(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void): number
    on(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::reload-stats-supported", ...args: any[]): void
    connect(sigName: "notify::stats", callback: (...args: any[]) => void): number
    on(sigName: "notify::stats", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::stats", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::stats", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::stats", ...args: any[]): void
    connect(sigName: "notify::suspended", callback: (...args: any[]) => void): number
    on(sigName: "notify::suspended", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::suspended", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::suspended", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::suspended", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMBearer structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class Bearer extends GdbusBearerProxy {

    // Own properties of ModemManager-1.0.ModemManager.Bearer

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Bearer

    constructor(config?: Bearer.ConstructorProperties) 
    _init(config?: Bearer.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Bearer.top_of_page">org.freedesktop.ModemManager1.Bearer</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_bearer_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_bearer_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_bearer_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_bearer_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_bearer_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module BearerIpConfig {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface BearerIpConfig {

    // Own properties of ModemManager-1.0.ModemManager.BearerIpConfig

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.BearerIpConfig

    /**
     * Gets the IP address to be used with this bearer.
     * @returns a string with the IP address, or #NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getAddress(): string | null
    /**
     * Gets the list of IP addresses of DNS servers to be used with this bearer.
     * @returns a %NULL-terminated array of strings. Do not free the returned value, it is owned by @self.
     */
    getDns(): string[]
    /**
     * Gets the IP address of the gateway to be used with this bearer.
     * @returns a string with the IP address, or #NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getGateway(): string | null
    /**
     * Gets the IP method to be used with this bearer.
     * @returns a #MMBearerIpMethod.
     */
    getMethod(): BearerIpMethod
    /**
     * Gets the MTU to be used with this bearer.
     * @returns the MTU.
     */
    getMtu(): number
    /**
     * Gets the network prefix to be used with this bearer.
     * @returns the network prefix.
     */
    getPrefix(): number

    // Class property signals of ModemManager-1.0.ModemManager.BearerIpConfig

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMBearerIpConfig structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class BearerIpConfig extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.BearerIpConfig

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.BearerIpConfig

    constructor(config?: BearerIpConfig.ConstructorProperties) 
    _init(config?: BearerIpConfig.ConstructorProperties): void
}

export module BearerProperties {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface BearerProperties {

    // Own properties of ModemManager-1.0.ModemManager.BearerProperties

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.BearerProperties

    /**
     * Gets the 5G network access type preference.
     * @returns a #MMBearerAccessTypePreference value.
     */
    getAccessTypePreference(): BearerAccessTypePreference
    /**
     * Checks whether roaming is allowed in the connection.
     * @returns %TRUE if roaming is allowed, %FALSE otherwise.
     */
    getAllowRoaming(): boolean
    /**
     * Gets the authentication methods allowed in the connection.
     * @returns a bitmask of #MMBearerAllowedAuth values, or %MM_BEARER_ALLOWED_AUTH_UNKNOWN to request the modem-default method.
     */
    getAllowedAuth(): BearerAllowedAuth
    /**
     * Gets the name of the access point to use when connecting.
     * @returns the access point, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getApn(): string | null
    /**
     * Gets the APN types to use.
     * @returns a mask of #MMBearerApnType values.
     */
    getApnType(): BearerApnType
    /**
     * Sets the IP type to use.
     * @returns a #MMBearerIpFamily.
     */
    getIpType(): BearerIpFamily
    /**
     * Gets the type of multiplex support requested by the user.
     * @returns a #MMBearerMultiplexSupport.
     */
    getMultiplex(): BearerMultiplexSupport
    /**
     * Gets the number to use when performing the connection.
     * @returns the number, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getNumber(): string | null
    /**
     * Gets the password used to authenticate with the access point.
     * @returns the password, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getPassword(): string | null
    /**
     * Gets the profile ID to use.
     * @returns the profile id.
     */
    getProfileId(): number
    /**
     * Gets the name of the profile to use when connecting.
     * @returns the profile name, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getProfileName(): string | null
    /**
     * Gets the RM protocol requested to use in the CDMA connection.
     * @returns a #MMModemCdmaRmProtocol.
     */
    getRmProtocol(): ModemCdmaRmProtocol
    /**
     * Gets the roaming allowance rules.
     * @returns a mask of #MMBearerRoamingAllowance values.
     */
    getRoamingAllowance(): BearerRoamingAllowance
    /**
     * Gets the username used to authenticate with the access point.
     * @returns the username, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getUser(): string | null
    /**
     * Sets the 5G network access type preference.
     * @param accessTypePreference a #MMBearerAccessTypePreference value.
     */
    setAccessTypePreference(accessTypePreference: BearerAccessTypePreference): void
    /**
     * Sets the flag to indicate whether roaming is allowed or not in the
     * connection.
     * @param allowRoaming boolean value.
     */
    setAllowRoaming(allowRoaming: boolean): void
    /**
     * Sets the authentication method to use.
     * @param allowedAuth a bitmask of #MMBearerAllowedAuth values.  %MM_BEARER_ALLOWED_AUTH_UNKNOWN may be given to request the modem-default  method.
     */
    setAllowedAuth(allowedAuth: BearerAllowedAuth): void
    /**
     * Sets the name of the access point to use when connecting.
     * @param apn Name of the access point.
     */
    setApn(apn: string | null): void
    /**
     * Sets the APN types to use.
     * @param apnType a mask of #MMBearerApnType values.
     */
    setApnType(apnType: BearerApnType): void
    /**
     * Sets the IP type to use.
     * @param ipType a #MMBearerIpFamily.
     */
    setIpType(ipType: BearerIpFamily): void
    /**
     * Gets the type of multiplex support requested by the user.
     * @param multiplex a #MMBearerMultiplexSupport.
     */
    setMultiplex(multiplex: BearerMultiplexSupport): void
    /**
     * Sets the number to use when performing the connection.
     * @param number the number.
     */
    setNumber(number: string | null): void
    /**
     * Sets the password used to authenticate with the access point.
     * @param password the password
     */
    setPassword(password: string | null): void
    /**
     * Sets the profile ID to use.
     * @param profileId a profile id.
     */
    setProfileId(profileId: number): void
    /**
     * Sets the name of the profile to use when connecting.
     * @param profileName Name of the profile.
     */
    setProfileName(profileName: string | null): void
    /**
     * Sets the RM protocol to use in the CDMA connection.
     * @param protocol a #MMModemCdmaRmProtocol.
     */
    setRmProtocol(protocol: ModemCdmaRmProtocol): void
    /**
     * Sets the roaming allowance rules.
     * @param roamingAllowance a mask of #MMBearerRoamingAllowance values
     */
    setRoamingAllowance(roamingAllowance: BearerRoamingAllowance): void
    /**
     * Sets the username used to authenticate with the access point.
     * @param user the username
     */
    setUser(user: string | null): void

    // Class property signals of ModemManager-1.0.ModemManager.BearerProperties

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMBearerProperties structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class BearerProperties extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.BearerProperties

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.BearerProperties

    constructor(config?: BearerProperties.ConstructorProperties) 
    /**
     * Creates a new empty #MMBearerProperties.
     * @constructor 
     * @returns a #MMBearerProperties. The returned value should be freed with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new empty #MMBearerProperties.
     * @constructor 
     * @returns a #MMBearerProperties. The returned value should be freed with g_object_unref().
     */
    static new(): BearerProperties
    _init(config?: BearerProperties.ConstructorProperties): void
}

export module BearerStats {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface BearerStats {

    // Own properties of ModemManager-1.0.ModemManager.BearerStats

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.BearerStats

    /**
     * Gets the number of connection attempts done with this bearer.
     * @returns a #guint.
     */
    getAttempts(): number
    /**
     * Gets the speed of the downlink, in bits per second.
     * @returns a #guint64.
     */
    getDownlinkSpeed(): number
    /**
     * Gets the duration of the current connection, in seconds.
     * @returns a #guint.
     */
    getDuration(): number
    /**
     * Gets the number of failed connection attempts done with this bearer.
     * @returns a #guint.
     */
    getFailedAttempts(): number
    /**
     * Gets the number of bytes received without error in the connection.
     * @returns a #guint64.
     */
    getRxBytes(): number
    /**
     * Gets the start date of the current connection as a timestamp in seconds
     * since the epoch.
     * @returns a #guint64.
     */
    getStartDate(): number
    /**
     * Gets the total duration of all the connections of this bearer.
     * @returns a #guint.
     */
    getTotalDuration(): number
    /**
     * Gets the total number of bytes received without error during all the
     * connections of this bearer.
     * @returns a #guint64.
     */
    getTotalRxBytes(): number
    /**
     * Gets the total number of bytes transmitted without error during all the
     * connections of this bearer.
     * @returns a #guint64.
     */
    getTotalTxBytes(): number
    /**
     * Gets the number of bytes transmitted without error in the connection.
     * @returns a #guint64.
     */
    getTxBytes(): number
    /**
     * Gets the speed of the uplink, in bits per second.
     * @returns a #guint64.
     */
    getUplinkSpeed(): number

    // Class property signals of ModemManager-1.0.ModemManager.BearerStats

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMBearerStats structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class BearerStats extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.BearerStats

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.BearerStats

    constructor(config?: BearerStats.ConstructorProperties) 
    _init(config?: BearerStats.ConstructorProperties): void
}

export module Call {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusCall.ConstructorProperties, GdbusCallProxy.ConstructorProperties {
    }

}

export interface Call extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusCall {

    // Own properties of ModemManager-1.0.ModemManager.Call

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Call

    /**
     * Asynchronously requests to accept the incoming call.
     * 
     * Call objects can only be executed once.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_call_accept_finish() to get the result of the operation.
     * 
     * See mm_call_accept_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    accept(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_call_accept().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_call_accept().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    acceptFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to accept the incoming call.
     * 
     * Call objects can only be sent once.
     * 
     * The calling thread is blocked until an incoming call is ready.
     * See mm_call_accept() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    acceptSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously requests to deflect the incoming call.
     * 
     * This call will be considered terminated once the deflection is performed.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_call_deflect_finish() to get the result of the operation.
     * 
     * See mm_call_deflect_sync() for the synchronous, blocking version of this
     * method.
     * @param number new number where the call will be deflected.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    deflect(number: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_call_deflect().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_call_deflect().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    deflectFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to deflect the incoming call.
     * 
     * This call will be considered terminated once the deflection is performed.
     * 
     * The calling thread is blocked until an incoming call is ready.
     * See mm_call_deflect() for the asynchronous version of this method.
     * @param number new number where the call will be deflected.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    deflectSync(number: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets the kernel device used for audio (if any).
     * @returns The audio port, or %NULL if call audio is not routed via the host or couldn't be retrieved.
     */
    dupAudioPort(): string | null
    /**
     * Gets the call number. In outgoing calls contains the dialing number or
     * the remote number in incoming calls
     * @returns The number, or %NULL if it couldn't be retrieved. The returned value should be freed with g_free().
     */
    dupNumber(): string | null
    /**
     * Gets a copy of the DBus path of the #MMCall object.
     * @returns The DBus path of the #MMCall object. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets a #MMCallAudioFormat object specifying the audio format used by the
     * audio port if call audio is routed via the host.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_call_get_audio_format() again to get a new #MMCallAudioFormat with the
     * new values.</warning>
     * @returns A #MMCallAudioFormat that must be freed with g_object_unref() or %NULL if unknown.
     */
    getAudioFormat(): CallAudioFormat
    /**
     * Gets the kernel device used for audio (if any).
     * @returns The audio port, or %NULL if call audio is not routed via the host or couldn't be retrieved.
     */
    getAudioPort(): string | null
    /**
     * Gets the call direction.
     * @returns a #MMCallDirection.
     */
    getDirection(): CallDirection
    /**
     * Gets whether the call is part of a multiparty call.
     * @returns %TRUE if the call is part of a multiparty call, %FALSE otherwise.
     */
    getMultiparty(): boolean
    /**
     * Gets the call number. In outgoing calls contains the dialing number or
     * the remote number in incoming calls
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_call_dup_number() if on another
     * thread.</warning>
     * @returns The number, or %NULL if it couldn't be retrieved.
     */
    getNumber(): string | null
    /**
     * Gets the DBus path of the #MMCall object.
     * @returns The DBus path of the #MMCall object.
     */
    getPath(): string | null
    /**
     * Gets the current state of call.
     * @returns a #MMCallState.
     */
    getState(): CallState
    /**
     * Gets the reason of why the call changes its state.
     * @returns a #MMCallStateReason.
     */
    getStateReason(): CallStateReason
    /**
     * Asynchronously requests to hangup the call.
     * 
     * Call objects can only be executed once.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_call_hangup_finish() to get the result of the operation.
     * 
     * See mm_call_hangup_sync() for the synchronous, blocking version of this
     * method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    hangup(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_call_hangup().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_call_hangup().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    hangupFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to hangup the call.
     * 
     * Call objects can only be sent once.
     * 
     * The calling thread is blocked until an incoming call is ready.
     * See mm_call_hangup() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    hangupSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Synchronously requests to join this call into a multiparty call.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_call_join_multiparty_finish() to get the result of the operation.
     * 
     * See mm_call_join_multiparty_sync() for the synchronous, blocking version of
     * this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    joinMultiparty(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_call_join_multiparty().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_call_join_multiparty().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    joinMultipartyFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to join this call into a multiparty call.
     * 
     * The calling thread is blocked until an incoming call is ready.
     * See mm_call_join_multiparty() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    joinMultipartySync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Synchronously requests to make this call private again by leaving the
     * multiparty call.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_call_leave_multiparty_finish() to get the result of the operation.
     * 
     * See mm_call_leave_multiparty_sync() for the synchronous, blocking version
     * of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    leaveMultiparty(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_call_leave_multiparty().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_call_leave_multiparty().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    leaveMultipartyFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to make this call private again by leaving the
     * multiparty call.
     * 
     * The calling thread is blocked until an incoming call is ready.
     * See mm_call_leave_multiparty() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    leaveMultipartySync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a #MMCallAudioFormat object specifying the audio format used by the
     * audio port if call audio is routed via the host.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_call_get_audio_format() if on another
     * thread.</warning>
     * @returns A #MMCallAudioFormat. Do not free the returned value, it belongs to @self.
     */
    peekAudioFormat(): CallAudioFormat
    /**
     * Asynchronously requests to send a DTMF tone the call.
     * 
     * Call objects can only be executed once.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_call_send_dtmf_finish() to get the result of the operation.
     * 
     * See mm_call_send_dtmf_sync() for the synchronous, blocking version of this
     * method.
     * @param dtmf the DMTF tone.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    sendDtmf(dtmf: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_call_send_dtmf().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_call_send_dtmf().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    sendDtmfFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to send a DTMF tone the call.
     * 
     * Call objects can only be sent once.
     * 
     * The calling thread is blocked until an incoming call is ready.
     * See mm_call_send_dtmf() for the asynchronous version of this method.
     * @param dtmf the DMTF tone.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    sendDtmfSync(dtmf: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously requests to queue the call.
     * 
     * Call objects can only be executed once.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_call_start_finish() to get the result of the operation.
     * 
     * See mm_call_start_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    start(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_call_start().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_call_start().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    startFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to queue the call for delivery.
     * 
     * Call objects can only be sent once.
     * 
     * The calling thread is blocked until a reply is received.
     * See mm_call_start() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    startSync(cancellable: Gio.Cancellable | null): boolean

    // Class property signals of ModemManager-1.0.ModemManager.Call

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::audio-format", callback: (...args: any[]) => void): number
    on(sigName: "notify::audio-format", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::audio-format", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::audio-format", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::audio-format", ...args: any[]): void
    connect(sigName: "notify::audio-port", callback: (...args: any[]) => void): number
    on(sigName: "notify::audio-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::audio-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::audio-port", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::audio-port", ...args: any[]): void
    connect(sigName: "notify::direction", callback: (...args: any[]) => void): number
    on(sigName: "notify::direction", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::direction", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::direction", ...args: any[]): void
    connect(sigName: "notify::multiparty", callback: (...args: any[]) => void): number
    on(sigName: "notify::multiparty", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::multiparty", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::multiparty", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::multiparty", ...args: any[]): void
    connect(sigName: "notify::number", callback: (...args: any[]) => void): number
    on(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::number", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::number", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::state-reason", callback: (...args: any[]) => void): number
    on(sigName: "notify::state-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state-reason", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMCall structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class Call extends GdbusCallProxy {

    // Own properties of ModemManager-1.0.ModemManager.Call

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Call

    constructor(config?: Call.ConstructorProperties) 
    _init(config?: Call.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Call.top_of_page">org.freedesktop.ModemManager1.Call</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_call_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_call_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_call_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_call_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_call_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module CallAudioFormat {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface CallAudioFormat {

    // Own properties of ModemManager-1.0.ModemManager.CallAudioFormat

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.CallAudioFormat

    /**
     * Gets the encoding of the audio format.  For example, "pcm" for PCM-encoded
     * audio.
     * @returns a string with the encoding, or #NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getEncoding(): string | null
    /**
     * Gets the sampling rate of the audio format.  For example, 8000 for an 8000hz
     * sampling rate.
     * @returns the sampling rate, or 0 if unknown.
     */
    getRate(): number
    /**
     * Gets the resolution of the audio format.  For example, "s16le" for signed
     * 16-bit little-endian audio sampling resolution.
     * @returns a string with the resolution, or #NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getResolution(): string | null

    // Class property signals of ModemManager-1.0.ModemManager.CallAudioFormat

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMCallAudioFormat structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class CallAudioFormat extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.CallAudioFormat

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.CallAudioFormat

    constructor(config?: CallAudioFormat.ConstructorProperties) 
    _init(config?: CallAudioFormat.ConstructorProperties): void
}

export module CallProperties {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface CallProperties {

    // Own properties of ModemManager-1.0.ModemManager.CallProperties

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.CallProperties

    getDictionary(): GLib.Variant
    /**
     * Gets the call direction.
     * @returns the call direction.
     */
    getDirection(): CallDirection
    /**
     * Gets the number, in UTF-8.
     * @returns the call number, or %NULL if it doesn't contain any (anonymous caller). Do not free the returned value, it is owned by @self.
     */
    getNumber(): string | null
    /**
     * Gets the call state.
     * @returns the call state.
     */
    getState(): CallState
    /**
     * Gets the call state reason.
     * @returns the call state reason.
     */
    getStateReason(): CallStateReason
    /**
     * Sets the call direction.
     * @param direction the call direction
     */
    setDirection(direction: CallDirection): void
    /**
     * Sets the call number.
     * @param text The number to set, in UTF-8.
     */
    setNumber(text: string | null): void
    /**
     * Sets the call state
     * @param state the call state
     */
    setState(state: CallState): void
    /**
     * Sets the call state reason.
     * @param stateReason the call state reason.
     */
    setStateReason(stateReason: CallStateReason): void

    // Class property signals of ModemManager-1.0.ModemManager.CallProperties

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMCallProperties structure contains private data and should only be
 * accessed using the provided API.
 * @class 
 */
export class CallProperties extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.CallProperties

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.CallProperties

    constructor(config?: CallProperties.ConstructorProperties) 
    /**
     * Creates a new empty #MMCallProperties.
     * @constructor 
     * @returns a #MMCallProperties. The returned value should be freed with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new empty #MMCallProperties.
     * @constructor 
     * @returns a #MMCallProperties. The returned value should be freed with g_object_unref().
     */
    static new(): CallProperties
    static newFromDictionary(dictionary: GLib.Variant): CallProperties
    static newFromString(str: string | null): CallProperties
    _init(config?: CallProperties.ConstructorProperties): void
}

export module CdmaManualActivationProperties {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface CdmaManualActivationProperties {

    // Own properties of ModemManager-1.0.ModemManager.CdmaManualActivationProperties

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.CdmaManualActivationProperties

    /**
     * Gets the Mobile Directory Number.
     * @returns The MDN. Do not free the returned value, it is owned by @self.
     */
    getMdn(): string | null
    /**
     * Gets the Mobile Indentification Number.
     * @returns The MIN. Do not free the returned value, it is owned by @self.
     */
    getMin(): string | null
    /**
     * Gets the MN-AAA key.
     * @returns The MN-AAA key. Do not free the returned value, it is owned by @self.
     */
    getMnAaaKey(): string | null
    /**
     * Gets the MN-HA key.
     * @returns The MN-HA key. Do not free the returned value, it is owned by @self.
     */
    getMnHaKey(): string | null
    /**
     * Gets the Preferred Roaming List.
     * @returns The PRL. Do not free the returned value, it is owned by @self.
     */
    getPrl(): [ /* returnType */ number, /* prlLen */ number ]
    /**
     * Gets the Preferred Roaming List.
     * @returns A #GByteArray with the PRL, or %NULL if it doesn't contain any. The returned value should be freed with g_byte_array_unref().
     */
    getPrlBytearray(): number[]
    /**
     * Gets the System Identification Number.
     * @returns The SID.
     */
    getSid(): number
    /**
     * Gets the Service Programming Code.
     * @returns The SPC. Do not free the returned value, it is owned by @self.
     */
    getSpc(): string | null
    /**
     * Gets the Preferred Roaming List.
     * @returns A #GByteArray with the PRL, or %NULL if it doesn't contain any. Do not free the returned value, it is owned by @self.
     */
    peekPrlBytearray(): number[]
    /**
     * Sets the Mobile Directory Number.
     * @param mdn The MDN string, maximum 15 characters.
     * @returns %TRUE if the MDN was successfully set, or %FALSE if @error is set.
     */
    setMdn(mdn: string | null): boolean
    /**
     * Sets the Mobile Identification Number.
     * @param min The MIN string, maximum 15 characters.
     * @returns %TRUE if the MIN was successfully set, or %FALSE if @error is set.
     */
    setMin(min: string | null): boolean
    /**
     * Sets the Mobile Identification Number.
     * @param mnAaaKey The MN-AAA key string, maximum 16 characters.
     * @returns %TRUE if the MN-AAA key was successfully set, or %FALSE if @error is set.
     */
    setMnAaaKey(mnAaaKey: string | null): boolean
    /**
     * Sets the Mobile Identification Number.
     * @param mnHaKey The MN-HA key string, maximum 16 characters.
     * @returns %TRUE if the MN-HA key was successfully set, or %FALSE if @error is set.
     */
    setMnHaKey(mnHaKey: string | null): boolean
    /**
     * Sets the Preferred Roaming List.
     * @param prl The PRL.
     * @param prlLength Length of `prl`.
     * @returns %TRUE if the PRL was successfully set, or %FALSE if @error is set.
     */
    setPrl(prl: number, prlLength: number): boolean
    /**
     * Sets the Preferred Roaming List.
     * @param prl A #GByteArray with the PRL to set. This method takes a new reference  of `prl`.
     * @returns %TRUE if the PRL was successfully set, or %FALSE if @error is set.
     */
    setPrlBytearray(prl: number[]): boolean
    /**
     * Sets the Service Identification Number.
     * @param sid The SID.
     */
    setSid(sid: number): void
    /**
     * Sets the Service Programming Code.
     * @param spc The SPC string, exactly 6 digits.
     * @returns %TRUE if the SPC was successfully set, or %FALSE if @error is set.
     */
    setSpc(spc: string | null): boolean

    // Class property signals of ModemManager-1.0.ModemManager.CdmaManualActivationProperties

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMCdmaManualActivationProperties structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class CdmaManualActivationProperties extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.CdmaManualActivationProperties

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.CdmaManualActivationProperties

    constructor(config?: CdmaManualActivationProperties.ConstructorProperties) 
    /**
     * Creates a new #MMCdmaManualActivationProperties object.
     * @constructor 
     * @returns A #MMCdmaManualActivationProperties. The returned value should be freed with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new #MMCdmaManualActivationProperties object.
     * @constructor 
     * @returns A #MMCdmaManualActivationProperties. The returned value should be freed with g_object_unref().
     */
    static new(): CdmaManualActivationProperties
    _init(config?: CdmaManualActivationProperties.ConstructorProperties): void
}

export module CellInfo {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface CellInfo {

    // Own properties of ModemManager-1.0.ModemManager.CellInfo

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.CellInfo

    /**
     * Get the type of cell.
     * @returns a #MMCellType.
     */
    getCellType(): CellType
    /**
     * Get whether the cell is a serving cell or a neighboring cell.a
     * @returns %TRUE if the cell is a serving cell, %FALSE otherwise.
     */
    getServing(): boolean

    // Own virtual methods of ModemManager-1.0.ModemManager.CellInfo

    buildString(): GLib.String
    getDictionary(): GLib.VariantDict

    // Class property signals of ModemManager-1.0.ModemManager.CellInfo

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMCellInfo structure contains private data and should only be
 * accessed using the provided API.
 * @class 
 */
export class CellInfo extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.CellInfo

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.CellInfo

    constructor(config?: CellInfo.ConstructorProperties) 
    _init(config?: CellInfo.ConstructorProperties): void
}

export module CellInfoCdma {

    // Constructor properties interface

    export interface ConstructorProperties extends CellInfo.ConstructorProperties {
    }

}

export interface CellInfoCdma {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoCdma

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.CellInfoCdma

    /**
     * Get the CDMA base station id.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros.
     * @returns the CDMA base station id, or %NULL if not available.
     */
    getBaseStationId(): string | null
    /**
     * Get the CDMA network id.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros.
     * @returns the CDMA network id, or %NULL if not available.
     */
    getNid(): string | null
    /**
     * Get the signal strength of the pilot.
     * 
     * Given in the same format and scale as the GSM SINR level.
     * @returns the pilot strength, or %G_MAXUINT if not available.
     */
    getPilotStrength(): number
    /**
     * Get the CDMA base station PN number.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros.
     * @returns the CDMA base station PN number, or %NULL if not available.
     */
    getRefPn(): string | null
    /**
     * Get the CDMA system id.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros.
     * @returns the CDMA system id, or %NULL if not available.
     */
    getSid(): string | null

    // Class property signals of ModemManager-1.0.ModemManager.CellInfoCdma

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMCellInfoCdma structure contains private data and should only be
 * accessed using the provided API.
 * @class 
 */
export class CellInfoCdma extends CellInfo {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoCdma

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.CellInfoCdma

    constructor(config?: CellInfoCdma.ConstructorProperties) 
    _init(config?: CellInfoCdma.ConstructorProperties): void
}

export module CellInfoGsm {

    // Constructor properties interface

    export interface ConstructorProperties extends CellInfo.ConstructorProperties {
    }

}

export interface CellInfoGsm {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoGsm

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.CellInfoGsm

    /**
     * Get the absolute RF channel number.
     * @returns the ARFCN, or %G_MAXUINT if not available.
     */
    getArfcn(): number
    /**
     * Get the GSM base station id, in upper-case hexadecimal format without leading
     * zeros. E.g. "3F".
     * @returns the GSM base station id, or %NULL if not available.
     */
    getBaseStationId(): string | null
    /**
     * Get the two- or four-byte Cell Identifier.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros,
     * as specified in 3GPP TS 27.007.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getCi(): string | null
    /**
     * Get the two-byte Location Area Code of the base station.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros,
     * as specified in 3GPP TS 27.007.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getLac(): string | null
    /**
     * Get the PLMN MCC/MNC.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getOperatorId(): string | null
    /**
     * Get the serving cell RX measurement.
     * @returns the rx level, or %G_MAXUINT if not available.
     */
    getRxLevel(): number
    /**
     * Get the measured delay (in bit periods) of an access burst transmission
     * on the RACH or PRACH to the expected signal from a mobile station at zero
     * distance under static channel conditions.
     * @returns the timing advance, or %G_MAXUINT if not available.
     */
    getTimingAdvance(): number

    // Class property signals of ModemManager-1.0.ModemManager.CellInfoGsm

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMCellInfoGsm structure contains private data and should only be
 * accessed using the provided API.
 * @class 
 */
export class CellInfoGsm extends CellInfo {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoGsm

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.CellInfoGsm

    constructor(config?: CellInfoGsm.ConstructorProperties) 
    _init(config?: CellInfoGsm.ConstructorProperties): void
}

export module CellInfoLte {

    // Constructor properties interface

    export interface ConstructorProperties extends CellInfo.ConstructorProperties {
    }

}

export interface CellInfoLte {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoLte

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.CellInfoLte

    /**
     * Get the bandwidth of the particular carrier in downlink.
     * @returns the bandwidth, or %G_MAXUINT if not available.
     */
    getBandwidth(): number
    /**
     * Get the two- or four-byte Cell Identifier.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros,
     * as specified in 3GPP TS 27.007.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getCi(): string | null
    /**
     * Get the E-UTRA absolute RF channel number.
     * @returns the EARFCN, or %G_MAXUINT if not available.
     */
    getEarfcn(): number
    /**
     * Get the PLMN MCC/MNC.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getOperatorId(): string | null
    /**
     * Get the physical cell identifier.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros,
     * as specified in 3GPP TS 27.007.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getPhysicalCi(): string | null
    /**
     * Get the average reference signal received power in dBm.
     * @returns the RSRP, or -%G_MAXDOUBLE if not available.
     */
    getRsrp(): number
    /**
     * Get the average reference signal received quality in dB.
     * @returns the RSRQ, or -%G_MAXDOUBLE if not available.
     */
    getRsrq(): number
    /**
     * Get the serving cell type.
     * @returns the serving cell type, or %MM_SERVING_CELL_TYPE_INVALID if not available.
     */
    getServingCellType(): ServingCellType
    /**
     * Get the two- or three- byte Tracking Area Code of the base station.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros,
     * as specified in 3GPP TS 27.007.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getTac(): string | null
    /**
     * Get the timing advance.
     * @returns the timing advance, or %G_MAXUINT if not available.
     */
    getTimingAdvance(): number

    // Class property signals of ModemManager-1.0.ModemManager.CellInfoLte

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMCellInfoLte structure contains private data and should only be
 * accessed using the provided API.
 * @class 
 */
export class CellInfoLte extends CellInfo {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoLte

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.CellInfoLte

    constructor(config?: CellInfoLte.ConstructorProperties) 
    _init(config?: CellInfoLte.ConstructorProperties): void
}

export module CellInfoNr5g {

    // Constructor properties interface

    export interface ConstructorProperties extends CellInfo.ConstructorProperties {
    }

}

export interface CellInfoNr5g {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoNr5g

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.CellInfoNr5g

    /**
     * Get the bandwidth of the particular carrier in downlink.
     * @returns the bandwidth, or %G_MAXUINT if not available.
     */
    getBandwidth(): number
    /**
     * Get the two- or four-byte Cell Identifier.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros,
     * as specified in 3GPP TS 27.007.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getCi(): string | null
    /**
     * Get the NR absolute RF channel number.
     * @returns the NRARFCN, or %G_MAXUINT if not available.
     */
    getNrarfcn(): number
    /**
     * Get the PLMN MCC/MNC.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getOperatorId(): string | null
    /**
     * Get the physical cell identifier.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros,
     * as specified in 3GPP TS 27.007.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getPhysicalCi(): string | null
    /**
     * Get the average reference signal received power in dBm.
     * @returns the RSRP, or -%G_MAXDOUBLE if not available.
     */
    getRsrp(): number
    /**
     * Get the average reference signal received quality in dB.
     * @returns the RSRQ, or -%G_MAXDOUBLE if not available.
     */
    getRsrq(): number
    /**
     * Get the serving cell type.
     * @returns the serving cell type, or %MM_SERVING_CELL_TYPE_INVALID if not available.
     */
    getServingCellType(): ServingCellType
    /**
     * Get the signal to interference and noise ratio.
     * @returns the SINR, or -%G_MAXDOUBLE if not available.
     */
    getSinr(): number
    /**
     * Get the two- or three- byte Tracking Area Code of the base station.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros,
     * as specified in 3GPP TS 27.007.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getTac(): string | null
    /**
     * Get the timing advance.
     * @returns the timing advance, or %G_MAXUINT if not available.
     */
    getTimingAdvance(): number

    // Class property signals of ModemManager-1.0.ModemManager.CellInfoNr5g

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMCellInfoNr5g structure contains private data and should only be
 * accessed using the provided API.
 * @class 
 */
export class CellInfoNr5g extends CellInfo {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoNr5g

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.CellInfoNr5g

    constructor(config?: CellInfoNr5g.ConstructorProperties) 
    _init(config?: CellInfoNr5g.ConstructorProperties): void
}

export module CellInfoTdscdma {

    // Constructor properties interface

    export interface ConstructorProperties extends CellInfo.ConstructorProperties {
    }

}

export interface CellInfoTdscdma {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoTdscdma

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.CellInfoTdscdma

    /**
     * Get the cell parameter id.
     * @returns the cell parameter id, or %G_MAXUINT if not available.
     */
    getCellParameterId(): number
    /**
     * Get the two- or four-byte Cell Identifier.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros,
     * as specified in 3GPP TS 27.007.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getCi(): string | null
    /**
     * Get the two-byte Location Area Code of the base station.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros,
     * as specified in 3GPP TS 27.007.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getLac(): string | null
    /**
     * Get the PLMN MCC/MNC.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getOperatorId(): string | null
    /**
     * Get the path loss of the cell.
     * @returns the path loss, or %G_MAXUINT if not available.
     */
    getPathLoss(): number
    /**
     * Get the received signal code power.
     * @returns the RSCP, or -%G_MAXDOUBLE if not available.
     */
    getRscp(): number
    /**
     * Get the measured delay (in bit periods) of an access burst transmission
     * on the RACH or PRACH to the expected signal from a mobile station at zero
     * distance under static channel conditions.
     * @returns the timing advance, or %G_MAXUINT if not available.
     */
    getTimingAdvance(): number
    /**
     * Get the UTRA absolute RF channel number.
     * @returns the UARFCN, or %G_MAXUINT if not available.
     */
    getUarfcn(): number

    // Class property signals of ModemManager-1.0.ModemManager.CellInfoTdscdma

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMCellInfoTdscdma structure contains private data and should only be
 * accessed using the provided API.
 * @class 
 */
export class CellInfoTdscdma extends CellInfo {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoTdscdma

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.CellInfoTdscdma

    constructor(config?: CellInfoTdscdma.ConstructorProperties) 
    _init(config?: CellInfoTdscdma.ConstructorProperties): void
}

export module CellInfoUmts {

    // Constructor properties interface

    export interface ConstructorProperties extends CellInfo.ConstructorProperties {
    }

}

export interface CellInfoUmts {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoUmts

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.CellInfoUmts

    /**
     * Get the two- or four-byte Cell Identifier.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros,
     * as specified in 3GPP TS 27.007.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getCi(): string | null
    /**
     * Get the ECIO, the received energy per chip divided by the power density
     * in the band measured in dBm on the primary CPICH channel of the cell.
     * @returns the ECIO, or -%G_MAXDOUBLE if not available.
     */
    getEcio(): number
    /**
     * Get the frequency of the downlink in kHz while in FDD.
     * @returns the frequency, or %G_MAXUINT if not available.
     */
    getFrequencyFddDl(): number
    /**
     * Get the frequency of the uplink in kHz while in FDD.
     * @returns the frequency, or %G_MAXUINT if not available.
     */
    getFrequencyFddUl(): number
    /**
     * Get the frequency in kHz while in TDD.
     * @returns the frequency, or %G_MAXUINT if not available.
     */
    getFrequencyTdd(): number
    /**
     * Get the two-byte Location Area Code of the base station.
     * 
     * Encoded in upper-case hexadecimal format without leading zeros,
     * as specified in 3GPP TS 27.007.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getLac(): string | null
    /**
     * Get the PLMN MCC/MNC.
     * @returns the MCCMNC, or %NULL if not available.
     */
    getOperatorId(): string | null
    /**
     * Get the path loss of the cell.
     * @returns the path loss, or %G_MAXUINT if not available.
     */
    getPathLoss(): number
    /**
     * Get the primary scrambling code.
     * @returns the PSC, or %G_MAXUINT if not available.
     */
    getPsc(): number
    /**
     * Get the received signal code power.
     * @returns the RSCP, or -%G_MAXDOUBLE if not available.
     */
    getRscp(): number
    /**
     * Get the UTRA absolute RF channel number.
     * @returns the UARFCN, or %G_MAXUINT if not available.
     */
    getUarfcn(): number

    // Class property signals of ModemManager-1.0.ModemManager.CellInfoUmts

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMCellInfoUmts structure contains private data and should only be
 * accessed using the provided API.
 * @class 
 */
export class CellInfoUmts extends CellInfo {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoUmts

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.CellInfoUmts

    constructor(config?: CellInfoUmts.ConstructorProperties) 
    _init(config?: CellInfoUmts.ConstructorProperties): void
}

export module FirmwareProperties {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface FirmwareProperties {

    // Own properties of ModemManager-1.0.ModemManager.FirmwareProperties

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.FirmwareProperties

    getDictionary(): GLib.Variant
    /**
     * Gets the boot version of a firmware image of type
     * %MM_FIRMWARE_IMAGE_TYPE_GOBI.
     * @returns The boot version, or %NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getGobiBootVersion(): string | null
    /**
     * Gets the MODEM unique ID of a firmware image of type
     * %MM_FIRMWARE_IMAGE_TYPE_GOBI.
     * @returns The PRI unique ID, or %NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getGobiModemUniqueId(): string | null
    /**
     * Gets the PRI info of a firmware image of type %MM_FIRMWARE_IMAGE_TYPE_GOBI.
     * @returns The PRI info, or %NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getGobiPriInfo(): string | null
    /**
     * Gets the PRI unique ID of a firmware image of type
     * %MM_FIRMWARE_IMAGE_TYPE_GOBI.
     * @returns The PRI unique ID, or %NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getGobiPriUniqueId(): string | null
    /**
     * Gets the PRI version of a firmware image of type %MM_FIRMWARE_IMAGE_TYPE_GOBI.
     * @returns The PRI version, or %NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getGobiPriVersion(): string | null
    /**
     * Gets the type of the firmare image.
     * @returns A #MMFirmwareImageType specifying The type of the image.
     */
    getImageType(): FirmwareImageType
    /**
     * Gets the unique ID of the firmare image.
     * @returns The ID of the image. Do not free the returned value, it is owned by @self.
     */
    getUniqueId(): string | null
    setGobiBootVersion(version: string | null): void
    setGobiModemUniqueId(id: string | null): void
    setGobiPriInfo(info: string | null): void
    setGobiPriUniqueId(id: string | null): void
    setGobiPriVersion(version: string | null): void

    // Class property signals of ModemManager-1.0.ModemManager.FirmwareProperties

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMFirmwareProperties structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class FirmwareProperties extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.FirmwareProperties

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.FirmwareProperties

    constructor(config?: FirmwareProperties.ConstructorProperties) 
    constructor(imageType: FirmwareImageType, uniqueId: string | null) 
    static new(imageType: FirmwareImageType, uniqueId: string | null): FirmwareProperties
    static newFromDictionary(dictionary: GLib.Variant): FirmwareProperties
    _init(config?: FirmwareProperties.ConstructorProperties): void
}

export module FirmwareUpdateSettings {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface FirmwareUpdateSettings {

    // Own properties of ModemManager-1.0.ModemManager.FirmwareUpdateSettings

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.FirmwareUpdateSettings

    /**
     * Gets the list of device ids used to identify the device during a firmware
     * update operation.
     * @returns The list of device ids, or %NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getDeviceIds(): string[]
    /**
     * Gets the AT command that should be sent to the module to trigger a reset
     * into fastboot mode.
     * 
     * Only applicable if the update method includes
     * %MM_MODEM_FIRMWARE_UPDATE_METHOD_FASTBOOT.
     * @returns The AT command string, or %NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getFastbootAt(): string | null
    /**
     * Gets the methods to use during the firmware update operation.
     * @returns a bitmask of #MMModemFirmwareUpdateMethod values.
     */
    getMethod(): ModemFirmwareUpdateMethod
    /**
     * Gets firmware version string.
     * @returns The version string, or %NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getVersion(): string | null

    // Class property signals of ModemManager-1.0.ModemManager.FirmwareUpdateSettings

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMFirmwareUpdateSettings structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class FirmwareUpdateSettings extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.FirmwareUpdateSettings

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.FirmwareUpdateSettings

    constructor(config?: FirmwareUpdateSettings.ConstructorProperties) 
    _init(config?: FirmwareUpdateSettings.ConstructorProperties): void
}

export module GdbusBearerProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusBearer.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusBearerProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusBearer {

    // Own properties of ModemManager-1.0.ModemManager.GdbusBearerProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusBearerProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::bearer-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::bearer-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::bearer-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::bearer-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::bearer-type", ...args: any[]): void
    connect(sigName: "notify::connected", callback: (...args: any[]) => void): number
    on(sigName: "notify::connected", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::connected", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::connected", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::connected", ...args: any[]): void
    connect(sigName: "notify::connection-error", callback: (...args: any[]) => void): number
    on(sigName: "notify::connection-error", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::connection-error", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::connection-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::connection-error", ...args: any[]): void
    connect(sigName: "notify::interface", callback: (...args: any[]) => void): number
    on(sigName: "notify::interface", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::interface", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::interface", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::interface", ...args: any[]): void
    connect(sigName: "notify::ip-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::ip-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ip-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ip-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ip-timeout", ...args: any[]): void
    connect(sigName: "notify::ip4-config", callback: (...args: any[]) => void): number
    on(sigName: "notify::ip4-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ip4-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ip4-config", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ip4-config", ...args: any[]): void
    connect(sigName: "notify::ip6-config", callback: (...args: any[]) => void): number
    on(sigName: "notify::ip6-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ip6-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ip6-config", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ip6-config", ...args: any[]): void
    connect(sigName: "notify::multiplexed", callback: (...args: any[]) => void): number
    on(sigName: "notify::multiplexed", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::multiplexed", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::multiplexed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::multiplexed", ...args: any[]): void
    connect(sigName: "notify::profile-id", callback: (...args: any[]) => void): number
    on(sigName: "notify::profile-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::profile-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::profile-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::profile-id", ...args: any[]): void
    connect(sigName: "notify::properties", callback: (...args: any[]) => void): number
    on(sigName: "notify::properties", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::properties", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::properties", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::properties", ...args: any[]): void
    connect(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void): number
    on(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::reload-stats-supported", ...args: any[]): void
    connect(sigName: "notify::stats", callback: (...args: any[]) => void): number
    on(sigName: "notify::stats", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::stats", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::stats", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::stats", ...args: any[]): void
    connect(sigName: "notify::suspended", callback: (...args: any[]) => void): number
    on(sigName: "notify::suspended", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::suspended", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::suspended", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::suspended", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusBearerProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusBearerProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusBearerProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusBearerProxy

    constructor(config?: GdbusBearerProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_bearer_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_bearer_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusBearerProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_bearer_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_bearer_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusBearerProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_bearer_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_bearer_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusBearerProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Bearer.top_of_page">org.freedesktop.ModemManager1.Bearer</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_bearer_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusBearerProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusBearerProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Bearer.top_of_page">org.freedesktop.ModemManager1.Bearer</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_bearer_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_bearer_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_bearer_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_bearer_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_bearer_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusBearerSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusBearer.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusBearerSkeleton extends Gio.DBusInterface, GdbusBearer {

    // Own properties of ModemManager-1.0.ModemManager.GdbusBearerSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusBearerSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::bearer-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::bearer-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::bearer-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::bearer-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::bearer-type", ...args: any[]): void
    connect(sigName: "notify::connected", callback: (...args: any[]) => void): number
    on(sigName: "notify::connected", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::connected", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::connected", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::connected", ...args: any[]): void
    connect(sigName: "notify::connection-error", callback: (...args: any[]) => void): number
    on(sigName: "notify::connection-error", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::connection-error", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::connection-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::connection-error", ...args: any[]): void
    connect(sigName: "notify::interface", callback: (...args: any[]) => void): number
    on(sigName: "notify::interface", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::interface", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::interface", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::interface", ...args: any[]): void
    connect(sigName: "notify::ip-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::ip-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ip-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ip-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ip-timeout", ...args: any[]): void
    connect(sigName: "notify::ip4-config", callback: (...args: any[]) => void): number
    on(sigName: "notify::ip4-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ip4-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ip4-config", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ip4-config", ...args: any[]): void
    connect(sigName: "notify::ip6-config", callback: (...args: any[]) => void): number
    on(sigName: "notify::ip6-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ip6-config", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ip6-config", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ip6-config", ...args: any[]): void
    connect(sigName: "notify::multiplexed", callback: (...args: any[]) => void): number
    on(sigName: "notify::multiplexed", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::multiplexed", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::multiplexed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::multiplexed", ...args: any[]): void
    connect(sigName: "notify::profile-id", callback: (...args: any[]) => void): number
    on(sigName: "notify::profile-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::profile-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::profile-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::profile-id", ...args: any[]): void
    connect(sigName: "notify::properties", callback: (...args: any[]) => void): number
    on(sigName: "notify::properties", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::properties", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::properties", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::properties", ...args: any[]): void
    connect(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void): number
    on(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::reload-stats-supported", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::reload-stats-supported", ...args: any[]): void
    connect(sigName: "notify::stats", callback: (...args: any[]) => void): number
    on(sigName: "notify::stats", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::stats", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::stats", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::stats", ...args: any[]): void
    connect(sigName: "notify::suspended", callback: (...args: any[]) => void): number
    on(sigName: "notify::suspended", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::suspended", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::suspended", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::suspended", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusBearerSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusBearerSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusBearerSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusBearerSkeleton

    constructor(config?: GdbusBearerSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Bearer.top_of_page">org.freedesktop.ModemManager1.Bearer</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Bearer.top_of_page">org.freedesktop.ModemManager1.Bearer</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusBearerSkeleton
    _init(config?: GdbusBearerSkeleton.ConstructorProperties): void
}

export module GdbusCallProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusCall.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusCallProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusCall {

    // Own properties of ModemManager-1.0.ModemManager.GdbusCallProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusCallProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::audio-format", callback: (...args: any[]) => void): number
    on(sigName: "notify::audio-format", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::audio-format", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::audio-format", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::audio-format", ...args: any[]): void
    connect(sigName: "notify::audio-port", callback: (...args: any[]) => void): number
    on(sigName: "notify::audio-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::audio-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::audio-port", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::audio-port", ...args: any[]): void
    connect(sigName: "notify::direction", callback: (...args: any[]) => void): number
    on(sigName: "notify::direction", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::direction", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::direction", ...args: any[]): void
    connect(sigName: "notify::multiparty", callback: (...args: any[]) => void): number
    on(sigName: "notify::multiparty", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::multiparty", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::multiparty", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::multiparty", ...args: any[]): void
    connect(sigName: "notify::number", callback: (...args: any[]) => void): number
    on(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::number", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::number", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::state-reason", callback: (...args: any[]) => void): number
    on(sigName: "notify::state-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state-reason", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusCallProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusCallProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusCallProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusCallProxy

    constructor(config?: GdbusCallProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_call_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_call_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusCallProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_call_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_call_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusCallProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_call_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_call_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusCallProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Call.top_of_page">org.freedesktop.ModemManager1.Call</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_call_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusCallProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusCallProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Call.top_of_page">org.freedesktop.ModemManager1.Call</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_call_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_call_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_call_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_call_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_call_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusCallSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusCall.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusCallSkeleton extends Gio.DBusInterface, GdbusCall {

    // Own properties of ModemManager-1.0.ModemManager.GdbusCallSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusCallSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::audio-format", callback: (...args: any[]) => void): number
    on(sigName: "notify::audio-format", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::audio-format", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::audio-format", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::audio-format", ...args: any[]): void
    connect(sigName: "notify::audio-port", callback: (...args: any[]) => void): number
    on(sigName: "notify::audio-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::audio-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::audio-port", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::audio-port", ...args: any[]): void
    connect(sigName: "notify::direction", callback: (...args: any[]) => void): number
    on(sigName: "notify::direction", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::direction", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::direction", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::direction", ...args: any[]): void
    connect(sigName: "notify::multiparty", callback: (...args: any[]) => void): number
    on(sigName: "notify::multiparty", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::multiparty", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::multiparty", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::multiparty", ...args: any[]): void
    connect(sigName: "notify::number", callback: (...args: any[]) => void): number
    on(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::number", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::number", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::state-reason", callback: (...args: any[]) => void): number
    on(sigName: "notify::state-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state-reason", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusCallSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusCallSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusCallSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusCallSkeleton

    constructor(config?: GdbusCallSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Call.top_of_page">org.freedesktop.ModemManager1.Call</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Call.top_of_page">org.freedesktop.ModemManager1.Call</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusCallSkeleton
    _init(config?: GdbusCallSkeleton.ConstructorProperties): void
}

export module GdbusModem3gppProfileManagerProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModem3gppProfileManager.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModem3gppProfileManagerProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModem3gppProfileManager {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::index-field", callback: (...args: any[]) => void): number
    on(sigName: "notify::index-field", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::index-field", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::index-field", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::index-field", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModem3gppProfileManagerProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModem3gppProfileManagerProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerProxy

    constructor(config?: GdbusModem3gppProfileManagerProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_profile_manager_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_profile_manager_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModem3gppProfileManagerProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_profile_manager_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_profile_manager_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModem3gppProfileManagerProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem3gpp_profile_manager_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_profile_manager_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModem3gppProfileManagerProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_profile_manager_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModem3gppProfileManagerProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModem3gppProfileManagerProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_profile_manager_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_profile_manager_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem3gpp_profile_manager_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_profile_manager_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_profile_manager_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModem3gppProfileManagerSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModem3gppProfileManager.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModem3gppProfileManagerSkeleton extends Gio.DBusInterface, GdbusModem3gppProfileManager {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::index-field", callback: (...args: any[]) => void): number
    on(sigName: "notify::index-field", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::index-field", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::index-field", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::index-field", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModem3gppProfileManagerSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModem3gppProfileManagerSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerSkeleton

    constructor(config?: GdbusModem3gppProfileManagerSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModem3gppProfileManagerSkeleton
    _init(config?: GdbusModem3gppProfileManagerSkeleton.ConstructorProperties): void
}

export module GdbusModem3gppProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModem3gpp.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModem3gppProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModem3gpp {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModem3gppProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void): number
    on(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::enabled-facility-locks", ...args: any[]): void
    connect(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void): number
    on(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::eps-ue-mode-operation", ...args: any[]): void
    connect(sigName: "notify::imei", callback: (...args: any[]) => void): number
    on(sigName: "notify::imei", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::imei", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::imei", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::imei", ...args: any[]): void
    connect(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void): number
    on(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::initial-eps-bearer", ...args: any[]): void
    connect(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void): number
    on(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::initial-eps-bearer-settings", ...args: any[]): void
    connect(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void): number
    on(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::nr5g-registration-settings", ...args: any[]): void
    connect(sigName: "notify::operator-code", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-code", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-code", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-code", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-code", ...args: any[]): void
    connect(sigName: "notify::operator-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-name", ...args: any[]): void
    connect(sigName: "notify::packet-service-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::packet-service-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::packet-service-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::packet-service-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::packet-service-state", ...args: any[]): void
    connect(sigName: "notify::pco", callback: (...args: any[]) => void): number
    on(sigName: "notify::pco", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::pco", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::pco", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::pco", ...args: any[]): void
    connect(sigName: "notify::registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::registration-state", ...args: any[]): void
    connect(sigName: "notify::subscription-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::subscription-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::subscription-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::subscription-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::subscription-state", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModem3gppProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModem3gppProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModem3gppProxy

    constructor(config?: GdbusModem3gppProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModem3gppProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModem3gppProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem3gpp_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModem3gppProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModem3gppProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModem3gppProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem3gpp_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModem3gppSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModem3gpp.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModem3gppSkeleton extends Gio.DBusInterface, GdbusModem3gpp {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModem3gppSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void): number
    on(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::enabled-facility-locks", ...args: any[]): void
    connect(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void): number
    on(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::eps-ue-mode-operation", ...args: any[]): void
    connect(sigName: "notify::imei", callback: (...args: any[]) => void): number
    on(sigName: "notify::imei", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::imei", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::imei", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::imei", ...args: any[]): void
    connect(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void): number
    on(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::initial-eps-bearer", ...args: any[]): void
    connect(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void): number
    on(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::initial-eps-bearer-settings", ...args: any[]): void
    connect(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void): number
    on(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::nr5g-registration-settings", ...args: any[]): void
    connect(sigName: "notify::operator-code", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-code", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-code", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-code", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-code", ...args: any[]): void
    connect(sigName: "notify::operator-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-name", ...args: any[]): void
    connect(sigName: "notify::packet-service-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::packet-service-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::packet-service-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::packet-service-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::packet-service-state", ...args: any[]): void
    connect(sigName: "notify::pco", callback: (...args: any[]) => void): number
    on(sigName: "notify::pco", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::pco", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::pco", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::pco", ...args: any[]): void
    connect(sigName: "notify::registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::registration-state", ...args: any[]): void
    connect(sigName: "notify::subscription-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::subscription-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::subscription-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::subscription-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::subscription-state", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModem3gppSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModem3gppSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModem3gppSkeleton

    constructor(config?: GdbusModem3gppSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModem3gppSkeleton
    _init(config?: GdbusModem3gppSkeleton.ConstructorProperties): void
}

export module GdbusModem3gppUssdProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModem3gppUssd.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModem3gppUssdProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModem3gppUssd {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppUssdProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModem3gppUssdProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::network-notification", callback: (...args: any[]) => void): number
    on(sigName: "notify::network-notification", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::network-notification", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::network-notification", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::network-notification", ...args: any[]): void
    connect(sigName: "notify::network-request", callback: (...args: any[]) => void): number
    on(sigName: "notify::network-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::network-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::network-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::network-request", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModem3gppUssdProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModem3gppUssdProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppUssdProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModem3gppUssdProxy

    constructor(config?: GdbusModem3gppUssdProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_ussd_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_ussd_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModem3gppUssdProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem3gpp_ussd_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_ussd_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModem3gppUssdProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem3gpp_ussd_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_ussd_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModem3gppUssdProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem3gpp_ussd_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModem3gppUssdProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModem3gppUssdProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_ussd_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_ussd_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem3gpp_ussd_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_ussd_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_ussd_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModem3gppUssdSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModem3gppUssd.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModem3gppUssdSkeleton extends Gio.DBusInterface, GdbusModem3gppUssd {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppUssdSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModem3gppUssdSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::network-notification", callback: (...args: any[]) => void): number
    on(sigName: "notify::network-notification", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::network-notification", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::network-notification", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::network-notification", ...args: any[]): void
    connect(sigName: "notify::network-request", callback: (...args: any[]) => void): number
    on(sigName: "notify::network-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::network-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::network-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::network-request", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModem3gppUssdSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModem3gppUssdSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppUssdSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModem3gppUssdSkeleton

    constructor(config?: GdbusModem3gppUssdSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModem3gppUssdSkeleton
    _init(config?: GdbusModem3gppUssdSkeleton.ConstructorProperties): void
}

export module GdbusModemCdmaProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemCdma.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModemCdmaProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemCdma {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemCdmaProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemCdmaProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::activation-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::activation-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::activation-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::activation-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::activation-state", ...args: any[]): void
    connect(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cdma1x-registration-state", ...args: any[]): void
    connect(sigName: "notify::esn", callback: (...args: any[]) => void): number
    on(sigName: "notify::esn", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::esn", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::esn", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::esn", ...args: any[]): void
    connect(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::evdo-registration-state", ...args: any[]): void
    connect(sigName: "notify::meid", callback: (...args: any[]) => void): number
    on(sigName: "notify::meid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::meid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::meid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::meid", ...args: any[]): void
    connect(sigName: "notify::nid", callback: (...args: any[]) => void): number
    on(sigName: "notify::nid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::nid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::nid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::nid", ...args: any[]): void
    connect(sigName: "notify::sid", callback: (...args: any[]) => void): number
    on(sigName: "notify::sid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sid", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemCdmaProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemCdmaProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemCdmaProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemCdmaProxy

    constructor(config?: GdbusModemCdmaProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem_cdma_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_cdma_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModemCdmaProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem_cdma_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_cdma_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModemCdmaProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem_cdma_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_cdma_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemCdmaProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_cdma_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemCdmaProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModemCdmaProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_cdma_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_cdma_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_cdma_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_cdma_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_cdma_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModemCdmaSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModemCdma.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModemCdmaSkeleton extends Gio.DBusInterface, GdbusModemCdma {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemCdmaSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemCdmaSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::activation-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::activation-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::activation-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::activation-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::activation-state", ...args: any[]): void
    connect(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cdma1x-registration-state", ...args: any[]): void
    connect(sigName: "notify::esn", callback: (...args: any[]) => void): number
    on(sigName: "notify::esn", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::esn", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::esn", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::esn", ...args: any[]): void
    connect(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::evdo-registration-state", ...args: any[]): void
    connect(sigName: "notify::meid", callback: (...args: any[]) => void): number
    on(sigName: "notify::meid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::meid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::meid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::meid", ...args: any[]): void
    connect(sigName: "notify::nid", callback: (...args: any[]) => void): number
    on(sigName: "notify::nid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::nid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::nid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::nid", ...args: any[]): void
    connect(sigName: "notify::sid", callback: (...args: any[]) => void): number
    on(sigName: "notify::sid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sid", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemCdmaSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemCdmaSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemCdmaSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemCdmaSkeleton

    constructor(config?: GdbusModemCdmaSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModemCdmaSkeleton
    _init(config?: GdbusModemCdmaSkeleton.ConstructorProperties): void
}

export module GdbusModemFirmwareProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemFirmware.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModemFirmwareProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemFirmware {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemFirmwareProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemFirmwareProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::update-settings", callback: (...args: any[]) => void): number
    on(sigName: "notify::update-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::update-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::update-settings", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::update-settings", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemFirmwareProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemFirmwareProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemFirmwareProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemFirmwareProxy

    constructor(config?: GdbusModemFirmwareProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem_firmware_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_firmware_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModemFirmwareProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem_firmware_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_firmware_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModemFirmwareProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem_firmware_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_firmware_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemFirmwareProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_firmware_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemFirmwareProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModemFirmwareProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_firmware_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_firmware_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_firmware_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_firmware_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_firmware_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModemFirmwareSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModemFirmware.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModemFirmwareSkeleton extends Gio.DBusInterface, GdbusModemFirmware {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemFirmwareSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemFirmwareSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::update-settings", callback: (...args: any[]) => void): number
    on(sigName: "notify::update-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::update-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::update-settings", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::update-settings", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemFirmwareSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemFirmwareSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemFirmwareSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemFirmwareSkeleton

    constructor(config?: GdbusModemFirmwareSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModemFirmwareSkeleton
    _init(config?: GdbusModemFirmwareSkeleton.ConstructorProperties): void
}

export module GdbusModemLocationProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemLocation.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModemLocationProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemLocation {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemLocationProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemLocationProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void): number
    on(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::assistance-data-servers", ...args: any[]): void
    connect(sigName: "notify::capabilities", callback: (...args: any[]) => void): number
    on(sigName: "notify::capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::capabilities", ...args: any[]): void
    connect(sigName: "notify::enabled", callback: (...args: any[]) => void): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::enabled", ...args: any[]): void
    connect(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void): number
    on(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gps-refresh-rate", ...args: any[]): void
    connect(sigName: "notify::location", callback: (...args: any[]) => void): number
    on(sigName: "notify::location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::location", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::location", ...args: any[]): void
    connect(sigName: "notify::signals-location", callback: (...args: any[]) => void): number
    on(sigName: "notify::signals-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::signals-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::signals-location", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::signals-location", ...args: any[]): void
    connect(sigName: "notify::supl-server", callback: (...args: any[]) => void): number
    on(sigName: "notify::supl-server", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supl-server", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supl-server", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supl-server", ...args: any[]): void
    connect(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-assistance-data", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemLocationProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemLocationProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemLocationProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemLocationProxy

    constructor(config?: GdbusModemLocationProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem_location_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_location_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModemLocationProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem_location_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_location_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModemLocationProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem_location_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_location_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemLocationProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_location_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemLocationProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModemLocationProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_location_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_location_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_location_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_location_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_location_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModemLocationSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModemLocation.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModemLocationSkeleton extends Gio.DBusInterface, GdbusModemLocation {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemLocationSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemLocationSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void): number
    on(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::assistance-data-servers", ...args: any[]): void
    connect(sigName: "notify::capabilities", callback: (...args: any[]) => void): number
    on(sigName: "notify::capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::capabilities", ...args: any[]): void
    connect(sigName: "notify::enabled", callback: (...args: any[]) => void): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::enabled", ...args: any[]): void
    connect(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void): number
    on(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gps-refresh-rate", ...args: any[]): void
    connect(sigName: "notify::location", callback: (...args: any[]) => void): number
    on(sigName: "notify::location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::location", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::location", ...args: any[]): void
    connect(sigName: "notify::signals-location", callback: (...args: any[]) => void): number
    on(sigName: "notify::signals-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::signals-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::signals-location", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::signals-location", ...args: any[]): void
    connect(sigName: "notify::supl-server", callback: (...args: any[]) => void): number
    on(sigName: "notify::supl-server", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supl-server", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supl-server", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supl-server", ...args: any[]): void
    connect(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-assistance-data", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemLocationSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemLocationSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemLocationSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemLocationSkeleton

    constructor(config?: GdbusModemLocationSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModemLocationSkeleton
    _init(config?: GdbusModemLocationSkeleton.ConstructorProperties): void
}

export module GdbusModemMessagingProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemMessaging.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModemMessagingProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemMessaging {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemMessagingProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemMessagingProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::default-storage", callback: (...args: any[]) => void): number
    on(sigName: "notify::default-storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::default-storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::default-storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::default-storage", ...args: any[]): void
    connect(sigName: "notify::messages", callback: (...args: any[]) => void): number
    on(sigName: "notify::messages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::messages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::messages", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::messages", ...args: any[]): void
    connect(sigName: "notify::supported-storages", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-storages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-storages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-storages", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-storages", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemMessagingProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemMessagingProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemMessagingProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemMessagingProxy

    constructor(config?: GdbusModemMessagingProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem_messaging_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_messaging_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModemMessagingProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem_messaging_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_messaging_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModemMessagingProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem_messaging_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_messaging_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemMessagingProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_messaging_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemMessagingProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModemMessagingProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_messaging_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_messaging_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_messaging_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_messaging_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_messaging_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModemMessagingSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModemMessaging.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModemMessagingSkeleton extends Gio.DBusInterface, GdbusModemMessaging {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemMessagingSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemMessagingSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::default-storage", callback: (...args: any[]) => void): number
    on(sigName: "notify::default-storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::default-storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::default-storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::default-storage", ...args: any[]): void
    connect(sigName: "notify::messages", callback: (...args: any[]) => void): number
    on(sigName: "notify::messages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::messages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::messages", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::messages", ...args: any[]): void
    connect(sigName: "notify::supported-storages", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-storages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-storages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-storages", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-storages", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemMessagingSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemMessagingSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemMessagingSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemMessagingSkeleton

    constructor(config?: GdbusModemMessagingSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModemMessagingSkeleton
    _init(config?: GdbusModemMessagingSkeleton.ConstructorProperties): void
}

export module GdbusModemOmaProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemOma.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModemOmaProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemOma {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemOmaProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemOmaProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::features", callback: (...args: any[]) => void): number
    on(sigName: "notify::features", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::features", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::features", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::features", ...args: any[]): void
    connect(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void): number
    on(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::pending-network-initiated-sessions", ...args: any[]): void
    connect(sigName: "notify::session-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::session-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::session-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::session-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::session-state", ...args: any[]): void
    connect(sigName: "notify::session-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::session-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::session-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::session-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::session-type", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemOmaProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemOmaProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemOmaProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemOmaProxy

    constructor(config?: GdbusModemOmaProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem_oma_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_oma_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModemOmaProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem_oma_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_oma_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModemOmaProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem_oma_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_oma_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemOmaProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_oma_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemOmaProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModemOmaProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_oma_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_oma_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_oma_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_oma_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_oma_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModemOmaSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModemOma.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModemOmaSkeleton extends Gio.DBusInterface, GdbusModemOma {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemOmaSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemOmaSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::features", callback: (...args: any[]) => void): number
    on(sigName: "notify::features", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::features", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::features", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::features", ...args: any[]): void
    connect(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void): number
    on(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::pending-network-initiated-sessions", ...args: any[]): void
    connect(sigName: "notify::session-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::session-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::session-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::session-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::session-state", ...args: any[]): void
    connect(sigName: "notify::session-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::session-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::session-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::session-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::session-type", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemOmaSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemOmaSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemOmaSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemOmaSkeleton

    constructor(config?: GdbusModemOmaSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModemOmaSkeleton
    _init(config?: GdbusModemOmaSkeleton.ConstructorProperties): void
}

export module GdbusModemProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModem.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModemProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModem {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::access-technologies", callback: (...args: any[]) => void): number
    on(sigName: "notify::access-technologies", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::access-technologies", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::access-technologies", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::access-technologies", ...args: any[]): void
    connect(sigName: "notify::bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::bearers", ...args: any[]): void
    connect(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void): number
    on(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::carrier-configuration", ...args: any[]): void
    connect(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void): number
    on(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::carrier-configuration-revision", ...args: any[]): void
    connect(sigName: "notify::current-bands", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-bands", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-bands", ...args: any[]): void
    connect(sigName: "notify::current-capabilities", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-capabilities", ...args: any[]): void
    connect(sigName: "notify::current-modes", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-modes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-modes", ...args: any[]): void
    connect(sigName: "notify::device", callback: (...args: any[]) => void): number
    on(sigName: "notify::device", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::device", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::device", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::device", ...args: any[]): void
    connect(sigName: "notify::device-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::device-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::device-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::device-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::device-identifier", ...args: any[]): void
    connect(sigName: "notify::drivers", callback: (...args: any[]) => void): number
    on(sigName: "notify::drivers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::drivers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::drivers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::drivers", ...args: any[]): void
    connect(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::equipment-identifier", ...args: any[]): void
    connect(sigName: "notify::hardware-revision", callback: (...args: any[]) => void): number
    on(sigName: "notify::hardware-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::hardware-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::hardware-revision", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::hardware-revision", ...args: any[]): void
    connect(sigName: "notify::manufacturer", callback: (...args: any[]) => void): number
    on(sigName: "notify::manufacturer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::manufacturer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::manufacturer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::manufacturer", ...args: any[]): void
    connect(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::max-active-bearers", ...args: any[]): void
    connect(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::max-active-multiplexed-bearers", ...args: any[]): void
    connect(sigName: "notify::max-bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::max-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::max-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::max-bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::max-bearers", ...args: any[]): void
    connect(sigName: "notify::model", callback: (...args: any[]) => void): number
    on(sigName: "notify::model", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::model", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::model", ...args: any[]): void
    connect(sigName: "notify::own-numbers", callback: (...args: any[]) => void): number
    on(sigName: "notify::own-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::own-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::own-numbers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::own-numbers", ...args: any[]): void
    connect(sigName: "notify::plugin", callback: (...args: any[]) => void): number
    on(sigName: "notify::plugin", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::plugin", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::plugin", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::plugin", ...args: any[]): void
    connect(sigName: "notify::ports", callback: (...args: any[]) => void): number
    on(sigName: "notify::ports", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ports", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ports", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ports", ...args: any[]): void
    connect(sigName: "notify::power-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::power-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::power-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::power-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::power-state", ...args: any[]): void
    connect(sigName: "notify::primary-port", callback: (...args: any[]) => void): number
    on(sigName: "notify::primary-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::primary-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::primary-port", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::primary-port", ...args: any[]): void
    connect(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void): number
    on(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::primary-sim-slot", ...args: any[]): void
    connect(sigName: "notify::revision", callback: (...args: any[]) => void): number
    on(sigName: "notify::revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::revision", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::revision", ...args: any[]): void
    connect(sigName: "notify::signal-quality", callback: (...args: any[]) => void): number
    on(sigName: "notify::signal-quality", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::signal-quality", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::signal-quality", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::signal-quality", ...args: any[]): void
    connect(sigName: "notify::sim", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim", ...args: any[]): void
    connect(sigName: "notify::sim-slots", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim-slots", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim-slots", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim-slots", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim-slots", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void): number
    on(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state-failed-reason", ...args: any[]): void
    connect(sigName: "notify::supported-bands", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-bands", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-bands", ...args: any[]): void
    connect(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-capabilities", ...args: any[]): void
    connect(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-ip-families", ...args: any[]): void
    connect(sigName: "notify::supported-modes", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-modes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-modes", ...args: any[]): void
    connect(sigName: "notify::unlock-required", callback: (...args: any[]) => void): number
    on(sigName: "notify::unlock-required", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::unlock-required", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::unlock-required", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::unlock-required", ...args: any[]): void
    connect(sigName: "notify::unlock-retries", callback: (...args: any[]) => void): number
    on(sigName: "notify::unlock-retries", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::unlock-retries", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::unlock-retries", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::unlock-retries", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemProxy

    constructor(config?: GdbusModemProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModemProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModemProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModemProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModemSarProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemSar.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModemSarProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemSar {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSarProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemSarProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::power-level", callback: (...args: any[]) => void): number
    on(sigName: "notify::power-level", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::power-level", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::power-level", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::power-level", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemSarProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemSarProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSarProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemSarProxy

    constructor(config?: GdbusModemSarProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem_sar_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_sar_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModemSarProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem_sar_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_sar_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModemSarProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem_sar_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_sar_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemSarProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_sar_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemSarProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModemSarProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_sar_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_sar_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_sar_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_sar_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_sar_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModemSarSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModemSar.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModemSarSkeleton extends Gio.DBusInterface, GdbusModemSar {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSarSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemSarSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::power-level", callback: (...args: any[]) => void): number
    on(sigName: "notify::power-level", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::power-level", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::power-level", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::power-level", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemSarSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemSarSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSarSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemSarSkeleton

    constructor(config?: GdbusModemSarSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModemSarSkeleton
    _init(config?: GdbusModemSarSkeleton.ConstructorProperties): void
}

export module GdbusModemSignalProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemSignal.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModemSignalProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemSignal {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSignalProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemSignalProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::cdma", callback: (...args: any[]) => void): number
    on(sigName: "notify::cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cdma", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cdma", ...args: any[]): void
    connect(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void): number
    on(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::error-rate-threshold", ...args: any[]): void
    connect(sigName: "notify::evdo", callback: (...args: any[]) => void): number
    on(sigName: "notify::evdo", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::evdo", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::evdo", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::evdo", ...args: any[]): void
    connect(sigName: "notify::gsm", callback: (...args: any[]) => void): number
    on(sigName: "notify::gsm", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gsm", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gsm", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gsm", ...args: any[]): void
    connect(sigName: "notify::lte", callback: (...args: any[]) => void): number
    on(sigName: "notify::lte", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::lte", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::lte", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::lte", ...args: any[]): void
    connect(sigName: "notify::nr5g", callback: (...args: any[]) => void): number
    on(sigName: "notify::nr5g", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::nr5g", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::nr5g", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::nr5g", ...args: any[]): void
    connect(sigName: "notify::rate", callback: (...args: any[]) => void): number
    on(sigName: "notify::rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::rate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::rate", ...args: any[]): void
    connect(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void): number
    on(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::rssi-threshold", ...args: any[]): void
    connect(sigName: "notify::umts", callback: (...args: any[]) => void): number
    on(sigName: "notify::umts", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::umts", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::umts", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::umts", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemSignalProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemSignalProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSignalProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemSignalProxy

    constructor(config?: GdbusModemSignalProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem_signal_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_signal_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModemSignalProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem_signal_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_signal_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModemSignalProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem_signal_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_signal_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemSignalProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_signal_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemSignalProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModemSignalProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_signal_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_signal_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_signal_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_signal_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_signal_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModemSignalSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModemSignal.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModemSignalSkeleton extends Gio.DBusInterface, GdbusModemSignal {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSignalSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemSignalSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::cdma", callback: (...args: any[]) => void): number
    on(sigName: "notify::cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cdma", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cdma", ...args: any[]): void
    connect(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void): number
    on(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::error-rate-threshold", ...args: any[]): void
    connect(sigName: "notify::evdo", callback: (...args: any[]) => void): number
    on(sigName: "notify::evdo", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::evdo", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::evdo", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::evdo", ...args: any[]): void
    connect(sigName: "notify::gsm", callback: (...args: any[]) => void): number
    on(sigName: "notify::gsm", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gsm", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gsm", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gsm", ...args: any[]): void
    connect(sigName: "notify::lte", callback: (...args: any[]) => void): number
    on(sigName: "notify::lte", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::lte", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::lte", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::lte", ...args: any[]): void
    connect(sigName: "notify::nr5g", callback: (...args: any[]) => void): number
    on(sigName: "notify::nr5g", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::nr5g", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::nr5g", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::nr5g", ...args: any[]): void
    connect(sigName: "notify::rate", callback: (...args: any[]) => void): number
    on(sigName: "notify::rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::rate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::rate", ...args: any[]): void
    connect(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void): number
    on(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::rssi-threshold", ...args: any[]): void
    connect(sigName: "notify::umts", callback: (...args: any[]) => void): number
    on(sigName: "notify::umts", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::umts", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::umts", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::umts", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemSignalSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemSignalSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSignalSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemSignalSkeleton

    constructor(config?: GdbusModemSignalSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModemSignalSkeleton
    _init(config?: GdbusModemSignalSkeleton.ConstructorProperties): void
}

export module GdbusModemSimpleProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemSimple.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModemSimpleProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemSimple {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSimpleProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemSimpleProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemSimpleProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemSimpleProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSimpleProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemSimpleProxy

    constructor(config?: GdbusModemSimpleProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem_simple_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_simple_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModemSimpleProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem_simple_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_simple_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModemSimpleProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem_simple_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_simple_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemSimpleProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_simple_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemSimpleProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModemSimpleProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_simple_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_simple_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_simple_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_simple_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_simple_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModemSimpleSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModemSimple.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModemSimpleSkeleton extends Gio.DBusInterface, GdbusModemSimple {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSimpleSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemSimpleSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemSimpleSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemSimpleSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSimpleSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemSimpleSkeleton

    constructor(config?: GdbusModemSimpleSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModemSimpleSkeleton
    _init(config?: GdbusModemSimpleSkeleton.ConstructorProperties): void
}

export module GdbusModemSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModem.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModemSkeleton extends Gio.DBusInterface, GdbusModem {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::access-technologies", callback: (...args: any[]) => void): number
    on(sigName: "notify::access-technologies", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::access-technologies", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::access-technologies", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::access-technologies", ...args: any[]): void
    connect(sigName: "notify::bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::bearers", ...args: any[]): void
    connect(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void): number
    on(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::carrier-configuration", ...args: any[]): void
    connect(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void): number
    on(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::carrier-configuration-revision", ...args: any[]): void
    connect(sigName: "notify::current-bands", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-bands", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-bands", ...args: any[]): void
    connect(sigName: "notify::current-capabilities", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-capabilities", ...args: any[]): void
    connect(sigName: "notify::current-modes", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-modes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-modes", ...args: any[]): void
    connect(sigName: "notify::device", callback: (...args: any[]) => void): number
    on(sigName: "notify::device", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::device", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::device", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::device", ...args: any[]): void
    connect(sigName: "notify::device-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::device-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::device-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::device-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::device-identifier", ...args: any[]): void
    connect(sigName: "notify::drivers", callback: (...args: any[]) => void): number
    on(sigName: "notify::drivers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::drivers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::drivers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::drivers", ...args: any[]): void
    connect(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::equipment-identifier", ...args: any[]): void
    connect(sigName: "notify::hardware-revision", callback: (...args: any[]) => void): number
    on(sigName: "notify::hardware-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::hardware-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::hardware-revision", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::hardware-revision", ...args: any[]): void
    connect(sigName: "notify::manufacturer", callback: (...args: any[]) => void): number
    on(sigName: "notify::manufacturer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::manufacturer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::manufacturer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::manufacturer", ...args: any[]): void
    connect(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::max-active-bearers", ...args: any[]): void
    connect(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::max-active-multiplexed-bearers", ...args: any[]): void
    connect(sigName: "notify::max-bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::max-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::max-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::max-bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::max-bearers", ...args: any[]): void
    connect(sigName: "notify::model", callback: (...args: any[]) => void): number
    on(sigName: "notify::model", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::model", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::model", ...args: any[]): void
    connect(sigName: "notify::own-numbers", callback: (...args: any[]) => void): number
    on(sigName: "notify::own-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::own-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::own-numbers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::own-numbers", ...args: any[]): void
    connect(sigName: "notify::plugin", callback: (...args: any[]) => void): number
    on(sigName: "notify::plugin", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::plugin", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::plugin", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::plugin", ...args: any[]): void
    connect(sigName: "notify::ports", callback: (...args: any[]) => void): number
    on(sigName: "notify::ports", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ports", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ports", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ports", ...args: any[]): void
    connect(sigName: "notify::power-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::power-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::power-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::power-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::power-state", ...args: any[]): void
    connect(sigName: "notify::primary-port", callback: (...args: any[]) => void): number
    on(sigName: "notify::primary-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::primary-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::primary-port", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::primary-port", ...args: any[]): void
    connect(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void): number
    on(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::primary-sim-slot", ...args: any[]): void
    connect(sigName: "notify::revision", callback: (...args: any[]) => void): number
    on(sigName: "notify::revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::revision", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::revision", ...args: any[]): void
    connect(sigName: "notify::signal-quality", callback: (...args: any[]) => void): number
    on(sigName: "notify::signal-quality", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::signal-quality", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::signal-quality", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::signal-quality", ...args: any[]): void
    connect(sigName: "notify::sim", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim", ...args: any[]): void
    connect(sigName: "notify::sim-slots", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim-slots", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim-slots", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim-slots", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim-slots", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void): number
    on(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state-failed-reason", ...args: any[]): void
    connect(sigName: "notify::supported-bands", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-bands", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-bands", ...args: any[]): void
    connect(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-capabilities", ...args: any[]): void
    connect(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-ip-families", ...args: any[]): void
    connect(sigName: "notify::supported-modes", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-modes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-modes", ...args: any[]): void
    connect(sigName: "notify::unlock-required", callback: (...args: any[]) => void): number
    on(sigName: "notify::unlock-required", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::unlock-required", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::unlock-required", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::unlock-required", ...args: any[]): void
    connect(sigName: "notify::unlock-retries", callback: (...args: any[]) => void): number
    on(sigName: "notify::unlock-retries", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::unlock-retries", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::unlock-retries", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::unlock-retries", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemSkeleton

    constructor(config?: GdbusModemSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModemSkeleton
    _init(config?: GdbusModemSkeleton.ConstructorProperties): void
}

export module GdbusModemTimeProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemTime.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModemTimeProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemTime {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemTimeProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemTimeProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::network-timezone", callback: (...args: any[]) => void): number
    on(sigName: "notify::network-timezone", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::network-timezone", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::network-timezone", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::network-timezone", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemTimeProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemTimeProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemTimeProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemTimeProxy

    constructor(config?: GdbusModemTimeProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem_time_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_time_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModemTimeProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem_time_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_time_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModemTimeProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem_time_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_time_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemTimeProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_time_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemTimeProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModemTimeProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_time_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_time_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_time_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_time_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_time_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModemTimeSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModemTime.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModemTimeSkeleton extends Gio.DBusInterface, GdbusModemTime {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemTimeSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemTimeSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::network-timezone", callback: (...args: any[]) => void): number
    on(sigName: "notify::network-timezone", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::network-timezone", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::network-timezone", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::network-timezone", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemTimeSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemTimeSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemTimeSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemTimeSkeleton

    constructor(config?: GdbusModemTimeSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModemTimeSkeleton
    _init(config?: GdbusModemTimeSkeleton.ConstructorProperties): void
}

export module GdbusModemVoiceProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemVoice.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusModemVoiceProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemVoice {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemVoiceProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemVoiceProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::calls", callback: (...args: any[]) => void): number
    on(sigName: "notify::calls", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::calls", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::calls", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::calls", ...args: any[]): void
    connect(sigName: "notify::emergency-only", callback: (...args: any[]) => void): number
    on(sigName: "notify::emergency-only", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::emergency-only", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::emergency-only", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::emergency-only", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemVoiceProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemVoiceProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemVoiceProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemVoiceProxy

    constructor(config?: GdbusModemVoiceProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_modem_voice_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_voice_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusModemVoiceProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_modem_voice_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem_voice_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusModemVoiceProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_modem_voice_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_voice_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemVoiceProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_modem_voice_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusModemVoiceProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusModemVoiceProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_voice_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusModemVoiceSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusModemVoice.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusModemVoiceSkeleton extends Gio.DBusInterface, GdbusModemVoice {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemVoiceSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusModemVoiceSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::calls", callback: (...args: any[]) => void): number
    on(sigName: "notify::calls", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::calls", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::calls", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::calls", ...args: any[]): void
    connect(sigName: "notify::emergency-only", callback: (...args: any[]) => void): number
    on(sigName: "notify::emergency-only", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::emergency-only", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::emergency-only", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::emergency-only", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusModemVoiceSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusModemVoiceSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemVoiceSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusModemVoiceSkeleton

    constructor(config?: GdbusModemVoiceSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusModemVoiceSkeleton
    _init(config?: GdbusModemVoiceSkeleton.ConstructorProperties): void
}

export module GdbusObjectManagerClient {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusObjectManager.ConstructorProperties, Gio.Initable.ConstructorProperties, Gio.DBusObjectManagerClient.ConstructorProperties {
    }

}

export interface GdbusObjectManagerClient extends Gio.AsyncInitable, Gio.DBusObjectManager, Gio.Initable {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectManagerClient

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusObjectManagerClient

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::bus-type", ...args: any[]): void
    connect(sigName: "notify::connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::connection", ...args: any[]): void
    connect(sigName: "notify::flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::flags", ...args: any[]): void
    connect(sigName: "notify::get-proxy-type-destroy-notify", callback: (...args: any[]) => void): number
    on(sigName: "notify::get-proxy-type-destroy-notify", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::get-proxy-type-destroy-notify", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::get-proxy-type-destroy-notify", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::get-proxy-type-destroy-notify", ...args: any[]): void
    connect(sigName: "notify::get-proxy-type-func", callback: (...args: any[]) => void): number
    on(sigName: "notify::get-proxy-type-func", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::get-proxy-type-func", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::get-proxy-type-func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::get-proxy-type-func", ...args: any[]): void
    connect(sigName: "notify::get-proxy-type-user-data", callback: (...args: any[]) => void): number
    on(sigName: "notify::get-proxy-type-user-data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::get-proxy-type-user-data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::get-proxy-type-user-data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::get-proxy-type-user-data", ...args: any[]): void
    connect(sigName: "notify::name", callback: (...args: any[]) => void): number
    on(sigName: "notify::name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::name", ...args: any[]): void
    connect(sigName: "notify::name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::name-owner", ...args: any[]): void
    connect(sigName: "notify::object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::object-path", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusObjectManagerClient structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusObjectManagerClient extends Gio.DBusObjectManagerClient {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectManagerClient

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusObjectManagerClient

    constructor(config?: GdbusObjectManagerClient.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_object_manager_client_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_object_manager_client_new().
     * @returns The constructed object manager client or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusObjectManagerClient

    // Overloads of newFinish

    /**
     * Finishes an operation started with g_dbus_object_manager_client_new().
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_object_manager_client_new().
     * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusObjectManagerClient
    /**
     * Finishes an operation started with mm_gdbus_object_manager_client_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_object_manager_client_new_for_bus().
     * @returns The constructed object manager client or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusObjectManagerClient

    // Overloads of newForBusFinish

    /**
     * Finishes an operation started with g_dbus_object_manager_client_new_for_bus().
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_object_manager_client_new_for_bus().
     * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusObjectManagerClient
    /**
     * Like mm_gdbus_object_manager_client_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_object_manager_client_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed object manager client or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusObjectManagerClient

    // Overloads of newForBusSync

    /**
     * Like g_dbus_object_manager_client_new_sync() but takes a #GBusType instead
     * of a #GDBusConnection.
     * 
     * This is a synchronous failable constructor - the calling thread is
     * blocked until a reply is received. See g_dbus_object_manager_client_new_for_bus()
     * for the asynchronous version.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name The owner of the control object (unique or well-known name).
     * @param objectPath The object path of the control object.
     * @param getProxyTypeFunc A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
     * @param cancellable A #GCancellable or %NULL
     * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, getProxyTypeFunc: Gio.DBusProxyTypeFunc | null, cancellable: Gio.Cancellable | null): Gio.DBusObjectManagerClient
    /**
     * Synchronously creates #GDBusObjectManagerClient using mm_gdbus_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_object_manager_client_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed object manager client or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusObjectManagerClient

    // Overloads of newSync

    /**
     * Creates a new #GDBusObjectManagerClient object.
     * 
     * This is a synchronous failable constructor - the calling thread is
     * blocked until a reply is received. See g_dbus_object_manager_client_new()
     * for the asynchronous version.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name The owner of the control object (unique or well-known name), or %NULL when not using a message bus connection.
     * @param objectPath The object path of the control object.
     * @param getProxyTypeFunc A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
     * @param cancellable A #GCancellable or %NULL
     * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, getProxyTypeFunc: Gio.DBusProxyTypeFunc | null, cancellable: Gio.Cancellable | null): Gio.DBusObjectManagerClient
    _init(config?: GdbusObjectManagerClient.ConstructorProperties): void
    /**
     * Asynchronously creates #GDBusObjectManagerClient using mm_gdbus_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_object_manager_client_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_object_manager_client_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Asynchronously creates a new #GDBusObjectManagerClient object.
     * 
     * This is an asynchronous failable constructor. When the result is
     * ready, `callback` will be invoked in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread you are calling this method from. You can
     * then call g_dbus_object_manager_client_new_finish() to get the result. See
     * g_dbus_object_manager_client_new_sync() for the synchronous version.
     * @param connection A #GDBusConnection.
     * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name The owner of the control object (unique or well-known name).
     * @param objectPath The object path of the control object.
     * @param getProxyTypeFunc A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
     * @param cancellable A #GCancellable or %NULL
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, getProxyTypeFunc: Gio.DBusProxyTypeFunc | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_object_manager_client_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_object_manager_client_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_object_manager_client_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_object_manager_client_new() but takes a #GBusType instead of a
     * #GDBusConnection.
     * 
     * This is an asynchronous failable constructor. When the result is
     * ready, `callback` will be invoked in the
     * [thread-default main loop][g-main-context-push-thread-default]
     * of the thread you are calling this method from. You can
     * then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
     * g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.
     * @param busType A #GBusType.
     * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name The owner of the control object (unique or well-known name).
     * @param objectPath The object path of the control object.
     * @param getProxyTypeFunc A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
     * @param cancellable A #GCancellable or %NULL
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, getProxyTypeFunc: Gio.DBusProxyTypeFunc | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * A #GDBusProxyTypeFunc that maps `interface_name` to the generated #GDBusObjectProxy derived and #GDBusProxy derived types.
     * @param manager A #GDBusObjectManagerClient.
     * @param objectPath The object path of the remote object (unused).
     * @param interfaceName Interface name of the remote object or %NULL to get the object proxy #GType.
     * @param userData User data (unused).
     * @returns A #GDBusProxy derived #GType if @interface_name is not %NULL, otherwise the #GType for #MmGdbusObjectProxy.
     */
    static getProxyType(manager: Gio.DBusObjectManagerClient, objectPath: string | null, interfaceName: string | null, userData: any | null): GObject.GType
}

export module GdbusObjectProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusObject.ConstructorProperties, GdbusObject.ConstructorProperties, Gio.DBusObjectProxy.ConstructorProperties {
    }

}

export interface GdbusObjectProxy extends Gio.DBusObject, GdbusObject {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusObjectProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::modem", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem", ...args: any[]): void
    connect(sigName: "notify::modem-cdma", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-cdma", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-cdma", ...args: any[]): void
    connect(sigName: "notify::modem-firmware", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-firmware", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-firmware", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-firmware", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-firmware", ...args: any[]): void
    connect(sigName: "notify::modem-location", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-location", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-location", ...args: any[]): void
    connect(sigName: "notify::modem-messaging", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-messaging", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-messaging", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-messaging", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-messaging", ...args: any[]): void
    connect(sigName: "notify::modem-oma", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-oma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-oma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-oma", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-oma", ...args: any[]): void
    connect(sigName: "notify::modem-sar", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-sar", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-sar", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-sar", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-sar", ...args: any[]): void
    connect(sigName: "notify::modem-signal", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-signal", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-signal", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-signal", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-signal", ...args: any[]): void
    connect(sigName: "notify::modem-simple", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-simple", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-simple", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-simple", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-simple", ...args: any[]): void
    connect(sigName: "notify::modem-time", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-time", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-time", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-time", ...args: any[]): void
    connect(sigName: "notify::modem-voice", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-voice", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-voice", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-voice", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-voice", ...args: any[]): void
    connect(sigName: "notify::modem3gpp", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem3gpp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem3gpp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem3gpp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem3gpp", ...args: any[]): void
    connect(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem3gpp-profile-manager", ...args: any[]): void
    connect(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem3gpp-ussd", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusObjectProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusObjectProxy extends Gio.DBusObjectProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusObjectProxy

    constructor(config?: GdbusObjectProxy.ConstructorProperties) 
    /**
     * Creates a new proxy object.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param objectPath An object path.
     * @returns The proxy object.
     */
    constructor(connection: Gio.DBusConnection, objectPath: string | null) 
    /**
     * Creates a new proxy object.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param objectPath An object path.
     * @returns The proxy object.
     */
    static new(connection: Gio.DBusConnection, objectPath: string | null): GdbusObjectProxy

    // Overloads of new

    /**
     * Creates a new #GDBusObjectProxy for the given connection and
     * object path.
     * @constructor 
     * @param connection a #GDBusConnection
     * @param objectPath the object path
     * @returns a new #GDBusObjectProxy
     */
    static new(connection: Gio.DBusConnection, objectPath: string | null): Gio.DBusObjectProxy
    _init(config?: GdbusObjectProxy.ConstructorProperties): void
}

export module GdbusObjectSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusObject.ConstructorProperties, GdbusObject.ConstructorProperties, Gio.DBusObjectSkeleton.ConstructorProperties {
    }

}

export interface GdbusObjectSkeleton extends Gio.DBusObject, GdbusObject {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectSkeleton

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.GdbusObjectSkeleton

    /**
     * Sets the #MmGdbusModem instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link> on `object`.
     * @param interface A #MmGdbusModem or %NULL to clear the interface.
     */
    setModem(interface: GdbusModem | null): void
    /**
     * Sets the #MmGdbusModem3gpp instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link> on `object`.
     * @param interface A #MmGdbusModem3gpp or %NULL to clear the interface.
     */
    setModem3gpp(interface: GdbusModem3gpp | null): void
    /**
     * Sets the #MmGdbusModem3gppProfileManager instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link> on `object`.
     * @param interface A #MmGdbusModem3gppProfileManager or %NULL to clear the interface.
     */
    setModem3gppProfileManager(interface: GdbusModem3gppProfileManager | null): void
    /**
     * Sets the #MmGdbusModem3gppUssd instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link> on `object`.
     * @param interface A #MmGdbusModem3gppUssd or %NULL to clear the interface.
     */
    setModem3gppUssd(interface: GdbusModem3gppUssd | null): void
    /**
     * Sets the #MmGdbusModemCdma instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link> on `object`.
     * @param interface A #MmGdbusModemCdma or %NULL to clear the interface.
     */
    setModemCdma(interface: GdbusModemCdma | null): void
    /**
     * Sets the #MmGdbusModemFirmware instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link> on `object`.
     * @param interface A #MmGdbusModemFirmware or %NULL to clear the interface.
     */
    setModemFirmware(interface: GdbusModemFirmware | null): void
    /**
     * Sets the #MmGdbusModemLocation instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link> on `object`.
     * @param interface A #MmGdbusModemLocation or %NULL to clear the interface.
     */
    setModemLocation(interface: GdbusModemLocation | null): void
    /**
     * Sets the #MmGdbusModemMessaging instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link> on `object`.
     * @param interface A #MmGdbusModemMessaging or %NULL to clear the interface.
     */
    setModemMessaging(interface: GdbusModemMessaging | null): void
    /**
     * Sets the #MmGdbusModemOma instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link> on `object`.
     * @param interface A #MmGdbusModemOma or %NULL to clear the interface.
     */
    setModemOma(interface: GdbusModemOma | null): void
    /**
     * Sets the #MmGdbusModemSar instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link> on `object`.
     * @param interface A #MmGdbusModemSar or %NULL to clear the interface.
     */
    setModemSar(interface: GdbusModemSar | null): void
    /**
     * Sets the #MmGdbusModemSignal instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link> on `object`.
     * @param interface A #MmGdbusModemSignal or %NULL to clear the interface.
     */
    setModemSignal(interface: GdbusModemSignal | null): void
    /**
     * Sets the #MmGdbusModemSimple instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link> on `object`.
     * @param interface A #MmGdbusModemSimple or %NULL to clear the interface.
     */
    setModemSimple(interface: GdbusModemSimple | null): void
    /**
     * Sets the #MmGdbusModemTime instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link> on `object`.
     * @param interface A #MmGdbusModemTime or %NULL to clear the interface.
     */
    setModemTime(interface: GdbusModemTime | null): void
    /**
     * Sets the #MmGdbusModemVoice instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link> on `object`.
     * @param interface A #MmGdbusModemVoice or %NULL to clear the interface.
     */
    setModemVoice(interface: GdbusModemVoice | null): void

    // Class property signals of ModemManager-1.0.ModemManager.GdbusObjectSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::modem", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem", ...args: any[]): void
    connect(sigName: "notify::modem-cdma", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-cdma", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-cdma", ...args: any[]): void
    connect(sigName: "notify::modem-firmware", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-firmware", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-firmware", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-firmware", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-firmware", ...args: any[]): void
    connect(sigName: "notify::modem-location", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-location", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-location", ...args: any[]): void
    connect(sigName: "notify::modem-messaging", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-messaging", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-messaging", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-messaging", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-messaging", ...args: any[]): void
    connect(sigName: "notify::modem-oma", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-oma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-oma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-oma", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-oma", ...args: any[]): void
    connect(sigName: "notify::modem-sar", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-sar", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-sar", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-sar", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-sar", ...args: any[]): void
    connect(sigName: "notify::modem-signal", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-signal", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-signal", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-signal", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-signal", ...args: any[]): void
    connect(sigName: "notify::modem-simple", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-simple", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-simple", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-simple", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-simple", ...args: any[]): void
    connect(sigName: "notify::modem-time", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-time", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-time", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-time", ...args: any[]): void
    connect(sigName: "notify::modem-voice", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-voice", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-voice", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-voice", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-voice", ...args: any[]): void
    connect(sigName: "notify::modem3gpp", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem3gpp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem3gpp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem3gpp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem3gpp", ...args: any[]): void
    connect(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem3gpp-profile-manager", ...args: any[]): void
    connect(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem3gpp-ussd", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusObjectSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusObjectSkeleton extends Gio.DBusObjectSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusObjectSkeleton

    constructor(config?: GdbusObjectSkeleton.ConstructorProperties) 
    /**
     * Creates a new skeleton object.
     * @constructor 
     * @param objectPath An object path.
     * @returns The skeleton object.
     */
    constructor(objectPath: string | null) 
    /**
     * Creates a new skeleton object.
     * @constructor 
     * @param objectPath An object path.
     * @returns The skeleton object.
     */
    static new(objectPath: string | null): GdbusObjectSkeleton

    // Overloads of new

    /**
     * Creates a new #GDBusObjectSkeleton.
     * @constructor 
     * @param objectPath An object path.
     * @returns A #GDBusObjectSkeleton. Free with g_object_unref().
     */
    static new(objectPath: string | null): Gio.DBusObjectSkeleton
    _init(config?: GdbusObjectSkeleton.ConstructorProperties): void
}

export module GdbusOrgFreedesktopModemManager1Proxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusOrgFreedesktopModemManager1.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusOrgFreedesktopModemManager1Proxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusOrgFreedesktopModemManager1 {

    // Own properties of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1Proxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1Proxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::version", callback: (...args: any[]) => void): number
    on(sigName: "notify::version", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::version", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::version", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::version", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusOrgFreedesktopModemManager1Proxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusOrgFreedesktopModemManager1Proxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1Proxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1Proxy

    constructor(config?: GdbusOrgFreedesktopModemManager1Proxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_org_freedesktop_modem_manager1_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_org_freedesktop_modem_manager1_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusOrgFreedesktopModemManager1Proxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_org_freedesktop_modem_manager1_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_org_freedesktop_modem_manager1_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusOrgFreedesktopModemManager1Proxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_org_freedesktop_modem_manager1_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_org_freedesktop_modem_manager1_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusOrgFreedesktopModemManager1Proxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1.top_of_page">org.freedesktop.ModemManager1</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_org_freedesktop_modem_manager1_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusOrgFreedesktopModemManager1Proxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusOrgFreedesktopModemManager1Proxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1.top_of_page">org.freedesktop.ModemManager1</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_org_freedesktop_modem_manager1_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_org_freedesktop_modem_manager1_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_org_freedesktop_modem_manager1_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_org_freedesktop_modem_manager1_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_org_freedesktop_modem_manager1_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusOrgFreedesktopModemManager1Skeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusOrgFreedesktopModemManager1.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusOrgFreedesktopModemManager1Skeleton extends Gio.DBusInterface, GdbusOrgFreedesktopModemManager1 {

    // Own properties of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1Skeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1Skeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::version", callback: (...args: any[]) => void): number
    on(sigName: "notify::version", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::version", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::version", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::version", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusOrgFreedesktopModemManager1Skeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusOrgFreedesktopModemManager1Skeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1Skeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1Skeleton

    constructor(config?: GdbusOrgFreedesktopModemManager1Skeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1.top_of_page">org.freedesktop.ModemManager1</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1.top_of_page">org.freedesktop.ModemManager1</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusOrgFreedesktopModemManager1Skeleton
    _init(config?: GdbusOrgFreedesktopModemManager1Skeleton.ConstructorProperties): void
}

export module GdbusSimProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusSim.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusSimProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusSim {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSimProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusSimProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::active", callback: (...args: any[]) => void): number
    on(sigName: "notify::active", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::active", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::active", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::active", ...args: any[]): void
    connect(sigName: "notify::eid", callback: (...args: any[]) => void): number
    on(sigName: "notify::eid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::eid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::eid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::eid", ...args: any[]): void
    connect(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void): number
    on(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::emergency-numbers", ...args: any[]): void
    connect(sigName: "notify::esim-status", callback: (...args: any[]) => void): number
    on(sigName: "notify::esim-status", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::esim-status", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::esim-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::esim-status", ...args: any[]): void
    connect(sigName: "notify::gid1", callback: (...args: any[]) => void): number
    on(sigName: "notify::gid1", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gid1", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gid1", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gid1", ...args: any[]): void
    connect(sigName: "notify::gid2", callback: (...args: any[]) => void): number
    on(sigName: "notify::gid2", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gid2", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gid2", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gid2", ...args: any[]): void
    connect(sigName: "notify::imsi", callback: (...args: any[]) => void): number
    on(sigName: "notify::imsi", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::imsi", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::imsi", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::imsi", ...args: any[]): void
    connect(sigName: "notify::operator-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-identifier", ...args: any[]): void
    connect(sigName: "notify::operator-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-name", ...args: any[]): void
    connect(sigName: "notify::preferred-networks", callback: (...args: any[]) => void): number
    on(sigName: "notify::preferred-networks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::preferred-networks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::preferred-networks", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::preferred-networks", ...args: any[]): void
    connect(sigName: "notify::removability", callback: (...args: any[]) => void): number
    on(sigName: "notify::removability", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::removability", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::removability", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::removability", ...args: any[]): void
    connect(sigName: "notify::sim-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim-identifier", ...args: any[]): void
    connect(sigName: "notify::sim-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim-type", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusSimProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusSimProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSimProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusSimProxy

    constructor(config?: GdbusSimProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_sim_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_sim_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusSimProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_sim_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_sim_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusSimProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_sim_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_sim_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusSimProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sim.top_of_page">org.freedesktop.ModemManager1.Sim</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_sim_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusSimProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusSimProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sim.top_of_page">org.freedesktop.ModemManager1.Sim</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sim_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sim_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_sim_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sim_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sim_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusSimSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusSim.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusSimSkeleton extends Gio.DBusInterface, GdbusSim {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSimSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusSimSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::active", callback: (...args: any[]) => void): number
    on(sigName: "notify::active", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::active", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::active", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::active", ...args: any[]): void
    connect(sigName: "notify::eid", callback: (...args: any[]) => void): number
    on(sigName: "notify::eid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::eid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::eid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::eid", ...args: any[]): void
    connect(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void): number
    on(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::emergency-numbers", ...args: any[]): void
    connect(sigName: "notify::esim-status", callback: (...args: any[]) => void): number
    on(sigName: "notify::esim-status", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::esim-status", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::esim-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::esim-status", ...args: any[]): void
    connect(sigName: "notify::gid1", callback: (...args: any[]) => void): number
    on(sigName: "notify::gid1", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gid1", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gid1", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gid1", ...args: any[]): void
    connect(sigName: "notify::gid2", callback: (...args: any[]) => void): number
    on(sigName: "notify::gid2", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gid2", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gid2", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gid2", ...args: any[]): void
    connect(sigName: "notify::imsi", callback: (...args: any[]) => void): number
    on(sigName: "notify::imsi", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::imsi", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::imsi", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::imsi", ...args: any[]): void
    connect(sigName: "notify::operator-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-identifier", ...args: any[]): void
    connect(sigName: "notify::operator-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-name", ...args: any[]): void
    connect(sigName: "notify::preferred-networks", callback: (...args: any[]) => void): number
    on(sigName: "notify::preferred-networks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::preferred-networks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::preferred-networks", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::preferred-networks", ...args: any[]): void
    connect(sigName: "notify::removability", callback: (...args: any[]) => void): number
    on(sigName: "notify::removability", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::removability", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::removability", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::removability", ...args: any[]): void
    connect(sigName: "notify::sim-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim-identifier", ...args: any[]): void
    connect(sigName: "notify::sim-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim-type", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusSimSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusSimSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSimSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusSimSkeleton

    constructor(config?: GdbusSimSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sim.top_of_page">org.freedesktop.ModemManager1.Sim</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sim.top_of_page">org.freedesktop.ModemManager1.Sim</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusSimSkeleton
    _init(config?: GdbusSimSkeleton.ConstructorProperties): void
}

export module GdbusSmsProxy {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusSms.ConstructorProperties, Gio.DBusProxy.ConstructorProperties {
    }

}

export interface GdbusSmsProxy extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusSms {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSmsProxy

    __gtype__: number

    // Class property signals of ModemManager-1.0.ModemManager.GdbusSmsProxy

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::class", callback: (...args: any[]) => void): number
    on(sigName: "notify::class", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::class", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::class", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::class", ...args: any[]): void
    connect(sigName: "notify::data", callback: (...args: any[]) => void): number
    on(sigName: "notify::data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::data", ...args: any[]): void
    connect(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void): number
    on(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::delivery-report-request", ...args: any[]): void
    connect(sigName: "notify::delivery-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::delivery-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::delivery-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::delivery-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::delivery-state", ...args: any[]): void
    connect(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void): number
    on(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::discharge-timestamp", ...args: any[]): void
    connect(sigName: "notify::message-reference", callback: (...args: any[]) => void): number
    on(sigName: "notify::message-reference", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::message-reference", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::message-reference", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::message-reference", ...args: any[]): void
    connect(sigName: "notify::number", callback: (...args: any[]) => void): number
    on(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::number", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::number", ...args: any[]): void
    connect(sigName: "notify::pdu-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::pdu-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::pdu-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::pdu-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::pdu-type", ...args: any[]): void
    connect(sigName: "notify::service-category", callback: (...args: any[]) => void): number
    on(sigName: "notify::service-category", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::service-category", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::service-category", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::service-category", ...args: any[]): void
    connect(sigName: "notify::smsc", callback: (...args: any[]) => void): number
    on(sigName: "notify::smsc", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::smsc", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::smsc", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::smsc", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::storage", callback: (...args: any[]) => void): number
    on(sigName: "notify::storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::storage", ...args: any[]): void
    connect(sigName: "notify::teleservice-id", callback: (...args: any[]) => void): number
    on(sigName: "notify::teleservice-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::teleservice-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::teleservice-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::teleservice-id", ...args: any[]): void
    connect(sigName: "notify::text", callback: (...args: any[]) => void): number
    on(sigName: "notify::text", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::text", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::text", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::text", ...args: any[]): void
    connect(sigName: "notify::timestamp", callback: (...args: any[]) => void): number
    on(sigName: "notify::timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::timestamp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::timestamp", ...args: any[]): void
    connect(sigName: "notify::validity", callback: (...args: any[]) => void): number
    on(sigName: "notify::validity", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::validity", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::validity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::validity", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusSmsProxy structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusSmsProxy extends Gio.DBusProxy {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSmsProxy

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusSmsProxy

    constructor(config?: GdbusSmsProxy.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_gdbus_sms_proxy_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_sms_proxy_new().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusSmsProxy

    // Overloads of newFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Finishes an operation started with mm_gdbus_sms_proxy_new_for_bus().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_sms_proxy_new_for_bus().
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusFinish(res: Gio.AsyncResult): GdbusSmsProxy

    // Overloads of newForBusFinish

    /**
     * Finishes creating a #GDBusProxy.
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().
     * @returns A #GDBusProxy or %NULL if @error is set.    Free with g_object_unref().
     */
    static newForBusFinish(res: Gio.AsyncResult): Gio.DBusProxy
    /**
     * Like mm_gdbus_sms_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_sms_proxy_new_for_bus() for the asynchronous version of this constructor.
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusSmsProxy

    // Overloads of newForBusSync

    /**
     * Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface        that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newForBusSync(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    /**
     * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sms.top_of_page">org.freedesktop.ModemManager1.Sms</link>. See g_dbus_proxy_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_sms_proxy_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed proxy object or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusSmsProxy

    // Overloads of newSync

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and synchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to return immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a synchronous failable constructor. See g_dbus_proxy_new()
     * and g_dbus_proxy_new_finish() for the asynchronous version.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #GDBusProxy or %NULL if error is set.    Free with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null): Gio.DBusProxy
    _init(config?: GdbusSmsProxy.ConstructorProperties): void
    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sms.top_of_page">org.freedesktop.ModemManager1.Sms</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sms_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sms_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_sms_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sms_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sms_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
}

export module GdbusSmsSkeleton {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusInterface.ConstructorProperties, GdbusSms.ConstructorProperties, Gio.DBusInterfaceSkeleton.ConstructorProperties {
    }

}

export interface GdbusSmsSkeleton extends Gio.DBusInterface, GdbusSms {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSmsSkeleton

    __gtype__: number

    // Conflicting methods

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo
    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo (never %NULL). Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Overloads of getInfo

    /**
     * Gets D-Bus introspection information for the D-Bus interface
     * implemented by `interface_`.
     * @virtual 
     * @returns A #GDBusInterfaceInfo. Do not free.
     */
    getInfo(): Gio.DBusInterfaceInfo

    // Class property signals of ModemManager-1.0.ModemManager.GdbusSmsSkeleton

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::class", callback: (...args: any[]) => void): number
    on(sigName: "notify::class", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::class", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::class", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::class", ...args: any[]): void
    connect(sigName: "notify::data", callback: (...args: any[]) => void): number
    on(sigName: "notify::data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::data", ...args: any[]): void
    connect(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void): number
    on(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::delivery-report-request", ...args: any[]): void
    connect(sigName: "notify::delivery-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::delivery-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::delivery-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::delivery-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::delivery-state", ...args: any[]): void
    connect(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void): number
    on(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::discharge-timestamp", ...args: any[]): void
    connect(sigName: "notify::message-reference", callback: (...args: any[]) => void): number
    on(sigName: "notify::message-reference", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::message-reference", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::message-reference", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::message-reference", ...args: any[]): void
    connect(sigName: "notify::number", callback: (...args: any[]) => void): number
    on(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::number", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::number", ...args: any[]): void
    connect(sigName: "notify::pdu-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::pdu-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::pdu-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::pdu-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::pdu-type", ...args: any[]): void
    connect(sigName: "notify::service-category", callback: (...args: any[]) => void): number
    on(sigName: "notify::service-category", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::service-category", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::service-category", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::service-category", ...args: any[]): void
    connect(sigName: "notify::smsc", callback: (...args: any[]) => void): number
    on(sigName: "notify::smsc", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::smsc", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::smsc", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::smsc", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::storage", callback: (...args: any[]) => void): number
    on(sigName: "notify::storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::storage", ...args: any[]): void
    connect(sigName: "notify::teleservice-id", callback: (...args: any[]) => void): number
    on(sigName: "notify::teleservice-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::teleservice-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::teleservice-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::teleservice-id", ...args: any[]): void
    connect(sigName: "notify::text", callback: (...args: any[]) => void): number
    on(sigName: "notify::text", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::text", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::text", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::text", ...args: any[]): void
    connect(sigName: "notify::timestamp", callback: (...args: any[]) => void): number
    on(sigName: "notify::timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::timestamp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::timestamp", ...args: any[]): void
    connect(sigName: "notify::validity", callback: (...args: any[]) => void): number
    on(sigName: "notify::validity", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::validity", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::validity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::validity", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MmGdbusSmsSkeleton structure contains only private data and should only be accessed using the provided API.
 * @class 
 */
export class GdbusSmsSkeleton extends Gio.DBusInterfaceSkeleton {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSmsSkeleton

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.GdbusSmsSkeleton

    constructor(config?: GdbusSmsSkeleton.ConstructorProperties) 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sms.top_of_page">org.freedesktop.ModemManager1.Sms</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    constructor() 
    /**
     * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sms.top_of_page">org.freedesktop.ModemManager1.Sms</link>.
     * @constructor 
     * @returns The skeleton object.
     */
    static new(): GdbusSmsSkeleton
    _init(config?: GdbusSmsSkeleton.ConstructorProperties): void
}

export module KernelEventProperties {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface KernelEventProperties {

    // Own properties of ModemManager-1.0.ModemManager.KernelEventProperties

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.KernelEventProperties

    /**
     * Gets the action.
     * @returns The action. Do not free the returned value, it is owned by @self.
     */
    getAction(): string | null
    /**
     * Gets the name.
     * @returns The name. Do not free the returned value, it is owned by @self.
     */
    getName(): string | null
    /**
     * Gets the subsystem.
     * @returns The subsystem. Do not free the returned value, it is owned by @self.
     */
    getSubsystem(): string | null
    /**
     * Gets the unique ID of the physical device.
     * @returns The uid. Do not free the returned value, it is owned by @self.
     */
    getUid(): string | null
    /**
     * Sets the action.
     * @param action The action to set.
     */
    setAction(action: string | null): void
    /**
     * Sets the name.
     * @param name The name to set.
     */
    setName(name: string | null): void
    /**
     * Sets the subsystem.
     * @param subsystem The subsystem to set.
     */
    setSubsystem(subsystem: string | null): void
    /**
     * Sets the unique ID of the physical device.
     * @param uid The uid to set.
     */
    setUid(uid: string | null): void

    // Class property signals of ModemManager-1.0.ModemManager.KernelEventProperties

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMKernelEventProperties structure contains private data and should only be
 * accessed using the provided API.
 * @class 
 */
export class KernelEventProperties extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.KernelEventProperties

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.KernelEventProperties

    constructor(config?: KernelEventProperties.ConstructorProperties) 
    /**
     * Creates a new empty #MMKernelEventProperties.
     * @constructor 
     * @returns a #MMKernelEventProperties. The returned value should be freed with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new empty #MMKernelEventProperties.
     * @constructor 
     * @returns a #MMKernelEventProperties. The returned value should be freed with g_object_unref().
     */
    static new(): KernelEventProperties
    _init(config?: KernelEventProperties.ConstructorProperties): void
}

export module Location3gpp {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface Location3gpp {

    // Own properties of ModemManager-1.0.ModemManager.Location3gpp

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Location3gpp

    /**
     * Gets the cell ID of the 3GPP network.
     * @returns the cell ID, or 0 if unknown.
     */
    getCellId(): number
    /**
     * Gets the location area code of the 3GPP network.
     * @returns the location area code, or 0 if unknown.
     */
    getLocationAreaCode(): number
    /**
     * Gets the Mobile Country Code of the 3GPP network.
     * @returns the MCC, or 0 if unknown.
     */
    getMobileCountryCode(): number
    /**
     * Gets the Mobile Network Code of the 3GPP network.
     * 
     * Note that 0 may actually be a valid MNC. In general, the MNC should be
     * considered valid just if the reported MCC is valid, as MCC should never
     * be 0.
     * @returns the MNC, or 0 if unknown.
     */
    getMobileNetworkCode(): number
    /**
     * Gets the 3GPP network Mobile Country Code and Mobile Network Code.
     * 
     * Returned in the format <literal>"MCCMNC"</literal>, where
     * <literal>MCC</literal> is the three-digit ITU E.212 Mobile Country Code
     * and <literal>MNC</literal> is the two- or three-digit GSM Mobile Network
     * Code. e.g. e<literal>"31026"</literal> or <literal>"310260"</literal>.
     * @returns The operator code, or %NULL if none available.
     */
    getOperatorCode(): string | null
    /**
     * Gets the location area code of the 3GPP network.
     * @returns the location area code, or 0 if unknown.
     */
    getTrackingAreaCode(): number

    // Class property signals of ModemManager-1.0.ModemManager.Location3gpp

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMLocation3gpp structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class Location3gpp extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.Location3gpp

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Location3gpp

    constructor(config?: Location3gpp.ConstructorProperties) 
    _init(config?: Location3gpp.ConstructorProperties): void
}

export module LocationCdmaBs {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface LocationCdmaBs {

    // Own properties of ModemManager-1.0.ModemManager.LocationCdmaBs

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.LocationCdmaBs

    /**
     * Gets the latitude, in the [-90,90] range.
     * @returns the latitude, or %MM_LOCATION_LATITUDE_UNKNOWN if unknown.
     */
    getLatitude(): number
    /**
     * Gets the longitude, in the [-180,180] range.
     * @returns the longitude, or %MM_LOCATION_LONGITUDE_UNKNOWN if unknown.
     */
    getLongitude(): number

    // Class property signals of ModemManager-1.0.ModemManager.LocationCdmaBs

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMLocationCdmaBs structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class LocationCdmaBs extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.LocationCdmaBs

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.LocationCdmaBs

    constructor(config?: LocationCdmaBs.ConstructorProperties) 
    _init(config?: LocationCdmaBs.ConstructorProperties): void
}

export module LocationGpsNmea {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface LocationGpsNmea {

    // Own properties of ModemManager-1.0.ModemManager.LocationGpsNmea

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.LocationGpsNmea

    /**
     * Gets a compilation of all cached traces, in a single string.
     * Traces are separated by '\r\n'.
     * @returns a string containing all traces, or #NULL if none available. The returned value should be freed with g_free().
     */
    buildFull(): string | null
    /**
     * Gets the last cached value of the specific `trace_type` given.
     * @param traceType specific NMEA trace type to gather.
     * @returns the NMEA trace, or %NULL if not available. Do not free the returned value, it is owned by @self.
     */
    getTrace(traceType: string | null): string | null
    /**
     * Gets all cached traces.
     * @returns The list of traces, or %NULL if none available. The returned value should be freed with g_strfreev().
     */
    getTraces(): string[]

    // Class property signals of ModemManager-1.0.ModemManager.LocationGpsNmea

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMLocationGpsNmea structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class LocationGpsNmea extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.LocationGpsNmea

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.LocationGpsNmea

    constructor(config?: LocationGpsNmea.ConstructorProperties) 
    _init(config?: LocationGpsNmea.ConstructorProperties): void
}

export module LocationGpsRaw {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface LocationGpsRaw {

    // Own properties of ModemManager-1.0.ModemManager.LocationGpsRaw

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.LocationGpsRaw

    /**
     * Gets the altitude, in the [-90,90] range.
     * @returns the altitude, or %MM_LOCATION_ALTITUDE_UNKNOWN if unknown.
     */
    getAltitude(): number
    /**
     * Gets the latitude, in the [-90,90] range.
     * @returns the latitude, or %MM_LOCATION_LATITUDE_UNKNOWN if unknown.
     */
    getLatitude(): number
    /**
     * Gets the longitude, in the [-180,180] range.
     * @returns the longitude, or %MM_LOCATION_LONGITUDE_UNKNOWN if unknown.
     */
    getLongitude(): number
    /**
     * Gets the UTC time of the location being reported.
     * @returns a string with the UTC time, or #NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    getUtcTime(): string | null

    // Class property signals of ModemManager-1.0.ModemManager.LocationGpsRaw

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMLocationGpsRaw structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class LocationGpsRaw extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.LocationGpsRaw

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.LocationGpsRaw

    constructor(config?: LocationGpsRaw.ConstructorProperties) 
    _init(config?: LocationGpsRaw.ConstructorProperties): void
}

export module Manager {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusObjectManager.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusObjectManagerClient.ConstructorProperties {
    }

}

export interface Manager extends Gio.AsyncInitable, Gio.DBusObjectManager, Gio.Initable {

    // Own properties of ModemManager-1.0.ModemManager.Manager

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Manager

    /**
     * Gets the #GDBusProxy interface of the `manager`.
     * @returns The #GDBusProxy interface of @manager, or #NULL if none. The returned object must be freed with g_object_unref().
     */
    getProxy(): Gio.DBusProxy
    /**
     * Gets the ModemManager version, as reported by the daemon.
     * 
     * It is safe to assume this value never changes during runtime.
     * @returns The version, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getVersion(): string | null
    /**
     * Asynchronously requests to add an inhibition on the device identified by
     * `uid`.
     * 
     * The `uid` must be the unique ID retrieved from an existing #MMModem using
     * mm_modem_get_device(). The caller should keep track of this `uid` and use it
     * in the mm_manager_uninhibit_device() call when the inhibition is no longer
     * required.
     * 
     * The inhibition added with this method may also be automatically removed when
     * the caller program disappears from the bus (e.g. if the program ends before
     * having called mm_manager_uninhibit_device() explicitly).
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_manager_inhibit_device_finish() to get the result of the operation.
     * 
     * See mm_manager_inhibit_device_sync() for the synchronous, blocking version of
     * this method.
     * @param uid the unique ID of the physical device.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    inhibitDevice(uid: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_manager_inhibit_device().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_manager_inhibit_device().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    inhibitDeviceFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to add an inhibition on the device identified by `uid`.
     * 
     * The `uid` must be the unique ID retrieved from an existing #MMModem using
     * mm_modem_get_device(). The caller should keep track of this `uid` and use it
     * in the mm_manager_uninhibit_device_sync() call when the inhibition is no
     * longer required.
     * 
     * The inhibition added with this method may also be automatically removed when
     * the caller program disappears from the bus (e.g. if the program ends before
     * having called mm_manager_uninhibit_device_sync() explicitly).
     * 
     * See mm_manager_inhibit_device() for the asynchronous version of this method.
     * @param uid the unique ID of the physical device.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    inhibitDeviceSync(uid: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets the #GDBusProxy interface of the `manager`.
     * @returns The #GDBusProxy interface of @manager, or #NULL if none. Do not free the returned object, it is owned by @manager.
     */
    peekProxy(): Gio.DBusProxy
    /**
     * Asynchronously report kernel event.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_manager_report_kernel_event_finish() to get the result of the operation.
     * 
     * See mm_manager_report_kernel_event_sync() for the synchronous, blocking
     * version of this method.
     * @param properties the properties of the kernel event.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    reportKernelEvent(properties: KernelEventProperties, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_manager_report_kernel_event().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_manager_report_kernel_event().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    reportKernelEventFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously report kernel event.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_manager_report_kernel_event() for the asynchronous version of this
     * method.
     * @param properties the properties of the kernel event.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    reportKernelEventSync(properties: KernelEventProperties, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously requests to scan looking for devices.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_manager_scan_devices_finish() to get the result of the operation.
     * 
     * See mm_manager_scan_devices_sync() for the synchronous, blocking version of
     * this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    scanDevices(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_manager_scan_devices().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_manager_scan_devices().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    scanDevicesFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to scan looking for devices.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_manager_scan_devices() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    scanDevicesSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously requests to set the specified logging level in the daemon.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_manager_set_logging_finish() to get the result of the operation.
     * 
     * See mm_manager_set_logging_sync() for the synchronous, blocking version of
     * this method.
     * @param level the login level to set.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setLogging(level: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_manager_set_logging().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_manager_set_logging().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    setLoggingFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to set the specified logging level in the daemon.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_manager_set_logging() for the asynchronous version of this method.
     * @param level the login level to set.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    setLoggingSync(level: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously requests to remove an inhibition on the device identified by
     * `uid`.
     * 
     * The `uid` must be the same unique ID that was sent in the inhibition request.
     * 
     * Only the same program that placed an inhibition on a given device is able to
     * remove the inhibition.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_manager_uninhibit_device_finish() to get the result of the operation.
     * 
     * See mm_manager_uninhibit_device_sync() for the synchronous, blocking version
     * of this method.
     * @param uid the unique ID of the physical device.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    uninhibitDevice(uid: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_manager_uninhibit_device().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_manager_uninhibit_device().
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    uninhibitDeviceFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to remove an inhibition on the device identified by
     * `uid`.
     * 
     * The `uid` must be the same unique ID that was sent in the inhibition request.
     * 
     * Only the same program that placed an inhibition on a given device is able to
     * remove the inhibition.
     * 
     * See mm_manager_uninhibit_device() for the asynchronous version of this
     * method.
     * @param uid the unique ID of the physical device.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the call succeeded, %FALSE if @error is set.
     */
    uninhibitDeviceSync(uid: string | null, cancellable: Gio.Cancellable | null): boolean

    // Class property signals of ModemManager-1.0.ModemManager.Manager

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::bus-type", ...args: any[]): void
    connect(sigName: "notify::connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::connection", ...args: any[]): void
    connect(sigName: "notify::flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::flags", ...args: any[]): void
    connect(sigName: "notify::get-proxy-type-destroy-notify", callback: (...args: any[]) => void): number
    on(sigName: "notify::get-proxy-type-destroy-notify", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::get-proxy-type-destroy-notify", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::get-proxy-type-destroy-notify", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::get-proxy-type-destroy-notify", ...args: any[]): void
    connect(sigName: "notify::get-proxy-type-func", callback: (...args: any[]) => void): number
    on(sigName: "notify::get-proxy-type-func", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::get-proxy-type-func", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::get-proxy-type-func", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::get-proxy-type-func", ...args: any[]): void
    connect(sigName: "notify::get-proxy-type-user-data", callback: (...args: any[]) => void): number
    on(sigName: "notify::get-proxy-type-user-data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::get-proxy-type-user-data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::get-proxy-type-user-data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::get-proxy-type-user-data", ...args: any[]): void
    connect(sigName: "notify::name", callback: (...args: any[]) => void): number
    on(sigName: "notify::name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::name", ...args: any[]): void
    connect(sigName: "notify::name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::name-owner", ...args: any[]): void
    connect(sigName: "notify::object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::object-path", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMManager structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class Manager extends GdbusObjectManagerClient {

    // Own properties of ModemManager-1.0.ModemManager.Manager

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Manager

    constructor(config?: Manager.ConstructorProperties) 
    /**
     * Finishes an operation started with mm_manager_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_manager_new().
     * @returns The constructed object manager client or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): Manager

    // Overloads of newFinish

    /**
     * Finishes an operation started with mm_gdbus_object_manager_client_new().
     * @constructor 
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_object_manager_client_new().
     * @returns The constructed object manager client or %NULL if @error is set.
     */
    static newFinish(res: Gio.AsyncResult): GdbusObjectManagerClient
    /**
     * Finishes an operation started with g_dbus_object_manager_client_new().
     * @constructor 
     * @param res A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_object_manager_client_new().
     * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
     */
    static newFinish(res: Gio.AsyncResult): Gio.DBusObjectManagerClient
    /**
     * Synchronously creates a #MMManager.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_manager_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed object manager client or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusObjectManagerClientFlags, cancellable: Gio.Cancellable | null): Manager

    // Overloads of newSync

    /**
     * Synchronously creates #GDBusObjectManagerClient using mm_gdbus_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new_sync() for more details.
     * 
     * The calling thread is blocked until a reply is received.
     * 
     * See mm_gdbus_object_manager_client_new() for the asynchronous version of this constructor.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The constructed object manager client or %NULL if @error is set.
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null): GdbusObjectManagerClient
    /**
     * Creates a new #GDBusObjectManagerClient object.
     * 
     * This is a synchronous failable constructor - the calling thread is
     * blocked until a reply is received. See g_dbus_object_manager_client_new()
     * for the asynchronous version.
     * @constructor 
     * @param connection A #GDBusConnection.
     * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name The owner of the control object (unique or well-known name), or %NULL when not using a message bus connection.
     * @param objectPath The object path of the control object.
     * @param getProxyTypeFunc A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
     * @param cancellable A #GCancellable or %NULL
     * @returns A   #GDBusObjectManagerClient object or %NULL if @error is set. Free   with g_object_unref().
     */
    static newSync(connection: Gio.DBusConnection, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, getProxyTypeFunc: Gio.DBusProxyTypeFunc | null, cancellable: Gio.Cancellable | null): Gio.DBusObjectManagerClient
    _init(config?: Manager.ConstructorProperties): void
    /**
     * Asynchronously creates a #MMManager.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from.
     * 
     * You can then call mm_manager_new_finish() to get the result of the operation.
     * 
     * See mm_manager_new_sync() for the synchronous, blocking version of this
     * constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusObjectManagerClientFlags, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Asynchronously creates #GDBusObjectManagerClient using mm_gdbus_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_object_manager_client_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_object_manager_client_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Asynchronously creates a new #GDBusObjectManagerClient object.
     * 
     * This is an asynchronous failable constructor. When the result is
     * ready, `callback` will be invoked in the
     * [thread-default main context][g-main-context-push-thread-default]
     * of the thread you are calling this method from. You can
     * then call g_dbus_object_manager_client_new_finish() to get the result. See
     * g_dbus_object_manager_client_new_sync() for the synchronous version.
     * @param connection A #GDBusConnection.
     * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name The owner of the control object (unique or well-known name).
     * @param objectPath The object path of the control object.
     * @param getProxyTypeFunc A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
     * @param cancellable A #GCancellable or %NULL
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, getProxyTypeFunc: Gio.DBusProxyTypeFunc | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Conflicting static methods

    /**
     * Like mm_gdbus_object_manager_client_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_object_manager_client_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_object_manager_client_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_object_manager_client_new() but takes a #GBusType instead of a
     * #GDBusConnection.
     * 
     * This is an asynchronous failable constructor. When the result is
     * ready, `callback` will be invoked in the
     * [thread-default main loop][g-main-context-push-thread-default]
     * of the thread you are calling this method from. You can
     * then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
     * g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.
     * @param busType A #GBusType.
     * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name The owner of the control object (unique or well-known name).
     * @param objectPath The object path of the control object.
     * @param getProxyTypeFunc A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
     * @param cancellable A #GCancellable or %NULL
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, getProxyTypeFunc: Gio.DBusProxyTypeFunc | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_object_manager_client_new() but takes a #GBusType instead of a
     * #GDBusConnection.
     * 
     * This is an asynchronous failable constructor. When the result is
     * ready, `callback` will be invoked in the
     * [thread-default main loop][g-main-context-push-thread-default]
     * of the thread you are calling this method from. You can
     * then call g_dbus_object_manager_client_new_for_bus_finish() to get the result. See
     * g_dbus_object_manager_client_new_for_bus_sync() for the synchronous version.
     * @param busType A #GBusType.
     * @param flags Zero or more flags from the #GDBusObjectManagerClientFlags enumeration.
     * @param name The owner of the control object (unique or well-known name).
     * @param objectPath The object path of the control object.
     * @param getProxyTypeFunc A #GDBusProxyTypeFunc function or %NULL to always construct #GDBusProxy proxies.
     * @param cancellable A #GCancellable or %NULL
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusObjectManagerClientFlags, name: string | null, objectPath: string | null, getProxyTypeFunc: Gio.DBusProxyTypeFunc | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
}

export module Modem {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModem.ConstructorProperties, GdbusModemProxy.ConstructorProperties {
    }

}

export interface Modem extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModem {

    // Own properties of ModemManager-1.0.ModemManager.Modem

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Modem

    /**
     * Asynchronously runs an AT command in the modem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_command_finish() to get the result of the operation.
     * 
     * See mm_modem_command_sync() for the synchronous, blocking version of this
     * method.
     * @param cmd AT command to run.
     * @param timeout Maximum time to wait for the response, in seconds.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    command(cmd: string | null, timeout: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_command().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_command().
     * @returns A newly allocated string with the reply to the command, or #NULL if @error is set. The returned value should be freed with g_free().
     */
    commandFinish(res: Gio.AsyncResult): string | null
    /**
     * Synchronously runs an AT command in the modem.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_command() for the asynchronous version of this method.
     * @param cmd AT command to run.
     * @param timeout Maximum time to wait for the response, in seconds.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A newly allocated string with the reply to the command, or #NULL if @error is set. The returned value should be freed with g_free().
     */
    commandSync(cmd: string | null, timeout: number, cancellable: Gio.Cancellable | null): string | null
    /**
     * Asynchronously creates a new packet data bearer in the #MMModem.
     * 
     * This request may fail if the modem does not support additional bearers,
     * if too many bearers are already defined, or if `properties` are invalid.
     * 
     * See <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.CreateBearer">CreateBearer</link>
     * to check which properties may be passed.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_create_bearer_finish() to get the result of the operation.
     * 
     * See mm_modem_create_bearer_sync() for the synchronous, blocking version of
     * this method.
     * @param properties A #MMBearerProperties object with the properties to use.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    createBearer(properties: BearerProperties, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_create_bearer().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_create_bearer().
     * @returns A newly created #MMBearer, or %NULL if @error is set.
     */
    createBearerFinish(res: Gio.AsyncResult): Bearer
    /**
     * Synchronously creates a new packet data bearer in the #MMModem.
     * 
     * This request may fail if the modem does not support additional bearers,
     * if too many bearers are already defined, or if `properties` are invalid.
     * 
     * See <link linkend="gdbus-method-org-freedesktop-ModemManager1-Modem.CreateBearer">CreateBearer</link>
     * to check which properties may be passed.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_create_bearer() for the asynchronous version of this method.
     * @param properties A #MMBearerProperties object with the properties to use.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A newly created #MMBearer, or %NULL if @error is set.
     */
    createBearerSync(properties: BearerProperties, cancellable: Gio.Cancellable | null): Bearer
    /**
     * Asynchronously deletes a given bearer from the #MMModem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_delete_bearer_finish() to get the result of the operation.
     * 
     * See mm_modem_delete_bearer_sync() for the synchronous, blocking version of
     * this method.
     * @param bearer Path of the bearer to delete.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    deleteBearer(bearer: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_delete_bearer().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_delete_bearer().
     * @returns %TRUE if the bearer was deleted, %FALSE if @error is set.
     */
    deleteBearerFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously deletes a given bearer from the #MMModem.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_delete_bearer() for the asynchronous version of this method.
     * @param bearer Path of the bearer to delete.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the bearer was deleted, %FALSE if @error is set.
     */
    deleteBearerSync(bearer: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously tries to disable the #MMModem. When disabled, the modem enters
     * low-power state and no network-related operations are available.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_disable_finish() to get the result of the operation.
     * 
     * See mm_modem_disable_sync() for the synchronous, blocking version of this
     * method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    disable(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_disable().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_disable().
     * @returns %TRUE if the modem was properly disabled, %FALSE if @error is set.
     */
    disableFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously tries to disable the #MMModem. When disabled, the modem enters
     * low-power state and no network-related operations are available.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_disable() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the modem was properly disabled, %FALSE if @error is set.
     */
    disableSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a copy of the DBus paths of the #MMBearer handled in this #MMModem.
     * @returns The DBus paths of the #MMBearer handled in this #MMModem, or %NULL if none available. The returned value should be freed with g_strfreev().
     */
    dupBearerPaths(): string[]
    /**
     * Gets a copy of the carrier-specific configuration (MCFG) in use, as reported
     * by this #MMModem.
     * @returns The carrier configuration, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupCarrierConfiguration(): string | null
    /**
     * Gets a copy of the carrier-specific configuration revision in use, as
     * reported by this #MMModem.
     * @returns The carrier configuration revision, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupCarrierConfigurationRevision(): string | null
    /**
     * Gets a copy of the physical modem device reference (ie, USB, PCI, PCMCIA
     * device), which may be dependent upon the operating system.
     * @returns The device, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupDevice(): string | null
    /**
     * Gets a copy of a best-effort device identifier based on various device
     * information like model name, firmware revision, USB/PCI/PCMCIA IDs, and other
     * properties.
     * 
     * This ID is not guaranteed to be unique and may be shared between
     * identical devices with the same firmware, but is intended to be "unique
     * enough" for use as a casual device identifier for various user
     * experience operations.
     * 
     * This is not the device's IMEI or ESN since those may not be available
     * before unlocking the device via a PIN.
     * @returns The device identifier, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupDeviceIdentifier(): string | null
    /**
     * Gets a copy of the Operating System device driver handling communication with
     * the modem hardware.
     * @returns The drivers, or %NULL if none available. The returned value should be freed with g_strfreev().
     */
    dupDrivers(): string[]
    /**
     * Gets a copy of the identity of the #MMModem.
     * 
     * This will be the IMEI number for GSM devices and the hex-format ESN/MEID
     * for CDMA devices.
     * @returns The equipment identifier, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupEquipmentIdentifier(): string | null
    /**
     * Gets a copy of the equipment hardware revision, as reported by this #MMModem.
     * @returns The equipment hardware revision, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupHardwareRevision(): string | null
    /**
     * Gets a copy of the equipment manufacturer, as reported by this #MMModem.
     * @returns The equipment manufacturer, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupManufacturer(): string | null
    /**
     * Gets a copy of the equipment model, as reported by this #MMModem.
     * @returns The equipment model, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupModel(): string | null
    /**
     * Gets a copy of the list of numbers (e.g. MSISDN in 3GPP) being currently
     * handled by this modem.
     * @returns The list of own numbers or %NULL if none is available. The returned value should be freed with g_strfreev().
     */
    dupOwnNumbers(): string[]
    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets a copy of the name of the plugin handling this #MMModem.
     * @returns The name of the plugin, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupPlugin(): string | null
    /**
     * Gets a copy of the name of the primary port controlling this #MMModem.
     * @returns The name of the primary port. The returned value should be freed with g_free().
     */
    dupPrimaryPort(): string | null
    /**
     * Gets a copy of the equipment revision, as reported by this #MMModem.
     * @returns The equipment revision, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupRevision(): string | null
    /**
     * Gets a copy of the DBus path of the #MMSim handled in this #MMModem.
     * @returns The DBus path of the #MMSim handled in this #MMModem, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupSimPath(): string | null
    /**
     * Gets a copy of the DBus paths of the #MMSim objects available in the
     * different SIM slots handled in this #MMModem. If a given SIM slot at a given
     * index doesn't have a SIM card available, an empty object path will be given.
     * This list includes the currently active SIM object path.
     * @returns The DBus paths of the #MMSim objects handled in this #MMModem, or %NULL if none available. The returned value should be freed with g_strfreev().
     */
    dupSimSlotPaths(): string[]
    /**
     * Asynchronously tries to enable the #MMModem. When enabled, the modem's radio
     * is powered on and data sessions, voice calls, location services, and Short
     * Message Service may be available.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_enable_finish() to get the result of the operation.
     * 
     * See mm_modem_enable_sync() for the synchronous, blocking version of this
     * method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    enable(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_enable().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_enable().
     * @returns %TRUE if the modem was properly enabled, %FALSE if @error is set.
     */
    enableFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously tries to enable the #MMModem. When enabled, the modem's radio
     * is powered on and data sessions, voice calls, location services, and Short
     * Message Service may be available.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_enable() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the modem was properly enabled, %FALSE if @error is set.
     */
    enableSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously clears the modem's configuration (including persistent
     * configuration and state), and returns the device to a factory-default state.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_factory_reset_finish() to get the result of the operation.
     * 
     * See mm_modem_factory_reset_sync() for the synchronous, blocking version of
     * this method.
     * @param code Carrier-supplied code required to reset the modem.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    factoryReset(code: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_factory_reset().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_factory_reset().
     * @returns %TRUE if the factory_reset was successful, %FALSE if @error is set.
     */
    factoryResetFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously clears the modem's configuration (including persistent
     * configuration and state), and returns the device to a factory-default state.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_factory_reset() for the asynchronous version of this method.
     * @param code Carrier-supplied code required to reset the modem.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the factory reset was successful, %FALSE if @error is set.
     */
    factoryResetSync(code: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets the current network access technology used by the #MMModem to
     * communicate with the network.
     * @returns A ##MMModemAccessTechnology value.
     */
    getAccessTechnologies(): ModemAccessTechnology
    /**
     * Gets the DBus paths of the #MMBearer handled in this #MMModem.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_bearer_paths() if on another thread.</warning>
     * @returns The DBus paths of the #MMBearer handled in this #MMModem, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getBearerPaths(): string[]
    /**
     * Gets the carrier-specific configuration (MCFG) in use, as reported by this
     * #MMModem.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_carrier_configuration() if on another thread.</warning>
     * @returns The carrier configuration, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getCarrierConfiguration(): string | null
    /**
     * Gets the carrier-specific configuration revision in use, as reported by this
     * #MMModem.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_carrier_configuration() if on another thread.</warning>
     * @returns The carrier configuration revision, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getCarrierConfigurationRevision(): string | null
    /**
     * Asynchronously requests to get info about serving and neighboring cells.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_get_cell_info_finish() to get the result of the operation.
     * 
     * See mm_modem_get_cell_info_sync() for the synchronous, blocking version of this
     * method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    getCellInfo(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_get_cell_info().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_get_cell_info().
     * @returns a list of #MMCellInfo objects, or #NULL if @error is set. The returned value should be freed with g_list_free_full() using g_object_unref() as #GDestroyNotify function.
     */
    getCellInfoFinish(res: Gio.AsyncResult): CellInfo[]
    /**
     * Synchronously requests to get info about serving and neighboring cells.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_get_cell_info() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns a list of #MMCellInfo objects, or #NULL if @error is set. The returned value should be freed with g_list_free_full() using g_object_unref() as #GDestroyNotify function.
     */
    getCellInfoSync(cancellable: Gio.Cancellable | null): CellInfo[]
    /**
     * Gets the list of radio frequency and technology bands the #MMModem is
     * currently using when connecting to a network.
     * 
     * For POTS devices, only the #MM_MODEM_BAND_ANY band is supported.
     * @returns %TRUE if @bands and @n_bands are set, %FALSE otherwise.
     */
    getCurrentBands(): [ /* returnType */ boolean, /* bands */ ModemBand[] ]
    /**
     * Gets the list of generic families of access technologies supported by this
     * #MMModem without a firmware reload or reinitialization.
     * @returns A bitmask of #MMModemCapability flags.
     */
    getCurrentCapabilities(): ModemCapability
    /**
     * Gets the list of modes specifying the access technologies (eg 2G/3G/4G)
     * the #MMModem is currently allowed to use when connecting to a network, as
     * well as the preferred one, if any.
     * @returns %TRUE if @allowed and @preferred are set, %FALSE otherwise.
     */
    getCurrentModes(): [ /* returnType */ boolean, /* allowed */ ModemMode, /* preferred */ ModemMode ]
    /**
     * Gets the physical modem device reference (ie, USB, PCI, PCMCIA device), which
     * may be dependent upon the operating system.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_device() if on another thread.</warning>
     * @returns The device, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getDevice(): string | null
    /**
     * Gets a best-effort device identifier based on various device information like
     * model name, firmware revision, USB/PCI/PCMCIA IDs, and other properties.
     * 
     * This ID is not guaranteed to be unique and may be shared between
     * identical devices with the same firmware, but is intended to be "unique
     * enough" for use as a casual device identifier for various user
     * experience operations.
     * 
     * This is not the device's IMEI or ESN since those may not be available
     * before unlocking the device via a PIN.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_device_identifier() if on another thread.</warning>
     * @returns The device identifier, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getDeviceIdentifier(): string | null
    /**
     * Gets the Operating System device drivers handling communication with the
     * modem hardware.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_drivers() if on another thread.</warning>
     * @returns The drivers, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getDrivers(): string[]
    /**
     * Gets the identity of the #MMModem.
     * 
     * This will be the IMEI number for GSM devices and the hex-format ESN/MEID
     * for CDMA devices.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_equipment_identifier() if on another thread.</warning>
     * @returns The equipment identifier, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getEquipmentIdentifier(): string | null
    /**
     * Gets the equipment hardware revision, as reported by this #MMModem.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_hardware_revision() if on another thread.</warning>
     * @returns The equipment hardware revision, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getHardwareRevision(): string | null
    /**
     * Gets the equipment manufacturer, as reported by this #MMModem.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_manufacturer() if on another thread.</warning>
     * @returns The equipment manufacturer, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getManufacturer(): string | null
    /**
     * Gets the maximum number of active packet data bearers this #MMModem supports
     * without enabling multiplexing support.
     * 
     * POTS and CDMA2000-only devices support one active bearer, while GSM/UMTS
     * and LTE/5GNR capable devices (including 3GPP+3GPP3 multimode devices) may support
     * one or more active bearers, depending on the amount of physical ports exposed
     * by the device.
     * @returns the maximum number of active packet data bearers.
     */
    getMaxActiveBearers(): number
    /**
     * Gets the maximum number of active packet data bearers this #MMModem supports
     * after enabling multiplexing support on one single network interface.
     * @returns the maximum number of active packet data bearers, or 0 if multiplexing is not supported.
     */
    getMaxActiveMultiplexedBearers(): number
    /**
     * Gets the maximum number of defined packet data bearers this #MMModem
     * supports.
     * 
     * This is not the number of active/connected bearers the modem supports,
     * but simply the number of bearers that may be defined at any given time.
     * For example, POTS and CDMA2000-only devices support only one bearer,
     * while GSM/UMTS devices typically support three or more, and any
     * LTE-capable device (whether LTE-only, GSM/UMTS-capable, and/or
     * CDMA2000-capable) also typically support three or more.
     * @returns the maximum number of defined packet data bearers.
     */
    getMaxBearers(): number
    /**
     * Gets the equipment model, as reported by this #MMModem.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_model() if on another thread.</warning>
     * @returns The equipment model, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getModel(): string | null
    /**
     * Gets the name of the plugin handling this #MMModem.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_plugin() if on another thread.</warning>
     * @returns The name of the plugin, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getPlugin(): string | null
    /**
     * Gets the list of ports in the modem.
     * @returns %TRUE if @ports and @n_ports are set, %FALSE otherwise.
     */
    getPorts(): [ /* returnType */ boolean, /* ports */ ModemPortInfo[] ]
    /**
     * Gets the power state of the #MMModem.
     * @returns A #MMModemPowerState value.
     */
    getPowerState(): ModemPowerState
    /**
     * Gets the name of the primary port controlling this #MMModem.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_primary_port() if on another thread.</warning>
     * @returns The name of the primary port. Do not free the returned value, it belongs to @self.
     */
    getPrimaryPort(): string | null
    /**
     * Gets the SIM slot number of the primary active SIM.
     * @returns slot number, in the [1,N] range.
     */
    getPrimarySimSlot(): number
    /**
     * Gets the equipment revision, as reported by this #MMModem.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_revision() if on another thread.</warning>
     * @returns The equipment revision, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getRevision(): string | null
    /**
     * Gets the signal quality value in percent (0 - 100) of the dominant access
     * technology the #MMModem is using to communicate with the network.
     * 
     * Always 0 for POTS devices.
     * @returns The signal quality.
     */
    getSignalQuality(): [ /* returnType */ number, /* recent */ boolean ]
    /**
     * Asynchronously gets the #MMSim object managed by this #MMModem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_get_sim_finish() to get the result of the operation.
     * 
     * See mm_modem_get_sim_sync() for the synchronous, blocking version of this
     * method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    getSim(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_get_sim().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_get_sim().
     * @returns a #MMSim or #NULL if @error is set. The returned value should be freed with g_object_unref().
     */
    getSimFinish(res: Gio.AsyncResult): Sim
    /**
     * Gets the DBus paths of the #MMSim objects available in the different SIM
     * slots handled in this #MMModem. If a given SIM slot at a given index doesn't
     * have a SIM card available, an empty object path will be given. This list
     * includes the currently active SIM object path.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_dup_sim_slot_paths() if on another thread.</warning>
     * @returns The DBus paths of the #MMSim objects handled in this #MMModem, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getSimSlotPaths(): string[]
    /**
     * Synchronously gets the #MMSim object managed by this #MMModem.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_get_sim() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns a #MMSim or #NULL if @error is set. The returned value should be freed with g_object_unref().
     */
    getSimSync(cancellable: Gio.Cancellable | null): Sim
    /**
     * Gets the overall state of the #MMModem.
     * @returns A #MMModemState value.
     */
    getState(): ModemState
    /**
     * Gets the reason specifying why the modem is in #MM_MODEM_STATE_FAILED state.
     * @returns A #MMModemStateFailedReason value.
     */
    getStateFailedReason(): ModemStateFailedReason
    /**
     * Gets the list of radio frequency and technology bands supported by the
     * #MMModem.
     * 
     * For POTS devices, only #MM_MODEM_BAND_ANY will be returned in `bands`.
     * @returns %TRUE if @bands and @n_bands are set, %FALSE otherwise.
     */
    getSupportedBands(): [ /* returnType */ boolean, /* bands */ ModemBand[] ]
    /**
     * Gets the list of combinations of generic families of access technologies
     * supported by this #MMModem.
     * @returns %TRUE if @capabilities and @n_capabilities are set, %FALSE otherwise.
     */
    getSupportedCapabilities(): [ /* returnType */ boolean, /* capabilities */ ModemCapability[] ]
    /**
     * Gets the list of supported IP families.
     * @returns A bitmask of #MMBearerIpFamily values.
     */
    getSupportedIpFamilies(): BearerIpFamily
    /**
     * Gets the list of supported mode combinations.
     * @returns %TRUE if @modes and @n_modes are set, %FALSE otherwise.
     */
    getSupportedModes(): [ /* returnType */ boolean, /* modes */ ModemModeCombination[] ]
    /**
     * Gets current lock state of the #MMModem.
     * @returns A #MMModemLock value, specifying the current lock state.
     */
    getUnlockRequired(): ModemLock
    /**
     * Gets a #MMUnlockRetries object, which provides, for each
     * <link linkend="MMModemLock">MMModemLock</link> handled by the modem, the
     * number of PIN tries remaining before the code becomes blocked (requiring a
     * PUK) or permanently blocked.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_get_unlock_retries() again to get a new #MMUnlockRetries with the
     * new values.</warning>
     * @returns A #MMUnlockRetries that must be freed with g_object_unref() or %NULL if unknown.
     */
    getUnlockRetries(): UnlockRetries
    /**
     * Asynchronously lists the packet data bearers in the #MMModem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_list_bearers_finish() to get the result of the operation.
     * 
     * See mm_modem_list_bearers_sync() for the synchronous, blocking version of
     * this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    listBearers(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_list_bearers().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_list_bearers().
     * @returns The list of #MMBearer objects, or %NULL if either none found or if @error is set.
     */
    listBearersFinish(res: Gio.AsyncResult): Bearer[]
    /**
     * Synchronously lists the packet data bearers in the #MMModem.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_list_bearers() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The list of #MMBearer objects, or %NULL if either none found or if @error is set.
     */
    listBearersSync(cancellable: Gio.Cancellable | null): Bearer[]
    /**
     * Asynchronously lists the SIM slots available in the #MMModem.
     * 
     * The returned array contains one element per slot available in the system;
     * a #MMSim in each of the slots that contains a valid SIM card or %NULL if
     * no SIM card is found.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_list_sim_slots_finish() to get the result of the operation.
     * 
     * See mm_modem_list_sim_slots_sync() for the synchronous, blocking version of
     * this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    listSimSlots(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_list_sim_slots().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_list_sim_slots().
     * @returns The array of #MMSim objects, or %NULL if @error is set.
     */
    listSimSlotsFinish(res: Gio.AsyncResult): Sim[]
    /**
     * Synchronously lists the SIM slots available in the #MMModem.
     * 
     * The returned array contains one element per slot available in the system;
     * a #MMSim in each of the slots that contains a valid SIM card or %NULL if
     * no SIM card is found.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_list_sim_slots() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The array of #MMSim objects, or %NULL if @error is set.
     */
    listSimSlotsSync(cancellable: Gio.Cancellable | null): Sim[]
    /**
     * Gets the list of radio frequency and technology bands the #MMModem is
     * currently using when connecting to a network.
     * 
     * For POTS devices, only the #MM_MODEM_BAND_ANY band is supported.
     * @returns %TRUE if @bands and @n_bands are set, %FALSE otherwise.
     */
    peekCurrentBands(): [ /* returnType */ boolean, /* bands */ ModemBand[] ]
    /**
     * Gets the list of ports in the modem.
     * @returns %TRUE if @ports and @n_ports are set, %FALSE otherwise.
     */
    peekPorts(): [ /* returnType */ boolean, /* ports */ ModemPortInfo[] ]
    /**
     * Gets the list of radio frequency and technology bands supported by the
     * #MMModem.
     * 
     * For POTS devices, only #MM_MODEM_BAND_ANY will be returned in `bands`.
     * @returns %TRUE if @bands and @n_bands are set, %FALSE otherwise.
     */
    peekSupportedBands(): [ /* returnType */ boolean, /* bands */ ModemBand[] ]
    /**
     * Gets the list of combinations of generic families of access technologies
     * supported by this #MMModem.
     * @returns %TRUE if @capabilities and @n_capabilities are set, %FALSE otherwise.
     */
    peekSupportedCapabilities(): [ /* returnType */ boolean, /* capabilities */ ModemCapability[] ]
    /**
     * Gets the list of supported mode combinations.
     * @returns %TRUE if @modes and @n_modes are set, %FALSE otherwise.
     */
    peekSupportedModes(): [ /* returnType */ boolean, /* modes */ ModemModeCombination[] ]
    /**
     * Gets a #MMUnlockRetries object, which provides, for each
     * <link linkend="MMModemLock">MMModemLock</link> handled by the modem, the
     * number of PIN tries remaining before the code becomes blocked (requiring a
     * PUK) or permanently blocked.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_get_unlock_retries() if on another thread.</warning>
     * @returns A #MMUnlockRetries. Do not free the returned value, it belongs to @self.
     */
    peekUnlockRetries(): UnlockRetries
    /**
     * Asynchronously clears non-persistent configuration and state, and returns the
     * device to a newly-powered-on state.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_reset_finish() to get the result of the operation.
     * 
     * See mm_modem_reset_sync() for the synchronous, blocking version of this
     * method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    reset(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_reset().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_reset().
     * @returns %TRUE if the reset was successful, %FALSE if @error is set.
     */
    resetFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously clears non-persistent configuration and state, and returns the
     * device to a newly-powered-on state.
     * 
     * The calling thread is blocked until a reply is received. See mm_modem_reset()
     * for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the reset was successful, %FALSE if @error is set.
     */
    resetSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously sets the radio frequency and technology bands the device is
     * currently allowed to use when connecting to a network.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_set_current_bands_finish() to get the result of the operation.
     * 
     * See mm_modem_set_current_bands_sync() for the synchronous, blocking version
     * of this method.
     * @param bands An array of #MMModemBand values specifying which bands are allowed.
     * @param nBands Number of elements in `bands`.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setCurrentBands(bands: ModemBand, nBands: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_set_current_bands().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_set_current_bands().
     * @returns %TRUE if the bands were successfully set, %FALSE if @error is set.
     */
    setCurrentBandsFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously sets the radio frequency and technology bands the device is
     * currently allowed to use when connecting to a network.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_set_current_bands() for the asynchronous version of this method.
     * @param bands An array of #MMModemBand values specifying which bands are allowed.
     * @param nBands Number of elements in `bands`.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the bands were successfully set, %FALSE if @error is set.
     */
    setCurrentBandsSync(bands: ModemBand, nBands: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously sets the capabilities of the device. A restart of the modem
     * may be required.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_set_current_capabilities_finish() to get the result of the
     * operation.
     * 
     * See mm_modem_set_current_capabilities_sync() for the synchronous, blocking
     * version of this method.
     * @param capabilities A #MMModemCapability mask.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setCurrentCapabilities(capabilities: ModemCapability, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_set_current_capabilities().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_set_current_capabilities().
     * @returns %TRUE if the capabilities were successfully set, %FALSE if @error is set.
     */
    setCurrentCapabilitiesFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously sets the capabilities of the device. A restart of the modem may
     * be required.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_set_current_capabilities() for the asynchronous version of this
     * method.
     * @param capabilities A #MMModemCapability mask.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the capabilities were successfully set, %FALSE if @error is set.
     */
    setCurrentCapabilitiesSync(capabilities: ModemCapability, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously sets the access technologies (e.g. 2G/3G/4G preference) the
     * device is currently allowed to use when connecting to a network.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_set_current_modes_finish() to get the result of the operation.
     * 
     * See mm_modem_set_current_modes_sync() for the synchronous, blocking version
     * of this method.
     * @param modes Mask of #MMModemMode values specifying which modes are allowed.
     * @param preferred A #MMModemMode value specifying which of the modes given in  `modes` is the preferred one, or #MM_MODEM_MODE_NONE if none.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setCurrentModes(modes: ModemMode, preferred: ModemMode, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_set_current_modes().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_set_current_modes().
     * @returns %TRUE if the allowed modes were successfully set, %FALSE if @error is set.
     */
    setCurrentModesFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously sets the access technologies (e.g. 2G/3G/4G preference) the
     * device is currently allowed to use when connecting to a network.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_set_current_modes() for the asynchronous version of this method.
     * @param modes Mask of #MMModemMode values specifying which modes are allowed.
     * @param preferred A #MMModemMode value specifying which of the modes given in  `modes` is the preferred one, or #MM_MODEM_MODE_NONE if none.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the allowed modes were successfully set, %FALSE if @error is set.
     */
    setCurrentModesSync(modes: ModemMode, preferred: ModemMode, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously sets the power state of the device. This method can only be
     * used while the modem is in %MM_MODEM_STATE_DISABLED state.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_set_power_state_finish() to get the result of the operation.
     * 
     * See mm_modem_set_power_state_sync() for the synchronous, blocking version of
     * this method.
     * @param state Either %MM_MODEM_POWER_STATE_LOW or %MM_MODEM_POWER_STATE_ON. Every  other #MMModemPowerState value is not allowed.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setPowerState(state: ModemPowerState, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_set_power_state().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_set_power_state().
     * @returns %TRUE if the power state was successfully set, %FALSE if @error is set.
     */
    setPowerStateFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously sets the power state of the device. This method can only be
     * used while the modem is in %MM_MODEM_STATE_DISABLED state.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_set_power_state() for the asynchronous version of this method.
     * @param state Either %MM_MODEM_POWER_STATE_LOW or %MM_MODEM_POWER_STATE_ON. Every  other #MMModemPowerState value is not allowed.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the power state was successfully set, %FALSE if @error is set.
     */
    setPowerStateSync(state: ModemPowerState, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously requests to select which SIM slot to be considered as primary.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_set_primary_sim_slot_finish() to get the result of the operation.
     * 
     * See mm_modem_set_primary_sim_slot_sync() for the synchronous, blocking version of
     * this method.
     * @param simSlot SIM slot number.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setPrimarySimSlot(simSlot: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_set_primary_sim_slot().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_set_primary_sim_slot().
     * @returns %TRUE if the SIM slot switch has been successfully requested, %FALSE if @error is set.
     */
    setPrimarySimSlotFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to select which SIM slot to be considered as primary.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_set_primary_sim_slot() for the asynchronous version of this method.
     * @param simSlot SIM slot number.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the SIM slot switch has been successfully requested, %FALSE if @error is set.
     */
    setPrimarySimSlotSync(simSlot: number, cancellable: Gio.Cancellable | null): boolean

    // Class property signals of ModemManager-1.0.ModemManager.Modem

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::access-technologies", callback: (...args: any[]) => void): number
    on(sigName: "notify::access-technologies", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::access-technologies", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::access-technologies", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::access-technologies", ...args: any[]): void
    connect(sigName: "notify::bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::bearers", ...args: any[]): void
    connect(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void): number
    on(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::carrier-configuration", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::carrier-configuration", ...args: any[]): void
    connect(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void): number
    on(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::carrier-configuration-revision", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::carrier-configuration-revision", ...args: any[]): void
    connect(sigName: "notify::current-bands", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-bands", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-bands", ...args: any[]): void
    connect(sigName: "notify::current-capabilities", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-capabilities", ...args: any[]): void
    connect(sigName: "notify::current-modes", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-modes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-modes", ...args: any[]): void
    connect(sigName: "notify::device", callback: (...args: any[]) => void): number
    on(sigName: "notify::device", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::device", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::device", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::device", ...args: any[]): void
    connect(sigName: "notify::device-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::device-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::device-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::device-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::device-identifier", ...args: any[]): void
    connect(sigName: "notify::drivers", callback: (...args: any[]) => void): number
    on(sigName: "notify::drivers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::drivers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::drivers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::drivers", ...args: any[]): void
    connect(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::equipment-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::equipment-identifier", ...args: any[]): void
    connect(sigName: "notify::hardware-revision", callback: (...args: any[]) => void): number
    on(sigName: "notify::hardware-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::hardware-revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::hardware-revision", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::hardware-revision", ...args: any[]): void
    connect(sigName: "notify::manufacturer", callback: (...args: any[]) => void): number
    on(sigName: "notify::manufacturer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::manufacturer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::manufacturer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::manufacturer", ...args: any[]): void
    connect(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::max-active-bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::max-active-bearers", ...args: any[]): void
    connect(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::max-active-multiplexed-bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::max-active-multiplexed-bearers", ...args: any[]): void
    connect(sigName: "notify::max-bearers", callback: (...args: any[]) => void): number
    on(sigName: "notify::max-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::max-bearers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::max-bearers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::max-bearers", ...args: any[]): void
    connect(sigName: "notify::model", callback: (...args: any[]) => void): number
    on(sigName: "notify::model", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::model", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::model", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::model", ...args: any[]): void
    connect(sigName: "notify::own-numbers", callback: (...args: any[]) => void): number
    on(sigName: "notify::own-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::own-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::own-numbers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::own-numbers", ...args: any[]): void
    connect(sigName: "notify::plugin", callback: (...args: any[]) => void): number
    on(sigName: "notify::plugin", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::plugin", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::plugin", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::plugin", ...args: any[]): void
    connect(sigName: "notify::ports", callback: (...args: any[]) => void): number
    on(sigName: "notify::ports", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::ports", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::ports", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::ports", ...args: any[]): void
    connect(sigName: "notify::power-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::power-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::power-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::power-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::power-state", ...args: any[]): void
    connect(sigName: "notify::primary-port", callback: (...args: any[]) => void): number
    on(sigName: "notify::primary-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::primary-port", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::primary-port", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::primary-port", ...args: any[]): void
    connect(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void): number
    on(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::primary-sim-slot", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::primary-sim-slot", ...args: any[]): void
    connect(sigName: "notify::revision", callback: (...args: any[]) => void): number
    on(sigName: "notify::revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::revision", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::revision", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::revision", ...args: any[]): void
    connect(sigName: "notify::signal-quality", callback: (...args: any[]) => void): number
    on(sigName: "notify::signal-quality", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::signal-quality", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::signal-quality", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::signal-quality", ...args: any[]): void
    connect(sigName: "notify::sim", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim", ...args: any[]): void
    connect(sigName: "notify::sim-slots", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim-slots", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim-slots", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim-slots", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim-slots", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void): number
    on(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state-failed-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state-failed-reason", ...args: any[]): void
    connect(sigName: "notify::supported-bands", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-bands", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-bands", ...args: any[]): void
    connect(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-capabilities", ...args: any[]): void
    connect(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-ip-families", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-ip-families", ...args: any[]): void
    connect(sigName: "notify::supported-modes", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-modes", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-modes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-modes", ...args: any[]): void
    connect(sigName: "notify::unlock-required", callback: (...args: any[]) => void): number
    on(sigName: "notify::unlock-required", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::unlock-required", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::unlock-required", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::unlock-required", ...args: any[]): void
    connect(sigName: "notify::unlock-retries", callback: (...args: any[]) => void): number
    on(sigName: "notify::unlock-retries", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::unlock-retries", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::unlock-retries", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::unlock-retries", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModem structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class Modem extends GdbusModemProxy {

    // Own properties of ModemManager-1.0.ModemManager.Modem

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Modem

    constructor(config?: Modem.ConstructorProperties) 
    _init(config?: Modem.ConstructorProperties): void
    /**
     * Gets the list of pending network-initiated OMA sessions.
     * @param self A #MMModem.
     * @returns %TRUE if @sessions and @n_sessions are set, %FALSE otherwise.
     */
    static getPendingNetworkInitiatedSessions(self: ModemOma): [ /* returnType */ boolean, /* sessions */ OmaPendingNetworkInitiatedSession[] ]
    /**
     * Gets the list of pending network-initiated OMA sessions.
     * @param self A #MMModem.
     * @returns %TRUE if @sessions and @n_sessions are set, %FALSE otherwise.
     */
    static peekPendingNetworkInitiatedSessions(self: ModemOma): [ /* returnType */ boolean, /* sessions */ OmaPendingNetworkInitiatedSession[] ]

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module Modem3gpp {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModem3gpp.ConstructorProperties, GdbusModem3gppProxy.ConstructorProperties {
    }

}

export interface Modem3gpp extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModem3gpp {

    // Own properties of ModemManager-1.0.ModemManager.Modem3gpp

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Modem3gpp

    /**
     * Asynchronously disables the modem personalization lock.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_disable_facility_lock_finish() to get the result of
     * the operation.
     * @param facility Single bit value describing the modem personalization lock to disable.
     * @param controlKey String with control key required to unlock the personalization.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    disableFacilityLock(facility: Modem3gppFacility, controlKey: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_disable_facility_lock().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_disable_facility_lock().
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    disableFacilityLockFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously disables facility lock.
     * 
     * The calling thread is blocked until a reply is received.
     * See mm_modem_3gpp_disable_facility_lock() for the asynchronous
     * version of this method.
     * @param facility Single bit value describing the modem personalization lock to disable.
     * @param controlKey String with control key required to unlock the personalization.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    disableFacilityLockSync(facility: Modem3gppFacility, controlKey: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a copy of the <ulink url="http://en.wikipedia.org/wiki/Imei">IMEI</ulink>,
     * as reported by this #MMModem3gpp.
     * @returns The IMEI, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupImei(): string | null
    /**
     * Gets a copy of the DBus path of the initial EPS #MMBearer exposed in this
     * #MMModem3gpp.
     * @returns The DBus path of the #MMBearer, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupInitialEpsBearerPath(): string | null
    /**
     * Gets a copy of the code of the operator to which the mobile is currently
     * registered.
     * 
     * Returned in the format <literal>"MCCMNC"</literal>, where
     * <literal>MCC</literal> is the three-digit ITU E.212 Mobile Country Code
     * and <literal>MNC</literal> is the two- or three-digit GSM Mobile Network
     * Code. e.g. e<literal>"31026"</literal> or <literal>"310260"</literal>.
     * @returns The operator code, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupOperatorCode(): string | null
    /**
     * Gets a copy of the name of the operator to which the mobile is
     * currently registered.
     * @returns The operator name, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupOperatorName(): string | null
    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Get the list of facilities for which PIN locking is enabled.
     * @returns A bitmask of #MMModem3gppFacility flags, specifying which facilities have locks enabled.
     */
    getEnabledFacilityLocks(): Modem3gppFacility
    /**
     * Get the UE mode of operation for EPS.
     * @returns A #MMModem3gppEpsUeModeOperation.
     */
    getEpsUeModeOperation(): Modem3gppEpsUeModeOperation
    /**
     * Gets the <ulink url="http://en.wikipedia.org/wiki/Imei">IMEI</ulink>,
     * as reported by this #MMModem3gpp.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_modem_3gpp_dup_imei() if on another
     * thread.</warning>
     * @returns The IMEI, or %NULL if none available.
     */
    getImei(): string | null
    /**
     * Asynchronously gets the initial EPS #MMBearer object exposed by this
     * #MMModem3gpp.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_get_initial_eps_bearer_finish() to get the result of the
     * operation.
     * 
     * See mm_modem_3gpp_get_initial_eps_bearer_sync() for the synchronous, blocking
     * version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    getInitialEpsBearer(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_get_initial_eps_bearer().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_get_initial_eps_bearer().
     * @returns a #MMSim or #NULL if @error is set. The returned value should be freed with g_object_unref().
     */
    getInitialEpsBearerFinish(res: Gio.AsyncResult): Bearer
    /**
     * Gets a #MMBearerProperties object specifying the settings configured in
     * the device to use when attaching to the LTE network.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_3gpp_get_initial_eps_bearer_settings() again to get a new
     * #MMBearerProperties with the new values.</warning>
     * @returns A #MMBearerProperties that must be freed with g_object_unref() or %NULL if unknown.
     */
    getInitialEpsBearerSettings(): BearerProperties
    /**
     * Synchronously gets the initial EPS #MMBearer object exposed by this
     * #MMModem3gpp.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_get_initial_eps_bearer() for the asynchronous version of this
     * method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns a #MMBearer or #NULL if @error is set. The returned value should be freed with g_object_unref().
     */
    getInitialEpsBearerSync(cancellable: Gio.Cancellable | null): Bearer
    /**
     * Gets a #MMNr5gRegistrationSettings object including the configured 5GNR
     * registration settings.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_3gpp_get_nr5g_registration_settings() again to get a new
     * #MMNr5gRegistrationSettings with the new values.</warning>
     * @returns A #MMNr5gRegistrationSettings that must be freed with g_object_unref() or %NULL if unknown.
     */
    getNr5gRegistrationSettings(): Nr5gRegistrationSettings
    /**
     * Gets the code of the operator to which the mobile is currently registered.
     * 
     * Returned in the format <literal>"MCCMNC"</literal>, where
     * <literal>MCC</literal> is the three-digit ITU E.212 Mobile Country Code
     * and <literal>MNC</literal> is the two- or three-digit GSM Mobile Network
     * Code. e.g. e<literal>"31026"</literal> or <literal>"310260"</literal>.
     * 
     * If the <literal>MCC</literal> and <literal>MNC</literal> are not known
     * or the mobile is not registered to a mobile network, this property will
     * be a zero-length (blank) string.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_modem_3gpp_dup_operator_code() if on another
     * thread.</warning>
     * @returns The operator code, or %NULL if none available.
     */
    getOperatorCode(): string | null
    /**
     * Gets the name of the operator to which the mobile is
     * currently registered.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_modem_3gpp_dup_operator_name() if on another
     * thread.</warning>
     * @returns The operator name, or %NULL if none available.
     */
    getOperatorName(): string | null
    /**
     * Get the packet domain service state.
     * @returns A #MMModem3gppPacketServiceState value, specifying the current PS attach  state.
     */
    getPacketServiceState(): Modem3gppPacketServiceState
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Get the list of #MMPco received from the network.
     * @returns a list of #MMPco objects, or #NULL if @error is set. The returned value should be freed with g_list_free_full() using g_object_unref() as #GDestroyNotify function.
     */
    getPco(): Pco[]
    /**
     * Get the the mobile registration status as defined in 3GPP TS 27.007
     * section 10.1.19.
     * @returns A #MMModem3gppRegistrationState value, specifying the current registration state.
     */
    getRegistrationState(): Modem3gppRegistrationState
    /**
     * Get the current subscription status of the account. This value is only
     * available after the modem attempts to register with the network.
     * 
     * The value of this property can only be obtained with operator specific logic
     * (e.g. processing specific PCO info), and therefore it doesn't make sense to
     * expose it in the ModemManager interface.
     * @returns A #MMModem3gppSubscriptionState value, specifying the current subscription state.
     */
    getSubscriptionState(): Modem3gppSubscriptionState
    /**
     * Gets a #MMBearerProperties object specifying the settings configured in
     * the device to use when attaching to the LTE network.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_modem_3gpp_get_initial_eps_bearer_settings()
     * if on another thread.</warning>
     * @returns A #MMBearerProperties. Do not free the returned value, it belongs to @self.
     */
    peekInitialEpsBearerSettings(): BearerProperties
    /**
     * Gets a #MMNr5gRegistrationSettings object including the configured 5GNR
     * registration settings.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_modem_3gpp_get_nr5g_registration_settings()
     * if on another thread.</warning>
     * @returns A #MMNr5gRegistrationSettings Do not free the returned value, it belongs to @self.
     */
    peekNr5gRegistrationSettings(): Nr5gRegistrationSettings
    /**
     * Asynchronously requests registration with a given mobile network.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_register_finish() to get the result of the operation.
     * 
     * See mm_modem_3gpp_register_sync() for the synchronous, blocking version of
     * this method.
     * @param networkId The operator ID to register. An empty string can be used to  register to the home network.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    register(networkId: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_register().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_register().
     * @returns %TRUE if the modem was registered, %FALSE if @error is set.
     */
    registerFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests registration with a given mobile network.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_register() for the asynchronous version of this method.
     * @param networkId The operator ID to register. An empty string can be used to  register to the home network.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the modem was registered, %FALSE if @error is set.
     */
    registerSync(networkId: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously requests to scan available 3GPP networks.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_scan_finish() to get the result of the operation.
     * 
     * See mm_modem_3gpp_scan_sync() for the synchronous, blocking version of this
     * method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    scan(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_scan().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_scan().
     * @returns a list of #MMModem3gppNetwork structs, or #NULL if @error is set. The returned value should be freed with g_list_free_full() using mm_modem_3gpp_network_free() as #GDestroyNotify function.
     */
    scanFinish(res: Gio.AsyncResult): Modem3gppNetwork[]
    /**
     * Synchronously requests to scan available 3GPP networks.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_scan() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns a list of #MMModem3gppNetwork structs, or #NULL if @error is set. The returned value should be freed with g_list_free_full() using mm_modem_3gpp_network_free() as #GDestroyNotify function.
     */
    scanSync(cancellable: Gio.Cancellable | null): Modem3gppNetwork[]
    /**
     * Asynchronously sends the carrier lock information to the modem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_location_inject_assistance_data_finish() to get the result of the
     * operation.
     * 
     * See mm_modem_3gpp_set_carrier_lock_sync() for the synchronous,
     * blocking version of this method.
     * @param data Carrier lock information.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setCarrierLock(data: number[], cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_set_carrier_lock().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_gdbus_modem3gpp_call_set_carrier_lock().
     * @returns %TRUE if the call succeded, %FALSE if @error is set.
     */
    setCarrierLockFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously sends the carrier lock information to the modem..
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_set_carrier_lock() for the asynchronous version of this method.
     * @param data Carrier lock information.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the carrier network info is successfully send, %FALSE if @error is set.
     */
    setCarrierLockSync(data: number[], cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously requests to update the EPS UE mode of operation.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_set_eps_ue_mode_operation_finish() to get the result of the
     * operation.
     * 
     * See mm_modem_3gpp_set_eps_ue_mode_operation_sync() for the synchronous,
     * blocking version of this method. The calling thread is blocked until a reply
     * is received.
     * @param mode A #MMModem3gppEpsUeModeOperation.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setEpsUeModeOperation(mode: Modem3gppEpsUeModeOperation, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_set_eps_ue_mode_operation().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_set_eps_ue_mode_operation().
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    setEpsUeModeOperationFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to update the EPS UE mode of operation.
     * 
     * The calling thread is blocked until a reply is received.
     * See mm_modem_3gpp_set_eps_ue_mode_operation() for the asynchronous version
     * of this method.
     * @param mode A #MMModem3gppEpsUeModeOperation.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    setEpsUeModeOperationSync(mode: Modem3gppEpsUeModeOperation, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously configures the settings for the initial LTE default bearer.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_set_initial_eps_bearer_settings_finish() to get the result of
     * the operation.
     * @param config A #MMBearerProperties object with the properties to use.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setInitialEpsBearerSettings(config: BearerProperties, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with
     * mm_modem_3gpp_set_initial_eps_bearer_settings().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_set_initial_eps_bearer_settings().
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    setInitialEpsBearerSettingsFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously configures the settings for the initial LTE default bearer.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_set_initial_eps_bearer_settings() for the asynchronous
     * version of this method.
     * @param config A #MMBearerProperties object with the properties to use.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    setInitialEpsBearerSettingsSync(config: BearerProperties, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously configures the 5GNR registration settings.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_set_nr5g_registration_settings_finish() to get the result of the operation.
     * 
     * See mm_modem_3gpp_set_nr5g_registration_settings_sync() for the synchronous,
     * blocking version of this method.
     * @param settings A #MMNr5gRegistrationSettings.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    setNr5gRegistrationSettings(settings: Nr5gRegistrationSettings, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_set_nr5g_registration_settings().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_set_nr5g_registration_settings().
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    setNr5gRegistrationSettingsFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously configures the 5GNR registration settings.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_set_nr5g_registration_settings() for the asynchronous
     * version of this method.
     * @param settings A #MMNr5gRegistrationSettings.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    setNr5gRegistrationSettingsSync(settings: Nr5gRegistrationSettings, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously tries to attach or detach from the packet domain service.
     * 
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_set_packet_service_state_finish() to get the result of the operation.
     * 
     * See mm_modem_3gpp_set_packet_service_state_sync() for the synchronous,
     * blocking version of this method.
     * @param state A #MMModem3gppPacketServiceState.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setPacketServiceState(state: Modem3gppPacketServiceState, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_set_packet_service_state().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_set_packet_service_state().
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    setPacketServiceStateFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously tries to attach or detach from the packet domain service.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_set_packet_service_state() for the asynchronous version of
     * this method.
     * @param state A #MMModem3gppPacketServiceState.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    setPacketServiceStateSync(state: Modem3gppPacketServiceState, cancellable: Gio.Cancellable | null): boolean

    // Class property signals of ModemManager-1.0.ModemManager.Modem3gpp

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void): number
    on(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::enabled-facility-locks", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::enabled-facility-locks", ...args: any[]): void
    connect(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void): number
    on(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::eps-ue-mode-operation", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::eps-ue-mode-operation", ...args: any[]): void
    connect(sigName: "notify::imei", callback: (...args: any[]) => void): number
    on(sigName: "notify::imei", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::imei", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::imei", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::imei", ...args: any[]): void
    connect(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void): number
    on(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::initial-eps-bearer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::initial-eps-bearer", ...args: any[]): void
    connect(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void): number
    on(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::initial-eps-bearer-settings", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::initial-eps-bearer-settings", ...args: any[]): void
    connect(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void): number
    on(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::nr5g-registration-settings", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::nr5g-registration-settings", ...args: any[]): void
    connect(sigName: "notify::operator-code", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-code", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-code", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-code", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-code", ...args: any[]): void
    connect(sigName: "notify::operator-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-name", ...args: any[]): void
    connect(sigName: "notify::packet-service-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::packet-service-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::packet-service-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::packet-service-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::packet-service-state", ...args: any[]): void
    connect(sigName: "notify::pco", callback: (...args: any[]) => void): number
    on(sigName: "notify::pco", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::pco", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::pco", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::pco", ...args: any[]): void
    connect(sigName: "notify::registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::registration-state", ...args: any[]): void
    connect(sigName: "notify::subscription-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::subscription-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::subscription-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::subscription-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::subscription-state", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModem3gpp structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class Modem3gpp extends GdbusModem3gppProxy {

    // Own properties of ModemManager-1.0.ModemManager.Modem3gpp

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Modem3gpp

    constructor(config?: Modem3gpp.ConstructorProperties) 
    _init(config?: Modem3gpp.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem3gpp_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module Modem3gppProfileManager {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModem3gppProfileManager.ConstructorProperties, GdbusModem3gppProfileManagerProxy.ConstructorProperties {
    }

}

export interface Modem3gppProfileManager extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModem3gppProfileManager {

    // Own properties of ModemManager-1.0.ModemManager.Modem3gppProfileManager

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Modem3gppProfileManager

    /**
     * Asynchronously deletes the connection profile.
     * 
     * The `profile` should have at least the profile ID set for the delete operation
     * to succeed.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_profile_manager_delete_finish() to get the result of the
     * operation.
     * 
     * See mm_modem_3gpp_profile_manager_delete_sync() for the synchronous, blocking
     * version of this method.
     * @param profile A #MM3gppProfile.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    delete(profile: TODO_3gppProfile, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_profile_manager_delete().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_profile_manager_delete().
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    deleteFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously deletes the connection profile.
     * 
     * The `profile` should have at least the profile ID set for the delete operation
     * to succeed.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_profile_manager_delete() for the asynchronous version of this
     * method.
     * @param profile A #MM3gppProfile.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    deleteSync(profile: TODO_3gppProfile, cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a copy of the name of the field used as index in profile management
     * operations.
     * @returns The index field, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupIndexField(): string | null
    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets the name of the field used as index in profile management
     * operations.
     * @returns The index field, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getIndexField(): string | null
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Asynchronously gets the list of available connection profiles.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_profile_manager_list_finish() to get the result of the
     * operation.
     * 
     * See mm_modem_3gpp_profile_manager_list_sync() for the synchronous, blocking
     * version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    list(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_profile_manager_list().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_profile_manager_list().
     * @returns %TRUE if the list was correctly retrieved, %FALSE if @error is set.
     */
    listFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* profiles */ TODO_3gppProfile[] ]
    /**
     * Synchronously gets the list of available connection profiles.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_profile_manager_list() for the asynchronous version of this
     * method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the list was correctly retrieved, %FALSE if @error is set.
     */
    listSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* profiles */ TODO_3gppProfile[] ]
    /**
     * Asynchronously updates a connection profile with the settings
     * given in `profile`.
     * 
     * If `profile` does not have an explicit profile ID set, a new profile will
     * be created.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_profile_manager_set_finish() to get the result of the
     * operation.
     * 
     * See mm_modem_3gpp_profile_manager_set_sync() for the synchronous, blocking
     * version of this method.
     * @param requested A #MM3gppProfile with the requested settings.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    set(requested: TODO_3gppProfile, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_profile_manager_set().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_profile_manager_set().
     * @returns A #MM3gppProfile with the stored settings, or %NULL if @error is set.
     */
    setFinish(res: Gio.AsyncResult): TODO_3gppProfile
    /**
     * Synchronously updates a connection profile with the settings
     * given in `profile`.
     * 
     * If `profile` does not have an explicit profile ID set, a new profile will
     * be created.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_profile_manager_set() for the asynchronous version of this
     * method.
     * @param requested A #MM3gppProfile with the requested settings.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #MM3gppProfile with the stored settings, or %NULL if @error is set.
     */
    setSync(requested: TODO_3gppProfile, cancellable: Gio.Cancellable | null): TODO_3gppProfile

    // Class property signals of ModemManager-1.0.ModemManager.Modem3gppProfileManager

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::index-field", callback: (...args: any[]) => void): number
    on(sigName: "notify::index-field", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::index-field", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::index-field", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::index-field", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModem3gppProfileManager structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class Modem3gppProfileManager extends GdbusModem3gppProfileManagerProxy {

    // Own properties of ModemManager-1.0.ModemManager.Modem3gppProfileManager

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Modem3gppProfileManager

    constructor(config?: Modem3gppProfileManager.ConstructorProperties) 
    _init(config?: Modem3gppProfileManager.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_profile_manager_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_profile_manager_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem3gpp_profile_manager_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_profile_manager_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_profile_manager_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module Modem3gppUssd {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModem3gppUssd.ConstructorProperties, GdbusModem3gppUssdProxy.ConstructorProperties {
    }

}

export interface Modem3gppUssd extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModem3gppUssd {

    // Own properties of ModemManager-1.0.ModemManager.Modem3gppUssd

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Modem3gppUssd

    /**
     * Asynchronously cancels an ongoing USSD session, either mobile or network
     * initiated.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_ussd_cancel_finish() to get the result of the operation.
     * 
     * See mm_modem_3gpp_ussd_cancel_sync() for the synchronous, blocking version
     * of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    cancel(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_ussd_cancel().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_ussd_cancel().
     * @returns %TRUE if the session was successfully cancelled, %FALSE if @error is set.
     */
    cancelFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously cancels an ongoing USSD session, either mobile or network
     * initiated.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_ussd_cancel() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the session was successfully cancelled, %FALSE if @error is set.
     */
    cancelSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a copy of any pending network-initiated request to which no USSD
     * response is required.
     * @returns The network notification, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupNetworkNotification(): string | null
    /**
     * Gets a copy of any pending network-initiated request.
     * @returns The network request, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupNetworkRequest(): string | null
    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets any pending network-initiated request to which no USSD response is
     * required.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_3gpp_ussd_dup_network_notification() if on another thread.</warning>
     * @returns The network notification, or %NULL if none available.
     */
    getNetworkNotification(): string | null
    /**
     * Gets any pending network-initiated request.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_modem_3gpp_ussd_dup_network_request() if on
     * another thread.</warning>
     * @returns The network request, or %NULL if none available.
     */
    getNetworkRequest(): string | null
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Get the state of the ongoing USSD session, if any.
     * @returns A #MMModem3gppUssdSessionState value, specifying the current state.
     */
    getState(): Modem3gppUssdSessionState
    /**
     * Asynchronously sends a USSD command string to the network initiating a USSD
     * session.
     * 
     * When the request is handled by the network, the method returns the
     * response or an appropriate error. The network may be awaiting further
     * response from the ME after returning from this method and no new command.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_ussd_initiate_finish() to get the result of the operation.
     * 
     * See mm_modem_3gpp_ussd_initiate_sync() for the synchronous, blocking version
     * of this method.
     * @param command The command to start the USSD session with.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    initiate(command: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_ussd_initiate().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_ussd_initiate().
     * @returns The response from the network, if any. The returned value should be freed with g_free().
     */
    initiateFinish(res: Gio.AsyncResult): string | null
    /**
     * Synchronously sends a USSD command string to the network initiating a USSD
     * session.
     * 
     * When the request is handled by the network, the method returns the
     * response or an appropriate error. The network may be awaiting further
     * response from the ME after returning from this method and no new command.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_ussd_initiate() for the asynchronous version of this method.
     * @param command The command to start the USSD session with.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The response from the network, if any. The returned value should be freed with g_free().
     */
    initiateSync(command: string | null, cancellable: Gio.Cancellable | null): string | null
    /**
     * Asynchronously responds to a USSD request that is either initiated by the
     * mobile network, or that is awaiting further input after a previous call to
     * mm_modem_3gpp_ussd_initiate().
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_3gpp_ussd_respond_finish() to get the result of the operation.
     * 
     * See mm_modem_3gpp_ussd_respond_sync() for the synchronous, blocking version
     * of this method.
     * @param response The response to network-initiated USSD command, or a response to a  request for further input.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    respond(response: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_3gpp_ussd_respond().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_3gpp_ussd_respond().
     * @returns The network reply to this response to the network-initiated USSD command. The reply may require further responses. The returned value should be freed with g_free().
     */
    respondFinish(res: Gio.AsyncResult): string | null
    /**
     * Synchronously responds to a USSD request that is either initiated by the
     * mobile network, or that is awaiting further input after a previous call to
     * mm_modem_3gpp_ussd_initiate().
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_3gpp_ussd_respond() for the asynchronous version of this method.
     * @param response The response to network-initiated USSD command, or a response to a  request for further input.
     * @param cancellable A #GCancellable or %NULL.
     * @returns The network reply to this response to the network-initiated USSD command. The reply may require further responses. The returned value should be freed with g_free().
     */
    respondSync(response: string | null, cancellable: Gio.Cancellable | null): string | null

    // Class property signals of ModemManager-1.0.ModemManager.Modem3gppUssd

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::network-notification", callback: (...args: any[]) => void): number
    on(sigName: "notify::network-notification", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::network-notification", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::network-notification", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::network-notification", ...args: any[]): void
    connect(sigName: "notify::network-request", callback: (...args: any[]) => void): number
    on(sigName: "notify::network-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::network-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::network-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::network-request", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModem3gppUssd structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class Modem3gppUssd extends GdbusModem3gppUssdProxy {

    // Own properties of ModemManager-1.0.ModemManager.Modem3gppUssd

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Modem3gppUssd

    constructor(config?: Modem3gppUssd.ConstructorProperties) 
    _init(config?: Modem3gppUssd.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_ussd_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_ussd_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem3gpp_ussd_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem3gpp_ussd_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem3gpp_ussd_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module ModemCdma {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemCdma.ConstructorProperties, GdbusModemCdmaProxy.ConstructorProperties {
    }

}

export interface ModemCdma extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemCdma {

    // Own properties of ModemManager-1.0.ModemManager.ModemCdma

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.ModemCdma

    /**
     * Asynchronously requests to provision the modem for use with a given carrier
     * using the modem's OTA activation functionality, if any.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_cdma_activate_finish() to get the result of the operation.
     * 
     * See mm_modem_cdma_activate_sync() for the synchronous, blocking version of
     * this method.
     * @param carrier Name of the carrier.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    activate(carrier: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_cdma_activate().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_cdma_activate().
     * @returns %TRUE if the activation was successful, %FALSE if @error is set.
     */
    activateFinish(res: Gio.AsyncResult): boolean
    /**
     * Asynchronously requests to provision the modem with the given properties.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from.
     * You can then call mm_modem_cdma_activate_manual_finish() to get the result of
     * the operation.
     * 
     * See mm_modem_cdma_activate_manual_sync() for the synchronous, blocking
     * version of this method.
     * @param properties A #MMCdmaManualActivationProperties.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    activateManual(properties: CdmaManualActivationProperties, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_cdma_activate_manual().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_cdma_activate_manual().
     * @returns %TRUE if the activation was successful, %FALSE if @error is set.
     */
    activateManualFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to provision the modem with the given properties.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_cdma_activate_manual() for the asynchronous version of this method.
     * @param properties A #MMCdmaManualActivationProperties.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the activation was successful, %FALSE if @error is set.
     */
    activateManualSync(properties: CdmaManualActivationProperties, cancellable: Gio.Cancellable | null): boolean
    /**
     * Synchronously requests to provision the modem for use with a given carrier
     * using the modem's OTA activation functionality, if any.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_cdma_activate() for the asynchronous version of this method.
     * @param carrier Name of the carrier.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the activation was successful, %FALSE if @error is set.
     */
    activateSync(carrier: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a copy of the
     * <ulink url="http://en.wikipedia.org/wiki/Electronic_serial_number">Electronic Serial Number</ulink>,
     * as reported by this #MMModemCdma.
     * 
     * The ESN is superceded by MEID, but still used in older devices.
     * @returns The ESN, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupEsn(): string | null
    /**
     * Gets a copy of the
     * <ulink url="http://en.wikipedia.org/wiki/MEID">Mobile Equipment Identifier</ulink>,
     * as reported by this #MMModemCdma.
     * @returns The MEID, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupMeid(): string | null
    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets the state of the activation in the 3GPP2 network.
     * @returns a #MMModemCdmaActivationState.
     */
    getActivationState(): ModemCdmaActivationState
    /**
     * Gets the state of the registration in the CDMA 1x network.
     * @returns a #MMModemCdmaRegistrationState.
     */
    getCdma1xRegistrationState(): ModemCdmaRegistrationState
    /**
     * Gets the
     * <ulink url="http://en.wikipedia.org/wiki/Electronic_serial_number">Electronic Serial Number</ulink>,
     * as reported by this #MMModemCdma.
     * 
     * The ESN is superceded by MEID, but still used in older devices.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_cdma_dup_esn() if on another thread.</warning>
     * @returns The ESN, or %NULL if none available.
     */
    getEsn(): string | null
    /**
     * Gets the state of the registration in the EV-DO network.
     * @returns a #MMModemCdmaRegistrationState.
     */
    getEvdoRegistrationState(): ModemCdmaRegistrationState
    /**
     * Gets the
     * <ulink url="http://en.wikipedia.org/wiki/MEID">Mobile Equipment Identifier</ulink>,
     * as reported by this #MMModemCdma.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_cdma_dup_meid() if on another thread.</warning>
     * @returns The MEID, or %NULL if none available.
     */
    getMeid(): string | null
    /**
     * Gets the
     * <ulink url="http://en.wikipedia.org/wiki/Network_Identification_Number">Network Identifier</ulink>
     * of the serving CDMA 1x network, if known, and if the modem is registered with
     * a CDMA 1x network.
     * @returns The NID, or %MM_MODEM_CDMA_NID_UNKNOWN.
     */
    getNid(): number
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Gets the
     * <ulink url="http://en.wikipedia.org/wiki/System_Identification_Number">System Identifier</ulink>
     * of the serving CDMA 1x network, if known, and if the modem is registered with
     * a CDMA 1x network.
     * @returns The SID, or %MM_MODEM_CDMA_SID_UNKNOWN.
     */
    getSid(): number

    // Class property signals of ModemManager-1.0.ModemManager.ModemCdma

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::activation-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::activation-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::activation-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::activation-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::activation-state", ...args: any[]): void
    connect(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cdma1x-registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cdma1x-registration-state", ...args: any[]): void
    connect(sigName: "notify::esn", callback: (...args: any[]) => void): number
    on(sigName: "notify::esn", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::esn", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::esn", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::esn", ...args: any[]): void
    connect(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::evdo-registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::evdo-registration-state", ...args: any[]): void
    connect(sigName: "notify::meid", callback: (...args: any[]) => void): number
    on(sigName: "notify::meid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::meid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::meid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::meid", ...args: any[]): void
    connect(sigName: "notify::nid", callback: (...args: any[]) => void): number
    on(sigName: "notify::nid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::nid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::nid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::nid", ...args: any[]): void
    connect(sigName: "notify::sid", callback: (...args: any[]) => void): number
    on(sigName: "notify::sid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sid", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModemCdma structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class ModemCdma extends GdbusModemCdmaProxy {

    // Own properties of ModemManager-1.0.ModemManager.ModemCdma

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.ModemCdma

    constructor(config?: ModemCdma.ConstructorProperties) 
    _init(config?: ModemCdma.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_cdma_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_cdma_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_cdma_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_cdma_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_cdma_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module ModemFirmware {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemFirmware.ConstructorProperties, GdbusModemFirmwareProxy.ConstructorProperties {
    }

}

export interface ModemFirmware extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemFirmware {

    // Own properties of ModemManager-1.0.ModemManager.ModemFirmware

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.ModemFirmware

    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Gets a #MMFirmwareUpdateSettings object specifying the expected update
     * settings.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_firmware_get_update_settings() again to get a new
     * #MMFirmwareUpdateSettings with the new values.</warning>
     * @returns A #MMFirmwareUpdateSettings that must be freed with g_object_unref() or %NULL if unknown.
     */
    getUpdateSettings(): FirmwareUpdateSettings
    /**
     * Asynchronously gets the list of available firmware images.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_firmware_list_finish() to get the result of the operation.
     * 
     * See mm_modem_firmware_list_sync() for the synchronous, blocking version of
     * this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    list(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_firmware_list().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_firmware_list().
     * @returns %TRUE if the list was correctly retrieved, %FALSE if @error is set.
     */
    listFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* selected */ FirmwareProperties, /* installed */ FirmwareProperties[] ]
    /**
     * Synchronously gets the list of available firmware images.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_firmware_list() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the list was correctly retrieved, %FALSE if @error is set.
     */
    listSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* selected */ FirmwareProperties, /* installed */ FirmwareProperties[] ]
    /**
     * Gets a #MMFirmwareUpdateSettings object specifying the expected update
     * settings.
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_modem_firmware_get_update_settings() if on
     * another thread.</warning>
     * @returns A #MMFirmwareUpdateSettings. Do not free the returned value, it belongs to @self.
     */
    peekUpdateSettings(): FirmwareUpdateSettings
    /**
     * Asynchronously selects a firmware image to boot.
     * 
     * <warning>The modem will possibly disappear once this action is run, as it
     * needs to reboot in order to select the new image.</warning>
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_firmware_select_finish() to get the result of the operation.
     * 
     * See mm_modem_firmware_select_sync() for the synchronous, blocking version of
     * this method.
     * @param uniqueId Unique ID of the firmware image to select.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    select(uniqueId: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_firmware_select().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_firmware_select().
     * @returns %TRUE if the selection was successful, %FALSE if @error is set.
     */
    selectFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously selects a firmware image to boot.
     * 
     * <warning>The modem will possibly disappear once this action is run, as it
     * needs to reboot in order to select the new image.</warning>
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_firmware_select() for the asynchronous version of this method.
     * @param uniqueId Unique ID of the firmware image to select.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the selection was successful, %FALSE if @error is set.
     */
    selectSync(uniqueId: string | null, cancellable: Gio.Cancellable | null): boolean

    // Class property signals of ModemManager-1.0.ModemManager.ModemFirmware

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::update-settings", callback: (...args: any[]) => void): number
    on(sigName: "notify::update-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::update-settings", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::update-settings", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::update-settings", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModemFirmware structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class ModemFirmware extends GdbusModemFirmwareProxy {

    // Own properties of ModemManager-1.0.ModemManager.ModemFirmware

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.ModemFirmware

    constructor(config?: ModemFirmware.ConstructorProperties) 
    _init(config?: ModemFirmware.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_firmware_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_firmware_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_firmware_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_firmware_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_firmware_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module ModemLocation {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemLocation.ConstructorProperties, GdbusModemLocationProxy.ConstructorProperties {
    }

}

export interface ModemLocation extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemLocation {

    // Own properties of ModemManager-1.0.ModemManager.ModemLocation

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.ModemLocation

    /**
     * Gets the list of assistance data servers.
     * @returns a %NULL-terminated array of server addresses, or %NULL if none available. The returned value should be freed with g_strfreev().
     */
    dupAssistanceDataServers(): string[]
    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets the address of the SUPL server.
     * @returns The SUPL server address, or %NULL if none available. The returned value should be freed with g_free().
     */
    dupSuplServer(): string | null
    /**
     * Asynchronously gets the current 3GPP location information.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_location_get_3gpp_finish() to get the result of the operation.
     * 
     * See mm_modem_location_get_3gpp_sync() for the synchronous, blocking version
     * of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    get3gpp(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_location_get_3gpp().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_location_get_3gpp().
     * @returns A #MMLocation3gpp, or #NULL if not available. The  returned value should be freed with g_object_unref().
     */
    get3gppFinish(res: Gio.AsyncResult): Location3gpp
    /**
     * Synchronously gets the current 3GPP location information.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_location_get_3gpp() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #MMLocation3gpp, or #NULL if not available. The returned value should be freed with g_object_unref().
     */
    get3gppSync(cancellable: Gio.Cancellable | null): Location3gpp
    /**
     * Gets the list of assistance data servers.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_location_dup_assistance_data_servers() if on another thread.
     * </warning>
     * @returns a %NULL-terminated array of server addresses, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getAssistanceDataServers(): string[]
    /**
     * Gets a bitmask of the location capabilities supported by this
     * #MMModemLocation.
     * @returns A #MMModemLocationSource.
     */
    getCapabilities(): ModemLocationSource
    /**
     * Asynchronously gets the current CDMA base station location information.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_location_get_cdma_bs_finish() to get the result of the operation.
     * 
     * See mm_modem_location_get_cdma_bs_sync() for the synchronous, blocking
     * version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    getCdmaBs(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_location_get_cdma_bs().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_location_get_cdma_bs().
     * @returns A #MMLocationCdmaBs, or #NULL if not available. The returned value should be freed with g_object_unref().
     */
    getCdmaBsFinish(res: Gio.AsyncResult): LocationCdmaBs
    /**
     * Synchronously gets the current CDMA base station location information.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_location_get_cdma_bs() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #MMLocationCdmaBs, or #NULL if not available. The returned value should be freed with g_object_unref().
     */
    getCdmaBsSync(cancellable: Gio.Cancellable | null): LocationCdmaBs
    /**
     * Gets a bitmask of the location capabilities which are enabled in this #MMModemLocation.
     * @returns A #MMModemLocationSource.
     */
    getEnabled(): ModemLocationSource
    /**
     * Asynchronously gets the current location information.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_location_get_full_finish() to get the result of the operation.
     * 
     * See mm_modem_location_get_full_sync() for the synchronous, blocking version
     * of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    getFull(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_location_get_full().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_location_get_full().
     * @returns %TRUE if the retrieval was successful, %FALSE if @error is set.
     */
    getFullFinish(res: Gio.AsyncResult): [ /* returnType */ boolean, /* location3gpp */ Location3gpp, /* locationGpsNmea */ LocationGpsNmea, /* locationGpsRaw */ LocationGpsRaw, /* locationCdmaBs */ LocationCdmaBs ]
    /**
     * Synchronously gets the current location information.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_location_get_full() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the setup was successful, %FALSE if @error is set.
     */
    getFullSync(cancellable: Gio.Cancellable | null): [ /* returnType */ boolean, /* location3gpp */ Location3gpp, /* locationGpsNmea */ LocationGpsNmea, /* locationGpsRaw */ LocationGpsRaw, /* locationCdmaBs */ LocationCdmaBs ]
    /**
     * Asynchronously gets the current GPS NMEA location information.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_location_get_gps_nmea_finish() to get the result of the operation.
     * 
     * See mm_modem_location_get_gps_nmea_sync() for the synchronous, blocking
     * version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    getGpsNmea(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_location_get_gps_nmea().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_location_get_gps_nmea().
     * @returns A #MMLocationGpsNmea, or #NULL if not available. The returned value should be freed with g_object_unref().
     */
    getGpsNmeaFinish(res: Gio.AsyncResult): LocationGpsNmea
    /**
     * Synchronously gets the current GPS NMEA location information.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_location_get_gps_nmea() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #MMLocationGpsNmea, or #NULL if not available. The returned value should be freed with g_object_unref().
     */
    getGpsNmeaSync(cancellable: Gio.Cancellable | null): LocationGpsNmea
    /**
     * Asynchronously gets the current GPS raw location information.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_location_get_gps_raw_finish() to get the result of the operation.
     * 
     * See mm_modem_location_get_gps_raw_sync() for the synchronous, blocking
     * version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    getGpsRaw(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_location_get_gps_raw().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_location_get_gps_raw().
     * @returns A #MMLocationGpsRaw, or #NULL if not available. The returned value should be freed with g_object_unref().
     */
    getGpsRawFinish(res: Gio.AsyncResult): LocationGpsRaw
    /**
     * Synchronously gets the current GPS raw location information.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_location_get_gps_raw() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #MMLocationGpsRaw, or #NULL if not available. The returned value should be freed with g_object_unref().
     */
    getGpsRawSync(cancellable: Gio.Cancellable | null): LocationGpsRaw
    /**
     * Gets the GPS refresh rate, in seconds.
     * @returns The GPS refresh rate, or 0 if no fixed rate is used.
     */
    getGpsRefreshRate(): number
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Gets a #MMLocation3gpp object with the current 3GPP location information.
     * 
     * Unlike mm_modem_location_get_3gpp() or mm_modem_location_get_3gpp_sync(),
     * this method does not perform an explicit query. Instead, this method will
     * return the location information that may have been signaled by the modem.
     * Therefore, this method will only succeed if location signaling is enabled
     * (e.g. with mm_modem_location_setup() in the #MMModemLocation).
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_location_get_signaled_3gpp() again to get a new #MMLocation3gpp
     * with the new values.</warning>
     * @returns A #MMLocation3gpp that must be freed with g_object_unref() or %NULL if none available.
     */
    getSignaled3gpp(): Location3gpp
    /**
     * Gets a #MMLocationCdmaBs object with the current CDMA base station location
     * information.
     * 
     * Unlike mm_modem_location_get_cdma_bs() or
     * mm_modem_location_get_cdma_bs_sync(), this method does not perform an
     * explicit query. Instead, this method will return the location information
     * that may have been signaled by the modem. Therefore, this method will only
     * succeed if location signaling is enabled (e.g. with mm_modem_location_setup()
     * in the #MMModemLocation).
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_location_get_signaled_cdma_bs() again to get a new #MMLocationCdmaBs
     * with the new values.</warning>
     * @returns A #MMLocationCdmaBs that must be freed with g_object_unref() or %NULL if none available.
     */
    getSignaledCdmaBs(): LocationCdmaBs
    /**
     * Gets a #MMLocationGpsNmea object with the current GPS NMEA location
     * information.
     * 
     * Unlike mm_modem_location_get_gps_nmea() or
     * mm_modem_location_get_gps_nmea_sync(), this method does not perform an
     * explicit query. Instead, this method will return the location information
     * that may have been signaled by the modem. Therefore, this method will only
     * succeed if location signaling is enabled (e.g. with mm_modem_location_setup()
     * in the #MMModemLocation).
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_location_get_signaled_gps_nmea() again to get a new #MMLocationGpsNmea
     * with the new values.</warning>
     * @returns A #MMLocationGpsNmea that must be freed with g_object_unref() or %NULL if none available.
     */
    getSignaledGpsNmea(): LocationGpsNmea
    /**
     * Gets a #MMLocationGpsRaw object with the current GPS raw location
     * information.
     * 
     * Unlike mm_modem_location_get_gps_raw() or
     * mm_modem_location_get_gps_raw_sync(), this method does not perform an
     * explicit query. Instead, this method will return the location information
     * that may have been signaled by the modem. Therefore, this method will only
     * succeed if location signaling is enabled (e.g. with mm_modem_location_setup()
     * in the #MMModemLocation).
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_location_get_signaled_gps_raw() again to get a new #MMLocationGpsRaw
     * with the new values.</warning>
     * @returns A #MMLocationGpsRaw that must be freed with g_object_unref() or %NULL if none available.
     */
    getSignaledGpsRaw(): LocationGpsRaw
    /**
     * Gets the address of the SUPL server.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_location_dup_supl_server() if on another thread.</warning>
     * @returns The SUPL server address, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getSuplServer(): string | null
    /**
     * Gets a bitmask of the supported assistance data types.
     * @returns A #MMModemLocationAssistanceDataType.
     */
    getSupportedAssistanceData(): ModemLocationAssistanceDataType
    /**
     * Aynchronously injects assistance data to the GNSS module.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_location_inject_assistance_data_finish() to get the result of the
     * operation.
     * 
     * See mm_modem_location_inject_assistance_data_sync() for the synchronous,
     * blocking version of this method.
     * @param data Data to inject.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    injectAssistanceData(data: number[], cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with
     * mm_modem_location_inject_assistance_data().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_location_inject_assistance_data().
     * @returns %TRUE if the injection was successful, %FALSE if @error is set.
     */
    injectAssistanceDataFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously injects assistance data to the GNSS module.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_location_inject_assistance_data() for the asynchronous version of
     * this method.
     * @param data Data to inject.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the injection was successful, %FALSE if @error is set.
     */
    injectAssistanceDataSync(data: number[], cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a #MMLocation3gpp object with the current 3GPP location information.
     * 
     * Unlike mm_modem_location_get_3gpp() or mm_modem_location_get_3gpp_sync(),
     * this method does not perform an explicit query. Instead, this method will
     * return the location information that may have been signaled by the modem.
     * Therefore, this method will only succeed if location signaling is enabled
     * (e.g. with mm_modem_location_setup() in the #MMModemLocation).
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_modem_location_get_signaled_3gpp() if on
     * another thread.</warning>
     * @returns A #MMLocation3gpp, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    peekSignaled3gpp(): Location3gpp
    /**
     * Gets a #MMLocationCdmaBs object with the current CDMA base station location
     * information.
     * 
     * Unlike mm_modem_location_get_cdma_bs() or
     * mm_modem_location_get_cdma_bs_sync(), this method does not perform an
     * explicit query. Instead, this method will return the location information
     * that may have been signaled by the modem. Therefore, this method will only
     * succeed if location signaling is enabled (e.g. with mm_modem_location_setup()
     * in the #MMModemLocation).
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_modem_location_get_signaled_cdma_bs() if on
     * another thread.</warning>
     * @returns A #MMLocationCdmaBs, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    peekSignaledCdmaBs(): LocationCdmaBs
    /**
     * Gets a #MMLocationGpsNmea object with the current GPS NMEA location
     * information.
     * 
     * Unlike mm_modem_location_get_gps_nmea() or
     * mm_modem_location_get_gps_nmea_sync(), this method does not perform an
     * explicit query. Instead, this method will return the location information
     * that may have been signaled by the modem. Therefore, this method will only
     * succeed if location signaling is enabled (e.g. with mm_modem_location_setup()
     * in the #MMModemLocation).
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_modem_location_get_signaled_gps_nmea() if on
     * another thread.</warning>
     * @returns A #MMLocationGpsNmea, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    peekSignaledGpsNmea(): LocationGpsNmea
    /**
     * Gets a #MMLocationGpsRaw object with the current GPS raw location
     * information.
     * 
     * Unlike mm_modem_location_get_gps_raw() or
     * mm_modem_location_get_gps_raw_sync(), this method does not perform an
     * explicit query. Instead, this method will return the location information
     * that may have been signaled by the modem. Therefore, this method will only
     * succeed if location signaling is enabled (e.g. with mm_modem_location_setup()
     * in the #MMModemLocation).
     * 
     * <warning>The returned value is only valid until the property changes so
     * it is only safe to use this function on the thread where
     * `self` was constructed. Use mm_modem_location_get_signaled_gps_raw() if on
     * another thread.</warning>
     * @returns A #MMLocationGpsRaw, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    peekSignaledGpsRaw(): LocationGpsRaw
    /**
     * Asynchronously configures the GPS refresh rate.
     * 
     * If a 0 rate is used, the GPS location updates will be immediately propagated
     * to the interface.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_location_set_gps_refresh_rate_finish() to get the result of the
     * operation.
     * 
     * See mm_modem_location_set_gps_refresh_rate_sync() for the synchronous,
     * blocking version of this method.
     * @param rate The GPS refresh rate, in seconds.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
     */
    setGpsRefreshRate(rate: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_location_set_gps_refresh_rate().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_location_set_gps_refresh_rate().
     * @returns %TRUE if setting the GPS refresh rate was successful, %FALSE if @error is set.
     */
    setGpsRefreshRateFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously configures the GPS refresh rate.
     * 
     * If a 0 rate is used, the GPS location updates will be immediately propagated
     * to the interface.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_location_set_gps_refresh_rate() for the asynchronous version of this
     * method.
     * @param rate The GPS refresh rate, in seconds.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if setting the refresh rate was successful, %FALSE if @error is set.
     */
    setGpsRefreshRateSync(rate: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously configures the address of the SUPL server for A-GPS operation.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_location_set_supl_server_finish() to get the result of the operation.
     * 
     * See mm_modem_location_set_supl_server_sync() for the synchronous, blocking
     * version of this method.
     * @param supl The SUPL server address, given as IP:PORT or with a full URL.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setSuplServer(supl: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_location_set_supl_server().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_location_set_supl_server().
     * @returns %TRUE if setting the SUPL server was successful, %FALSE if @error is set.
     */
    setSuplServerFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously configures the address of the SUPL server for A-GPS operation.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_location_set_supl_server() for the asynchronous version of this
     * method.
     * @param supl The SUPL server address, given as IP:PORT or with a full URL.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if setting the SUPL server was successful, %FALSE if @error is set.
     */
    setSuplServerSync(supl: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously configures the location sources to use when gathering location
     * information. Also enable or disable location information gathering.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_location_setup_finish() to get the result of the operation.
     * 
     * See mm_modem_location_setup_sync() for the synchronous, blocking version of
     * this method.
     * @param sources Bitmask of #MMModemLocationSource values specifying which locations  should get enabled.
     * @param signalLocation Flag to enable or disable location signaling.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setup(sources: ModemLocationSource, signalLocation: boolean, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_location_setup().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to mm_modem_location_setup().
     * @returns %TRUE if the setup was successful, %FALSE if @error is set.
     */
    setupFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously configures the location sources to use when gathering location
     * information. Also enable or disable location information gathering.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_location_setup() for the asynchronous version of this method.
     * @param sources Bitmask of #MMModemLocationSource values specifying which locations  should get enabled.
     * @param signalLocation Flag to enable or disable location signaling.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the setup was successful, %FALSE if @error is set.
     */
    setupSync(sources: ModemLocationSource, signalLocation: boolean, cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets the status of the location signaling in the #MMModemLocation.
     * @returns %TRUE if location changes are signaled, %FALSE otherwise.
     */
    signalsLocation(): boolean

    // Class property signals of ModemManager-1.0.ModemManager.ModemLocation

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void): number
    on(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::assistance-data-servers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::assistance-data-servers", ...args: any[]): void
    connect(sigName: "notify::capabilities", callback: (...args: any[]) => void): number
    on(sigName: "notify::capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::capabilities", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::capabilities", ...args: any[]): void
    connect(sigName: "notify::enabled", callback: (...args: any[]) => void): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::enabled", ...args: any[]): void
    connect(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void): number
    on(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gps-refresh-rate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gps-refresh-rate", ...args: any[]): void
    connect(sigName: "notify::location", callback: (...args: any[]) => void): number
    on(sigName: "notify::location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::location", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::location", ...args: any[]): void
    connect(sigName: "notify::signals-location", callback: (...args: any[]) => void): number
    on(sigName: "notify::signals-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::signals-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::signals-location", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::signals-location", ...args: any[]): void
    connect(sigName: "notify::supl-server", callback: (...args: any[]) => void): number
    on(sigName: "notify::supl-server", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supl-server", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supl-server", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supl-server", ...args: any[]): void
    connect(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-assistance-data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-assistance-data", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModemLocation structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class ModemLocation extends GdbusModemLocationProxy {

    // Own properties of ModemManager-1.0.ModemManager.ModemLocation

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.ModemLocation

    constructor(config?: ModemLocation.ConstructorProperties) 
    _init(config?: ModemLocation.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_location_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_location_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_location_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_location_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_location_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module ModemMessaging {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemMessaging.ConstructorProperties, GdbusModemMessagingProxy.ConstructorProperties {
    }

}

export interface ModemMessaging extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemMessaging {

    // Own properties of ModemManager-1.0.ModemManager.ModemMessaging

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.ModemMessaging

    /**
     * Asynchronously creates a new #MMSms in the modem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_messaging_create_finish() to get the result of the operation.
     * 
     * See mm_modem_messaging_create_sync() for the synchronous, blocking version of
     * this method.
     * @param properties A ##MMSmsProperties object with the properties to use.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    create(properties: SmsProperties, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_messaging_create().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_messaging_create().
     * @returns A newly created #MMSms, or %NULL if @error is set. The returned value should be freed with g_object_unref().
     */
    createFinish(res: Gio.AsyncResult): Sms
    /**
     * Synchronously creates a new #MMSms in the modem.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_messaging_create() for the asynchronous version of this method.
     * @param properties A ##MMSmsProperties object with the properties to use.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A newly created #MMSms, or %NULL if @error is set. The returned value should be freed with g_object_unref().
     */
    createSync(properties: SmsProperties, cancellable: Gio.Cancellable | null): Sms
    /**
     * Asynchronously deletes a given #MMSms from the modem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_messaging_delete_finish() to get the result of the operation.
     * 
     * See mm_modem_messaging_delete_sync() for the synchronous, blocking version
     * of this method.
     * @param sms Path of the #MMSms to delete.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    delete(sms: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_messaging_delete().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_messaging_delete().
     * @returns %TRUE if the sms was deleted, %FALSE if @error is set.
     */
    deleteFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously deletes a given #MMSms from the modem.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_messaging_delete() for the asynchronous version of this method.
     * @param sms Path of the #MMSms to delete.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the SMS was deleted, %FALSE if @error is set.
     */
    deleteSync(sms: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets the default SMS storage used when storing or receiving SMS messages.
     * @returns the default #MMSmsStorage.
     */
    getDefaultStorage(): SmsStorage
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Gets the list of SMS storages supported by the #MMModem.
     * @returns %TRUE if @storages and @n_storages are set, %FALSE otherwise.
     */
    getSupportedStorages(): [ /* returnType */ boolean, /* storages */ SmsStorage[] ]
    /**
     * Asynchronously lists the #MMSms objects in the modem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_messaging_list_finish() to get the result of the operation.
     * 
     * See mm_modem_messaging_list_sync() for the synchronous, blocking version of
     * this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    list(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_messaging_list().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_messaging_list().
     * @returns A list of #MMSms objects, or #NULL if either not found or @error is set. The returned value should be freed with g_list_free_full() using g_object_unref() as #GDestroyNotify function.
     */
    listFinish(res: Gio.AsyncResult): Sms[]
    /**
     * Synchronously lists the #MMSms objects in the modem.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_messaging_list() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A list of #MMSms objects, or #NULL if either not found or @error is set. The returned value should be freed with g_list_free_full() using g_object_unref() as #GDestroyNotify function.
     */
    listSync(cancellable: Gio.Cancellable | null): Sms[]
    /**
     * Gets the list of SMS storages supported by the #MMModem.
     * @returns %TRUE if @storages and @n_storages are set, %FALSE otherwise.
     */
    peekSupportedStorages(): [ /* returnType */ boolean, /* storages */ SmsStorage, /* nStorages */ number ]

    // Class property signals of ModemManager-1.0.ModemManager.ModemMessaging

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::default-storage", callback: (...args: any[]) => void): number
    on(sigName: "notify::default-storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::default-storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::default-storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::default-storage", ...args: any[]): void
    connect(sigName: "notify::messages", callback: (...args: any[]) => void): number
    on(sigName: "notify::messages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::messages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::messages", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::messages", ...args: any[]): void
    connect(sigName: "notify::supported-storages", callback: (...args: any[]) => void): number
    on(sigName: "notify::supported-storages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::supported-storages", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::supported-storages", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::supported-storages", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModemMessaging structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class ModemMessaging extends GdbusModemMessagingProxy {

    // Own properties of ModemManager-1.0.ModemManager.ModemMessaging

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.ModemMessaging

    constructor(config?: ModemMessaging.ConstructorProperties) 
    _init(config?: ModemMessaging.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_messaging_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_messaging_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_messaging_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_messaging_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_messaging_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module ModemOma {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemOma.ConstructorProperties, GdbusModemOmaProxy.ConstructorProperties {
    }

}

export interface ModemOma extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemOma {

    // Own properties of ModemManager-1.0.ModemManager.ModemOma

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.ModemOma

    /**
     * Asynchronously accepts a nework-initiated OMA device management session.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_oma_accept_network_initiated_session_finish() to get the result of
     * the operation.
     * 
     * See mm_modem_oma_accept_network_initiated_session_sync() for the synchronous,
     * blocking version of this method.
     * @param sessionId The unique ID of the network-initiated session.
     * @param accept %TRUE if the session is to be accepted, %FALSE otherwise.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    acceptNetworkInitiatedSession(sessionId: number, accept: boolean, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with
     * mm_modem_oma_accept_network_initiated_session().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_oma_accept_network_initiated_session().
     * @returns %TRUE if the session was started, %FALSE if @error is set.
     */
    acceptNetworkInitiatedSessionFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously accepts a nework-initiated OMA device management session.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_oma_accept_network_initiated_session() for the asynchronous version
     * of this method.
     * @param sessionId The unique ID of the network-initiated session.
     * @param accept %TRUE if the session is to be accepted, %FALSE otherwise.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the session was started, %FALSE if @error is set.
     */
    acceptNetworkInitiatedSessionSync(sessionId: number, accept: boolean, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously cancels the current OMA device management session.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_oma_cancel_session_finish() to get the result of the operation.
     * 
     * See mm_modem_oma_cancel_session_sync() for the synchronous, blocking version
     * of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    cancelSession(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_oma_cancel_session().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_oma_cancel_session().
     * @returns %TRUE if the session was started, %FALSE if @error is set.
     */
    cancelSessionFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously cancels the current OMA device management session.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_oma_cancel_session() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the session was started, %FALSE if @error is set.
     */
    cancelSessionSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets the currently enabled OMA features.
     * @returns a bitmask of #MMOmaFeature values.
     */
    getFeatures(): OmaFeature
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Gets the list of pending network-initiated OMA sessions.
     * @returns %TRUE if @sessions and @n_sessions are set, %FALSE otherwise.
     */
    getPendingNetworkInitiatedSessions(): [ /* returnType */ boolean, /* sessions */ OmaPendingNetworkInitiatedSession[] ]
    /**
     * Gets the state of the current OMA device management session.
     * @returns a #MMOmaSessionState.
     */
    getSessionState(): OmaSessionState
    /**
     * Gets the type of the current OMA device management session.
     * @returns a #MMOmaSessionType.
     */
    getSessionType(): OmaSessionType
    /**
     * Gets the list of pending network-initiated OMA sessions.
     * @returns %TRUE if @sessions and @n_sessions are set, %FALSE otherwise.
     */
    peekPendingNetworkInitiatedSessions(): [ /* returnType */ boolean, /* sessions */ OmaPendingNetworkInitiatedSession[] ]
    /**
     * Asynchronously sets up the OMA device management service.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_oma_setup_finish() to get the result of the operation.
     * 
     * See mm_modem_oma_setup_sync() for the synchronous, blocking version of this
     * method.
     * @param features Mask of #MMOmaFeature values to enable.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setup(features: OmaFeature, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_oma_setup().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_oma_setup().
     * @returns %TRUE if the setup was successful, %FALSE if @error is set.
     */
    setupFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously sets up the OMA device management service.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_oma_setup() for the asynchronous version of this method.
     * @param features Mask of #MMOmaFeature values to enable.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the setup was successful, %FALSE if @error is set.
     */
    setupSync(features: OmaFeature, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously starts a client-initiated OMA device management session.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_oma_start_client_initiated_session_finish() to get the result of the
     * operation.
     * 
     * See mm_modem_oma_start_client_initiated_session_sync() for the synchronous,
     * blocking version of this method.
     * @param sessionType A #MMOmaSessionType.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    startClientInitiatedSession(sessionType: OmaSessionType, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with
     * mm_modem_oma_start_client_initiated_session().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_oma_start_client_initiated_session().
     * @returns %TRUE if the session was started, %FALSE if @error is set.
     */
    startClientInitiatedSessionFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously starts a client-initiated OMA device management session.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_oma_start_client_initiated_session() for the asynchronous version
     * of this method.
     * @param sessionType A #MMOmaSessionType.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the session was started, %FALSE if @error is set.
     */
    startClientInitiatedSessionSync(sessionType: OmaSessionType, cancellable: Gio.Cancellable | null): boolean

    // Class property signals of ModemManager-1.0.ModemManager.ModemOma

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::features", callback: (...args: any[]) => void): number
    on(sigName: "notify::features", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::features", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::features", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::features", ...args: any[]): void
    connect(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void): number
    on(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::pending-network-initiated-sessions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::pending-network-initiated-sessions", ...args: any[]): void
    connect(sigName: "notify::session-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::session-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::session-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::session-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::session-state", ...args: any[]): void
    connect(sigName: "notify::session-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::session-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::session-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::session-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::session-type", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModemOma structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class ModemOma extends GdbusModemOmaProxy {

    // Own properties of ModemManager-1.0.ModemManager.ModemOma

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.ModemOma

    constructor(config?: ModemOma.ConstructorProperties) 
    _init(config?: ModemOma.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_oma_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_oma_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_oma_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_oma_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_oma_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module ModemSar {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemSar.ConstructorProperties, GdbusModemSarProxy.ConstructorProperties {
    }

}

export interface ModemSar extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemSar {

    // Own properties of ModemManager-1.0.ModemManager.ModemSar

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.ModemSar

    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Asynchronously enable or disable dynamic SAR.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_sar_enable_finish() to get the result of the operation.
     * 
     * See mm_modem_sar_enable_sync() for the synchronous, blocking version of
     * this method.
     * @param enable %TRUE to enable dynamic SAR and %FALSE to disable it.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    enable(enable: boolean, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_sar_enable().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_sar_enable().
     * @returns %TRUE if the enable was successful, %FALSE if @error is set.
     */
    enableFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously enable or disable dynamic SAR.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_sar_enable() for the asynchronous version of this method.
     * @param enable %TRUE to enable dynamic SAR and %FALSE to disable it.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the enable was successful, %FALSE if @error is set.
     */
    enableSync(enable: boolean, cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Gets the index of the SAR power level mapping table.
     * @returns the index.
     */
    getPowerLevel(): number
    /**
     * Gets the state of dynamic SAR.
     * @returns %TRUE if dynamic SAR is enabled, %FALSE otherwise.
     */
    getState(): boolean
    /**
     * Asynchronously set current dynamic SAR power level.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_sar_set_power_level_finish() to get the result of the operation.
     * 
     * See mm_modem_sar_set_power_level_sync() for the synchronous, blocking version of
     * this method.
     * @param level Index of the SAR power level mapping table
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setPowerLevel(level: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    setPowerLevelFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously set current dynamic SAR power level.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_sar_set_power_level() for the asynchronous version of this method.
     * @param level Index of the SAR power level mapping table
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if set power level was successful, %FALSE if @error is set.
     */
    setPowerLevelSync(level: number, cancellable: Gio.Cancellable | null): boolean

    // Class property signals of ModemManager-1.0.ModemManager.ModemSar

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::power-level", callback: (...args: any[]) => void): number
    on(sigName: "notify::power-level", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::power-level", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::power-level", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::power-level", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModemSar structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class ModemSar extends GdbusModemSarProxy {

    // Own properties of ModemManager-1.0.ModemManager.ModemSar

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.ModemSar

    constructor(config?: ModemSar.ConstructorProperties) 
    _init(config?: ModemSar.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_sar_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_sar_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_sar_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_sar_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_sar_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module ModemSignal {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemSignal.ConstructorProperties, GdbusModemSignalProxy.ConstructorProperties {
    }

}

export interface ModemSignal extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemSignal {

    // Own properties of ModemManager-1.0.ModemManager.ModemSignal

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.ModemSignal

    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets a #MMSignal object specifying the CDMA signal information.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_signal_get_cdma() again to get a new #MMSignal with the new values.
     * </warning>
     * @returns A #MMSignal that must be freed with g_object_unref() or %NULL if unknown.
     */
    getCdma(): Signal
    /**
     * Gets whether the error rate threshold is enabled or not.
     * @returns %TRUE if the error rate threshold is enabled, %FALSE otherwise.
     */
    getErrorRateThreshold(): boolean
    /**
     * Gets a #MMSignal object specifying the EV-DO signal information.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_signal_get_evdo() again to get a new #MMSignal with the new values.
     * </warning>
     * @returns A #MMSignal that must be freed with g_object_unref() or %NULL if unknown.
     */
    getEvdo(): Signal
    /**
     * Gets a #MMSignal object specifying the GSM signal information.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_signal_get_gsm() again to get a new #MMSignal with the
     * new values.</warning>
     * @returns A #MMSignal that must be freed with g_object_unref() or %NULL if unknown.
     */
    getGsm(): Signal
    /**
     * Gets a #MMSignal object specifying the LTE signal information.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_signal_get_lte() again to get a new #MMSignal with the new values.
     * </warning>
     * @returns A #MMSignal that must be freed with g_object_unref() or %NULL if unknown.
     */
    getLte(): Signal
    /**
     * Gets a #MMSignal object specifying the 5G signal information.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_signal_get_nr5g() again to get a new #MMSignal with the new values.
     * </warning>
     * @returns A #MMSignal that must be freed with g_object_unref() or %NULL if unknown.
     */
    getNr5g(): Signal
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Gets the currently configured refresh rate.
     * @returns the refresh rate, in seconds.
     */
    getRate(): number
    /**
     * Gets the currently configured RSSI threshold, in dBm.
     * 
     * A value of 0 indicates the threshold is disabled.
     * @returns the RSSI threshold.
     */
    getRssiThreshold(): number
    /**
     * Gets a #MMSignal object specifying the UMTS signal information.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_signal_get_umts() again to get a new #MMSignal with the new values.
     * </warning>
     * @returns A #MMSignal that must be freed with g_object_unref() or %NULL if unknown.
     */
    getUmts(): Signal
    /**
     * Gets a #MMSignal object specifying the CDMA signal information.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_signal_get_cdma() if on another thread.</warning>
     * @returns A #MMSignal. Do not free the returned value, it belongs to @self.
     */
    peekCdma(): Signal
    /**
     * Gets a #MMSignal object specifying the EV-DO signal information.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_signal_get_evdo() if on another thread.</warning>
     * @returns A #MMSignal. Do not free the returned value, it belongs to @self.
     */
    peekEvdo(): Signal
    /**
     * Gets a #MMSignal object specifying the GSM signal information.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_signal_get_gsm() if on another thread.</warning>
     * @returns A #MMSignal. Do not free the returned value, it belongs to @self.
     */
    peekGsm(): Signal
    /**
     * Gets a #MMSignal object specifying the LTE signal information.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_signal_get_lte() if on another thread.</warning>
     * @returns A #MMSignal. Do not free the returned value, it belongs to @self.
     */
    peekLte(): Signal
    /**
     * Gets a #MMSignal object specifying the 5G signal information.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_signal_get_nr5g() if on another thread.</warning>
     * @returns A #MMSignal. Do not free the returned value, it belongs to @self.
     */
    peekNr5g(): Signal
    /**
     * Gets a #MMSignal object specifying the UMTS signal information.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_signal_get_umts() if on another thread.</warning>
     * @returns A #MMSignal. Do not free the returned value, it belongs to @self.
     */
    peekUmts(): Signal
    /**
     * Asynchronously enables or disables the extended signal quality information
     * retrieval via periodic polling.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_signal_setup_finish() to get the result of the operation.
     * 
     * See mm_modem_signal_setup_sync() for the synchronous, blocking version of
     * this method.
     * @param rate Refresh rate to set, in seconds. Use 0 to disable periodic polling.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setup(rate: number, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_signal_setup().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_signal_setup().
     * @returns %TRUE if the setup was successful, %FALSE if @error is set.
     */
    setupFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously enables or disables the extended signal quality information
     * retrieval via periodic polling.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_signal_setup() for the asynchronous version of this method.
     * @param rate Refresh rate to set, in seconds. Use 0 to disable periodic polling.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the setup was successful, %FALSE if @error is set.
     */
    setupSync(rate: number, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously setups thresholds so that the device itself decides when to report the
     * extended signal quality information updates.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_signal_setup_thresholds_finish() to get the result of the operation.
     * 
     * See mm_modem_signal_setup_thresholds_sync() for the synchronous, blocking version of
     * this method.
     * @param properties Threshold values to set.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setupThresholds(properties: SignalThresholdProperties, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_signal_setup_thresholds().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_signal_setup_thresholds().
     * @returns %TRUE if the setup was successful, %FALSE if @error is set.
     */
    setupThresholdsFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously setups thresholds so that the device itself decides when to report the
     * extended signal quality information updates.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_signal_setup_thresholds() for the asynchronous version of this method.
     * @param properties Threshold values to set.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the setup was successful, %FALSE if @error is set.
     */
    setupThresholdsSync(properties: SignalThresholdProperties, cancellable: Gio.Cancellable | null): boolean

    // Class property signals of ModemManager-1.0.ModemManager.ModemSignal

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::cdma", callback: (...args: any[]) => void): number
    on(sigName: "notify::cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cdma", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cdma", ...args: any[]): void
    connect(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void): number
    on(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::error-rate-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::error-rate-threshold", ...args: any[]): void
    connect(sigName: "notify::evdo", callback: (...args: any[]) => void): number
    on(sigName: "notify::evdo", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::evdo", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::evdo", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::evdo", ...args: any[]): void
    connect(sigName: "notify::gsm", callback: (...args: any[]) => void): number
    on(sigName: "notify::gsm", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gsm", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gsm", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gsm", ...args: any[]): void
    connect(sigName: "notify::lte", callback: (...args: any[]) => void): number
    on(sigName: "notify::lte", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::lte", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::lte", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::lte", ...args: any[]): void
    connect(sigName: "notify::nr5g", callback: (...args: any[]) => void): number
    on(sigName: "notify::nr5g", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::nr5g", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::nr5g", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::nr5g", ...args: any[]): void
    connect(sigName: "notify::rate", callback: (...args: any[]) => void): number
    on(sigName: "notify::rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::rate", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::rate", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::rate", ...args: any[]): void
    connect(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void): number
    on(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::rssi-threshold", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::rssi-threshold", ...args: any[]): void
    connect(sigName: "notify::umts", callback: (...args: any[]) => void): number
    on(sigName: "notify::umts", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::umts", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::umts", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::umts", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModemSignal structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class ModemSignal extends GdbusModemSignalProxy {

    // Own properties of ModemManager-1.0.ModemManager.ModemSignal

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.ModemSignal

    constructor(config?: ModemSignal.ConstructorProperties) 
    _init(config?: ModemSignal.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_signal_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_signal_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_signal_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_signal_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_signal_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module ModemSimple {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemSimple.ConstructorProperties, GdbusModemSimpleProxy.ConstructorProperties {
    }

}

export interface ModemSimple extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemSimple {

    // Own properties of ModemManager-1.0.ModemManager.ModemSimple

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.ModemSimple

    /**
     * Asynchronously requests to connect the modem using the given `properties`.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_simple_connect_finish() to get the result of the operation.
     * 
     * See mm_modem_simple_connect_sync() for the synchronous, blocking version of
     * this method.
     * @param properties A #MMSimpleConnectProperties bundle.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    connect(properties: SimpleConnectProperties, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_simple_connect().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_simple_connect().
     * @returns A #MMBearer, or %FALSE if @error is set. The returned value must be freed with g_object_unref().
     */
    connectFinish(res: Gio.AsyncResult): Bearer
    /**
     * Synchronously requests to connect the modem using the given `properties`.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_simple_connect() for the asynchronous version of this method.
     * @param properties A #MMSimpleConnectProperties bundle.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #MMBearer, or %FALSE if @error is set. The returned value must be freed with g_object_unref().
     */
    connectSync(properties: SimpleConnectProperties, cancellable: Gio.Cancellable | null): Bearer
    /**
     * Asynchronously requests to disconnect the modem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_simple_disconnect_finish() to get the result of the operation.
     * 
     * See mm_modem_simple_disconnect_sync() for the synchronous, blocking version
     * of this method.
     * @param bearer Path of the bearer to disconnect, or %NULL to  disconnect all connected bearers.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    disconnect(bearer: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_simple_disconnect().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_simple_disconnect().
     * @returns %TRUE if the modem is successfully disconnected, %FALSE if @error is set.
     */
    disconnectFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to disconnect the modem.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_simple_disconnect() for the asynchronous version of this method.
     * @param bearer Path of the bearer to disconnect, or %NULL to  disconnect all connected bearers.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the modem is successfully disconnected, %FALSE if @error is set.
     */
    disconnectSync(bearer: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Asynchronously requests a compilation of the status of the modem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_simple_get_status_finish() to get the result of the operation.
     * 
     * See mm_modem_simple_get_status_sync() for the synchronous, blocking version
     * of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    getStatus(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_simple_get_status().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_simple_connect().
     * @returns A #MMSimpleStatus, or %FALSE if @error is set. The returned value must be freed with g_object_unref().
     */
    getStatusFinish(res: Gio.AsyncResult): SimpleStatus
    /**
     * Synchronously requests a compilation of the status of the modem.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_simple_get_status() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A #MMSimpleStatus, or %FALSE if @error is set. The returned value must be freed with g_object_unref().
     */
    getStatusSync(cancellable: Gio.Cancellable | null): SimpleStatus

    // Class property signals of ModemManager-1.0.ModemManager.ModemSimple

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModemSimple structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class ModemSimple extends GdbusModemSimpleProxy {

    // Own properties of ModemManager-1.0.ModemManager.ModemSimple

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.ModemSimple

    constructor(config?: ModemSimple.ConstructorProperties) 
    _init(config?: ModemSimple.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_simple_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_simple_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_simple_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_simple_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_simple_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module ModemTime {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemTime.ConstructorProperties, GdbusModemTimeProxy.ConstructorProperties {
    }

}

export interface ModemTime extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemTime {

    // Own properties of ModemManager-1.0.ModemManager.ModemTime

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.ModemTime

    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Asynchronously requests the current network time.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_time_get_network_time_finish() to get the result of the operation.
     * 
     * See mm_modem_time_get_network_time_sync() for the synchronous, blocking
     * version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    getNetworkTime(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_time_get_network_time().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_enable().
     * @returns A string containing the network time, or %NULL if @error is set. The returned value should be freed with g_free().
     */
    getNetworkTimeFinish(res: Gio.AsyncResult): string | null
    /**
     * Synchronously requests the current network time.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_time_get_network_time() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A string containing the network time, or %NULL if @error is set. The returned value should be freed with g_free().
     */
    getNetworkTimeSync(cancellable: Gio.Cancellable | null): string | null
    /**
     * Gets the network timezone information.
     * 
     * <warning>The values reported by `self` are not updated when the values in the
     * interface change. Instead, the client is expected to call
     * mm_modem_time_get_network_timezone() again to get a new #MMNetworkTimezone
     * with the new values.</warning>
     * @returns A #MMNetworkTimezone that must be freed with g_object_unref() or %NULL if unknown.
     */
    getNetworkTimezone(): NetworkTimezone
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Gets the network timezone information.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_modem_time_get_network_timezone() if on another thread.</warning>
     * @returns A #MMNetworkTimezone. Do not free the returned value, it belongs to @self.
     */
    peekNetworkTimezone(): NetworkTimezone

    // Class property signals of ModemManager-1.0.ModemManager.ModemTime

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::network-timezone", callback: (...args: any[]) => void): number
    on(sigName: "notify::network-timezone", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::network-timezone", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::network-timezone", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::network-timezone", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModemTime structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class ModemTime extends GdbusModemTimeProxy {

    // Own properties of ModemManager-1.0.ModemManager.ModemTime

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.ModemTime

    constructor(config?: ModemTime.ConstructorProperties) 
    _init(config?: ModemTime.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_time_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_time_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_time_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_time_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_time_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module ModemVoice {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusModemVoice.ConstructorProperties, GdbusModemVoiceProxy.ConstructorProperties {
    }

}

export interface ModemVoice extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusModemVoice {

    // Own properties of ModemManager-1.0.ModemManager.ModemVoice

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.ModemVoice

    /**
     * Asynchronously queries the status of the call waiting network service.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_voice_call_waiting_query_finish() to get the result of the
     * operation.
     * 
     * See mm_modem_voice_call_waiting_query_sync() for the synchronous, blocking
     * version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    callWaitingQuery(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_voice_call_waiting_query().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_voice_call_waiting_query().
     * @param status Output location where to store the status.
     * @returns %TRUE if @status is set, %FALSE if @error is set.
     */
    callWaitingQueryFinish(res: Gio.AsyncResult, status: boolean): boolean
    /**
     * Synchronously queries the status of the call waiting network service.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_voice_call_waiting_query() for the asynchronous version of this
     * method.
     * @param cancellable A #GCancellable or %NULL.
     * @param status Output location where to store the status.
     * @returns %TRUE if @status is set, %FALSE if @error is set.
     */
    callWaitingQuerySync(cancellable: Gio.Cancellable | null, status: boolean): boolean
    /**
     * Asynchronously enables or disables the call waiting network service.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_voice_call_waiting_setup_finish() to get the result of the
     * operation.
     * 
     * See mm_modem_voice_call_waiting_setup_sync() for the synchronous, blocking
     * version of this method.
     * @param enable Whether the call waiting service should be enabled.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    callWaitingSetup(enable: boolean, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_voice_call_waiting_setup().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_voice_call_waiting_setup().
     * @returns %TRUE if  @status is set, %FALSE if @error is set.
     */
    callWaitingSetupFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously enables or disables the call waiting network service.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_voice_call_waiting_setup() for the asynchronous version of this
     * method.
     * @param enable Whether the call waiting service should be enabled.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation is successful, %FALSE if @error is set.
     */
    callWaitingSetupSync(enable: boolean, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously creates a new #MMCall in the modem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_voice_create_call_finish() to get the result of the operation.
     * 
     * See mm_modem_voice_create_call_sync() for the synchronous, blocking version
     * of this method.
     * @param properties A ##MMCallProperties object with the properties to use.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    createCall(properties: CallProperties, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_voice_create_call().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_voice_create_call().
     * @returns A newly created #MMCall, or %NULL if @error is set. The returned value should be freed with g_object_unref().
     */
    createCallFinish(res: Gio.AsyncResult): Call
    /**
     * Synchronously creates a new #MMCall in the modem.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_voice_create_call() for the asynchronous version of this method.
     * @param properties A ##MMCallProperties object with the properties to use.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A newly created #MMCall, or %NULL if @error is set. The returned value should be freed with g_object_unref().
     */
    createCallSync(properties: CallProperties, cancellable: Gio.Cancellable | null): Call
    /**
     * Asynchronously deletes a given #MMCall from the modem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_voice_delete_call_finish() to get the result of the operation.
     * 
     * See mm_modem_voice_delete_call_sync() for the synchronous, blocking version
     * of this method.
     * @param call Path of the #MMCall to delete.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    deleteCall(call: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_voice_delete_call().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_voice_delete_call().
     * @returns %TRUE if the call was deleted, %FALSE if @error is set.
     */
    deleteCallFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously deletes a given #MMCall from the modem.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_voice_delete_call() for the asynchronous version of this method.
     * @param call Path of the #MMCall to delete.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the CALL was deleted, %FALSE if @error is set.
     */
    deleteCallSync(call: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a copy of the DBus path of the #MMObject object which implements this
     * interface.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Checks whether emergency calls only are allowed.
     * @returns %TRUE if only emergency calls are allowed, %FALSE otherwise.
     */
    getEmergencyOnly(): boolean
    /**
     * Gets the DBus path of the #MMObject which implements this interface.
     * @returns The DBus path of the #MMObject object.
     */
    getPath(): string | null
    /**
     * Asynchronously hangs up all ongoing (active, waiting, held) calls.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_voice_hangup_all_finish() to get the result of the operation.
     * 
     * See mm_modem_voice_hangup_all_sync() for the synchronous, blocking version of
     * this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    hangupAll(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_voice_hangup_all().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_voice_hangup_all().
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    hangupAllFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously hangs up all ongoing (active, waiting, held) calls.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_voice_hangup_all() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    hangupAllSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously hangs up all active calls and accepts the next waiting or held
     * call.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_voice_hangup_and_accept_finish() to get the result of the operation.
     * 
     * See mm_modem_voice_hangup_and_accept_sync() for the synchronous, blocking
     * version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    hangupAndAccept(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_voice_hangup_and_accept().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_voice_hangup_and_accept().
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    hangupAndAcceptFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously hangs up all active calls and accepts the next waiting or held
     * call.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_voice_hangup_and_accept() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    hangupAndAcceptSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously puts all active calls on hold and accepts the next waiting or
     * held call.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_voice_hold_and_accept_finish() to get the result of the operation.
     * 
     * See mm_modem_voice_hold_and_accept_sync() for the synchronous, blocking
     * version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    holdAndAccept(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_voice_hold_and_accept().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_voice_hold_and_accept().
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    holdAndAcceptFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously puts all active calls on hold and accepts the next waiting or
     * held call.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_voice_hold_and_accept() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    holdAndAcceptSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously lists the #MMCall objects in the modem.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_voice_list_calls_finish() to get the result of the operation.
     * 
     * See mm_modem_voice_list_calls_sync() for the synchronous, blocking version of
     * this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    listCalls(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_voice_list_calls().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_voice_list_calls().
     * @returns A list of #MMCall objects, or #NULL if either not found or @error is set. The returned value should be freed with g_list_free_full() using g_object_unref() as #GDestroyNotify function.
     */
    listCallsFinish(res: Gio.AsyncResult): Call[]
    /**
     * Synchronously lists the #MMCall objects in the modem.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_voice_list_calls() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns A list of #MMCall objects, or #NULL if either not found or @error is set. The returned value should be freed with g_list_free_full() using g_object_unref() as #GDestroyNotify function.
     */
    listCallsSync(cancellable: Gio.Cancellable | null): Call[]
    /**
     * Asynchronously joins all active and held calls, and disconnects from them.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_modem_voice_transfer_finish() to get the result of the operation.
     * 
     * See mm_modem_voice_transfer_sync() for the synchronous, blocking version of
     * this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    transfer(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_modem_voice_transfer().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_modem_voice_transfer().
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    transferFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously joins all active and held calls, and disconnects from them.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_modem_voice_transfer() for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    transferSync(cancellable: Gio.Cancellable | null): boolean

    // Class property signals of ModemManager-1.0.ModemManager.ModemVoice

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::calls", callback: (...args: any[]) => void): number
    on(sigName: "notify::calls", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::calls", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::calls", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::calls", ...args: any[]): void
    connect(sigName: "notify::emergency-only", callback: (...args: any[]) => void): number
    on(sigName: "notify::emergency-only", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::emergency-only", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::emergency-only", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::emergency-only", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMModemVoice structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class ModemVoice extends GdbusModemVoiceProxy {

    // Own properties of ModemManager-1.0.ModemManager.ModemVoice

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.ModemVoice

    constructor(config?: ModemVoice.ConstructorProperties) 
    _init(config?: ModemVoice.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_modem_voice_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_modem_voice_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_modem_voice_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module NetworkTimezone {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface NetworkTimezone {

    // Own properties of ModemManager-1.0.ModemManager.NetworkTimezone

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.NetworkTimezone

    /**
     * Gets the timezone offset due to daylight saving time (in minutes) reported by
     * the network.
     * @returns the offset, or %MM_NETWORK_TIMEZONE_OFFSET_UNKNOWN if unknown.
     */
    getDstOffset(): number
    /**
     * Gets the number of leap seconds (TAI-UTC), as reported by the network.
     * @returns the number of leap seconds, or %MM_NETWORK_TIMEZONE_LEAP_SECONDS_UNKNOWN if unknown.
     */
    getLeapSeconds(): number
    /**
     * Gets the timezone offset (in minutes) reported by the network.
     * @returns the offset, or %MM_NETWORK_TIMEZONE_OFFSET_UNKNOWN if unknown.
     */
    getOffset(): number

    // Class property signals of ModemManager-1.0.ModemManager.NetworkTimezone

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMNetworkTimezone structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class NetworkTimezone extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.NetworkTimezone

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.NetworkTimezone

    constructor(config?: NetworkTimezone.ConstructorProperties) 
    _init(config?: NetworkTimezone.ConstructorProperties): void
}

export module Nr5gRegistrationSettings {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface Nr5gRegistrationSettings {

    // Own properties of ModemManager-1.0.ModemManager.Nr5gRegistrationSettings

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Nr5gRegistrationSettings

    /**
     * Gets the MICO mode configuration.
     * @returns a #MMModem3gppDrxCycle.
     */
    getDrxCycle(): Modem3gppDrxCycle
    /**
     * Gets the MICO mode configuration.
     * @returns a #MMModem3gppMicoMode.
     */
    getMicoMode(): Modem3gppMicoMode
    /**
     * Sets the MICO mode configuration.
     * @param drxCycle a #MMModem3gppDrxCycle.
     */
    setDrxCycle(drxCycle: Modem3gppDrxCycle): void
    /**
     * Sets the MICO mode configuration.
     * @param micoMode a #MMModem3gppMicoMode.
     */
    setMicoMode(micoMode: Modem3gppMicoMode): void

    // Class property signals of ModemManager-1.0.ModemManager.Nr5gRegistrationSettings

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMNr5gRegistrationSettings structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class Nr5gRegistrationSettings extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.Nr5gRegistrationSettings

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Nr5gRegistrationSettings

    constructor(config?: Nr5gRegistrationSettings.ConstructorProperties) 
    /**
     * Creates a new empty #MMNr5gRegistrationSettings.
     * @constructor 
     * @returns a #MMNr5gRegistrationSettings. The returned value should be freed with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new empty #MMNr5gRegistrationSettings.
     * @constructor 
     * @returns a #MMNr5gRegistrationSettings. The returned value should be freed with g_object_unref().
     */
    static new(): Nr5gRegistrationSettings
    _init(config?: Nr5gRegistrationSettings.ConstructorProperties): void
}

export module Object {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.DBusObject.ConstructorProperties, GdbusObject.ConstructorProperties, GdbusObjectProxy.ConstructorProperties {
    }

}

export interface Object extends Gio.DBusObject, GdbusObject {

    // Own properties of ModemManager-1.0.ModemManager.Object

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Object

    /**
     * Gets a copy of the DBus path of the #MMObject object.
     * @returns The DBus path of the #MMObject. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets the #MMModem instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem on `self,` if any.
     * @returns A #MMModem that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModem(): Modem

    // Overloads of getModem

    /**
     * Gets the #MmGdbusModem instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link> on `object,` if any.
     * @returns A #MmGdbusModem that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModem(): GdbusModem | null
    /**
     * Gets the #MMModem3gpp instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.Modem3gpp on `self,` if any.
     * @returns A #MMModem3gpp that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModem3gpp(): Modem3gpp

    // Overloads of getModem3gpp

    /**
     * Gets the #MmGdbusModem3gpp instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link> on `object,` if any.
     * @returns A #MmGdbusModem3gpp that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModem3gpp(): GdbusModem3gpp | null
    /**
     * Gets the #MMModem3gppProfileManager instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.Modem3gpp-ProfileManager on `self,` if any.
     * @returns A #MMModem3gppProfileManager that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModem3gppProfileManager(): Modem3gppProfileManager

    // Overloads of getModem3gppProfileManager

    /**
     * Gets the #MmGdbusModem3gppProfileManager instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link> on `object,` if any.
     * @returns A #MmGdbusModem3gppProfileManager that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModem3gppProfileManager(): GdbusModem3gppProfileManager | null
    /**
     * Gets the #MMModem3gppUssd instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.Modem3gpp-Ussd on `self,` if any.
     * @returns A #MMModem3gppUssd that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModem3gppUssd(): Modem3gppUssd

    // Overloads of getModem3gppUssd

    /**
     * Gets the #MmGdbusModem3gppUssd instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link> on `object,` if any.
     * @returns A #MmGdbusModem3gppUssd that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModem3gppUssd(): GdbusModem3gppUssd | null
    /**
     * Gets the #MMModemCdma instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.ModemCdma on `self,` if any.
     * @returns A #MMModemCdma that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModemCdma(): ModemCdma

    // Overloads of getModemCdma

    /**
     * Gets the #MmGdbusModemCdma instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link> on `object,` if any.
     * @returns A #MmGdbusModemCdma that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemCdma(): GdbusModemCdma | null
    /**
     * Gets the #MMModemFirmware instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.Firmware on `self,` if any.
     * @returns A #MMModemFirmware that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModemFirmware(): ModemFirmware

    // Overloads of getModemFirmware

    /**
     * Gets the #MmGdbusModemFirmware instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link> on `object,` if any.
     * @returns A #MmGdbusModemFirmware that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemFirmware(): GdbusModemFirmware | null
    /**
     * Gets the #MMModemLocation instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.Modemlocation on `self,` if any.
     * @returns A #MMModemLocation that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModemLocation(): ModemLocation

    // Overloads of getModemLocation

    /**
     * Gets the #MmGdbusModemLocation instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link> on `object,` if any.
     * @returns A #MmGdbusModemLocation that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemLocation(): GdbusModemLocation | null
    /**
     * Gets the #MMModemMessaging instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.Modemmessaging on `self,` if any.
     * @returns A #MMModemMessaging that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModemMessaging(): ModemMessaging

    // Overloads of getModemMessaging

    /**
     * Gets the #MmGdbusModemMessaging instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link> on `object,` if any.
     * @returns A #MmGdbusModemMessaging that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemMessaging(): GdbusModemMessaging | null
    /**
     * Gets the #MMModemOma instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.Oma on `self,` if any.
     * @returns A #MMModemOma that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModemOma(): ModemOma

    // Overloads of getModemOma

    /**
     * Gets the #MmGdbusModemOma instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link> on `object,` if any.
     * @returns A #MmGdbusModemOma that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemOma(): GdbusModemOma | null
    /**
     * Gets the #MMModemSar instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.Sar on `self,` if any.
     * @returns A #MMModemSar that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModemSar(): ModemSar

    // Overloads of getModemSar

    /**
     * Gets the #MmGdbusModemSar instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link> on `object,` if any.
     * @returns A #MmGdbusModemSar that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemSar(): GdbusModemSar | null
    /**
     * Gets the #MMModemSignal instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.Signal on `self,` if any.
     * @returns A #MMModemSignal that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModemSignal(): ModemSignal

    // Overloads of getModemSignal

    /**
     * Gets the #MmGdbusModemSignal instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link> on `object,` if any.
     * @returns A #MmGdbusModemSignal that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemSignal(): GdbusModemSignal | null
    /**
     * Gets the #MMModemSimple instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.Modemsimple on `self,` if any.
     * @returns A #MMModemSimple that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModemSimple(): ModemSimple

    // Overloads of getModemSimple

    /**
     * Gets the #MmGdbusModemSimple instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link> on `object,` if any.
     * @returns A #MmGdbusModemSimple that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemSimple(): GdbusModemSimple | null
    /**
     * Gets the #MMModemTime instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.Time on `self,` if any.
     * @returns A #MMModemTime that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModemTime(): ModemTime

    // Overloads of getModemTime

    /**
     * Gets the #MmGdbusModemTime instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link> on `object,` if any.
     * @returns A #MmGdbusModemTime that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemTime(): GdbusModemTime | null
    /**
     * Gets the #MMModemVoice instance for the D-Bus interface
     * org.freedesktop.ModemManager1.Modem.Modemvoice on `self,` if any.
     * @returns A #MMModemVoice that must be freed with g_object_unref() or %NULL if @self does not implement the interface.
     */
    getModemVoice(): ModemVoice

    // Overloads of getModemVoice

    /**
     * Gets the #MmGdbusModemVoice instance for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link> on `object,` if any.
     * @returns A #MmGdbusModemVoice that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
     */
    getModemVoice(): GdbusModemVoice | null

    // Class property signals of ModemManager-1.0.ModemManager.Object

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::modem", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem", ...args: any[]): void
    connect(sigName: "notify::modem-cdma", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-cdma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-cdma", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-cdma", ...args: any[]): void
    connect(sigName: "notify::modem-firmware", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-firmware", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-firmware", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-firmware", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-firmware", ...args: any[]): void
    connect(sigName: "notify::modem-location", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-location", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-location", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-location", ...args: any[]): void
    connect(sigName: "notify::modem-messaging", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-messaging", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-messaging", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-messaging", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-messaging", ...args: any[]): void
    connect(sigName: "notify::modem-oma", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-oma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-oma", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-oma", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-oma", ...args: any[]): void
    connect(sigName: "notify::modem-sar", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-sar", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-sar", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-sar", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-sar", ...args: any[]): void
    connect(sigName: "notify::modem-signal", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-signal", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-signal", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-signal", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-signal", ...args: any[]): void
    connect(sigName: "notify::modem-simple", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-simple", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-simple", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-simple", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-simple", ...args: any[]): void
    connect(sigName: "notify::modem-time", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-time", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-time", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-time", ...args: any[]): void
    connect(sigName: "notify::modem-voice", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem-voice", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem-voice", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem-voice", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem-voice", ...args: any[]): void
    connect(sigName: "notify::modem3gpp", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem3gpp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem3gpp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem3gpp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem3gpp", ...args: any[]): void
    connect(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem3gpp-profile-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem3gpp-profile-manager", ...args: any[]): void
    connect(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void): number
    on(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::modem3gpp-ussd", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::modem3gpp-ussd", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMObject structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class Object extends GdbusObjectProxy {

    // Own properties of ModemManager-1.0.ModemManager.Object

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Object

    constructor(config?: Object.ConstructorProperties) 
    _init(config?: Object.ConstructorProperties): void

    // Conflicting static methods

    static new(...args: any[]): any
}

export module Pco {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface Pco {

    // Own properties of ModemManager-1.0.ModemManager.Pco

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Pco

    /**
     * Gets the PCO data in raw bytes.
     * @returns the PCO data, or %NULL if it doesn't contain any.
     */
    getData(): [ /* returnType */ number, /* dataSize */ number ]

    // Overloads of getData

    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     * @returns the data if found,          or %NULL if no such data exists.
     */
    getData(key: string | null): any | null
    /**
     * Gets the session ID associated with the PCO.
     * @returns the session ID.
     */
    getSessionId(): number
    /**
     * Gets the complete flag that indicates whether the PCO data contains the
     * complete PCO structure received from the network.
     * @returns %TRUE if the PCO data contains the complete PCO structure, %FALSE otherwise.
     */
    isComplete(): boolean

    // Class property signals of ModemManager-1.0.ModemManager.Pco

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMPco structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class Pco extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.Pco

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Pco

    constructor(config?: Pco.ConstructorProperties) 
    _init(config?: Pco.ConstructorProperties): void
    /**
     * Frees all of the memory used by a #GList of #MMPco.
     * @param pcoList a #GList of  #MMPco.
     */
    static listFree(pcoList: Pco[]): void
}

export module Signal {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface Signal {

    // Own properties of ModemManager-1.0.ModemManager.Signal

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Signal

    /**
     * Gets the Ec/Io, in dB.
     * 
     * Only applicable to CDMA1x, CDMA EV-DO and UMTS (WCDMA).
     * @returns the ECIO, or %MM_SIGNAL_UNKNOWN if unknown.
     */
    getEcio(): number
    /**
     * Gets the channel error rate (BER, BLER,... depends on the RAT), in
     * percentage.
     * 
     * Applicable to all RAT.
     * @returns the error rate, or %MM_SIGNAL_UNKNOWN if unknown.
     */
    getErrorRate(): number
    /**
     * Gets the Io, in dBm.
     * 
     * Only applicable to CDMA EV-DO.
     * @returns the Io, or %MM_SIGNAL_UNKNOWN if unknown.
     */
    getIo(): number
    /**
     * Gets the RSCP (Received Signal Code Power), in dBm.
     * @returns the RSCP, or %MM_SIGNAL_UNKNOWN if unknown.
     */
    getRscp(): number
    /**
     * Gets the RSRP (Reference Signal Received Power), in dBm.
     * 
     * Only applicable to LTE.
     * @returns the RSRP, or %MM_SIGNAL_UNKNOWN if unknown.
     */
    getRsrp(): number
    /**
     * Gets the RSRQ (Reference Signal Received Quality), in dB.
     * 
     * Only applicable to LTE.
     * @returns the RSRQ, or %MM_SIGNAL_UNKNOWN if unknown.
     */
    getRsrq(): number
    /**
     * Gets the RSSI (Received Signal Strength Indication), in dBm.
     * @returns the RSSI, or %MM_SIGNAL_UNKNOWN if unknown.
     */
    getRssi(): number
    /**
     * Gets the SINR level, in dB.
     * 
     * Only applicable to CDMA EV-DO.
     * @returns the SINR, or %MM_SIGNAL_UNKNOWN if unknown.
     */
    getSinr(): number
    /**
     * Gets the S/R ration, in dB.
     * 
     * Only applicable to LTE.
     * @returns the S/R ratio, or %MM_SIGNAL_UNKNOWN if unknown.
     */
    getSnr(): number

    // Class property signals of ModemManager-1.0.ModemManager.Signal

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMSignal structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class Signal extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.Signal

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Signal

    constructor(config?: Signal.ConstructorProperties) 
    _init(config?: Signal.ConstructorProperties): void
}

export module SignalThresholdProperties {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface SignalThresholdProperties {

    // Own properties of ModemManager-1.0.ModemManager.SignalThresholdProperties

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.SignalThresholdProperties

    /**
     * Gets whether the error rate threshold is enabled or disabled.
     * @returns %TRUE if the error rate threshold is enabled, %FALSE otherwise.
     */
    getErrorRate(): boolean
    /**
     * Gets the RSSI threshold, in dBm.
     * @returns the RSSI threshold, or 0 if disabled.
     */
    getRssi(): number
    /**
     * Enables or disables the error rate threshold.
     * @param errorRateThreshold %TRUE to enable, %FALSE to disable.
     */
    setErrorRate(errorRateThreshold: boolean): void
    /**
     * Sets the RSSI threshold, in dBm.
     * @param rssiThreshold the RSSI threshold, or 0 to disable.
     */
    setRssi(rssiThreshold: number): void

    // Class property signals of ModemManager-1.0.ModemManager.SignalThresholdProperties

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMSignalThresholdProperties structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class SignalThresholdProperties extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.SignalThresholdProperties

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.SignalThresholdProperties

    constructor(config?: SignalThresholdProperties.ConstructorProperties) 
    /**
     * Creates a new empty #MMSignalThresholdProperties.
     * @constructor 
     * @returns a #MMSignalThresholdProperties. The returned value should be freed with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new empty #MMSignalThresholdProperties.
     * @constructor 
     * @returns a #MMSignalThresholdProperties. The returned value should be freed with g_object_unref().
     */
    static new(): SignalThresholdProperties
    _init(config?: SignalThresholdProperties.ConstructorProperties): void
}

export module Sim {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusSim.ConstructorProperties, GdbusSimProxy.ConstructorProperties {
    }

}

export interface Sim extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusSim {

    // Own properties of ModemManager-1.0.ModemManager.Sim

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Sim

    /**
     * Asynchronously changes the PIN code in the SIM card.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_sim_change_pin_finish() to get the result of the operation.
     * 
     * See mm_sim_change_pin_sync() for the synchronous, blocking version of this
     * method.
     * @param oldPin The current PIN code.
     * @param newPin The new PIN code to be set.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    changePin(oldPin: string | null, newPin: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_sim_change_pin().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_sim_change_pin().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    changePinFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously changes the PIN code in the SIM card.
     * 
     * The calling thread is blocked until a reply is received.
     * See mm_sim_change_pin() for the asynchronous version of this method.
     * @param oldPin The current PIN code.
     * @param newPin The new PIN code to be set.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    changePinSync(oldPin: string | null, newPin: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously disables requesting the PIN code in the SIM card.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_sim_disable_pin_finish() to get the result of the operation.
     * 
     * See mm_sim_disable_pin_sync() for the synchronous, blocking version of this
     * method.
     * @param pin The PIN code.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    disablePin(pin: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_sim_disable_pin().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_sim_disable_pin().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    disablePinFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously disables requesting the PIN code in the SIM card.
     * 
     * The calling thread is blocked until a reply is received.
     * See mm_sim_disable_pin() for the asynchronous version of this method.
     * @param pin The PIN code.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    disablePinSync(pin: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Gets a copy of the Embedded UICC ID (EID) of the #MMSim object.
     * @returns The EID of the #MMSim object, or %NULL if it couldn't be retrieved. The returned value should be freed with g_free().
     */
    dupEid(): string | null
    /**
     * Gets a copy of the list of emergency call numbers programmed in the SIM card.
     * @returns The emergency numbers, or %NULL if none available. The returned value should be freed with g_strfreev().
     */
    dupEmergencyNumbers(): string[]
    /**
     * Gets the Group Identifier Level 1 of the #MMSim object.
     * @returns The GID1 data, or %NULL if unknown.
     */
    dupGid1(): number[]
    /**
     * Gets the Group Identifier Level 2 of the #MMSim object.
     * @returns The GID2 data, or %NULL if unknown.
     */
    dupGid2(): number[]
    /**
     * Gets a copy of the unique SIM identifier of the #MMSim object.
     * @returns The unique identifier of the #MMSim object, or %NULL if it couldn't be retrieved. The returned value should be freed with g_free().
     */
    dupIdentifier(): string | null
    /**
     * Gets a copy of the International Mobile Subscriber Identity (IMSI) of the
     * #MMSim object.
     * @returns The IMSI of the #MMSim object, or %NULL if it couldn't be retrieved. The returned value should be freed with g_free().
     */
    dupImsi(): string | null
    /**
     * Gets a copy of the Operator Identifier of the #MMSim object.
     * @returns The Operator Identifier of the #MMSim object, or %NULL if it couldn't be retrieved. The returned value should be freed with g_free().
     */
    dupOperatorIdentifier(): string | null
    /**
     * Gets a copy of the Operator Name of the #MMSim object.
     * @returns The Operator Name of the #MMSim object, or %NULL if it couldn't be retrieved. The returned value should be freed with g_free().
     */
    dupOperatorName(): string | null
    /**
     * Gets a copy of the DBus path of the #MMSim object.
     * @returns The DBus path of the #MMSim object. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Asynchronously enables requesting the PIN code in the SIM card.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_sim_enable_pin_finish() to get the result of the operation.
     * 
     * See mm_sim_enable_pin_sync() for the synchronous, blocking version of this
     * method.
     * @param pin The PIN code.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    enablePin(pin: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_sim_enable_pin().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_sim_enable_pin().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    enablePinFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously enables requesting the PIN code in the SIM card.
     * 
     * The calling thread is blocked until a reply is received.
     * See mm_sim_enable_pin() for the asynchronous version of this method.
     * @param pin The PIN code.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    enablePinSync(pin: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Checks whether the #MMSim is currently active.
     * @returns %TRUE if the SIM is active, %FALSE otherwise.
     */
    getActive(): boolean
    /**
     * Gets the Embedded UICC ID (or EID) of the #MMSim object.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_sim_dup_eid() if on another thread.</warning>
     * @returns The EID of the #MMSim object, or %NULL if it couldn't be retrieved.
     */
    getEid(): string | null
    /**
     * Gets the list of emergency call numbers programmed in the SIM card.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_sim_dup_emergency_numbers() if on another thread.</warning>
     * @returns The emergency numbers, or %NULL if none available. Do not free the returned value, it belongs to @self.
     */
    getEmergencyNumbers(): string[]
    /**
     * Gets the eSIM status.
     * 
     * Only applicable if the SIM type is %MM_SIM_TYPE_ESIM.
     * @returns a #MMSimEsimStatus.
     */
    getEsimStatus(): SimEsimStatus
    /**
     * Gets the Group Identifier Level 1 of the #MMSim object.
     * @returns The GID1 data, or %NULL if unknown.
     */
    getGid1(): number[]
    /**
     * Gets the Group Identifier Level 2 of the #MMSim object.
     * @returns The GID2 data, or %NULL if unknown.
     */
    getGid2(): number[]
    /**
     * Gets the unique SIM identifier of the #MMSim object.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_sim_dup_identifier() if on another thread.</warning>
     * @returns The unique identifier of the #MMSim object, or %NULL if it couldn't be retrieved.
     */
    getIdentifier(): string | null
    /**
     * Gets the International Mobile Subscriber Identity (IMSI) of the #MMSim
     * object.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_sim_dup_imsi() if on another thread.</warning>
     * @returns The IMSI of the #MMSim object, or %NULL if it couldn't be retrieved.
     */
    getImsi(): string | null
    /**
     * Gets the Operator Identifier of the #MMSim object.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_sim_dup_operator_identifier() if on another thread.</warning>
     * @returns The Operator Identifier of the #MMSim object, or %NULL if it couldn't be retrieved.
     */
    getOperatorIdentifier(): string | null
    /**
     * Gets the Operator Name of the #MMSim object.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_sim_dup_operator_name() if on another thread.</warning>
     * @returns The Operator Name of the #MMSim object, or %NULL if it couldn't be retrieved.
     */
    getOperatorName(): string | null
    /**
     * Gets the DBus path of the #MMSim object.
     * @returns The DBus path of the #MMSim object.
     */
    getPath(): string | null
    /**
     * Gets the list of #MMSimPreferredNetwork objects exposed by this
     * #MMSim.
     * @returns a list of #MMSimPreferredNetwork objects, or #NULL. The returned value should be freed with g_list_free_full() using mm_sim_preferred_network_free() as #GDestroyNotify function.
     */
    getPreferredNetworks(): SimPreferredNetwork[]
    /**
     * Gets whether the SIM is removable or not.
     * @returns a #MMSimRemovability.
     */
    getRemovability(): SimRemovability
    /**
     * Gets the SIM type.
     * @returns a #MMSimType.
     */
    getSimType(): SimType
    /**
     * Asynchronously sends the PIN code to the SIM card.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_sim_send_pin_finish() to get the result of the operation.
     * 
     * See mm_sim_send_pin_sync() for the synchronous, blocking version of this
     * method.
     * @param pin The PIN code.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    sendPin(pin: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_sim_send_pin().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_sim_send_pin().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    sendPinFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously sends the PIN to the SIM card.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_sim_send_pin() for the asynchronous version of this method.
     * @param pin The PIN code.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    sendPinSync(pin: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously sends the PUK code to the SIM card.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_sim_send_puk_finish() to get the result of the operation.
     * 
     * See mm_sim_send_puk_sync() for the synchronous, blocking version of this
     * method.
     * @param puk The PUK code.
     * @param pin The PIN code.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    sendPuk(puk: string | null, pin: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_sim_send_puk().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_sim_send_puk().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    sendPukFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously sends the PUK to the SIM card.
     * 
     * The calling thread is blocked until a reply is received.
     * See mm_sim_send_puk() for the asynchronous version of this method.
     * @param puk The PUK code.
     * @param pin The PIN code.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    sendPukSync(puk: string | null, pin: string | null, cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronously sets the preferred network list of this #MMSim.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_sim_set_preferred_networks_finish() to get the result of
     * the operation.
     * @param preferredNetworks   A list of #MMSimPreferredNetwork objects
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    setPreferredNetworks(preferredNetworks: SimPreferredNetwork[], cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_sim_set_preferred_networks().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_sim_set_preferred_networks().
     * @returns %TRUE if the operation was successful, %FALSE if @error is set.
     */
    setPreferredNetworksFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously sets the preferred network list of this #MMSim.
     * 
     * The calling thread is blocked until a reply is received. See
     * mm_sim_set_preferred_networks() for the asynchronous
     * version of this method.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_sim_set_preferred_networks_finish() to get the result of
     * the operation.
     * @param preferredNetworks   A list of #MMSimPreferredNetwork objects
     * @param cancellable A #GCancellable or %NULL.
     */
    setPreferredNetworksSync(preferredNetworks: SimPreferredNetwork[], cancellable: Gio.Cancellable | null): boolean

    // Class property signals of ModemManager-1.0.ModemManager.Sim

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::active", callback: (...args: any[]) => void): number
    on(sigName: "notify::active", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::active", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::active", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::active", ...args: any[]): void
    connect(sigName: "notify::eid", callback: (...args: any[]) => void): number
    on(sigName: "notify::eid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::eid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::eid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::eid", ...args: any[]): void
    connect(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void): number
    on(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::emergency-numbers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::emergency-numbers", ...args: any[]): void
    connect(sigName: "notify::esim-status", callback: (...args: any[]) => void): number
    on(sigName: "notify::esim-status", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::esim-status", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::esim-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::esim-status", ...args: any[]): void
    connect(sigName: "notify::gid1", callback: (...args: any[]) => void): number
    on(sigName: "notify::gid1", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gid1", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gid1", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gid1", ...args: any[]): void
    connect(sigName: "notify::gid2", callback: (...args: any[]) => void): number
    on(sigName: "notify::gid2", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::gid2", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::gid2", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::gid2", ...args: any[]): void
    connect(sigName: "notify::imsi", callback: (...args: any[]) => void): number
    on(sigName: "notify::imsi", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::imsi", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::imsi", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::imsi", ...args: any[]): void
    connect(sigName: "notify::operator-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-identifier", ...args: any[]): void
    connect(sigName: "notify::operator-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::operator-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::operator-name", ...args: any[]): void
    connect(sigName: "notify::preferred-networks", callback: (...args: any[]) => void): number
    on(sigName: "notify::preferred-networks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::preferred-networks", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::preferred-networks", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::preferred-networks", ...args: any[]): void
    connect(sigName: "notify::removability", callback: (...args: any[]) => void): number
    on(sigName: "notify::removability", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::removability", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::removability", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::removability", ...args: any[]): void
    connect(sigName: "notify::sim-identifier", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim-identifier", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim-identifier", ...args: any[]): void
    connect(sigName: "notify::sim-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::sim-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::sim-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::sim-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::sim-type", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMSim structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class Sim extends GdbusSimProxy {

    // Own properties of ModemManager-1.0.ModemManager.Sim

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Sim

    constructor(config?: Sim.ConstructorProperties) 
    _init(config?: Sim.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sim.top_of_page">org.freedesktop.ModemManager1.Sim</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sim_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sim_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_sim_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sim_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sim_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module SimpleConnectProperties {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface SimpleConnectProperties {

    // Own properties of ModemManager-1.0.ModemManager.SimpleConnectProperties

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.SimpleConnectProperties

    /**
     * Checks whether roaming is allowed in the connection.
     * @returns %TRUE if roaming is allowed, %FALSE otherwise.
     */
    getAllowRoaming(): boolean
    /**
     * Gets the authentication methods allowed in the connection.
     * @returns a bitmask of #MMBearerAllowedAuth values, or %MM_BEARER_ALLOWED_AUTH_UNKNOWN to request the modem-default method.
     */
    getAllowedAuth(): BearerAllowedAuth
    /**
     * Gets the name of the access point to use when connecting.
     * @returns the access point, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getApn(): string | null
    /**
     * Gets the APN types to use.
     * @returns a mask of #MMBearerApnType values.
     */
    getApnType(): BearerApnType
    /**
     * Sets the IP type to use.
     * @returns a #MMBearerIpFamily.
     */
    getIpType(): BearerIpFamily
    /**
     * Get the multiplex support requested by the user.
     * @returns a #MMBearerMultiplexSupport.
     */
    getMultiplex(): BearerMultiplexSupport
    /**
     * Gets the number to use when performing the connection.
     * @returns the number, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getNumber(): string | null
    /**
     * Gets the ID of the network to which register before connecting.
     * @returns the operator ID, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getOperatorId(): string | null
    /**
     * Gets the password used to authenticate with the access point.
     * @returns the password, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getPassword(): string | null
    /**
     * Gets the PIN code to use when unlocking the modem.
     * @returns the PIN, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getPin(): string | null
    /**
     * Gets the profile ID to use.
     * @returns the profile id.
     */
    getProfileId(): number
    /**
     * Get the RM protocol requested by the user.
     * @returns a #MMModemCdmaRmProtocol.
     */
    getRmProtocol(): ModemCdmaRmProtocol
    /**
     * Gets the username used to authenticate with the access point.
     * @returns the username, or #NULL if not set. Do not free the returned value, it is owned by @self.
     */
    getUser(): string | null
    /**
     * Sets the flag to indicate whether roaming is allowed or not in the
     * connection.
     * @param allowRoaming boolean value.
     */
    setAllowRoaming(allowRoaming: boolean): void
    /**
     * Sets the authentication method to use.
     * @param allowedAuth a bitmask of #MMBearerAllowedAuth values.  %MM_BEARER_ALLOWED_AUTH_UNKNOWN may be given to request the modem-default method.
     */
    setAllowedAuth(allowedAuth: BearerAllowedAuth): void
    /**
     * Sets the name of the access point to use when connecting.
     * @param apn Name of the access point.
     */
    setApn(apn: string | null): void
    /**
     * Sets the APN types to use.
     * @param apnType a mask of #MMBearerApnType values.
     */
    setApnType(apnType: BearerApnType): void
    /**
     * Sets the IP type to use.
     * @param ipType a #MMBearerIpFamily.
     */
    setIpType(ipType: BearerIpFamily): void
    /**
     * Sets the multiplex support requested by the user.
     * @param multiplex a #MMBearerMultiplexSupport.
     */
    setMultiplex(multiplex: BearerMultiplexSupport): void
    /**
     * Sets the number to use when performing the connection.
     * @param number the number.
     */
    setNumber(number: string | null): void
    /**
     * Sets the ID of the network to which register before connecting.
     * @param operatorId operator ID, given as MCC/MNC.
     */
    setOperatorId(operatorId: string | null): void
    /**
     * Sets the password used to authenticate with the access point.
     * @param password the password
     */
    setPassword(password: string | null): void
    /**
     * Sets the PIN code to use when unlocking the modem.
     * @param pin PIN code.
     */
    setPin(pin: string | null): void
    /**
     * Sets the profile ID to use.
     * @param profileId a profile id.
     */
    setProfileId(profileId: number): void
    /**
     * Sets the RM protocol requested by the user.
     * @param protocol a #MMModemCdmaRmProtocol.
     */
    setRmProtocol(protocol: ModemCdmaRmProtocol): void
    /**
     * Sets the username used to authenticate with the access point.
     * @param user the username
     */
    setUser(user: string | null): void

    // Class property signals of ModemManager-1.0.ModemManager.SimpleConnectProperties

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMSimpleConnectProperties structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class SimpleConnectProperties extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.SimpleConnectProperties

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.SimpleConnectProperties

    constructor(config?: SimpleConnectProperties.ConstructorProperties) 
    /**
     * Creates a new empty #MMSimpleConnectProperties.
     * @constructor 
     * @returns a #MMSimpleConnectProperties. The returned value should be freed with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new empty #MMSimpleConnectProperties.
     * @constructor 
     * @returns a #MMSimpleConnectProperties. The returned value should be freed with g_object_unref().
     */
    static new(): SimpleConnectProperties
    _init(config?: SimpleConnectProperties.ConstructorProperties): void
}

export module SimpleStatus {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {

        // Own constructor properties of ModemManager-1.0.ModemManager.SimpleStatus

        accessTechnologies?: ModemAccessTechnology | null
        cdmaCdma1xRegistrationState?: ModemCdmaRegistrationState | null
        cdmaEvdoRegistrationState?: ModemCdmaRegistrationState | null
        cdmaNid?: number | null
        cdmaSid?: number | null
        currentBands?: GLib.Variant | null
        m3gppOperatorCode?: string | null
        m3gppOperatorName?: string | null
        m3gppRegistrationState?: Modem3gppRegistrationState | null
        m3gppSubscriptionState?: Modem3gppSubscriptionState | null
        signalQuality?: GLib.Variant | null
        state?: ModemState | null
    }

}

export interface SimpleStatus {

    // Own properties of ModemManager-1.0.ModemManager.SimpleStatus

    accessTechnologies: ModemAccessTechnology
    cdmaCdma1xRegistrationState: ModemCdmaRegistrationState
    cdmaEvdoRegistrationState: ModemCdmaRegistrationState
    cdmaNid: number
    cdmaSid: number
    currentBands: GLib.Variant
    m3gppOperatorCode: string | null
    m3gppOperatorName: string | null
    m3gppRegistrationState: Modem3gppRegistrationState
    m3gppSubscriptionState: Modem3gppSubscriptionState
    signalQuality: GLib.Variant
    state: ModemState
    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.SimpleStatus

    /**
     * Gets the MCC/MNC of the operator of the 3GPP network where the modem is
     * registered.
     * @returns the operator code, or %NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    get3gppOperatorCode(): string | null
    /**
     * Gets the name of the operator of the 3GPP network where the modem is
     * registered.
     * @returns the operator name, or %NULL if unknown. Do not free the returned value, it is owned by @self.
     */
    get3gppOperatorName(): string | null
    /**
     * Gets the current state of the registration in the 3GPP network.
     * @returns a #MMModem3gppRegistrationState.
     */
    get3gppRegistrationState(): Modem3gppRegistrationState
    /**
     * Gets the current subscription status of the account.
     * @returns a #MMModem3gppSubscriptionState.
     */
    get3gppSubscriptionState(): Modem3gppSubscriptionState
    /**
     * Gets the currently used access technologies.
     * @returns a bitmask of #MMModemAccessTechnology values.
     */
    getAccessTechnologies(): ModemAccessTechnology
    /**
     * Gets the current state of the registration in the CDMA-1x network.
     * @returns a #MMModemCdmaRegistrationState.
     */
    getCdmaCdma1xRegistrationState(): ModemCdmaRegistrationState
    /**
     * Gets the current state of the registration in the EV-DO network.
     * @returns a #MMModemCdmaRegistrationState.
     */
    getCdmaEvdoRegistrationState(): ModemCdmaRegistrationState
    /**
     * Gets the Network Identification number of the CDMA network.
     * @returns the NID, or %MM_MODEM_CDMA_NID_UNKNOWN if unknown.
     */
    getCdmaNid(): number
    /**
     * Gets the System Identification number of the CDMA network.
     * @returns the SID, or %MM_MODEM_CDMA_SID_UNKNOWN if unknown.
     */
    getCdmaSid(): number
    /**
     * Gets the currently used frequency bands.
     */
    getCurrentBands(): [ /* bands */ ModemBand, /* nBands */ number ]
    /**
     * Gets the signal quality.
     * @returns the signal quality.
     */
    getSignalQuality(): [ /* returnType */ number, /* recent */ boolean ]
    /**
     * Gets the state of the modem.
     * @returns a #MMModemState.
     */
    getState(): ModemState

    // Class property signals of ModemManager-1.0.ModemManager.SimpleStatus

    connect(sigName: "notify::access-technologies", callback: (...args: any[]) => void): number
    on(sigName: "notify::access-technologies", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::access-technologies", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::access-technologies", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::access-technologies", ...args: any[]): void
    connect(sigName: "notify::cdma-cdma1x-registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::cdma-cdma1x-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cdma-cdma1x-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cdma-cdma1x-registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cdma-cdma1x-registration-state", ...args: any[]): void
    connect(sigName: "notify::cdma-evdo-registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::cdma-evdo-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cdma-evdo-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cdma-evdo-registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cdma-evdo-registration-state", ...args: any[]): void
    connect(sigName: "notify::cdma-nid", callback: (...args: any[]) => void): number
    on(sigName: "notify::cdma-nid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cdma-nid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cdma-nid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cdma-nid", ...args: any[]): void
    connect(sigName: "notify::cdma-sid", callback: (...args: any[]) => void): number
    on(sigName: "notify::cdma-sid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::cdma-sid", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::cdma-sid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::cdma-sid", ...args: any[]): void
    connect(sigName: "notify::current-bands", callback: (...args: any[]) => void): number
    on(sigName: "notify::current-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::current-bands", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::current-bands", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::current-bands", ...args: any[]): void
    connect(sigName: "notify::m3gpp-operator-code", callback: (...args: any[]) => void): number
    on(sigName: "notify::m3gpp-operator-code", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::m3gpp-operator-code", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::m3gpp-operator-code", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::m3gpp-operator-code", ...args: any[]): void
    connect(sigName: "notify::m3gpp-operator-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::m3gpp-operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::m3gpp-operator-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::m3gpp-operator-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::m3gpp-operator-name", ...args: any[]): void
    connect(sigName: "notify::m3gpp-registration-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::m3gpp-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::m3gpp-registration-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::m3gpp-registration-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::m3gpp-registration-state", ...args: any[]): void
    connect(sigName: "notify::m3gpp-subscription-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::m3gpp-subscription-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::m3gpp-subscription-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::m3gpp-subscription-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::m3gpp-subscription-state", ...args: any[]): void
    connect(sigName: "notify::signal-quality", callback: (...args: any[]) => void): number
    on(sigName: "notify::signal-quality", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::signal-quality", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::signal-quality", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::signal-quality", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMSimpleStatus structure contains private data and should
 * only be accessed using the provided API.
 * @class 
 */
export class SimpleStatus extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.SimpleStatus

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.SimpleStatus

    constructor(config?: SimpleStatus.ConstructorProperties) 
    _init(config?: SimpleStatus.ConstructorProperties): void
}

export module Sms {

    // Constructor properties interface

    export interface ConstructorProperties extends Gio.AsyncInitable.ConstructorProperties, Gio.DBusInterface.ConstructorProperties, Gio.Initable.ConstructorProperties, GdbusSms.ConstructorProperties, GdbusSmsProxy.ConstructorProperties {
    }

}

export interface Sms extends Gio.AsyncInitable, Gio.DBusInterface, Gio.Initable, GdbusSms {

    // Own properties of ModemManager-1.0.ModemManager.Sms

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.Sms

    /**
     * Gets the message data.
     * @returns The message data, or %NULL if it doesn't contain any (e.g. contains text instead). The returned value should be freed with g_free().
     */
    dupData(): number[]
    /**
     * Gets the time when the first PDU of the SMS message left the SMSC, in
     * <ulink url="http://en.wikipedia.org/wiki/ISO_8601">ISO8601</ulink>
     * format.
     * 
     * This field is only applicable if the PDU type is
     * %MM_SMS_PDU_TYPE_STATUS_REPORT.
     * @returns The timestamp, or %NULL if it couldn't be retrieved. The returned value should be freed with g_free().
     */
    dupDischargeTimestamp(): string | null
    /**
     * Gets the number to which the message is addressed.
     * @returns The number, or %NULL if it couldn't be retrieved. The returned value should be freed with g_free().
     */
    dupNumber(): string | null
    /**
     * Gets a copy of the DBus path of the #MMSms object.
     * @returns The DBus path of the #MMSms object. The returned value should be freed with g_free().
     */
    dupPath(): string | null
    /**
     * Gets the SMS service center number.
     * @returns The number of the SMSC, or %NULL if it couldn't be retrieved. The returned value should be freed with g_free().
     */
    dupSmsc(): string | null
    /**
     * Gets the message text, in UTF-8.
     * @returns The message text, or %NULL if it doesn't contain any (e.g. contains data instead). The returned value should be freed with g_free().
     */
    dupText(): string | null
    /**
     * Gets the time when the first PDU of the SMS message arrived the SMSC, in
     * <ulink url="http://en.wikipedia.org/wiki/ISO_8601">ISO8601</ulink>
     * format.
     * 
     * This field is only applicable if the PDU type is %MM_SMS_PDU_TYPE_DELIVER or
     * %MM_SMS_PDU_TYPE_STATUS_REPORT.
     * @returns The timestamp, or %NULL if it couldn't be retrieved. The returned value should be freed with g_free().
     */
    dupTimestamp(): string | null
    /**
     * Gets the 3GPP message class of the SMS.
     * @returns the message class, or -1 for invalid/unset class.
     */
    getClass(): number
    /**
     * Gets the message data.
     * @returns The message data, or %NULL if it doesn't contain any (e.g. contains text instead).
     */
    getData(): number[]

    // Overloads of getData

    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     * @returns the data if found,          or %NULL if no such data exists.
     */
    getData(key: string | null): any | null
    /**
     * Checks whether delivery report is requested for this SMS.
     * @returns %TRUE if delivery report is requested, %FALSE otherwise.
     */
    getDeliveryReportRequest(): boolean
    /**
     * Gets the delivery state of this SMS.
     * 
     * This field is only applicable if the PDU type is
     * %MM_SMS_PDU_TYPE_STATUS_REPORT.
     * @returns A #MMSmsDeliveryState specifying the delivery state.
     */
    getDeliveryState(): number
    /**
     * Gets the time when the first PDU of the SMS message left the SMSC, in
     * <ulink url="http://en.wikipedia.org/wiki/ISO_8601">ISO8601</ulink>
     * format.
     * 
     * This field is only applicable if the PDU type is
     * %MM_SMS_PDU_TYPE_STATUS_REPORT.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_sms_dup_discharge_timestamp() if on another thread.</warning>
     * @returns The timestamp, or %NULL if it couldn't be retrieved.
     */
    getDischargeTimestamp(): string | null
    /**
     * Gets the message reference of the last PDU sent/received within this SMS.
     * 
     * If the PDU type is %MM_SMS_PDU_TYPE_STATUS_REPORT, this field identifies the
     * message reference of the PDU associated to the status report.
     * @returns The message reference.
     */
    getMessageReference(): number
    /**
     * Gets the number to which the message is addressed.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_sms_dup_number() if on another thread.</warning>
     * @returns The number, or %NULL if it couldn't be retrieved.
     */
    getNumber(): string | null
    /**
     * Gets the DBus path of the #MMSms object.
     * @returns The DBus path of the #MMSms object.
     */
    getPath(): string | null
    /**
     * Gets the PDU type on which this SMS is based.
     * @returns A #MMSmsPduType specifying the PDU type.
     */
    getPduType(): SmsPduType
    /**
     * Gets the 3GPP2 Service Category.
     * @returns a #MMSmsCdmaServiceCategory.
     */
    getServiceCategory(): SmsCdmaServiceCategory
    /**
     * Gets the SMS service center number.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_sms_dup_smsc() if on another thread.</warning>
     * @returns The number of the SMSC, or %NULL if it couldn't be retrieved.
     */
    getSmsc(): string | null
    /**
     * Gets the state of this SMS.
     * @returns A #MMSmsState specifying the state.
     */
    getState(): SmsState
    /**
     * Gets the storage in which this SMS is kept.
     * @returns A #MMSmsStorage specifying the storage.
     */
    getStorage(): SmsStorage
    /**
     * Gets the 3GPP2 Teleservice ID.
     * @returns a #MMSmsCdmaTeleserviceId.
     */
    getTeleserviceId(): SmsCdmaTeleserviceId
    /**
     * Gets the message text, in UTF-8.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_sms_dup_text() if on another thread.</warning>
     * @returns The message text, or %NULL if it doesn't contain any (e.g. contains data instead).
     */
    getText(): string | null
    /**
     * Gets the time when the first PDU of the SMS message arrived the SMSC, in
     * <ulink url="http://en.wikipedia.org/wiki/ISO_8601">ISO8601</ulink>
     * format.
     * 
     * This field is only applicable if the PDU type is %MM_SMS_PDU_TYPE_DELIVER or
     * %MM_SMS_PDU_TYPE_STATUS_REPORT.
     * 
     * <warning>The returned value is only valid until the property changes so it is
     * only safe to use this function on the thread where `self` was constructed. Use
     * mm_sms_dup_timestamp() if on another thread.</warning>
     * @returns The timestamp, or %NULL if it couldn't be retrieved.
     */
    getTimestamp(): string | null
    /**
     * Gets the length of the validity period, in minutes.
     * 
     * Only applicable if the type of validity is #MM_SMS_VALIDITY_TYPE_RELATIVE.
     * @returns the length of the validity period, or 0 if unknown.
     */
    getValidityRelative(): number
    /**
     * Gets the type of validity information in the SMS.
     * @returns the validity type or #MM_SMS_VALIDITY_TYPE_UNKNOWN.
     */
    getValidityType(): SmsValidityType
    /**
     * Asynchronously requests to queue the message for delivery.
     * 
     * SMS objects can only be sent once.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_sms_send_finish() to get the result of the operation.
     * 
     * See mm_sms_send_sync() for the synchronous, blocking version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    send(cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_sms_send().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_sms_send().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    sendFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronously requests to queue the message for delivery.
     * 
     * SMS objects can only be sent once.
     * 
     * The calling thread is blocked until a reply is received. See mm_sms_send()
     * for the asynchronous version of this method.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    sendSync(cancellable: Gio.Cancellable | null): boolean
    /**
     * Asynchronoulsy requests to store the message in the device if not already done.
     * 
     * SMS objects can only be stored once.
     * 
     * When the operation is finished, `callback` will be invoked in the
     * <link linkend="g-main-context-push-thread-default">thread-default main loop</link>
     * of the thread you are calling this method from. You can then call
     * mm_sms_store_finish() to get the result of the operation.
     * 
     * See mm_sms_store_sync() for the synchronous, blocking version of this method.
     * @param storage A #MMSmsStorage specifying where to store the SMS, or  %MM_SMS_STORAGE_UNKNOWN to use the default.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied or  %NULL.
     */
    store(storage: SmsStorage, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an operation started with mm_sms_store().
     * @param res The #GAsyncResult obtained from the #GAsyncReadyCallback passed to  mm_sms_store().
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    storeFinish(res: Gio.AsyncResult): boolean
    /**
     * Synchronoulsy requests to store the message in the device if not already
     * done.
     * 
     * SMS objects can only be stored once.
     * 
     * The calling thread is blocked until a reply is received. See mm_sms_store()
     * for the asynchronous version of this method.
     * @param storage A #MMSmsStorage specifying where to store the SMS, or  %MM_SMS_STORAGE_UNKNOWN to use the default.
     * @param cancellable A #GCancellable or %NULL.
     * @returns %TRUE if the operation succeeded, %FALSE if @error is set.
     */
    storeSync(storage: SmsStorage, cancellable: Gio.Cancellable | null): boolean

    // Class property signals of ModemManager-1.0.ModemManager.Sms

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-bus-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-bus-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-bus-type", ...args: any[]): void
    connect(sigName: "notify::g-connection", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-connection", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-connection", ...args: any[]): void
    connect(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-default-timeout", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-default-timeout", ...args: any[]): void
    connect(sigName: "notify::g-flags", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-flags", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-flags", ...args: any[]): void
    connect(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-info", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-info", ...args: any[]): void
    connect(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-interface-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-interface-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-interface-name", ...args: any[]): void
    connect(sigName: "notify::g-name", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name", ...args: any[]): void
    connect(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-name-owner", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-name-owner", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-name-owner", ...args: any[]): void
    connect(sigName: "notify::g-object-path", callback: (...args: any[]) => void): number
    on(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::g-object-path", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::g-object-path", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::g-object-path", ...args: any[]): void
    connect(sigName: "notify::class", callback: (...args: any[]) => void): number
    on(sigName: "notify::class", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::class", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::class", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::class", ...args: any[]): void
    connect(sigName: "notify::data", callback: (...args: any[]) => void): number
    on(sigName: "notify::data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::data", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::data", ...args: any[]): void
    connect(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void): number
    on(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::delivery-report-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::delivery-report-request", ...args: any[]): void
    connect(sigName: "notify::delivery-state", callback: (...args: any[]) => void): number
    on(sigName: "notify::delivery-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::delivery-state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::delivery-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::delivery-state", ...args: any[]): void
    connect(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void): number
    on(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::discharge-timestamp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::discharge-timestamp", ...args: any[]): void
    connect(sigName: "notify::message-reference", callback: (...args: any[]) => void): number
    on(sigName: "notify::message-reference", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::message-reference", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::message-reference", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::message-reference", ...args: any[]): void
    connect(sigName: "notify::number", callback: (...args: any[]) => void): number
    on(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::number", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::number", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::number", ...args: any[]): void
    connect(sigName: "notify::pdu-type", callback: (...args: any[]) => void): number
    on(sigName: "notify::pdu-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::pdu-type", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::pdu-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::pdu-type", ...args: any[]): void
    connect(sigName: "notify::service-category", callback: (...args: any[]) => void): number
    on(sigName: "notify::service-category", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::service-category", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::service-category", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::service-category", ...args: any[]): void
    connect(sigName: "notify::smsc", callback: (...args: any[]) => void): number
    on(sigName: "notify::smsc", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::smsc", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::smsc", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::smsc", ...args: any[]): void
    connect(sigName: "notify::state", callback: (...args: any[]) => void): number
    on(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::state", ...args: any[]): void
    connect(sigName: "notify::storage", callback: (...args: any[]) => void): number
    on(sigName: "notify::storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::storage", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::storage", ...args: any[]): void
    connect(sigName: "notify::teleservice-id", callback: (...args: any[]) => void): number
    on(sigName: "notify::teleservice-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::teleservice-id", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::teleservice-id", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::teleservice-id", ...args: any[]): void
    connect(sigName: "notify::text", callback: (...args: any[]) => void): number
    on(sigName: "notify::text", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::text", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::text", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::text", ...args: any[]): void
    connect(sigName: "notify::timestamp", callback: (...args: any[]) => void): number
    on(sigName: "notify::timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::timestamp", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::timestamp", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::timestamp", ...args: any[]): void
    connect(sigName: "notify::validity", callback: (...args: any[]) => void): number
    on(sigName: "notify::validity", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::validity", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::validity", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::validity", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMSms structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class Sms extends GdbusSmsProxy {

    // Own properties of ModemManager-1.0.ModemManager.Sms

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.Sms

    constructor(config?: Sms.ConstructorProperties) 
    _init(config?: Sms.ConstructorProperties): void

    // Conflicting static methods

    /**
     * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sms.top_of_page">org.freedesktop.ModemManager1.Sms</link>. See g_dbus_proxy_new() for more details.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sms_proxy_new_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sms_proxy_new_sync() for the synchronous, blocking version of this constructor.
     * @param connection A #GDBusConnection.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of new

    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Creates a proxy for accessing `interface_name` on the remote object
     * at `object_path` owned by `name` at `connection` and asynchronously
     * loads D-Bus properties unless the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
     * the #GDBusProxy::g-properties-changed signal to get notified about
     * property changes.
     * 
     * If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
     * match rules for signals. Connect to the #GDBusProxy::g-signal signal
     * to handle signals from the remote object.
     * 
     * If both %G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
     * %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
     * guaranteed to complete immediately without blocking.
     * 
     * If `name` is a well-known name and the
     * %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION
     * flags aren't set and no name owner currently exists, the message bus
     * will be requested to launch a name owner for the name.
     * 
     * This is a failable asynchronous constructor - when the proxy is
     * ready, `callback` will be invoked and you can use
     * g_dbus_proxy_new_finish() to get the result.
     * 
     * See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param connection A #GDBusConnection.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique) or %NULL if `connection` is not a message bus connection.
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static new(connection: Gio.DBusConnection, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like mm_gdbus_sms_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * When the operation is finished, `callback` will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
     * You can then call mm_gdbus_sms_proxy_new_for_bus_finish() to get the result of the operation.
     * 
     * See mm_gdbus_sms_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
     * @param busType A #GBusType.
     * @param flags Flags from the #GDBusProxyFlags enumeration.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback A #GAsyncReadyCallback to call when the request is satisfied.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, name: string | null, objectPath: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void

    // Overloads of newForBus

    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    /**
     * Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
     * 
     * #GDBusProxy is used in this [example][gdbus-wellknown-proxy].
     * @param busType A #GBusType.
     * @param flags Flags used when constructing the proxy.
     * @param info A #GDBusInterfaceInfo specifying the minimal interface that `proxy` conforms to or %NULL.
     * @param name A bus name (well-known or unique).
     * @param objectPath An object path.
     * @param interfaceName A D-Bus interface name.
     * @param cancellable A #GCancellable or %NULL.
     * @param callback Callback function to invoke when the proxy is ready.
     */
    static newForBus(busType: Gio.BusType, flags: Gio.DBusProxyFlags, info: Gio.DBusInterfaceInfo | null, name: string | null, objectPath: string | null, interfaceName: string | null, cancellable: Gio.Cancellable | null, callback: Gio.AsyncReadyCallback | null): void
    static newFinish(...args: any[]): any
    static newForBusFinish(...args: any[]): any
    static newForBusSync(...args: any[]): any
    static newSync(...args: any[]): any
}

export module SmsProperties {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface SmsProperties {

    // Own properties of ModemManager-1.0.ModemManager.SmsProperties

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.SmsProperties

    /**
     * Gets the 3GPP message class of the SMS.
     * @returns the message class, or -1 for invalid/unset class.
     */
    getClass(): number
    /**
     * Gets the message data.
     * @returns The message data, or %NULL if it doesn't contain any (e.g. contains text instead).
     */
    getData(): [ /* returnType */ number, /* dataLen */ number ]

    // Overloads of getData

    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     * @param key name of the key for that association
     * @returns the data if found,          or %NULL if no such data exists.
     */
    getData(key: string | null): any | null
    /**
     * Gets the message data.
     * @returns A #GByteArray with the message data, or %NULL if it doesn't contain any (e.g. contains text instead). The returned value should be freed with g_byte_array_unref().
     */
    getDataBytearray(): number[]
    /**
     * Checks whether delivery report is requested for the SMS.
     * @returns %TRUE if delivery report is requested, %FALSE otherwise.
     */
    getDeliveryReportRequest(): boolean
    /**
     * Gets the number to which the message is addressed.
     * @returns The number, or %NULL if it couldn't be retrieved. Do not free the returned value, it is owned by @self.
     */
    getNumber(): string | null
    /**
     * Gets the CDMA message service category of the SMS.
     * @returns the CDMA service category.
     */
    getServiceCategory(): SmsCdmaServiceCategory
    /**
     * Gets the SMS service center number.
     * @returns The number of the SMSC, or %NULL if it couldn't be retrieved. Do not free the returned value, it is owned by @self.
     */
    getSmsc(): string | null
    /**
     * Gets the CDMA teleservice ID of the SMS.
     * @returns the CDMA teleservice ID.
     */
    getTeleserviceId(): SmsCdmaTeleserviceId
    /**
     * Gets the message text, in UTF-8.
     * @returns The message text, or %NULL if it doesn't contain any (e.g. contains data instead). Do not free the returned value, it is owned by @self.
     */
    getText(): string | null
    /**
     * Gets the relative validity time of the SMS.
     * @returns the validity time or 0 if unknown.
     */
    getValidityRelative(): number
    /**
     * Gets the relative validity type the SMS.
     * @returns a #MMSmsValidityType.
     */
    getValidityType(): SmsValidityType
    /**
     * Gets the message data.
     * @returns A #GByteArray with the message data, or %NULL if it doesn't contain any (e.g. contains text instead). Do not free the returned value, it is owned by @self.
     */
    peekDataBytearray(): number[]
    /**
     * Sets the 3GPP message class of the SMS.
     * @param messageClass The message class (0..3), or -1 for invalid/unset class.
     */
    setClass(messageClass: number): void
    /**
     * Sets the message data.
     * @param data The data to set.
     * @param dataLength Length of `data`.
     */
    setData(data: number, dataLength: number): void

    // Overloads of setData

    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized)  so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     * @param key name of the key
     * @param data data to associate with that key
     */
    setData(key: string | null, data: any | null): void
    /**
     * Sets the message data.
     * @param data A #GByteArray with the data to set. This method takes a new reference  of `data`.
     */
    setDataBytearray(data: number[]): void
    /**
     * Sets whether delivery report is requested for the SMS.
     * @param request %TRUE if delivery report is requested, %FALSE otherwise.
     */
    setDeliveryReportRequest(request: boolean): void
    /**
     * Sets the number to which the message is addressed.
     * @param number The number.
     */
    setNumber(number: string | null): void
    /**
     * Sets the CDMA service category of the SMS.
     * @param serviceCategory The CDMA service category.
     */
    setServiceCategory(serviceCategory: SmsCdmaServiceCategory): void
    /**
     * Sets the SMS service center number.
     * @param smsc The SMSC number.
     */
    setSmsc(smsc: string | null): void
    /**
     * Sets the CDMA teleservice ID of the SMS.
     * @param teleserviceId The CDMA teleservice ID.
     */
    setTeleserviceId(teleserviceId: SmsCdmaTeleserviceId): void
    /**
     * Sets the message text.
     * @param text The text to set, in UTF-8.
     */
    setText(text: string | null): void
    /**
     * Sets the relative validity time of the SMS.
     * @param validity The validity of %MM_SMS_VALIDITY_TYPE_RELATIVE type.
     */
    setValidityRelative(validity: number): void

    // Class property signals of ModemManager-1.0.ModemManager.SmsProperties

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMSmsProperties structure contains private data and should only be
 * accessed using the provided API.
 * @class 
 */
export class SmsProperties extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.SmsProperties

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.SmsProperties

    constructor(config?: SmsProperties.ConstructorProperties) 
    /**
     * Creates a new empty #MMSmsProperties.
     * @constructor 
     * @returns a #MMSmsProperties. The returned value should be freed with g_object_unref().
     */
    constructor() 
    /**
     * Creates a new empty #MMSmsProperties.
     * @constructor 
     * @returns a #MMSmsProperties. The returned value should be freed with g_object_unref().
     */
    static new(): SmsProperties
    _init(config?: SmsProperties.ConstructorProperties): void
}

export module UnlockRetries {

    // Constructor properties interface

    export interface ConstructorProperties extends GObject.Object.ConstructorProperties {
    }

}

export interface UnlockRetries {

    // Own properties of ModemManager-1.0.ModemManager.UnlockRetries

    __gtype__: number

    // Owm methods of ModemManager-1.0.ModemManager.UnlockRetries

    /**
     * Executes `callback` for each lock information found in `self`.
     * @param callback callback to call for each available lock.
     */
    foreach(callback: UnlockRetriesForeachCb): void
    /**
     * Gets the unlock retries for the given `lock`.
     * @param lock a #MMModemLock.
     * @returns the unlock retries or %MM_UNLOCK_RETRIES_UNKNOWN if unknown.
     */
    get(lock: ModemLock): number

    // Class property signals of ModemManager-1.0.ModemManager.UnlockRetries

    connect(sigName: "notify::__gtype__", callback: (...args: any[]) => void): number
    on(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify::__gtype__", callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify::__gtype__", callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: "notify::__gtype__", ...args: any[]): void
    connect(sigName: string, callback: (...args: any[]) => void): number
    on(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: string, callback: (...args: any[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: string, callback: (...args: any[]) => void): NodeJS.EventEmitter
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
}

/**
 * The #MMUnlockRetries structure contains private data and should only be accessed
 * using the provided API.
 * @class 
 */
export class UnlockRetries extends GObject.Object {

    // Own properties of ModemManager-1.0.ModemManager.UnlockRetries

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.UnlockRetries

    constructor(config?: UnlockRetries.ConstructorProperties) 
    _init(config?: UnlockRetries.ConstructorProperties): void
}

export interface TODO_3gppProfileClass {
}

export abstract class TODO_3gppProfileClass {

    // Own properties of ModemManager-1.0.ModemManager.3gppProfileClass

    static name: string
}

export interface TODO_3gppProfilePrivate {
}

export class TODO_3gppProfilePrivate {

    // Own properties of ModemManager-1.0.ModemManager.3gppProfilePrivate

    static name: string
}

export interface BearerClass {
}

export abstract class BearerClass {

    // Own properties of ModemManager-1.0.ModemManager.BearerClass

    static name: string
}

export interface BearerIpConfigClass {
}

export abstract class BearerIpConfigClass {

    // Own properties of ModemManager-1.0.ModemManager.BearerIpConfigClass

    static name: string
}

export interface BearerIpConfigPrivate {
}

export class BearerIpConfigPrivate {

    // Own properties of ModemManager-1.0.ModemManager.BearerIpConfigPrivate

    static name: string
}

export interface BearerPrivate {
}

export class BearerPrivate {

    // Own properties of ModemManager-1.0.ModemManager.BearerPrivate

    static name: string
}

export interface BearerPropertiesClass {
}

export abstract class BearerPropertiesClass {

    // Own properties of ModemManager-1.0.ModemManager.BearerPropertiesClass

    static name: string
}

export interface BearerPropertiesPrivate {
}

export class BearerPropertiesPrivate {

    // Own properties of ModemManager-1.0.ModemManager.BearerPropertiesPrivate

    static name: string
}

export interface BearerStatsClass {
}

export abstract class BearerStatsClass {

    // Own properties of ModemManager-1.0.ModemManager.BearerStatsClass

    static name: string
}

export interface BearerStatsPrivate {
}

export class BearerStatsPrivate {

    // Own properties of ModemManager-1.0.ModemManager.BearerStatsPrivate

    static name: string
}

export interface CallAudioFormatClass {
}

export abstract class CallAudioFormatClass {

    // Own properties of ModemManager-1.0.ModemManager.CallAudioFormatClass

    static name: string
}

export interface CallAudioFormatPrivate {
}

export class CallAudioFormatPrivate {

    // Own properties of ModemManager-1.0.ModemManager.CallAudioFormatPrivate

    static name: string
}

export interface CallClass {
}

export abstract class CallClass {

    // Own properties of ModemManager-1.0.ModemManager.CallClass

    static name: string
}

export interface CallPrivate {
}

export class CallPrivate {

    // Own properties of ModemManager-1.0.ModemManager.CallPrivate

    static name: string
}

export interface CallPropertiesClass {
}

export abstract class CallPropertiesClass {

    // Own properties of ModemManager-1.0.ModemManager.CallPropertiesClass

    static name: string
}

export interface CallPropertiesPrivate {
}

export class CallPropertiesPrivate {

    // Own properties of ModemManager-1.0.ModemManager.CallPropertiesPrivate

    static name: string
}

export interface CdmaManualActivationPropertiesClass {
}

export abstract class CdmaManualActivationPropertiesClass {

    // Own properties of ModemManager-1.0.ModemManager.CdmaManualActivationPropertiesClass

    static name: string
}

export interface CdmaManualActivationPropertiesPrivate {
}

export class CdmaManualActivationPropertiesPrivate {

    // Own properties of ModemManager-1.0.ModemManager.CdmaManualActivationPropertiesPrivate

    static name: string
}

export interface CellInfoCdmaClass {
}

export abstract class CellInfoCdmaClass {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoCdmaClass

    static name: string
}

export interface CellInfoCdmaPrivate {
}

export class CellInfoCdmaPrivate {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoCdmaPrivate

    static name: string
}

export interface CellInfoClass {

    // Own fields of ModemManager-1.0.ModemManager.CellInfoClass

    getDictionary: (self: CellInfo) => GLib.VariantDict
    buildString: (self: CellInfo) => GLib.String
}

export abstract class CellInfoClass {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoClass

    static name: string
}

export interface CellInfoGsmClass {
}

export abstract class CellInfoGsmClass {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoGsmClass

    static name: string
}

export interface CellInfoGsmPrivate {
}

export class CellInfoGsmPrivate {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoGsmPrivate

    static name: string
}

export interface CellInfoLteClass {
}

export abstract class CellInfoLteClass {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoLteClass

    static name: string
}

export interface CellInfoLtePrivate {
}

export class CellInfoLtePrivate {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoLtePrivate

    static name: string
}

export interface CellInfoNr5gClass {
}

export abstract class CellInfoNr5gClass {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoNr5gClass

    static name: string
}

export interface CellInfoNr5gPrivate {
}

export class CellInfoNr5gPrivate {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoNr5gPrivate

    static name: string
}

export interface CellInfoPrivate {
}

export class CellInfoPrivate {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoPrivate

    static name: string
}

export interface CellInfoTdscdmaClass {
}

export abstract class CellInfoTdscdmaClass {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoTdscdmaClass

    static name: string
}

export interface CellInfoTdscdmaPrivate {
}

export class CellInfoTdscdmaPrivate {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoTdscdmaPrivate

    static name: string
}

export interface CellInfoUmtsClass {
}

export abstract class CellInfoUmtsClass {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoUmtsClass

    static name: string
}

export interface CellInfoUmtsPrivate {
}

export class CellInfoUmtsPrivate {

    // Own properties of ModemManager-1.0.ModemManager.CellInfoUmtsPrivate

    static name: string
}

export interface FirmwarePropertiesClass {
}

export abstract class FirmwarePropertiesClass {

    // Own properties of ModemManager-1.0.ModemManager.FirmwarePropertiesClass

    static name: string
}

export interface FirmwarePropertiesPrivate {
}

export class FirmwarePropertiesPrivate {

    // Own properties of ModemManager-1.0.ModemManager.FirmwarePropertiesPrivate

    static name: string
}

export interface FirmwareUpdateSettingsClass {
}

export abstract class FirmwareUpdateSettingsClass {

    // Own properties of ModemManager-1.0.ModemManager.FirmwareUpdateSettingsClass

    static name: string
}

export interface FirmwareUpdateSettingsPrivate {
}

export class FirmwareUpdateSettingsPrivate {

    // Own properties of ModemManager-1.0.ModemManager.FirmwareUpdateSettingsPrivate

    static name: string
}

export interface GdbusBearerIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusBearerIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleConnect: (object: GdbusBearer, invocation: Gio.DBusMethodInvocation) => boolean
    handleDisconnect: (object: GdbusBearer, invocation: Gio.DBusMethodInvocation) => boolean
    getBearerType: (object: GdbusBearer) => number
    getConnected: (object: GdbusBearer) => boolean
    getConnectionError: (object: GdbusBearer) => GLib.Variant | null
    getInterface: (object: GdbusBearer) => string | null
    getIp4Config: (object: GdbusBearer) => GLib.Variant | null
    getIp6Config: (object: GdbusBearer) => GLib.Variant | null
    getIpTimeout: (object: GdbusBearer) => number
    getMultiplexed: (object: GdbusBearer) => boolean
    getProfileId: (object: GdbusBearer) => number
    getProperties: (object: GdbusBearer) => GLib.Variant | null
    getReloadStatsSupported: (object: GdbusBearer) => boolean
    getStats: (object: GdbusBearer) => GLib.Variant | null
    getSuspended: (object: GdbusBearer) => boolean
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Bearer.top_of_page">org.freedesktop.ModemManager1.Bearer</link>.
 * @record 
 */
export abstract class GdbusBearerIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusBearerIface

    static name: string
}

export interface GdbusBearerProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusBearerProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusBearerProxy.
 * @record 
 */
export abstract class GdbusBearerProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusBearerProxyClass

    static name: string
}

export interface GdbusBearerProxyPrivate {
}

export class GdbusBearerProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusBearerProxyPrivate

    static name: string
}

export interface GdbusBearerSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusBearerSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusBearerSkeleton.
 * @record 
 */
export abstract class GdbusBearerSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusBearerSkeletonClass

    static name: string
}

export interface GdbusBearerSkeletonPrivate {
}

export class GdbusBearerSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusBearerSkeletonPrivate

    static name: string
}

export interface GdbusCallIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusCallIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleAccept: (object: GdbusCall, invocation: Gio.DBusMethodInvocation) => boolean
    handleDeflect: (object: GdbusCall, invocation: Gio.DBusMethodInvocation, argNumber: string | null) => boolean
    handleHangup: (object: GdbusCall, invocation: Gio.DBusMethodInvocation) => boolean
    handleJoinMultiparty: (object: GdbusCall, invocation: Gio.DBusMethodInvocation) => boolean
    handleLeaveMultiparty: (object: GdbusCall, invocation: Gio.DBusMethodInvocation) => boolean
    handleSendDtmf: (object: GdbusCall, invocation: Gio.DBusMethodInvocation, argDtmf: string | null) => boolean
    handleStart: (object: GdbusCall, invocation: Gio.DBusMethodInvocation) => boolean
    getAudioFormat: (object: GdbusCall) => GLib.Variant | null
    getAudioPort: (object: GdbusCall) => string | null
    getDirection: (object: GdbusCall) => number
    getMultiparty: (object: GdbusCall) => boolean
    getNumber: (object: GdbusCall) => string | null
    getState: (object: GdbusCall) => number
    getStateReason: (object: GdbusCall) => number
    dtmfReceived: (object: GdbusCall, argDtmf: string | null) => void
    stateChanged: (object: GdbusCall, argOld: number, argNew: number, argReason: number) => void
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Call.top_of_page">org.freedesktop.ModemManager1.Call</link>.
 * @record 
 */
export abstract class GdbusCallIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusCallIface

    static name: string
}

export interface GdbusCallProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusCallProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusCallProxy.
 * @record 
 */
export abstract class GdbusCallProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusCallProxyClass

    static name: string
}

export interface GdbusCallProxyPrivate {
}

export class GdbusCallProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusCallProxyPrivate

    static name: string
}

export interface GdbusCallSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusCallSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusCallSkeleton.
 * @record 
 */
export abstract class GdbusCallSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusCallSkeletonClass

    static name: string
}

export interface GdbusCallSkeletonPrivate {
}

export class GdbusCallSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusCallSkeletonPrivate

    static name: string
}

export interface GdbusModem3gppIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModem3gppIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleDisableFacilityLock: (object: GdbusModem3gpp, invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant) => boolean
    handleRegister: (object: GdbusModem3gpp, invocation: Gio.DBusMethodInvocation, argOperatorId: string | null) => boolean
    handleScan: (object: GdbusModem3gpp, invocation: Gio.DBusMethodInvocation) => boolean
    handleSetCarrierLock: (object: GdbusModem3gpp, invocation: Gio.DBusMethodInvocation, argData: GLib.Variant) => boolean
    handleSetEpsUeModeOperation: (object: GdbusModem3gpp, invocation: Gio.DBusMethodInvocation, argMode: number) => boolean
    handleSetInitialEpsBearerSettings: (object: GdbusModem3gpp, invocation: Gio.DBusMethodInvocation, argSettings: GLib.Variant) => boolean
    handleSetNr5gRegistrationSettings: (object: GdbusModem3gpp, invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant) => boolean
    handleSetPacketServiceState: (object: GdbusModem3gpp, invocation: Gio.DBusMethodInvocation, argState: number) => boolean
    getEnabledFacilityLocks: (object: GdbusModem3gpp) => number
    getEpsUeModeOperation: (object: GdbusModem3gpp) => number
    getImei: (object: GdbusModem3gpp) => string | null
    getInitialEpsBearer: (object: GdbusModem3gpp) => string | null
    getInitialEpsBearerSettings: (object: GdbusModem3gpp) => GLib.Variant | null
    getNr5gRegistrationSettings: (object: GdbusModem3gpp) => GLib.Variant | null
    getOperatorCode: (object: GdbusModem3gpp) => string | null
    getOperatorName: (object: GdbusModem3gpp) => string | null
    getPacketServiceState: (object: GdbusModem3gpp) => number
    getPco: (object: GdbusModem3gpp) => GLib.Variant | null
    getRegistrationState: (object: GdbusModem3gpp) => number
    getSubscriptionState: (object: GdbusModem3gpp) => number
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp</link>.
 * @record 
 */
export abstract class GdbusModem3gppIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppIface

    static name: string
}

export interface GdbusModem3gppProfileManagerIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleDelete: (object: GdbusModem3gppProfileManager, invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant) => boolean
    handleList: (object: GdbusModem3gppProfileManager, invocation: Gio.DBusMethodInvocation) => boolean
    handleSet: (object: GdbusModem3gppProfileManager, invocation: Gio.DBusMethodInvocation, argRequestedProperties: GLib.Variant) => boolean
    getIndexField: (object: GdbusModem3gppProfileManager) => string | null
    updated: (object: GdbusModem3gppProfileManager) => void
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-ProfileManager.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.ProfileManager</link>.
 * @record 
 */
export abstract class GdbusModem3gppProfileManagerIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerIface

    static name: string
}

export interface GdbusModem3gppProfileManagerProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModem3gppProfileManagerProxy.
 * @record 
 */
export abstract class GdbusModem3gppProfileManagerProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerProxyClass

    static name: string
}

export interface GdbusModem3gppProfileManagerProxyPrivate {
}

export class GdbusModem3gppProfileManagerProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerProxyPrivate

    static name: string
}

export interface GdbusModem3gppProfileManagerSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModem3gppProfileManagerSkeleton.
 * @record 
 */
export abstract class GdbusModem3gppProfileManagerSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerSkeletonClass

    static name: string
}

export interface GdbusModem3gppProfileManagerSkeletonPrivate {
}

export class GdbusModem3gppProfileManagerSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProfileManagerSkeletonPrivate

    static name: string
}

export interface GdbusModem3gppProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModem3gppProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModem3gppProxy.
 * @record 
 */
export abstract class GdbusModem3gppProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProxyClass

    static name: string
}

export interface GdbusModem3gppProxyPrivate {
}

export class GdbusModem3gppProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppProxyPrivate

    static name: string
}

export interface GdbusModem3gppSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModem3gppSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModem3gppSkeleton.
 * @record 
 */
export abstract class GdbusModem3gppSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppSkeletonClass

    static name: string
}

export interface GdbusModem3gppSkeletonPrivate {
}

export class GdbusModem3gppSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppSkeletonPrivate

    static name: string
}

export interface GdbusModem3gppUssdIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModem3gppUssdIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleCancel: (object: GdbusModem3gppUssd, invocation: Gio.DBusMethodInvocation) => boolean
    handleInitiate: (object: GdbusModem3gppUssd, invocation: Gio.DBusMethodInvocation, argCommand: string | null) => boolean
    handleRespond: (object: GdbusModem3gppUssd, invocation: Gio.DBusMethodInvocation, argResponse: string | null) => boolean
    getNetworkNotification: (object: GdbusModem3gppUssd) => string | null
    getNetworkRequest: (object: GdbusModem3gppUssd) => string | null
    getState: (object: GdbusModem3gppUssd) => number
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Modem3gpp-Ussd.top_of_page">org.freedesktop.ModemManager1.Modem.Modem3gpp.Ussd</link>.
 * @record 
 */
export abstract class GdbusModem3gppUssdIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppUssdIface

    static name: string
}

export interface GdbusModem3gppUssdProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModem3gppUssdProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModem3gppUssdProxy.
 * @record 
 */
export abstract class GdbusModem3gppUssdProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppUssdProxyClass

    static name: string
}

export interface GdbusModem3gppUssdProxyPrivate {
}

export class GdbusModem3gppUssdProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppUssdProxyPrivate

    static name: string
}

export interface GdbusModem3gppUssdSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModem3gppUssdSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModem3gppUssdSkeleton.
 * @record 
 */
export abstract class GdbusModem3gppUssdSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppUssdSkeletonClass

    static name: string
}

export interface GdbusModem3gppUssdSkeletonPrivate {
}

export class GdbusModem3gppUssdSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModem3gppUssdSkeletonPrivate

    static name: string
}

export interface GdbusModemCdmaIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemCdmaIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleActivate: (object: GdbusModemCdma, invocation: Gio.DBusMethodInvocation, argCarrierCode: string | null) => boolean
    handleActivateManual: (object: GdbusModemCdma, invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant) => boolean
    getActivationState: (object: GdbusModemCdma) => number
    getCdma1xRegistrationState: (object: GdbusModemCdma) => number
    getEsn: (object: GdbusModemCdma) => string | null
    getEvdoRegistrationState: (object: GdbusModemCdma) => number
    getMeid: (object: GdbusModemCdma) => string | null
    getNid: (object: GdbusModemCdma) => number
    getSid: (object: GdbusModemCdma) => number
    activationStateChanged: (object: GdbusModemCdma, argActivationState: number, argActivationError: number, argStatusChanges: GLib.Variant) => void
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-ModemCdma.top_of_page">org.freedesktop.ModemManager1.Modem.ModemCdma</link>.
 * @record 
 */
export abstract class GdbusModemCdmaIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemCdmaIface

    static name: string
}

export interface GdbusModemCdmaProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemCdmaProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModemCdmaProxy.
 * @record 
 */
export abstract class GdbusModemCdmaProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemCdmaProxyClass

    static name: string
}

export interface GdbusModemCdmaProxyPrivate {
}

export class GdbusModemCdmaProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemCdmaProxyPrivate

    static name: string
}

export interface GdbusModemCdmaSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemCdmaSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModemCdmaSkeleton.
 * @record 
 */
export abstract class GdbusModemCdmaSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemCdmaSkeletonClass

    static name: string
}

export interface GdbusModemCdmaSkeletonPrivate {
}

export class GdbusModemCdmaSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemCdmaSkeletonPrivate

    static name: string
}

export interface GdbusModemFirmwareIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemFirmwareIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleList: (object: GdbusModemFirmware, invocation: Gio.DBusMethodInvocation) => boolean
    handleSelect: (object: GdbusModemFirmware, invocation: Gio.DBusMethodInvocation, argUniqueid: string | null) => boolean
    getUpdateSettings: (object: GdbusModemFirmware) => GLib.Variant | null
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Firmware.top_of_page">org.freedesktop.ModemManager1.Modem.Firmware</link>.
 * @record 
 */
export abstract class GdbusModemFirmwareIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemFirmwareIface

    static name: string
}

export interface GdbusModemFirmwareProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemFirmwareProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModemFirmwareProxy.
 * @record 
 */
export abstract class GdbusModemFirmwareProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemFirmwareProxyClass

    static name: string
}

export interface GdbusModemFirmwareProxyPrivate {
}

export class GdbusModemFirmwareProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemFirmwareProxyPrivate

    static name: string
}

export interface GdbusModemFirmwareSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemFirmwareSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModemFirmwareSkeleton.
 * @record 
 */
export abstract class GdbusModemFirmwareSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemFirmwareSkeletonClass

    static name: string
}

export interface GdbusModemFirmwareSkeletonPrivate {
}

export class GdbusModemFirmwareSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemFirmwareSkeletonPrivate

    static name: string
}

export interface GdbusModemIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleCommand: (object: GdbusModem, invocation: Gio.DBusMethodInvocation, argCmd: string | null, argTimeout: number) => boolean
    handleCreateBearer: (object: GdbusModem, invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant) => boolean
    handleDeleteBearer: (object: GdbusModem, invocation: Gio.DBusMethodInvocation, argBearer: string | null) => boolean
    handleEnable: (object: GdbusModem, invocation: Gio.DBusMethodInvocation, argEnable: boolean) => boolean
    handleFactoryReset: (object: GdbusModem, invocation: Gio.DBusMethodInvocation, argCode: string | null) => boolean
    handleGetCellInfo: (object: GdbusModem, invocation: Gio.DBusMethodInvocation) => boolean
    handleListBearers: (object: GdbusModem, invocation: Gio.DBusMethodInvocation) => boolean
    handleReset: (object: GdbusModem, invocation: Gio.DBusMethodInvocation) => boolean
    handleSetCurrentBands: (object: GdbusModem, invocation: Gio.DBusMethodInvocation, argBands: GLib.Variant) => boolean
    handleSetCurrentCapabilities: (object: GdbusModem, invocation: Gio.DBusMethodInvocation, argCapabilities: number) => boolean
    handleSetCurrentModes: (object: GdbusModem, invocation: Gio.DBusMethodInvocation, argModes: GLib.Variant) => boolean
    handleSetPowerState: (object: GdbusModem, invocation: Gio.DBusMethodInvocation, argState: number) => boolean
    handleSetPrimarySimSlot: (object: GdbusModem, invocation: Gio.DBusMethodInvocation, argSimSlot: number) => boolean
    getAccessTechnologies: (object: GdbusModem) => number
    getBearers: (object: GdbusModem) => string[] | null
    getCarrierConfiguration: (object: GdbusModem) => string | null
    getCarrierConfigurationRevision: (object: GdbusModem) => string | null
    getCurrentBands: (object: GdbusModem) => GLib.Variant | null
    getCurrentCapabilities: (object: GdbusModem) => number
    getCurrentModes: (object: GdbusModem) => GLib.Variant | null
    getDevice: (object: GdbusModem) => string | null
    getDeviceIdentifier: (object: GdbusModem) => string | null
    getDrivers: (object: GdbusModem) => string[] | null
    getEquipmentIdentifier: (object: GdbusModem) => string | null
    getHardwareRevision: (object: GdbusModem) => string | null
    getManufacturer: (object: GdbusModem) => string | null
    getMaxActiveBearers: (object: GdbusModem) => number
    getMaxActiveMultiplexedBearers: (object: GdbusModem) => number
    getMaxBearers: (object: GdbusModem) => number
    getModel: (object: GdbusModem) => string | null
    getOwnNumbers: (object: GdbusModem) => string[] | null
    getPlugin: (object: GdbusModem) => string | null
    getPorts: (object: GdbusModem) => GLib.Variant | null
    getPowerState: (object: GdbusModem) => number
    getPrimaryPort: (object: GdbusModem) => string | null
    getPrimarySimSlot: (object: GdbusModem) => number
    getRevision: (object: GdbusModem) => string | null
    getSignalQuality: (object: GdbusModem) => GLib.Variant | null
    getSim: (object: GdbusModem) => string | null
    getSimSlots: (object: GdbusModem) => string[] | null
    getState: (object: GdbusModem) => number
    getStateFailedReason: (object: GdbusModem) => number
    getSupportedBands: (object: GdbusModem) => GLib.Variant | null
    getSupportedCapabilities: (object: GdbusModem) => GLib.Variant | null
    getSupportedIpFamilies: (object: GdbusModem) => number
    getSupportedModes: (object: GdbusModem) => GLib.Variant | null
    getUnlockRequired: (object: GdbusModem) => number
    getUnlockRetries: (object: GdbusModem) => GLib.Variant | null
    stateChanged: (object: GdbusModem, argOld: number, argNew: number, argReason: number) => void
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem.top_of_page">org.freedesktop.ModemManager1.Modem</link>.
 * @record 
 */
export abstract class GdbusModemIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemIface

    static name: string
}

export interface GdbusModemLocationIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemLocationIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleGetLocation: (object: GdbusModemLocation, invocation: Gio.DBusMethodInvocation) => boolean
    handleInjectAssistanceData: (object: GdbusModemLocation, invocation: Gio.DBusMethodInvocation, argData: GLib.Variant) => boolean
    handleSetGpsRefreshRate: (object: GdbusModemLocation, invocation: Gio.DBusMethodInvocation, argRate: number) => boolean
    handleSetSuplServer: (object: GdbusModemLocation, invocation: Gio.DBusMethodInvocation, argSupl: string | null) => boolean
    handleSetup: (object: GdbusModemLocation, invocation: Gio.DBusMethodInvocation, argSources: number, argSignalLocation: boolean) => boolean
    getAssistanceDataServers: (object: GdbusModemLocation) => string[] | null
    getCapabilities: (object: GdbusModemLocation) => number
    getEnabled: (object: GdbusModemLocation) => number
    getGpsRefreshRate: (object: GdbusModemLocation) => number
    getLocation: (object: GdbusModemLocation) => GLib.Variant | null
    getSignalsLocation: (object: GdbusModemLocation) => boolean
    getSuplServer: (object: GdbusModemLocation) => string | null
    getSupportedAssistanceData: (object: GdbusModemLocation) => number
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Location.top_of_page">org.freedesktop.ModemManager1.Modem.Location</link>.
 * @record 
 */
export abstract class GdbusModemLocationIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemLocationIface

    static name: string
}

export interface GdbusModemLocationProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemLocationProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModemLocationProxy.
 * @record 
 */
export abstract class GdbusModemLocationProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemLocationProxyClass

    static name: string
}

export interface GdbusModemLocationProxyPrivate {
}

export class GdbusModemLocationProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemLocationProxyPrivate

    static name: string
}

export interface GdbusModemLocationSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemLocationSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModemLocationSkeleton.
 * @record 
 */
export abstract class GdbusModemLocationSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemLocationSkeletonClass

    static name: string
}

export interface GdbusModemLocationSkeletonPrivate {
}

export class GdbusModemLocationSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemLocationSkeletonPrivate

    static name: string
}

export interface GdbusModemMessagingIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemMessagingIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleCreate: (object: GdbusModemMessaging, invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant) => boolean
    handleDelete: (object: GdbusModemMessaging, invocation: Gio.DBusMethodInvocation, argPath: string | null) => boolean
    handleList: (object: GdbusModemMessaging, invocation: Gio.DBusMethodInvocation) => boolean
    getDefaultStorage: (object: GdbusModemMessaging) => number
    getMessages: (object: GdbusModemMessaging) => string[] | null
    getSupportedStorages: (object: GdbusModemMessaging) => GLib.Variant | null
    added: (object: GdbusModemMessaging, argPath: string | null, argReceived: boolean) => void
    deleted: (object: GdbusModemMessaging, argPath: string | null) => void
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Messaging.top_of_page">org.freedesktop.ModemManager1.Modem.Messaging</link>.
 * @record 
 */
export abstract class GdbusModemMessagingIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemMessagingIface

    static name: string
}

export interface GdbusModemMessagingProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemMessagingProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModemMessagingProxy.
 * @record 
 */
export abstract class GdbusModemMessagingProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemMessagingProxyClass

    static name: string
}

export interface GdbusModemMessagingProxyPrivate {
}

export class GdbusModemMessagingProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemMessagingProxyPrivate

    static name: string
}

export interface GdbusModemMessagingSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemMessagingSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModemMessagingSkeleton.
 * @record 
 */
export abstract class GdbusModemMessagingSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemMessagingSkeletonClass

    static name: string
}

export interface GdbusModemMessagingSkeletonPrivate {
}

export class GdbusModemMessagingSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemMessagingSkeletonPrivate

    static name: string
}

export interface GdbusModemOmaIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemOmaIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleAcceptNetworkInitiatedSession: (object: GdbusModemOma, invocation: Gio.DBusMethodInvocation, argSessionId: number, argAccept: boolean) => boolean
    handleCancelSession: (object: GdbusModemOma, invocation: Gio.DBusMethodInvocation) => boolean
    handleSetup: (object: GdbusModemOma, invocation: Gio.DBusMethodInvocation, argFeatures: number) => boolean
    handleStartClientInitiatedSession: (object: GdbusModemOma, invocation: Gio.DBusMethodInvocation, argSessionType: number) => boolean
    getFeatures: (object: GdbusModemOma) => number
    getPendingNetworkInitiatedSessions: (object: GdbusModemOma) => GLib.Variant | null
    getSessionState: (object: GdbusModemOma) => number
    getSessionType: (object: GdbusModemOma) => number
    sessionStateChanged: (object: GdbusModemOma, argOldSessionState: number, argNewSessionState: number, argSessionStateFailedReason: number) => void
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Oma.top_of_page">org.freedesktop.ModemManager1.Modem.Oma</link>.
 * @record 
 */
export abstract class GdbusModemOmaIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemOmaIface

    static name: string
}

export interface GdbusModemOmaProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemOmaProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModemOmaProxy.
 * @record 
 */
export abstract class GdbusModemOmaProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemOmaProxyClass

    static name: string
}

export interface GdbusModemOmaProxyPrivate {
}

export class GdbusModemOmaProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemOmaProxyPrivate

    static name: string
}

export interface GdbusModemOmaSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemOmaSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModemOmaSkeleton.
 * @record 
 */
export abstract class GdbusModemOmaSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemOmaSkeletonClass

    static name: string
}

export interface GdbusModemOmaSkeletonPrivate {
}

export class GdbusModemOmaSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemOmaSkeletonPrivate

    static name: string
}

export interface GdbusModemProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModemProxy.
 * @record 
 */
export abstract class GdbusModemProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemProxyClass

    static name: string
}

export interface GdbusModemProxyPrivate {
}

export class GdbusModemProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemProxyPrivate

    static name: string
}

export interface GdbusModemSarIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemSarIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleEnable: (object: GdbusModemSar, invocation: Gio.DBusMethodInvocation, argEnable: boolean) => boolean
    handleSetPowerLevel: (object: GdbusModemSar, invocation: Gio.DBusMethodInvocation, argLevel: number) => boolean
    getPowerLevel: (object: GdbusModemSar) => number
    getState: (object: GdbusModemSar) => boolean
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Sar.top_of_page">org.freedesktop.ModemManager1.Modem.Sar</link>.
 * @record 
 */
export abstract class GdbusModemSarIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSarIface

    static name: string
}

export interface GdbusModemSarProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemSarProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModemSarProxy.
 * @record 
 */
export abstract class GdbusModemSarProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSarProxyClass

    static name: string
}

export interface GdbusModemSarProxyPrivate {
}

export class GdbusModemSarProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSarProxyPrivate

    static name: string
}

export interface GdbusModemSarSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemSarSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModemSarSkeleton.
 * @record 
 */
export abstract class GdbusModemSarSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSarSkeletonClass

    static name: string
}

export interface GdbusModemSarSkeletonPrivate {
}

export class GdbusModemSarSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSarSkeletonPrivate

    static name: string
}

export interface GdbusModemSignalIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemSignalIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleSetup: (object: GdbusModemSignal, invocation: Gio.DBusMethodInvocation, argRate: number) => boolean
    handleSetupThresholds: (object: GdbusModemSignal, invocation: Gio.DBusMethodInvocation, argSettings: GLib.Variant) => boolean
    getCdma: (object: GdbusModemSignal) => GLib.Variant | null
    getErrorRateThreshold: (object: GdbusModemSignal) => boolean
    getEvdo: (object: GdbusModemSignal) => GLib.Variant | null
    getGsm: (object: GdbusModemSignal) => GLib.Variant | null
    getLte: (object: GdbusModemSignal) => GLib.Variant | null
    getNr5g: (object: GdbusModemSignal) => GLib.Variant | null
    getRate: (object: GdbusModemSignal) => number
    getRssiThreshold: (object: GdbusModemSignal) => number
    getUmts: (object: GdbusModemSignal) => GLib.Variant | null
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Signal.top_of_page">org.freedesktop.ModemManager1.Modem.Signal</link>.
 * @record 
 */
export abstract class GdbusModemSignalIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSignalIface

    static name: string
}

export interface GdbusModemSignalProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemSignalProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModemSignalProxy.
 * @record 
 */
export abstract class GdbusModemSignalProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSignalProxyClass

    static name: string
}

export interface GdbusModemSignalProxyPrivate {
}

export class GdbusModemSignalProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSignalProxyPrivate

    static name: string
}

export interface GdbusModemSignalSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemSignalSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModemSignalSkeleton.
 * @record 
 */
export abstract class GdbusModemSignalSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSignalSkeletonClass

    static name: string
}

export interface GdbusModemSignalSkeletonPrivate {
}

export class GdbusModemSignalSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSignalSkeletonPrivate

    static name: string
}

export interface GdbusModemSimpleIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemSimpleIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleConnect: (object: GdbusModemSimple, invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant) => boolean
    handleDisconnect: (object: GdbusModemSimple, invocation: Gio.DBusMethodInvocation, argBearer: string | null) => boolean
    handleGetStatus: (object: GdbusModemSimple, invocation: Gio.DBusMethodInvocation) => boolean
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Simple.top_of_page">org.freedesktop.ModemManager1.Modem.Simple</link>.
 * @record 
 */
export abstract class GdbusModemSimpleIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSimpleIface

    static name: string
}

export interface GdbusModemSimpleProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemSimpleProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModemSimpleProxy.
 * @record 
 */
export abstract class GdbusModemSimpleProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSimpleProxyClass

    static name: string
}

export interface GdbusModemSimpleProxyPrivate {
}

export class GdbusModemSimpleProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSimpleProxyPrivate

    static name: string
}

export interface GdbusModemSimpleSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemSimpleSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModemSimpleSkeleton.
 * @record 
 */
export abstract class GdbusModemSimpleSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSimpleSkeletonClass

    static name: string
}

export interface GdbusModemSimpleSkeletonPrivate {
}

export class GdbusModemSimpleSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSimpleSkeletonPrivate

    static name: string
}

export interface GdbusModemSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModemSkeleton.
 * @record 
 */
export abstract class GdbusModemSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSkeletonClass

    static name: string
}

export interface GdbusModemSkeletonPrivate {
}

export class GdbusModemSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemSkeletonPrivate

    static name: string
}

export interface GdbusModemTimeIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemTimeIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleGetNetworkTime: (object: GdbusModemTime, invocation: Gio.DBusMethodInvocation) => boolean
    getNetworkTimezone: (object: GdbusModemTime) => GLib.Variant | null
    networkTimeChanged: (object: GdbusModemTime, argTime: string | null) => void
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Time.top_of_page">org.freedesktop.ModemManager1.Modem.Time</link>.
 * @record 
 */
export abstract class GdbusModemTimeIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemTimeIface

    static name: string
}

export interface GdbusModemTimeProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemTimeProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModemTimeProxy.
 * @record 
 */
export abstract class GdbusModemTimeProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemTimeProxyClass

    static name: string
}

export interface GdbusModemTimeProxyPrivate {
}

export class GdbusModemTimeProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemTimeProxyPrivate

    static name: string
}

export interface GdbusModemTimeSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemTimeSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModemTimeSkeleton.
 * @record 
 */
export abstract class GdbusModemTimeSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemTimeSkeletonClass

    static name: string
}

export interface GdbusModemTimeSkeletonPrivate {
}

export class GdbusModemTimeSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemTimeSkeletonPrivate

    static name: string
}

export interface GdbusModemVoiceIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemVoiceIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleCallWaitingQuery: (object: GdbusModemVoice, invocation: Gio.DBusMethodInvocation) => boolean
    handleCallWaitingSetup: (object: GdbusModemVoice, invocation: Gio.DBusMethodInvocation, argEnable: boolean) => boolean
    handleCreateCall: (object: GdbusModemVoice, invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant) => boolean
    handleDeleteCall: (object: GdbusModemVoice, invocation: Gio.DBusMethodInvocation, argPath: string | null) => boolean
    handleHangupAll: (object: GdbusModemVoice, invocation: Gio.DBusMethodInvocation) => boolean
    handleHangupAndAccept: (object: GdbusModemVoice, invocation: Gio.DBusMethodInvocation) => boolean
    handleHoldAndAccept: (object: GdbusModemVoice, invocation: Gio.DBusMethodInvocation) => boolean
    handleListCalls: (object: GdbusModemVoice, invocation: Gio.DBusMethodInvocation) => boolean
    handleTransfer: (object: GdbusModemVoice, invocation: Gio.DBusMethodInvocation) => boolean
    getCalls: (object: GdbusModemVoice) => string[] | null
    getEmergencyOnly: (object: GdbusModemVoice) => boolean
    callAdded: (object: GdbusModemVoice, argPath: string | null) => void
    callDeleted: (object: GdbusModemVoice, argPath: string | null) => void
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Modem-Voice.top_of_page">org.freedesktop.ModemManager1.Modem.Voice</link>.
 * @record 
 */
export abstract class GdbusModemVoiceIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemVoiceIface

    static name: string
}

export interface GdbusModemVoiceProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemVoiceProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusModemVoiceProxy.
 * @record 
 */
export abstract class GdbusModemVoiceProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemVoiceProxyClass

    static name: string
}

export interface GdbusModemVoiceProxyPrivate {
}

export class GdbusModemVoiceProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemVoiceProxyPrivate

    static name: string
}

export interface GdbusModemVoiceSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusModemVoiceSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusModemVoiceSkeleton.
 * @record 
 */
export abstract class GdbusModemVoiceSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemVoiceSkeletonClass

    static name: string
}

export interface GdbusModemVoiceSkeletonPrivate {
}

export class GdbusModemVoiceSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusModemVoiceSkeletonPrivate

    static name: string
}

export interface GdbusObjectIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusObjectIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
}

/**
 * Virtual table for the #MmGdbusObject interface.
 * @record 
 */
export abstract class GdbusObjectIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectIface

    static name: string
}

export interface GdbusObjectManagerClientClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusObjectManagerClientClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusObjectManagerClientClass
}

/**
 * Class structure for #MmGdbusObjectManagerClient.
 * @record 
 */
export abstract class GdbusObjectManagerClientClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectManagerClientClass

    static name: string
}

export interface GdbusObjectManagerClientPrivate {
}

export class GdbusObjectManagerClientPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectManagerClientPrivate

    static name: string
}

export interface GdbusObjectProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusObjectProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusObjectProxyClass
}

/**
 * Class structure for #MmGdbusObjectProxy.
 * @record 
 */
export abstract class GdbusObjectProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectProxyClass

    static name: string
}

export interface GdbusObjectProxyPrivate {
}

export class GdbusObjectProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectProxyPrivate

    static name: string
}

export interface GdbusObjectSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusObjectSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusObjectSkeletonClass
}

/**
 * Class structure for #MmGdbusObjectSkeleton.
 * @record 
 */
export abstract class GdbusObjectSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectSkeletonClass

    static name: string
}

export interface GdbusObjectSkeletonPrivate {
}

export class GdbusObjectSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusObjectSkeletonPrivate

    static name: string
}

export interface GdbusOrgFreedesktopModemManager1Iface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1Iface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleInhibitDevice: (object: GdbusOrgFreedesktopModemManager1, invocation: Gio.DBusMethodInvocation, argUid: string | null, argInhibit: boolean) => boolean
    handleReportKernelEvent: (object: GdbusOrgFreedesktopModemManager1, invocation: Gio.DBusMethodInvocation, argProperties: GLib.Variant) => boolean
    handleScanDevices: (object: GdbusOrgFreedesktopModemManager1, invocation: Gio.DBusMethodInvocation) => boolean
    handleSetLogging: (object: GdbusOrgFreedesktopModemManager1, invocation: Gio.DBusMethodInvocation, argLevel: string | null) => boolean
    getVersion: (object: GdbusOrgFreedesktopModemManager1) => string | null
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1.top_of_page">org.freedesktop.ModemManager1</link>.
 * @record 
 */
export abstract class GdbusOrgFreedesktopModemManager1Iface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1Iface

    static name: string
}

export interface GdbusOrgFreedesktopModemManager1ProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1ProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusOrgFreedesktopModemManager1Proxy.
 * @record 
 */
export abstract class GdbusOrgFreedesktopModemManager1ProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1ProxyClass

    static name: string
}

export interface GdbusOrgFreedesktopModemManager1ProxyPrivate {
}

export class GdbusOrgFreedesktopModemManager1ProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1ProxyPrivate

    static name: string
}

export interface GdbusOrgFreedesktopModemManager1SkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1SkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusOrgFreedesktopModemManager1Skeleton.
 * @record 
 */
export abstract class GdbusOrgFreedesktopModemManager1SkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1SkeletonClass

    static name: string
}

export interface GdbusOrgFreedesktopModemManager1SkeletonPrivate {
}

export class GdbusOrgFreedesktopModemManager1SkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusOrgFreedesktopModemManager1SkeletonPrivate

    static name: string
}

export interface GdbusSimIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusSimIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleChangePin: (object: GdbusSim, invocation: Gio.DBusMethodInvocation, argOldPin: string | null, argNewPin: string | null) => boolean
    handleEnablePin: (object: GdbusSim, invocation: Gio.DBusMethodInvocation, argPin: string | null, argEnabled: boolean) => boolean
    handleSendPin: (object: GdbusSim, invocation: Gio.DBusMethodInvocation, argPin: string | null) => boolean
    handleSendPuk: (object: GdbusSim, invocation: Gio.DBusMethodInvocation, argPuk: string | null, argPin: string | null) => boolean
    handleSetPreferredNetworks: (object: GdbusSim, invocation: Gio.DBusMethodInvocation, argPreferredNetworks: GLib.Variant) => boolean
    getActive: (object: GdbusSim) => boolean
    getEid: (object: GdbusSim) => string | null
    getEmergencyNumbers: (object: GdbusSim) => string[] | null
    getEsimStatus: (object: GdbusSim) => number
    getGid1: (object: GdbusSim) => GLib.Variant | null
    getGid2: (object: GdbusSim) => GLib.Variant | null
    getImsi: (object: GdbusSim) => string | null
    getOperatorIdentifier: (object: GdbusSim) => string | null
    getOperatorName: (object: GdbusSim) => string | null
    getPreferredNetworks: (object: GdbusSim) => GLib.Variant | null
    getRemovability: (object: GdbusSim) => number
    getSimIdentifier: (object: GdbusSim) => string | null
    getSimType: (object: GdbusSim) => number
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sim.top_of_page">org.freedesktop.ModemManager1.Sim</link>.
 * @record 
 */
export abstract class GdbusSimIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSimIface

    static name: string
}

export interface GdbusSimProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusSimProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusSimProxy.
 * @record 
 */
export abstract class GdbusSimProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSimProxyClass

    static name: string
}

export interface GdbusSimProxyPrivate {
}

export class GdbusSimProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSimProxyPrivate

    static name: string
}

export interface GdbusSimSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusSimSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusSimSkeleton.
 * @record 
 */
export abstract class GdbusSimSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSimSkeletonClass

    static name: string
}

export interface GdbusSimSkeletonPrivate {
}

export class GdbusSimSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSimSkeletonPrivate

    static name: string
}

export interface GdbusSmsIface {

    // Own fields of ModemManager-1.0.ModemManager.GdbusSmsIface

    /**
     * The parent interface.
     * @field 
     */
    parentIface: GObject.TypeInterface
    handleSend: (object: GdbusSms, invocation: Gio.DBusMethodInvocation) => boolean
    handleStore: (object: GdbusSms, invocation: Gio.DBusMethodInvocation, argStorage: number) => boolean
    getClass: (object: GdbusSms) => number
    getData: (object: GdbusSms) => GLib.Variant | null
    getDeliveryReportRequest: (object: GdbusSms) => boolean
    getDeliveryState: (object: GdbusSms) => number
    getDischargeTimestamp: (object: GdbusSms) => string | null
    getMessageReference: (object: GdbusSms) => number
    getNumber: (object: GdbusSms) => string | null
    getPduType: (object: GdbusSms) => number
    getServiceCategory: (object: GdbusSms) => number
    getSmsc: (object: GdbusSms) => string | null
    getState: (object: GdbusSms) => number
    getStorage: (object: GdbusSms) => number
    getTeleserviceId: (object: GdbusSms) => number
    getText: (object: GdbusSms) => string | null
    getTimestamp: (object: GdbusSms) => string | null
    getValidity: (object: GdbusSms) => GLib.Variant | null
}

/**
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-ModemManager1-Sms.top_of_page">org.freedesktop.ModemManager1.Sms</link>.
 * @record 
 */
export abstract class GdbusSmsIface {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSmsIface

    static name: string
}

export interface GdbusSmsProxyClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusSmsProxyClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusProxyClass
}

/**
 * Class structure for #MmGdbusSmsProxy.
 * @record 
 */
export abstract class GdbusSmsProxyClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSmsProxyClass

    static name: string
}

export interface GdbusSmsProxyPrivate {
}

export class GdbusSmsProxyPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSmsProxyPrivate

    static name: string
}

export interface GdbusSmsSkeletonClass {

    // Own fields of ModemManager-1.0.ModemManager.GdbusSmsSkeletonClass

    /**
     * The parent class.
     * @field 
     */
    parentClass: Gio.DBusInterfaceSkeletonClass
}

/**
 * Class structure for #MmGdbusSmsSkeleton.
 * @record 
 */
export abstract class GdbusSmsSkeletonClass {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSmsSkeletonClass

    static name: string
}

export interface GdbusSmsSkeletonPrivate {
}

export class GdbusSmsSkeletonPrivate {

    // Own properties of ModemManager-1.0.ModemManager.GdbusSmsSkeletonPrivate

    static name: string
}

export interface KernelEventPropertiesClass {
}

export abstract class KernelEventPropertiesClass {

    // Own properties of ModemManager-1.0.ModemManager.KernelEventPropertiesClass

    static name: string
}

export interface KernelEventPropertiesPrivate {
}

export class KernelEventPropertiesPrivate {

    // Own properties of ModemManager-1.0.ModemManager.KernelEventPropertiesPrivate

    static name: string
}

export interface Location3gppClass {
}

export abstract class Location3gppClass {

    // Own properties of ModemManager-1.0.ModemManager.Location3gppClass

    static name: string
}

export interface Location3gppPrivate {
}

export class Location3gppPrivate {

    // Own properties of ModemManager-1.0.ModemManager.Location3gppPrivate

    static name: string
}

export interface LocationCdmaBsClass {
}

export abstract class LocationCdmaBsClass {

    // Own properties of ModemManager-1.0.ModemManager.LocationCdmaBsClass

    static name: string
}

export interface LocationCdmaBsPrivate {
}

export class LocationCdmaBsPrivate {

    // Own properties of ModemManager-1.0.ModemManager.LocationCdmaBsPrivate

    static name: string
}

export interface LocationGpsNmeaClass {
}

export abstract class LocationGpsNmeaClass {

    // Own properties of ModemManager-1.0.ModemManager.LocationGpsNmeaClass

    static name: string
}

export interface LocationGpsNmeaPrivate {
}

export class LocationGpsNmeaPrivate {

    // Own properties of ModemManager-1.0.ModemManager.LocationGpsNmeaPrivate

    static name: string
}

export interface LocationGpsRawClass {
}

export abstract class LocationGpsRawClass {

    // Own properties of ModemManager-1.0.ModemManager.LocationGpsRawClass

    static name: string
}

export interface LocationGpsRawPrivate {
}

export class LocationGpsRawPrivate {

    // Own properties of ModemManager-1.0.ModemManager.LocationGpsRawPrivate

    static name: string
}

export interface ManagerClass {
}

export abstract class ManagerClass {

    // Own properties of ModemManager-1.0.ModemManager.ManagerClass

    static name: string
}

export interface ManagerPrivate {
}

export class ManagerPrivate {

    // Own properties of ModemManager-1.0.ModemManager.ManagerPrivate

    static name: string
}

export interface Modem3gppClass {
}

export abstract class Modem3gppClass {

    // Own properties of ModemManager-1.0.ModemManager.Modem3gppClass

    static name: string
}

export interface Modem3gppNetwork {

    // Owm methods of ModemManager-1.0.ModemManager.Modem3gppNetwork

    /**
     * Frees a #MMModem3gppNetwork.
     */
    free(): void
    /**
     * Get the technology used to access the 3GPP network.
     * @returns A #MMModemAccessTechnology.
     */
    getAccessTechnology(): ModemAccessTechnology
    /**
     * Get availability of the 3GPP network.
     * @returns A #MMModem3gppNetworkAvailability.
     */
    getAvailability(): Modem3gppNetworkAvailability
    /**
     * Get the operator code (MCCMNC) of the 3GPP network.
     * @returns The operator code, or %NULL if none available.
     */
    getOperatorCode(): string | null
    /**
     * Get the long operator name of the 3GPP network.
     * @returns The long operator name, or %NULL if none available.
     */
    getOperatorLong(): string | null
    /**
     * Get the short operator name of the 3GPP network.
     * @returns The long operator name, or %NULL if none available.
     */
    getOperatorShort(): string | null
}

/**
 * The #MMModem3gppNetwork structure contains private data and should only be accessed
 * using the provided API.
 * @record 
 */
export class Modem3gppNetwork {

    // Own properties of ModemManager-1.0.ModemManager.Modem3gppNetwork

    static name: string
}

export interface Modem3gppPrivate {
}

export class Modem3gppPrivate {

    // Own properties of ModemManager-1.0.ModemManager.Modem3gppPrivate

    static name: string
}

export interface Modem3gppProfileManagerClass {
}

export abstract class Modem3gppProfileManagerClass {

    // Own properties of ModemManager-1.0.ModemManager.Modem3gppProfileManagerClass

    static name: string
}

export interface Modem3gppUssdClass {
}

export abstract class Modem3gppUssdClass {

    // Own properties of ModemManager-1.0.ModemManager.Modem3gppUssdClass

    static name: string
}

export interface ModemCdmaClass {
}

export abstract class ModemCdmaClass {

    // Own properties of ModemManager-1.0.ModemManager.ModemCdmaClass

    static name: string
}

export interface ModemClass {
}

export abstract class ModemClass {

    // Own properties of ModemManager-1.0.ModemManager.ModemClass

    static name: string
}

export interface ModemFirmwareClass {
}

export abstract class ModemFirmwareClass {

    // Own properties of ModemManager-1.0.ModemManager.ModemFirmwareClass

    static name: string
}

export interface ModemFirmwarePrivate {
}

export class ModemFirmwarePrivate {

    // Own properties of ModemManager-1.0.ModemManager.ModemFirmwarePrivate

    static name: string
}

export interface ModemLocationClass {
}

export abstract class ModemLocationClass {

    // Own properties of ModemManager-1.0.ModemManager.ModemLocationClass

    static name: string
}

export interface ModemLocationPrivate {
}

export class ModemLocationPrivate {

    // Own properties of ModemManager-1.0.ModemManager.ModemLocationPrivate

    static name: string
}

export interface ModemMessagingClass {
}

export abstract class ModemMessagingClass {

    // Own properties of ModemManager-1.0.ModemManager.ModemMessagingClass

    static name: string
}

export interface ModemMessagingPrivate {
}

export class ModemMessagingPrivate {

    // Own properties of ModemManager-1.0.ModemManager.ModemMessagingPrivate

    static name: string
}

export interface ModemModeCombination {

    // Own fields of ModemManager-1.0.ModemManager.ModemModeCombination

    /**
     * Mask of #MMModemMode values specifying allowed modes.
     * @field 
     */
    allowed: ModemMode
    /**
     * A single #MMModemMode value specifying the preferred mode.
     * @field 
     */
    preferred: ModemMode
}

/**
 * #MMModemModeCombination is a simple struct holding a pair of #MMModemMode
 * values.
 * @record 
 */
export class ModemModeCombination {

    // Own properties of ModemManager-1.0.ModemManager.ModemModeCombination

    static name: string
}

export interface ModemOmaClass {
}

export abstract class ModemOmaClass {

    // Own properties of ModemManager-1.0.ModemManager.ModemOmaClass

    static name: string
}

export interface ModemOmaPrivate {
}

export class ModemOmaPrivate {

    // Own properties of ModemManager-1.0.ModemManager.ModemOmaPrivate

    static name: string
}

export interface ModemPortInfo {

    // Own fields of ModemManager-1.0.ModemManager.ModemPortInfo

    /**
     * Name of the port.
     * @field 
     */
    name: string | null
    /**
     * A #MMModemPortType value.
     * @field 
     */
    type: ModemPortType

    // Owm methods of ModemManager-1.0.ModemManager.ModemPortInfo

    /**
     * Frees an array of #MMModemPortInfo values.
     * @param arraySize length of `array`.
     */
    arrayFree(arraySize: number): void
}

/**
 * Information of a given port.
 * @record 
 */
export class ModemPortInfo {

    // Own properties of ModemManager-1.0.ModemManager.ModemPortInfo

    static name: string
}

export interface ModemPrivate {
}

export class ModemPrivate {

    // Own properties of ModemManager-1.0.ModemManager.ModemPrivate

    static name: string
}

export interface ModemSarClass {
}

export abstract class ModemSarClass {

    // Own properties of ModemManager-1.0.ModemManager.ModemSarClass

    static name: string
}

export interface ModemSignalClass {
}

export abstract class ModemSignalClass {

    // Own properties of ModemManager-1.0.ModemManager.ModemSignalClass

    static name: string
}

export interface ModemSignalPrivate {
}

export class ModemSignalPrivate {

    // Own properties of ModemManager-1.0.ModemManager.ModemSignalPrivate

    static name: string
}

export interface ModemSimpleClass {
}

export abstract class ModemSimpleClass {

    // Own properties of ModemManager-1.0.ModemManager.ModemSimpleClass

    static name: string
}

export interface ModemTimeClass {
}

export abstract class ModemTimeClass {

    // Own properties of ModemManager-1.0.ModemManager.ModemTimeClass

    static name: string
}

export interface ModemTimePrivate {
}

export class ModemTimePrivate {

    // Own properties of ModemManager-1.0.ModemManager.ModemTimePrivate

    static name: string
}

export interface ModemVoiceClass {
}

export abstract class ModemVoiceClass {

    // Own properties of ModemManager-1.0.ModemManager.ModemVoiceClass

    static name: string
}

export interface ModemVoicePrivate {
}

export class ModemVoicePrivate {

    // Own properties of ModemManager-1.0.ModemManager.ModemVoicePrivate

    static name: string
}

export interface NetworkTimezoneClass {
}

export abstract class NetworkTimezoneClass {

    // Own properties of ModemManager-1.0.ModemManager.NetworkTimezoneClass

    static name: string
}

export interface NetworkTimezonePrivate {
}

export class NetworkTimezonePrivate {

    // Own properties of ModemManager-1.0.ModemManager.NetworkTimezonePrivate

    static name: string
}

export interface Nr5gRegistrationSettingsClass {
}

export abstract class Nr5gRegistrationSettingsClass {

    // Own properties of ModemManager-1.0.ModemManager.Nr5gRegistrationSettingsClass

    static name: string
}

export interface Nr5gRegistrationSettingsPrivate {
}

export class Nr5gRegistrationSettingsPrivate {

    // Own properties of ModemManager-1.0.ModemManager.Nr5gRegistrationSettingsPrivate

    static name: string
}

export interface ObjectClass {
}

export abstract class ObjectClass {

    // Own properties of ModemManager-1.0.ModemManager.ObjectClass

    static name: string
}

export interface OmaPendingNetworkInitiatedSession {

    // Own fields of ModemManager-1.0.ModemManager.OmaPendingNetworkInitiatedSession

    /**
     * A #MMOmaSessionType.
     * @field 
     */
    sessionType: OmaSessionType
    /**
     * Unique ID of the network-initiated OMA session.
     * @field 
     */
    sessionId: number
}

/**
 * #MMOmaPendingNetworkInitiatedSession is a simple struct specifying the
 * information available for a pending network-initiated OMA session.
 * @record 
 */
export class OmaPendingNetworkInitiatedSession {

    // Own properties of ModemManager-1.0.ModemManager.OmaPendingNetworkInitiatedSession

    static name: string
}

export interface PcoClass {
}

export abstract class PcoClass {

    // Own properties of ModemManager-1.0.ModemManager.PcoClass

    static name: string
}

export interface PcoPrivate {
}

export class PcoPrivate {

    // Own properties of ModemManager-1.0.ModemManager.PcoPrivate

    static name: string
}

export interface SignalClass {
}

export abstract class SignalClass {

    // Own properties of ModemManager-1.0.ModemManager.SignalClass

    static name: string
}

export interface SignalPrivate {
}

export class SignalPrivate {

    // Own properties of ModemManager-1.0.ModemManager.SignalPrivate

    static name: string
}

export interface SignalThresholdPropertiesClass {
}

export abstract class SignalThresholdPropertiesClass {

    // Own properties of ModemManager-1.0.ModemManager.SignalThresholdPropertiesClass

    static name: string
}

export interface SignalThresholdPropertiesPrivate {
}

export class SignalThresholdPropertiesPrivate {

    // Own properties of ModemManager-1.0.ModemManager.SignalThresholdPropertiesPrivate

    static name: string
}

export interface SimClass {
}

export abstract class SimClass {

    // Own properties of ModemManager-1.0.ModemManager.SimClass

    static name: string
}

export interface SimPreferredNetwork {

    // Owm methods of ModemManager-1.0.ModemManager.SimPreferredNetwork

    /**
     * Frees a #MMSimPreferredNetwork.
     */
    free(): void
    /**
     * Get the access technology mask of the preferred network.
     * @returns A #MMModemAccessTechnology.
     */
    getAccessTechnology(): ModemAccessTechnology
    /**
     * Get the operator code (MCCMNC) of the preferred network.
     * @returns The operator code, or %NULL if none available.
     */
    getOperatorCode(): string | null
    /**
     * Set the desired access technologies of this preferred network entry.
     * @param accessTechnology A #MMModemAccessTechnology mask.
     */
    setAccessTechnology(accessTechnology: ModemAccessTechnology): void
    /**
     * Set the operator code (MCCMNC) of this preferred network.
     * @param operatorCode Operator code
     */
    setOperatorCode(operatorCode: string | null): void
}

/**
 * The #MMSimPreferredNetwork structure contains private data and should only be accessed
 * using the provided API.
 * @record 
 */
export class SimPreferredNetwork {

    // Own properties of ModemManager-1.0.ModemManager.SimPreferredNetwork

    static name: string

    // Constructors of ModemManager-1.0.ModemManager.SimPreferredNetwork

    /**
     * Creates a new empty #MMSimPreferredNetwork.
     * @constructor 
     * @returns a #MMSimPreferredNetwork. The returned value should be freed with mm_sim_preferred_network_free().
     */
    constructor() 
    /**
     * Creates a new empty #MMSimPreferredNetwork.
     * @constructor 
     * @returns a #MMSimPreferredNetwork. The returned value should be freed with mm_sim_preferred_network_free().
     */
    static new(): SimPreferredNetwork
}

export interface SimpleConnectPropertiesClass {
}

export abstract class SimpleConnectPropertiesClass {

    // Own properties of ModemManager-1.0.ModemManager.SimpleConnectPropertiesClass

    static name: string
}

export interface SimpleConnectPropertiesPrivate {
}

export class SimpleConnectPropertiesPrivate {

    // Own properties of ModemManager-1.0.ModemManager.SimpleConnectPropertiesPrivate

    static name: string
}

export interface SimpleStatusClass {
}

export abstract class SimpleStatusClass {

    // Own properties of ModemManager-1.0.ModemManager.SimpleStatusClass

    static name: string
}

export interface SimpleStatusPrivate {
}

export class SimpleStatusPrivate {

    // Own properties of ModemManager-1.0.ModemManager.SimpleStatusPrivate

    static name: string
}

export interface SmsClass {
}

export abstract class SmsClass {

    // Own properties of ModemManager-1.0.ModemManager.SmsClass

    static name: string
}

export interface SmsPropertiesClass {
}

export abstract class SmsPropertiesClass {

    // Own properties of ModemManager-1.0.ModemManager.SmsPropertiesClass

    static name: string
}

export interface SmsPropertiesPrivate {
}

export class SmsPropertiesPrivate {

    // Own properties of ModemManager-1.0.ModemManager.SmsPropertiesPrivate

    static name: string
}

export interface UnlockRetriesClass {
}

export abstract class UnlockRetriesClass {

    // Own properties of ModemManager-1.0.ModemManager.UnlockRetriesClass

    static name: string
}

export interface UnlockRetriesPrivate {
}

export class UnlockRetriesPrivate {

    // Own properties of ModemManager-1.0.ModemManager.UnlockRetriesPrivate

    static name: string
}

// END