/**
 * Type Definitions for Gjs (https://gjs.guide/)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in `ts-for-gir` or create a bug report on https://github.com/gjsify/ts-for-gir
 *
 * The based EJS template file is used for the generated .d.ts file of each GIR module like Gtk-4.0, GObject-2.0, ...
 */

import '@girs/gjs';

// Module dependencies
import type cairo from 'cairo';
import type GObject from '@girs/gobject-2.0';
import type GLib from '@girs/glib-2.0';
import type Json from '@girs/json-1.0';
import type Gio from '@girs/gio-2.0';
import type GModule from '@girs/gmodule-2.0';
import type GL from '@girs/gl-1.0';
import type CoglPango from '@girs/coglpango-1.0';
import type PangoCairo from '@girs/pangocairo-1.0';
import type Pango from '@girs/pango-1.0';
import type HarfBuzz from '@girs/harfbuzz-0.0';
import type freetype2 from '@girs/freetype2-2.0';
import type Cogl from '@girs/cogl-1.0';
import type Atk from '@girs/atk-1.0';

export namespace Clutter {
    /**
     * Clutter-1.0
     */

    /**
     * Controls how a #ClutterActor should align itself inside the extra space
     * assigned to it during the allocation.
     *
     * Alignment only matters if the allocated space given to an actor is
     * bigger than its natural size; for example, when the #ClutterActor:x-expand
     * or the #ClutterActor:y-expand properties of #ClutterActor are set to %TRUE.
     */

    /**
     * Controls how a #ClutterActor should align itself inside the extra space
     * assigned to it during the allocation.
     *
     * Alignment only matters if the allocated space given to an actor is
     * bigger than its natural size; for example, when the #ClutterActor:x-expand
     * or the #ClutterActor:y-expand properties of #ClutterActor are set to %TRUE.
     */
    export namespace ActorAlign {
        export const $gtype: GObject.GType<ActorAlign>;
    }

    enum ActorAlign {
        /**
         * Stretch to cover the whole allocated space
         */
        FILL,
        /**
         * Snap to left or top side, leaving space
         *   to the right or bottom. For horizontal layouts, in right-to-left
         *   locales this should be reversed.
         */
        START,
        /**
         * Center the actor inside the allocation
         */
        CENTER,
        /**
         * Snap to right or bottom side, leaving space
         *   to the left or top. For horizontal layouts, in right-to-left locales
         *   this should be reversed.
         */
        END,
    }
    /**
     * Specifies the axis on which #ClutterAlignConstraint should maintain
     * the alignment.
     */

    /**
     * Specifies the axis on which #ClutterAlignConstraint should maintain
     * the alignment.
     */
    export namespace AlignAxis {
        export const $gtype: GObject.GType<AlignAxis>;
    }

    enum AlignAxis {
        /**
         * Maintain the alignment on the X axis
         */
        X_AXIS,
        /**
         * Maintain the alignment on the Y axis
         */
        Y_AXIS,
        /**
         * Maintain the alignment on both the X and Y axis
         */
        BOTH,
    }
    /**
     * The animation modes used by #ClutterAlpha and #ClutterAnimation. This
     * enumeration can be expanded in later versions of Clutter.
     *
     * <figure id="easing-modes">
     *   <title>Easing modes provided by Clutter</title>
     *   <graphic fileref="easing-modes.png" format="PNG"/>
     * </figure>
     *
     * Every global alpha function registered using clutter_alpha_register_func()
     * or clutter_alpha_register_closure() will have a logical id greater than
     * %CLUTTER_ANIMATION_LAST.
     */

    /**
     * The animation modes used by #ClutterAlpha and #ClutterAnimation. This
     * enumeration can be expanded in later versions of Clutter.
     *
     * <figure id="easing-modes">
     *   <title>Easing modes provided by Clutter</title>
     *   <graphic fileref="easing-modes.png" format="PNG"/>
     * </figure>
     *
     * Every global alpha function registered using clutter_alpha_register_func()
     * or clutter_alpha_register_closure() will have a logical id greater than
     * %CLUTTER_ANIMATION_LAST.
     */
    export namespace AnimationMode {
        export const $gtype: GObject.GType<AnimationMode>;
    }

    enum AnimationMode {
        /**
         * custom progress function
         */
        CUSTOM_MODE,
        /**
         * linear tweening
         */
        LINEAR,
        /**
         * quadratic tweening
         */
        EASE_IN_QUAD,
        /**
         * quadratic tweening, inverse of
         *    %CLUTTER_EASE_IN_QUAD
         */
        EASE_OUT_QUAD,
        /**
         * quadratic tweening, combininig
         *    %CLUTTER_EASE_IN_QUAD and %CLUTTER_EASE_OUT_QUAD
         */
        EASE_IN_OUT_QUAD,
        /**
         * cubic tweening
         */
        EASE_IN_CUBIC,
        /**
         * cubic tweening, invers of
         *    %CLUTTER_EASE_IN_CUBIC
         */
        EASE_OUT_CUBIC,
        /**
         * cubic tweening, combining
         *    %CLUTTER_EASE_IN_CUBIC and %CLUTTER_EASE_OUT_CUBIC
         */
        EASE_IN_OUT_CUBIC,
        /**
         * quartic tweening
         */
        EASE_IN_QUART,
        /**
         * quartic tweening, inverse of
         *    %CLUTTER_EASE_IN_QUART
         */
        EASE_OUT_QUART,
        /**
         * quartic tweening, combining
         *    %CLUTTER_EASE_IN_QUART and %CLUTTER_EASE_OUT_QUART
         */
        EASE_IN_OUT_QUART,
        /**
         * quintic tweening
         */
        EASE_IN_QUINT,
        /**
         * quintic tweening, inverse of
         *    %CLUTTER_EASE_IN_QUINT
         */
        EASE_OUT_QUINT,
        /**
         * fifth power tweening, combining
         *    %CLUTTER_EASE_IN_QUINT and %CLUTTER_EASE_OUT_QUINT
         */
        EASE_IN_OUT_QUINT,
        /**
         * sinusoidal tweening
         */
        EASE_IN_SINE,
        /**
         * sinusoidal tweening, inverse of
         *    %CLUTTER_EASE_IN_SINE
         */
        EASE_OUT_SINE,
        /**
         * sine wave tweening, combining
         *    %CLUTTER_EASE_IN_SINE and %CLUTTER_EASE_OUT_SINE
         */
        EASE_IN_OUT_SINE,
        /**
         * exponential tweening
         */
        EASE_IN_EXPO,
        /**
         * exponential tweening, inverse of
         *    %CLUTTER_EASE_IN_EXPO
         */
        EASE_OUT_EXPO,
        /**
         * exponential tweening, combining
         *    %CLUTTER_EASE_IN_EXPO and %CLUTTER_EASE_OUT_EXPO
         */
        EASE_IN_OUT_EXPO,
        /**
         * circular tweening
         */
        EASE_IN_CIRC,
        /**
         * circular tweening, inverse of
         *    %CLUTTER_EASE_IN_CIRC
         */
        EASE_OUT_CIRC,
        /**
         * circular tweening, combining
         *    %CLUTTER_EASE_IN_CIRC and %CLUTTER_EASE_OUT_CIRC
         */
        EASE_IN_OUT_CIRC,
        /**
         * elastic tweening, with offshoot on start
         */
        EASE_IN_ELASTIC,
        /**
         * elastic tweening, with offshoot on end
         */
        EASE_OUT_ELASTIC,
        /**
         * elastic tweening with offshoot on both ends
         */
        EASE_IN_OUT_ELASTIC,
        /**
         * overshooting cubic tweening, with
         *   backtracking on start
         */
        EASE_IN_BACK,
        /**
         * overshooting cubic tweening, with
         *   backtracking on end
         */
        EASE_OUT_BACK,
        /**
         * overshooting cubic tweening, with
         *   backtracking on both ends
         */
        EASE_IN_OUT_BACK,
        /**
         * exponentially decaying parabolic (bounce)
         *   tweening, with bounce on start
         */
        EASE_IN_BOUNCE,
        /**
         * exponentially decaying parabolic (bounce)
         *   tweening, with bounce on end
         */
        EASE_OUT_BOUNCE,
        /**
         * exponentially decaying parabolic (bounce)
         *   tweening, with bounce on both ends
         */
        EASE_IN_OUT_BOUNCE,
        /**
         * parametrized step function; see clutter_timeline_set_step_progress()
         *   for further details. (Since 1.12)
         */
        STEPS,
        /**
         * equivalent to %CLUTTER_STEPS with a number of steps
         *   equal to 1, and a step mode of %CLUTTER_STEP_MODE_START. (Since 1.12)
         */
        STEP_START,
        /**
         * equivalent to %CLUTTER_STEPS with a number of steps
         *   equal to 1, and a step mode of %CLUTTER_STEP_MODE_END. (Since 1.12)
         */
        STEP_END,
        /**
         * cubic bezier between (0, 0) and (1, 1) with two
         *   control points; see clutter_timeline_set_cubic_bezier_progress(). (Since 1.12)
         */
        CUBIC_BEZIER,
        /**
         * equivalent to %CLUTTER_CUBIC_BEZIER with control points
         *   in (0.25, 0.1) and (0.25, 1.0). (Since 1.12)
         */
        EASE,
        /**
         * equivalent to %CLUTTER_CUBIC_BEZIER with control points
         *   in (0.42, 0) and (1.0, 1.0). (Since 1.12)
         */
        EASE_IN,
        /**
         * equivalent to %CLUTTER_CUBIC_BEZIER with control points
         *   in (0, 0) and (0.58, 1.0). (Since 1.12)
         */
        EASE_OUT,
        /**
         * equivalent to %CLUTTER_CUBIC_BEZIER with control points
         *   in (0.42, 0) and (0.58, 1.0). (Since 1.12)
         */
        EASE_IN_OUT,
        /**
         * last animation mode, used as a guard for
         *   registered global alpha functions
         */
        ANIMATION_LAST,
    }
    /**
     * The alignment policies available on each axis for #ClutterBinLayout
     */

    /**
     * The alignment policies available on each axis for #ClutterBinLayout
     */
    export namespace BinAlignment {
        export const $gtype: GObject.GType<BinAlignment>;
    }

    enum BinAlignment {
        /**
         * Fixed position alignment; the
         *   #ClutterBinLayout will honour the fixed position provided
         *   by the actors themselves when allocating them
         */
        FIXED,
        /**
         * Fill the allocation size
         */
        FILL,
        /**
         * Position the actors at the top
         *   or left side of the container, depending on the axis
         */
        START,
        /**
         * Position the actors at the bottom
         *   or right side of the container, depending on the axis
         */
        END,
        /**
         * Position the actors at the
         *   center of the container, depending on the axis
         */
        CENTER,
    }
    /**
     * Specifies which property should be used in a binding
     */

    /**
     * Specifies which property should be used in a binding
     */
    export namespace BindCoordinate {
        export const $gtype: GObject.GType<BindCoordinate>;
    }

    enum BindCoordinate {
        /**
         * Bind the X coordinate
         */
        X,
        /**
         * Bind the Y coordinate
         */
        Y,
        /**
         * Bind the width
         */
        WIDTH,
        /**
         * Bind the height
         */
        HEIGHT,
        /**
         * Equivalent to to %CLUTTER_BIND_X and
         *   %CLUTTER_BIND_Y (added in Clutter 1.6)
         */
        POSITION,
        /**
         * Equivalent to %CLUTTER_BIND_WIDTH and
         *   %CLUTTER_BIND_HEIGHT (added in Clutter 1.6)
         */
        SIZE,
        /**
         * Equivalent to %CLUTTER_BIND_POSITION and
         *   %CLUTTER_BIND_SIZE (added in Clutter 1.10)
         */
        ALL,
    }
    /**
     * The alignment policies available on each axis of the #ClutterBoxLayout
     */

    /**
     * The alignment policies available on each axis of the #ClutterBoxLayout
     */
    export namespace BoxAlignment {
        export const $gtype: GObject.GType<BoxAlignment>;
    }

    enum BoxAlignment {
        /**
         * Align the child to the top or to
         *   to the left, depending on the used axis
         */
        START,
        /**
         * Align the child to the bottom or to
         *   the right, depending on the used axis
         */
        END,
        /**
         * Align the child to the center
         */
        CENTER,
    }
    /**
     * Controls the alignment of the #ClutterContent inside a #ClutterActor.
     */

    /**
     * Controls the alignment of the #ClutterContent inside a #ClutterActor.
     */
    export namespace ContentGravity {
        export const $gtype: GObject.GType<ContentGravity>;
    }

    enum ContentGravity {
        /**
         * Align the content to the top left corner
         */
        TOP_LEFT,
        /**
         * Align the content to the top edge
         */
        TOP,
        /**
         * Align the content to the top right corner
         */
        TOP_RIGHT,
        /**
         * Align the content to the left edge
         */
        LEFT,
        /**
         * Align the content to the center
         */
        CENTER,
        /**
         * Align the content to the right edge
         */
        RIGHT,
        /**
         * Align the content to the bottom left corner
         */
        BOTTOM_LEFT,
        /**
         * Align the content to the bottom edge
         */
        BOTTOM,
        /**
         * Align the content to the bottom right corner
         */
        BOTTOM_RIGHT,
        /**
         * Resize the content to fill the allocation
         */
        RESIZE_FILL,
        /**
         * Resize the content to remain within the
         *   allocation, while maintaining the aspect ratio
         */
        RESIZE_ASPECT,
    }
    /**
     * The axis of the constraint that should be applied on the
     * dragging action
     */

    /**
     * The axis of the constraint that should be applied on the
     * dragging action
     */
    export namespace DragAxis {
        export const $gtype: GObject.GType<DragAxis>;
    }

    enum DragAxis {
        /**
         * No constraint
         */
        AXIS_NONE,
        /**
         * Set a constraint on the X axis
         */
        X_AXIS,
        /**
         * Set a constraint on the Y axis
         */
        Y_AXIS,
    }
    /**
     * Types of events.
     */

    /**
     * Types of events.
     */
    export namespace EventType {
        export const $gtype: GObject.GType<EventType>;
    }

    enum EventType {
        /**
         * Empty event
         */
        NOTHING,
        /**
         * Key press event
         */
        KEY_PRESS,
        /**
         * Key release event
         */
        KEY_RELEASE,
        /**
         * Pointer motion event
         */
        MOTION,
        /**
         * Actor enter event
         */
        ENTER,
        /**
         * Actor leave event
         */
        LEAVE,
        /**
         * Pointer button press event
         */
        BUTTON_PRESS,
        /**
         * Pointer button release event
         */
        BUTTON_RELEASE,
        /**
         * Pointer scroll event
         */
        SCROLL,
        /**
         * Stage state change event
         */
        STAGE_STATE,
        /**
         * Destroy notification event
         */
        DESTROY_NOTIFY,
        /**
         * Client message event
         */
        CLIENT_MESSAGE,
        /**
         * Stage delete event
         */
        DELETE,
        /**
         * A new touch event sequence has started;
         *   event added in 1.10
         */
        TOUCH_BEGIN,
        /**
         * A touch event sequence has been updated;
         *   event added in 1.10
         */
        TOUCH_UPDATE,
        /**
         * A touch event sequence has finished;
         *   event added in 1.10
         */
        TOUCH_END,
        /**
         * A touch event sequence has been canceled;
         *   event added in 1.10
         */
        TOUCH_CANCEL,
        /**
         * A pinch gesture event, the current state is
         *   determined by its phase field; event added in 1.24
         */
        TOUCHPAD_PINCH,
        /**
         * A swipe gesture event, the current state is
         *   determined by its phase field; event added in 1.24
         */
        TOUCHPAD_SWIPE,
        /**
         * Marks the end of the #ClutterEventType enumeration;
         *   added in 1.10
         */
        EVENT_LAST,
    }
    /**
     * The direction of the arrangement of the children inside
     * a #ClutterFlowLayout
     */

    /**
     * The direction of the arrangement of the children inside
     * a #ClutterFlowLayout
     */
    export namespace FlowOrientation {
        export const $gtype: GObject.GType<FlowOrientation>;
    }

    enum FlowOrientation {
        /**
         * Arrange the children of the flow layout
         *   horizontally first
         */
        HORIZONTAL,
        /**
         * Arrange the children of the flow layout
         *   vertically first
         */
        VERTICAL,
    }
    /**
     * Enum passed to the clutter_gesture_action_set_threshold_trigger_edge()
     * function.
     */

    /**
     * Enum passed to the clutter_gesture_action_set_threshold_trigger_edge()
     * function.
     */
    export namespace GestureTriggerEdge {
        export const $gtype: GObject.GType<GestureTriggerEdge>;
    }

    enum GestureTriggerEdge {
        /**
         * Tell #ClutterGestureAction that
         * the gesture must begin immediately and there's no drag limit that
         * will cause its cancellation;
         */
        NONE,
        /**
         * Tell #ClutterGestureAction that
         * it needs to wait until the drag threshold has been exceeded before
         * considering that the gesture has begun;
         */
        AFTER,
        /**
         * Tell #ClutterGestureAction that
         * the gesture must begin immediately and that it must be cancelled
         * once the drag exceed the configured threshold.
         */
        BEFORE,
    }
    /**
     * Gravity of the scaling operations. When a gravity different than
     * %CLUTTER_GRAVITY_NONE is used, an actor is scaled keeping the position
     * of the specified portion at the same coordinates.
     */

    /**
     * Gravity of the scaling operations. When a gravity different than
     * %CLUTTER_GRAVITY_NONE is used, an actor is scaled keeping the position
     * of the specified portion at the same coordinates.
     */
    export namespace Gravity {
        export const $gtype: GObject.GType<Gravity>;
    }

    enum Gravity {
        /**
         * Do not apply any gravity
         */
        NONE,
        /**
         * Scale from topmost downwards
         */
        NORTH,
        /**
         * Scale from the top right corner
         */
        NORTH_EAST,
        /**
         * Scale from the right side
         */
        EAST,
        /**
         * Scale from the bottom right corner
         */
        SOUTH_EAST,
        /**
         * Scale from the bottom upwards
         */
        SOUTH,
        /**
         * Scale from the bottom left corner
         */
        SOUTH_WEST,
        /**
         * Scale from the left side
         */
        WEST,
        /**
         * Scale from the top left corner
         */
        NORTH_WEST,
        /**
         * Scale from the center.
         */
        CENTER,
    }
    /**
     * Grid position modes.
     */

    /**
     * Grid position modes.
     */
    export namespace GridPosition {
        export const $gtype: GObject.GType<GridPosition>;
    }

    enum GridPosition {
        /**
         * left position
         */
        LEFT,
        /**
         * right position
         */
        RIGHT,
        /**
         * top position
         */
        TOP,
        /**
         * bottom position
         */
        BOTTOM,
    }
    /**
     * Error enumeration for #ClutterImage.
     */
    class ImageError extends GLib.Error {
        static $gtype: GObject.GType<ImageError>;

        // Static fields

        /**
         * Invalid data passed to the
         *   clutter_image_set_data() function.
         */
        static DATA: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        static quark(): GLib.Quark;
    }

    /**
     * Error conditions returned by clutter_init() and clutter_init_with_args().
     */
    class InitError extends GLib.Error {
        static $gtype: GObject.GType<InitError>;

        // Static fields

        /**
         * Initialisation successful
         */
        static SUCCESS: number;
        /**
         * Unknown error
         */
        static ERROR_UNKNOWN: number;
        /**
         * Thread initialisation failed
         */
        static ERROR_THREADS: number;
        /**
         * Backend initialisation failed
         */
        static ERROR_BACKEND: number;
        /**
         * Internal error
         */
        static ERROR_INTERNAL: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        static quark(): GLib.Quark;
    }

    /**
     * The type of axes Clutter recognizes on a #ClutterInputDevice
     */

    /**
     * The type of axes Clutter recognizes on a #ClutterInputDevice
     */
    export namespace InputAxis {
        export const $gtype: GObject.GType<InputAxis>;
    }

    enum InputAxis {
        /**
         * Unused axis
         */
        IGNORE,
        /**
         * The position on the X axis
         */
        X,
        /**
         * The position of the Y axis
         */
        Y,
        /**
         * The pressure information
         */
        PRESSURE,
        /**
         * The tilt on the X axis
         */
        XTILT,
        /**
         * The tile on the Y axis
         */
        YTILT,
        /**
         * A wheel
         */
        WHEEL,
        /**
         * Distance (Since 1.12)
         */
        DISTANCE,
        /**
         * Last value of the enumeration; this value is
         *   useful when iterating over the enumeration values (Since 1.12)
         */
        LAST,
    }
    /**
     * The types of input devices available.
     *
     * The #ClutterInputDeviceType enumeration can be extended at later
     * date; not every platform supports every input device type.
     */

    /**
     * The types of input devices available.
     *
     * The #ClutterInputDeviceType enumeration can be extended at later
     * date; not every platform supports every input device type.
     */
    export namespace InputDeviceType {
        export const $gtype: GObject.GType<InputDeviceType>;
    }

    enum InputDeviceType {
        /**
         * A pointer device
         */
        POINTER_DEVICE,
        /**
         * A keyboard device
         */
        KEYBOARD_DEVICE,
        /**
         * A generic extension device
         */
        EXTENSION_DEVICE,
        /**
         * A joystick device
         */
        JOYSTICK_DEVICE,
        /**
         * A tablet device
         */
        TABLET_DEVICE,
        /**
         * A touchpad device
         */
        TOUCHPAD_DEVICE,
        /**
         * A touch screen device
         */
        TOUCHSCREEN_DEVICE,
        /**
         * A pen device
         */
        PEN_DEVICE,
        /**
         * An eraser device
         */
        ERASER_DEVICE,
        /**
         * A cursor device
         */
        CURSOR_DEVICE,
        /**
         * The number of device types
         */
        N_DEVICE_TYPES,
    }
    /**
     * The mode for input devices available.
     */

    /**
     * The mode for input devices available.
     */
    export namespace InputMode {
        export const $gtype: GObject.GType<InputMode>;
    }

    enum InputMode {
        /**
         * A master, virtual device
         */
        MASTER,
        /**
         * A slave, physical device, attached to
         *   a master device
         */
        SLAVE,
        /**
         * A slave, physical device, not attached
         *   to a master device
         */
        FLOATING,
    }
    /**
     * The mode of interpolation between key frames
     */

    /**
     * The mode of interpolation between key frames
     */
    export namespace Interpolation {
        export const $gtype: GObject.GType<Interpolation>;
    }

    enum Interpolation {
        /**
         * linear interpolation
         */
        LINEAR,
        /**
         * cubic interpolation
         */
        CUBIC,
    }
    /**
     * The states for the #ClutterClickAction::long-press signal.
     */

    /**
     * The states for the #ClutterClickAction::long-press signal.
     */
    export namespace LongPressState {
        export const $gtype: GObject.GType<LongPressState>;
    }

    enum LongPressState {
        /**
         * Queries the action whether it supports
         *   long presses
         */
        QUERY,
        /**
         * Activates the action on a long press
         */
        ACTIVATE,
        /**
         * The long press was cancelled
         */
        CANCEL,
    }
    /**
     * Represents the orientation of actors or layout managers.
     */

    /**
     * Represents the orientation of actors or layout managers.
     */
    export namespace Orientation {
        export const $gtype: GObject.GType<Orientation>;
    }

    enum Orientation {
        /**
         * An horizontal orientation
         */
        HORIZONTAL,
        /**
         * A vertical orientation
         */
        VERTICAL,
    }
    /**
     * The axis of the constraint that should be applied on the
     * panning action
     */

    /**
     * The axis of the constraint that should be applied on the
     * panning action
     */
    export namespace PanAxis {
        export const $gtype: GObject.GType<PanAxis>;
    }

    enum PanAxis {
        /**
         * No constraint
         */
        AXIS_NONE,
        /**
         * Set a constraint on the X axis
         */
        X_AXIS,
        /**
         * Set a constraint on the Y axis
         */
        Y_AXIS,
        /**
         * Constrain panning automatically based on initial
         *   movement (available since 1.24)
         */
        AXIS_AUTO,
    }
    /**
     * Types of nodes in a #ClutterPath.
     */

    /**
     * Types of nodes in a #ClutterPath.
     */
    export namespace PathNodeType {
        export const $gtype: GObject.GType<PathNodeType>;
    }

    enum PathNodeType {
        /**
         * jump to the given position
         */
        MOVE_TO,
        /**
         * create a line from the last node to the
         *   given position
         */
        LINE_TO,
        /**
         * bezier curve using the last position and
         *   three control points.
         */
        CURVE_TO,
        /**
         * create a line from the last node to the last
         *   %CLUTTER_PATH_MOVE_TO node.
         */
        CLOSE,
        /**
         * same as %CLUTTER_PATH_MOVE_TO but with
         *   coordinates relative to the last node.
         */
        REL_MOVE_TO,
        /**
         * same as %CLUTTER_PATH_LINE_TO but with
         *   coordinates relative to the last node.
         */
        REL_LINE_TO,
        /**
         * same as %CLUTTER_PATH_CURVE_TO but with
         *   coordinates relative to the last node.
         */
        REL_CURVE_TO,
    }
    /**
     * Controls the paint cycle of the scene graph when in pick mode
     */

    /**
     * Controls the paint cycle of the scene graph when in pick mode
     */
    export namespace PickMode {
        export const $gtype: GObject.GType<PickMode>;
    }

    enum PickMode {
        /**
         * Do not paint any actor
         */
        NONE,
        /**
         * Paint only the reactive actors
         */
        REACTIVE,
        /**
         * Paint all actors
         */
        ALL,
    }
    /**
     * Specifies the type of requests for a #ClutterActor.
     */

    /**
     * Specifies the type of requests for a #ClutterActor.
     */
    export namespace RequestMode {
        export const $gtype: GObject.GType<RequestMode>;
    }

    enum RequestMode {
        /**
         * Height for width requests
         */
        HEIGHT_FOR_WIDTH,
        /**
         * Width for height requests
         */
        WIDTH_FOR_HEIGHT,
        /**
         * Use the preferred size of the
         *   #ClutterContent, if it has any (available since 1.22)
         */
        CONTENT_SIZE,
    }
    /**
     * Axis of a rotation.
     */

    /**
     * Axis of a rotation.
     */
    export namespace RotateAxis {
        export const $gtype: GObject.GType<RotateAxis>;
    }

    enum RotateAxis {
        /**
         * Rotate around the X axis
         */
        X_AXIS,
        /**
         * Rotate around the Y axis
         */
        Y_AXIS,
        /**
         * Rotate around the Z axis
         */
        Z_AXIS,
    }
    /**
     * Direction of a rotation.
     */

    /**
     * Direction of a rotation.
     */
    export namespace RotateDirection {
        export const $gtype: GObject.GType<RotateDirection>;
    }

    enum RotateDirection {
        /**
         * Clockwise rotation
         */
        CW,
        /**
         * Counter-clockwise rotation
         */
        CCW,
    }
    /**
     * The scaling filters to be used with the #ClutterActor:minification-filter
     * and #ClutterActor:magnification-filter properties.
     */

    /**
     * The scaling filters to be used with the #ClutterActor:minification-filter
     * and #ClutterActor:magnification-filter properties.
     */
    export namespace ScalingFilter {
        export const $gtype: GObject.GType<ScalingFilter>;
    }

    enum ScalingFilter {
        /**
         * Linear interpolation filter
         */
        LINEAR,
        /**
         * Nearest neighbor interpolation filter
         */
        NEAREST,
        /**
         * Trilinear minification filter, with
         *   mipmap generation; this filter linearly interpolates on every axis,
         *   as well as between mipmap levels.
         */
        TRILINEAR,
    }
    /**
     * #ClutterScript error enumeration.
     */
    class ScriptError extends GLib.Error {
        static $gtype: GObject.GType<ScriptError>;

        // Static fields

        /**
         * Type function not found
         *   or invalid
         */
        static TYPE_FUNCTION: number;
        /**
         * Property not found or invalid
         */
        static PROPERTY: number;
        /**
         * Invalid value
         */
        static VALUE: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        static quark(): GLib.Quark;
    }

    /**
     * Direction of a pointer scroll event.
     *
     * The %CLUTTER_SCROLL_SMOOTH value implies that the #ClutterScrollEvent
     * has precise scrolling delta information.
     */

    /**
     * Direction of a pointer scroll event.
     *
     * The %CLUTTER_SCROLL_SMOOTH value implies that the #ClutterScrollEvent
     * has precise scrolling delta information.
     */
    export namespace ScrollDirection {
        export const $gtype: GObject.GType<ScrollDirection>;
    }

    enum ScrollDirection {
        /**
         * Scroll up
         */
        UP,
        /**
         * Scroll down
         */
        DOWN,
        /**
         * Scroll left
         */
        LEFT,
        /**
         * Scroll right
         */
        RIGHT,
        /**
         * Precise scrolling delta (available in 1.10)
         */
        SMOOTH,
    }
    /**
     * The scroll source determines the source of the scroll event. Keep in mind
     * that the source device #ClutterInputDeviceType is not enough to infer
     * the scroll source.
     */

    /**
     * The scroll source determines the source of the scroll event. Keep in mind
     * that the source device #ClutterInputDeviceType is not enough to infer
     * the scroll source.
     */
    export namespace ScrollSource {
        export const $gtype: GObject.GType<ScrollSource>;
    }

    enum ScrollSource {
        /**
         * Source of scroll events is unknown.
         */
        UNKNOWN,
        /**
         * The scroll event is originated by a mouse wheel.
         */
        WHEEL,
        /**
         * The scroll event is originated by one or more
         *   fingers on the device (eg. touchpads).
         */
        FINGER,
        /**
         * The scroll event is originated by the
         *   motion of some device (eg. a scroll button is set).
         */
        CONTINUOUS,
    }
    /**
     * #ClutterShader error enumeration
     */
    class ShaderError extends GLib.Error {
        static $gtype: GObject.GType<ShaderError>;

        // Static fields

        /**
         * No ASM shaders support
         */
        static NO_ASM: number;
        /**
         * No GLSL shaders support
         */
        static NO_GLSL: number;
        /**
         * Compilation error
         */
        static COMPILE: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        static quark(): GLib.Quark;
    }

    /**
     * The type of GLSL shader program
     */

    /**
     * The type of GLSL shader program
     */
    export namespace ShaderType {
        export const $gtype: GObject.GType<ShaderType>;
    }

    enum ShaderType {
        /**
         * a vertex shader
         */
        VERTEX_SHADER,
        /**
         * a fragment shader
         */
        FRAGMENT_SHADER,
    }
    /**
     * The edge to snap
     */

    /**
     * The edge to snap
     */
    export namespace SnapEdge {
        export const $gtype: GObject.GType<SnapEdge>;
    }

    enum SnapEdge {
        /**
         * the top edge
         */
        TOP,
        /**
         * the right edge
         */
        RIGHT,
        /**
         * the bottom edge
         */
        BOTTOM,
        /**
         * the left edge
         */
        LEFT,
    }
    /**
     * Named colors, for accessing global colors defined by Clutter
     */

    /**
     * Named colors, for accessing global colors defined by Clutter
     */
    export namespace StaticColor {
        export const $gtype: GObject.GType<StaticColor>;
    }

    enum StaticColor {
        /**
         * White color (ffffffff)
         */
        WHITE,
        /**
         * Black color (000000ff)
         */
        BLACK,
        /**
         * Red color (ff0000ff)
         */
        RED,
        /**
         * Dark red color (800000ff)
         */
        DARK_RED,
        /**
         * Green color (00ff00ff)
         */
        GREEN,
        /**
         * Dark green color (008000ff)
         */
        DARK_GREEN,
        /**
         * Blue color (0000ffff)
         */
        BLUE,
        /**
         * Dark blue color (000080ff)
         */
        DARK_BLUE,
        /**
         * Cyan color (00ffffff)
         */
        CYAN,
        /**
         * Dark cyan color (008080ff)
         */
        DARK_CYAN,
        /**
         * Magenta color (ff00ffff)
         */
        MAGENTA,
        /**
         * Dark magenta color (800080ff)
         */
        DARK_MAGENTA,
        /**
         * Yellow color (ffff00ff)
         */
        YELLOW,
        /**
         * Dark yellow color (808000ff)
         */
        DARK_YELLOW,
        /**
         * Gray color (a0a0a4ff)
         */
        GRAY,
        /**
         * Dark Gray color (808080ff)
         */
        DARK_GRAY,
        /**
         * Light gray color (c0c0c0ff)
         */
        LIGHT_GRAY,
        /**
         * Butter color (edd400ff)
         */
        BUTTER,
        /**
         * Light butter color (fce94fff)
         */
        BUTTER_LIGHT,
        /**
         * Dark butter color (c4a000ff)
         */
        BUTTER_DARK,
        /**
         * Orange color (f57900ff)
         */
        ORANGE,
        /**
         * Light orange color (fcaf3fff)
         */
        ORANGE_LIGHT,
        /**
         * Dark orange color (ce5c00ff)
         */
        ORANGE_DARK,
        /**
         * Chocolate color (c17d11ff)
         */
        CHOCOLATE,
        /**
         * Light chocolate color (e9b96eff)
         */
        CHOCOLATE_LIGHT,
        /**
         * Dark chocolate color (8f5902ff)
         */
        CHOCOLATE_DARK,
        /**
         * Chameleon color (73d216ff)
         */
        CHAMELEON,
        /**
         * Light chameleon color (8ae234ff)
         */
        CHAMELEON_LIGHT,
        /**
         * Dark chameleon color (4e9a06ff)
         */
        CHAMELEON_DARK,
        /**
         * Sky color (3465a4ff)
         */
        SKY_BLUE,
        /**
         * Light sky color (729fcfff)
         */
        SKY_BLUE_LIGHT,
        /**
         * Dark sky color (204a87ff)
         */
        SKY_BLUE_DARK,
        /**
         * Plum color (75507bff)
         */
        PLUM,
        /**
         * Light plum color (ad7fa8ff)
         */
        PLUM_LIGHT,
        /**
         * Dark plum color (5c3566ff)
         */
        PLUM_DARK,
        /**
         * Scarlet red color (cc0000ff)
         */
        SCARLET_RED,
        /**
         * Light scarlet red color (ef2929ff)
         */
        SCARLET_RED_LIGHT,
        /**
         * Dark scarlet red color (a40000ff)
         */
        SCARLET_RED_DARK,
        /**
         * Aluminium, first variant (eeeeecff)
         */
        ALUMINIUM_1,
        /**
         * Aluminium, second variant (d3d7cfff)
         */
        ALUMINIUM_2,
        /**
         * Aluminium, third variant (babdb6ff)
         */
        ALUMINIUM_3,
        /**
         * Aluminium, fourth variant (888a85ff)
         */
        ALUMINIUM_4,
        /**
         * Aluminium, fifth variant (555753ff)
         */
        ALUMINIUM_5,
        /**
         * Aluminium, sixth variant (2e3436ff)
         */
        ALUMINIUM_6,
        /**
         * Transparent color (00000000)
         */
        TRANSPARENT,
    }
    /**
     * Change the value transition of a step function.
     *
     * See clutter_timeline_set_step_progress().
     */

    /**
     * Change the value transition of a step function.
     *
     * See clutter_timeline_set_step_progress().
     */
    export namespace StepMode {
        export const $gtype: GObject.GType<StepMode>;
    }

    enum StepMode {
        /**
         * The change in the value of a
         *   %CLUTTER_STEP progress mode should occur at the start of
         *   the transition
         */
        START,
        /**
         * The change in the value of a
         *   %CLUTTER_STEP progress mode should occur at the end of
         *   the transition
         */
        END,
    }
    /**
     * The alignment policies available on each axis of the #ClutterTableLayout
     */

    /**
     * The alignment policies available on each axis of the #ClutterTableLayout
     */
    export namespace TableAlignment {
        export const $gtype: GObject.GType<TableAlignment>;
    }

    enum TableAlignment {
        /**
         * Align the child to the top or to the
         *   left of a cell in the table, depending on the axis
         */
        START,
        /**
         * Align the child to the center of
         *   a cell in the table
         */
        CENTER,
        /**
         * Align the child to the bottom or to the
         *   right of a cell in the table, depending on the axis
         */
        END,
    }
    /**
     * The text direction to be used by #ClutterActor<!-- -->s
     */

    /**
     * The text direction to be used by #ClutterActor<!-- -->s
     */
    export namespace TextDirection {
        export const $gtype: GObject.GType<TextDirection>;
    }

    enum TextDirection {
        /**
         * Use the default setting, as returned
         *   by clutter_get_default_text_direction()
         */
        DEFAULT,
        /**
         * Use left-to-right text direction
         */
        LTR,
        /**
         * Use right-to-left text direction
         */
        RTL,
    }
    /**
     * Error enumeration for #ClutterTexture
     */
    class TextureError extends GLib.Error {
        static $gtype: GObject.GType<TextureError>;

        // Static fields

        /**
         * OOM condition
         */
        static OUT_OF_MEMORY: number;
        /**
         * YUV operation attempted but no YUV support
         *   found
         */
        static NO_YUV: number;
        /**
         * The requested format for
         * clutter_texture_set_from_rgb_data or
         * clutter_texture_set_from_yuv_data is unsupported.
         */
        static BAD_FORMAT: number;

        // Constructors

        constructor(options: { message: string; code: number });
        _init(...args: any[]): void;

        // Static methods

        static quark(): GLib.Quark;
    }

    /**
     * Enumaration controlling the texture quality.
     */

    /**
     * Enumaration controlling the texture quality.
     */
    export namespace TextureQuality {
        export const $gtype: GObject.GType<TextureQuality>;
    }

    enum TextureQuality {
        /**
         * fastest rendering will use nearest neighbour
         *   interpolation when rendering. good setting.
         */
        LOW,
        /**
         * higher quality rendering without using
         *   extra resources.
         */
        MEDIUM,
        /**
         * render the texture with the best quality
         *   available using extra memory.
         */
        HIGH,
    }
    /**
     * The direction of a #ClutterTimeline
     */

    /**
     * The direction of a #ClutterTimeline
     */
    export namespace TimelineDirection {
        export const $gtype: GObject.GType<TimelineDirection>;
    }

    enum TimelineDirection {
        /**
         * forward direction for a timeline
         */
        FORWARD,
        /**
         * backward direction for a timeline
         */
        BACKWARD,
    }
    /**
     * The phase of a touchpad gesture event. All gestures are guaranteed to
     * begin with an event of type %CLUTTER_TOUCHPAD_GESTURE_PHASE_BEGIN,
     * followed by a number of %CLUTTER_TOUCHPAD_GESTURE_PHASE_UPDATE (possibly 0).
     *
     * A finished gesture may have 2 possible outcomes, an event with phase
     * %CLUTTER_TOUCHPAD_GESTURE_PHASE_END will be emitted when the gesture is
     * considered successful, this should be used as the hint to perform any
     * permanent changes.
     *
     * Cancelled gestures may be so for a variety of reasons, due to hardware,
     * or due to the gesture recognition layers hinting the gesture did not
     * finish resolutely (eg. a 3rd finger being added during a pinch gesture).
     * In these cases, the last event with report the phase
     * %CLUTTER_TOUCHPAD_GESTURE_PHASE_CANCEL, this should be used as a hint
     * to undo any visible/permanent changes that were done throughout the
     * progress of the gesture.
     *
     * See also #ClutterTouchpadPinchEvent and #ClutterTouchpadPinchEvent.
     */

    /**
     * The phase of a touchpad gesture event. All gestures are guaranteed to
     * begin with an event of type %CLUTTER_TOUCHPAD_GESTURE_PHASE_BEGIN,
     * followed by a number of %CLUTTER_TOUCHPAD_GESTURE_PHASE_UPDATE (possibly 0).
     *
     * A finished gesture may have 2 possible outcomes, an event with phase
     * %CLUTTER_TOUCHPAD_GESTURE_PHASE_END will be emitted when the gesture is
     * considered successful, this should be used as the hint to perform any
     * permanent changes.
     *
     * Cancelled gestures may be so for a variety of reasons, due to hardware,
     * or due to the gesture recognition layers hinting the gesture did not
     * finish resolutely (eg. a 3rd finger being added during a pinch gesture).
     * In these cases, the last event with report the phase
     * %CLUTTER_TOUCHPAD_GESTURE_PHASE_CANCEL, this should be used as a hint
     * to undo any visible/permanent changes that were done throughout the
     * progress of the gesture.
     *
     * See also #ClutterTouchpadPinchEvent and #ClutterTouchpadPinchEvent.
     */
    export namespace TouchpadGesturePhase {
        export const $gtype: GObject.GType<TouchpadGesturePhase>;
    }

    enum TouchpadGesturePhase {
        /**
         * The gesture has begun.
         */
        BEGIN,
        /**
         * The gesture has been updated.
         */
        UPDATE,
        /**
         * The gesture was finished, changes
         *   should be permanently applied.
         */
        END,
        /**
         * The gesture was cancelled, all
         *   changes should be undone.
         */
        CANCEL,
    }
    /**
     * The type of unit in which a value is expressed
     *
     * This enumeration might be expanded at later date
     */

    /**
     * The type of unit in which a value is expressed
     *
     * This enumeration might be expanded at later date
     */
    export namespace UnitType {
        export const $gtype: GObject.GType<UnitType>;
    }

    enum UnitType {
        /**
         * Unit expressed in pixels (with subpixel precision)
         */
        PIXEL,
        /**
         * Unit expressed in em
         */
        EM,
        /**
         * Unit expressed in millimeters
         */
        MM,
        /**
         * Unit expressed in points
         */
        POINT,
        /**
         * Unit expressed in centimeters
         */
        CM,
    }
    /**
     * The axis of the constraint that should be applied by the
     * zooming action.
     */

    /**
     * The axis of the constraint that should be applied by the
     * zooming action.
     */
    export namespace ZoomAxis {
        export const $gtype: GObject.GType<ZoomAxis>;
    }

    enum ZoomAxis {
        /**
         * Scale only on the X axis
         */
        X_AXIS,
        /**
         * Scale only on the Y axis
         */
        Y_AXIS,
        /**
         * Scale on both axis
         */
        BOTH,
    }
    const __0: number;
    const __1: number;
    const __2: number;
    const __3: number;
    const __3270_AltCursor: number;
    const __3270_Attn: number;
    const __3270_BackTab: number;
    const __3270_ChangeScreen: number;
    const __3270_Copy: number;
    const __3270_CursorBlink: number;
    const __3270_CursorSelect: number;
    const __3270_DeleteWord: number;
    const __3270_Duplicate: number;
    const __3270_Enter: number;
    const __3270_EraseEOF: number;
    const __3270_EraseInput: number;
    const __3270_ExSelect: number;
    const __3270_FieldMark: number;
    const __3270_Ident: number;
    const __3270_Jump: number;
    const __3270_KeyClick: number;
    const __3270_Left2: number;
    const __3270_PA1: number;
    const __3270_PA2: number;
    const __3270_PA3: number;
    const __3270_Play: number;
    const __3270_PrintScreen: number;
    const __3270_Quit: number;
    const __3270_Record: number;
    const __3270_Reset: number;
    const __3270_Right2: number;
    const __3270_Rule: number;
    const __3270_Setup: number;
    const __3270_Test: number;
    const __4: number;
    const __5: number;
    const __6: number;
    const __7: number;
    const __8: number;
    const __9: number;
    const A: number;
    const AE: number;
    const Aacute: number;
    const Abelowdot: number;
    const Abreve: number;
    const Abreveacute: number;
    const Abrevebelowdot: number;
    const Abrevegrave: number;
    const Abrevehook: number;
    const Abrevetilde: number;
    const AccessX_Enable: number;
    const AccessX_Feedback_Enable: number;
    const Acircumflex: number;
    const Acircumflexacute: number;
    const Acircumflexbelowdot: number;
    const Acircumflexgrave: number;
    const Acircumflexhook: number;
    const Acircumflextilde: number;
    const AddFavorite: number;
    const Adiaeresis: number;
    const Agrave: number;
    const Ahook: number;
    const Alt_L: number;
    const Alt_R: number;
    const Amacron: number;
    const Aogonek: number;
    const ApplicationLeft: number;
    const ApplicationRight: number;
    const Arabic_0: number;
    const Arabic_1: number;
    const Arabic_2: number;
    const Arabic_3: number;
    const Arabic_4: number;
    const Arabic_5: number;
    const Arabic_6: number;
    const Arabic_7: number;
    const Arabic_8: number;
    const Arabic_9: number;
    const Arabic_ain: number;
    const Arabic_alef: number;
    const Arabic_alefmaksura: number;
    const Arabic_beh: number;
    const Arabic_comma: number;
    const Arabic_dad: number;
    const Arabic_dal: number;
    const Arabic_damma: number;
    const Arabic_dammatan: number;
    const Arabic_ddal: number;
    const Arabic_farsi_yeh: number;
    const Arabic_fatha: number;
    const Arabic_fathatan: number;
    const Arabic_feh: number;
    const Arabic_fullstop: number;
    const Arabic_gaf: number;
    const Arabic_ghain: number;
    const Arabic_ha: number;
    const Arabic_hah: number;
    const Arabic_hamza: number;
    const Arabic_hamza_above: number;
    const Arabic_hamza_below: number;
    const Arabic_hamzaonalef: number;
    const Arabic_hamzaonwaw: number;
    const Arabic_hamzaonyeh: number;
    const Arabic_hamzaunderalef: number;
    const Arabic_heh: number;
    const Arabic_heh_doachashmee: number;
    const Arabic_heh_goal: number;
    const Arabic_jeem: number;
    const Arabic_jeh: number;
    const Arabic_kaf: number;
    const Arabic_kasra: number;
    const Arabic_kasratan: number;
    const Arabic_keheh: number;
    const Arabic_khah: number;
    const Arabic_lam: number;
    const Arabic_madda_above: number;
    const Arabic_maddaonalef: number;
    const Arabic_meem: number;
    const Arabic_noon: number;
    const Arabic_noon_ghunna: number;
    const Arabic_peh: number;
    const Arabic_percent: number;
    const Arabic_qaf: number;
    const Arabic_question_mark: number;
    const Arabic_ra: number;
    const Arabic_rreh: number;
    const Arabic_sad: number;
    const Arabic_seen: number;
    const Arabic_semicolon: number;
    const Arabic_shadda: number;
    const Arabic_sheen: number;
    const Arabic_sukun: number;
    const Arabic_superscript_alef: number;
    const Arabic_switch: number;
    const Arabic_tah: number;
    const Arabic_tatweel: number;
    const Arabic_tcheh: number;
    const Arabic_teh: number;
    const Arabic_tehmarbuta: number;
    const Arabic_thal: number;
    const Arabic_theh: number;
    const Arabic_tteh: number;
    const Arabic_veh: number;
    const Arabic_waw: number;
    const Arabic_yeh: number;
    const Arabic_yeh_baree: number;
    const Arabic_zah: number;
    const Arabic_zain: number;
    const Aring: number;
    const Armenian_AT: number;
    const Armenian_AYB: number;
    const Armenian_BEN: number;
    const Armenian_CHA: number;
    const Armenian_DA: number;
    const Armenian_DZA: number;
    const Armenian_E: number;
    const Armenian_FE: number;
    const Armenian_GHAT: number;
    const Armenian_GIM: number;
    const Armenian_HI: number;
    const Armenian_HO: number;
    const Armenian_INI: number;
    const Armenian_JE: number;
    const Armenian_KE: number;
    const Armenian_KEN: number;
    const Armenian_KHE: number;
    const Armenian_LYUN: number;
    const Armenian_MEN: number;
    const Armenian_NU: number;
    const Armenian_O: number;
    const Armenian_PE: number;
    const Armenian_PYUR: number;
    const Armenian_RA: number;
    const Armenian_RE: number;
    const Armenian_SE: number;
    const Armenian_SHA: number;
    const Armenian_TCHE: number;
    const Armenian_TO: number;
    const Armenian_TSA: number;
    const Armenian_TSO: number;
    const Armenian_TYUN: number;
    const Armenian_VEV: number;
    const Armenian_VO: number;
    const Armenian_VYUN: number;
    const Armenian_YECH: number;
    const Armenian_ZA: number;
    const Armenian_ZHE: number;
    const Armenian_accent: number;
    const Armenian_amanak: number;
    const Armenian_apostrophe: number;
    const Armenian_at: number;
    const Armenian_ayb: number;
    const Armenian_ben: number;
    const Armenian_but: number;
    const Armenian_cha: number;
    const Armenian_da: number;
    const Armenian_dza: number;
    const Armenian_e: number;
    const Armenian_exclam: number;
    const Armenian_fe: number;
    const Armenian_full_stop: number;
    const Armenian_ghat: number;
    const Armenian_gim: number;
    const Armenian_hi: number;
    const Armenian_ho: number;
    const Armenian_hyphen: number;
    const Armenian_ini: number;
    const Armenian_je: number;
    const Armenian_ke: number;
    const Armenian_ken: number;
    const Armenian_khe: number;
    const Armenian_ligature_ew: number;
    const Armenian_lyun: number;
    const Armenian_men: number;
    const Armenian_nu: number;
    const Armenian_o: number;
    const Armenian_paruyk: number;
    const Armenian_pe: number;
    const Armenian_pyur: number;
    const Armenian_question: number;
    const Armenian_ra: number;
    const Armenian_re: number;
    const Armenian_se: number;
    const Armenian_separation_mark: number;
    const Armenian_sha: number;
    const Armenian_shesht: number;
    const Armenian_tche: number;
    const Armenian_to: number;
    const Armenian_tsa: number;
    const Armenian_tso: number;
    const Armenian_tyun: number;
    const Armenian_verjaket: number;
    const Armenian_vev: number;
    const Armenian_vo: number;
    const Armenian_vyun: number;
    const Armenian_yech: number;
    const Armenian_yentamna: number;
    const Armenian_za: number;
    const Armenian_zhe: number;
    const Atilde: number;
    const AudibleBell_Enable: number;
    const AudioCycleTrack: number;
    const AudioForward: number;
    const AudioLowerVolume: number;
    const AudioMedia: number;
    const AudioMicMute: number;
    const AudioMute: number;
    const AudioNext: number;
    const AudioPause: number;
    const AudioPlay: number;
    const AudioPrev: number;
    const AudioRaiseVolume: number;
    const AudioRandomPlay: number;
    const AudioRecord: number;
    const AudioRepeat: number;
    const AudioRewind: number;
    const AudioStop: number;
    const Away: number;
    const B: number;
    /**
     * The middle button of a pointer device.
     */
    const BUTTON_MIDDLE: number;
    /**
     * The primary button of a pointer device.
     *
     * This is typically the left mouse button in a right-handed
     * mouse configuration.
     */
    const BUTTON_PRIMARY: number;
    /**
     * The secondary button of a pointer device.
     *
     * This is typically the right mouse button in a right-handed
     * mouse configuration.
     */
    const BUTTON_SECONDARY: number;
    const Babovedot: number;
    const Back: number;
    const BackForward: number;
    const BackSpace: number;
    const Battery: number;
    const Begin: number;
    const Blue: number;
    const Bluetooth: number;
    const Book: number;
    const BounceKeys_Enable: number;
    const Break: number;
    const BrightnessAdjust: number;
    const Byelorussian_SHORTU: number;
    const Byelorussian_shortu: number;
    const C: number;
    const CD: number;
    const CH: number;
    /**
     * Cogl (internal GL abstraction utility library) backend. Can be "gl" or
     * "gles" currently
     */
    const COGL: string;
    /**
     * Default value for "now".
     */
    const CURRENT_TIME: number;
    const C_H: number;
    const C_h: number;
    const Cabovedot: number;
    const Cacute: number;
    const Calculator: number;
    const Calendar: number;
    const Cancel: number;
    const Caps_Lock: number;
    const Ccaron: number;
    const Ccedilla: number;
    const Ccircumflex: number;
    const Ch: number;
    const Clear: number;
    const ClearGrab: number;
    const Close: number;
    const Codeinput: number;
    const ColonSign: number;
    const Community: number;
    const ContrastAdjust: number;
    const Control_L: number;
    const Control_R: number;
    const Copy: number;
    const CruzeiroSign: number;
    const Cut: number;
    const CycleAngle: number;
    const Cyrillic_A: number;
    const Cyrillic_BE: number;
    const Cyrillic_CHE: number;
    const Cyrillic_CHE_descender: number;
    const Cyrillic_CHE_vertstroke: number;
    const Cyrillic_DE: number;
    const Cyrillic_DZHE: number;
    const Cyrillic_E: number;
    const Cyrillic_EF: number;
    const Cyrillic_EL: number;
    const Cyrillic_EM: number;
    const Cyrillic_EN: number;
    const Cyrillic_EN_descender: number;
    const Cyrillic_ER: number;
    const Cyrillic_ES: number;
    const Cyrillic_GHE: number;
    const Cyrillic_GHE_bar: number;
    const Cyrillic_HA: number;
    const Cyrillic_HARDSIGN: number;
    const Cyrillic_HA_descender: number;
    const Cyrillic_I: number;
    const Cyrillic_IE: number;
    const Cyrillic_IO: number;
    const Cyrillic_I_macron: number;
    const Cyrillic_JE: number;
    const Cyrillic_KA: number;
    const Cyrillic_KA_descender: number;
    const Cyrillic_KA_vertstroke: number;
    const Cyrillic_LJE: number;
    const Cyrillic_NJE: number;
    const Cyrillic_O: number;
    const Cyrillic_O_bar: number;
    const Cyrillic_PE: number;
    const Cyrillic_SCHWA: number;
    const Cyrillic_SHA: number;
    const Cyrillic_SHCHA: number;
    const Cyrillic_SHHA: number;
    const Cyrillic_SHORTI: number;
    const Cyrillic_SOFTSIGN: number;
    const Cyrillic_TE: number;
    const Cyrillic_TSE: number;
    const Cyrillic_U: number;
    const Cyrillic_U_macron: number;
    const Cyrillic_U_straight: number;
    const Cyrillic_U_straight_bar: number;
    const Cyrillic_VE: number;
    const Cyrillic_YA: number;
    const Cyrillic_YERU: number;
    const Cyrillic_YU: number;
    const Cyrillic_ZE: number;
    const Cyrillic_ZHE: number;
    const Cyrillic_ZHE_descender: number;
    const Cyrillic_a: number;
    const Cyrillic_be: number;
    const Cyrillic_che: number;
    const Cyrillic_che_descender: number;
    const Cyrillic_che_vertstroke: number;
    const Cyrillic_de: number;
    const Cyrillic_dzhe: number;
    const Cyrillic_e: number;
    const Cyrillic_ef: number;
    const Cyrillic_el: number;
    const Cyrillic_em: number;
    const Cyrillic_en: number;
    const Cyrillic_en_descender: number;
    const Cyrillic_er: number;
    const Cyrillic_es: number;
    const Cyrillic_ghe: number;
    const Cyrillic_ghe_bar: number;
    const Cyrillic_ha: number;
    const Cyrillic_ha_descender: number;
    const Cyrillic_hardsign: number;
    const Cyrillic_i: number;
    const Cyrillic_i_macron: number;
    const Cyrillic_ie: number;
    const Cyrillic_io: number;
    const Cyrillic_je: number;
    const Cyrillic_ka: number;
    const Cyrillic_ka_descender: number;
    const Cyrillic_ka_vertstroke: number;
    const Cyrillic_lje: number;
    const Cyrillic_nje: number;
    const Cyrillic_o: number;
    const Cyrillic_o_bar: number;
    const Cyrillic_pe: number;
    const Cyrillic_schwa: number;
    const Cyrillic_sha: number;
    const Cyrillic_shcha: number;
    const Cyrillic_shha: number;
    const Cyrillic_shorti: number;
    const Cyrillic_softsign: number;
    const Cyrillic_te: number;
    const Cyrillic_tse: number;
    const Cyrillic_u: number;
    const Cyrillic_u_macron: number;
    const Cyrillic_u_straight: number;
    const Cyrillic_u_straight_bar: number;
    const Cyrillic_ve: number;
    const Cyrillic_ya: number;
    const Cyrillic_yeru: number;
    const Cyrillic_yu: number;
    const Cyrillic_ze: number;
    const Cyrillic_zhe: number;
    const Cyrillic_zhe_descender: number;
    const D: number;
    const DOS: number;
    const Dabovedot: number;
    const Dcaron: number;
    const Delete: number;
    const Display: number;
    const Documents: number;
    const DongSign: number;
    const Down: number;
    const Dstroke: number;
    const E: number;
    const ENG: number;
    const ETH: number;
    /**
     * Continues the propagation of an event; this macro should be
     * used in event-related signals.
     */
    const EVENT_PROPAGATE: boolean;
    /**
     * Stops the propagation of an event; this macro should be used
     * in event-related signals.
     */
    const EVENT_STOP: boolean;
    const EZH: number;
    const Eabovedot: number;
    const Eacute: number;
    const Ebelowdot: number;
    const Ecaron: number;
    const Ecircumflex: number;
    const Ecircumflexacute: number;
    const Ecircumflexbelowdot: number;
    const Ecircumflexgrave: number;
    const Ecircumflexhook: number;
    const Ecircumflextilde: number;
    const EcuSign: number;
    const Ediaeresis: number;
    const Egrave: number;
    const Ehook: number;
    const Eisu_Shift: number;
    const Eisu_toggle: number;
    const Eject: number;
    const Emacron: number;
    const End: number;
    const Eogonek: number;
    const Escape: number;
    const Eth: number;
    const Etilde: number;
    const EuroSign: number;
    const Excel: number;
    const Execute: number;
    const Explorer: number;
    const F: number;
    const F1: number;
    const F10: number;
    const F11: number;
    const F12: number;
    const F13: number;
    const F14: number;
    const F15: number;
    const F16: number;
    const F17: number;
    const F18: number;
    const F19: number;
    const F2: number;
    const F20: number;
    const F21: number;
    const F22: number;
    const F23: number;
    const F24: number;
    const F25: number;
    const F26: number;
    const F27: number;
    const F28: number;
    const F29: number;
    const F3: number;
    const F30: number;
    const F31: number;
    const F32: number;
    const F33: number;
    const F34: number;
    const F35: number;
    const F4: number;
    const F5: number;
    const F6: number;
    const F7: number;
    const F8: number;
    const F9: number;
    const FFrancSign: number;
    /**
     * GL Windowing system used
     */
    const FLAVOUR: string;
    const Fabovedot: number;
    const Farsi_0: number;
    const Farsi_1: number;
    const Farsi_2: number;
    const Farsi_3: number;
    const Farsi_4: number;
    const Farsi_5: number;
    const Farsi_6: number;
    const Farsi_7: number;
    const Farsi_8: number;
    const Farsi_9: number;
    const Farsi_yeh: number;
    const Favorites: number;
    const Finance: number;
    const Find: number;
    const First_Virtual_Screen: number;
    const Forward: number;
    const FrameBack: number;
    const FrameForward: number;
    const G: number;
    const Gabovedot: number;
    const Game: number;
    const Gbreve: number;
    const Gcaron: number;
    const Gcedilla: number;
    const Gcircumflex: number;
    const Georgian_an: number;
    const Georgian_ban: number;
    const Georgian_can: number;
    const Georgian_char: number;
    const Georgian_chin: number;
    const Georgian_cil: number;
    const Georgian_don: number;
    const Georgian_en: number;
    const Georgian_fi: number;
    const Georgian_gan: number;
    const Georgian_ghan: number;
    const Georgian_hae: number;
    const Georgian_har: number;
    const Georgian_he: number;
    const Georgian_hie: number;
    const Georgian_hoe: number;
    const Georgian_in: number;
    const Georgian_jhan: number;
    const Georgian_jil: number;
    const Georgian_kan: number;
    const Georgian_khar: number;
    const Georgian_las: number;
    const Georgian_man: number;
    const Georgian_nar: number;
    const Georgian_on: number;
    const Georgian_par: number;
    const Georgian_phar: number;
    const Georgian_qar: number;
    const Georgian_rae: number;
    const Georgian_san: number;
    const Georgian_shin: number;
    const Georgian_tan: number;
    const Georgian_tar: number;
    const Georgian_un: number;
    const Georgian_vin: number;
    const Georgian_we: number;
    const Georgian_xan: number;
    const Georgian_zen: number;
    const Georgian_zhar: number;
    const Go: number;
    const Greek_ALPHA: number;
    const Greek_ALPHAaccent: number;
    const Greek_BETA: number;
    const Greek_CHI: number;
    const Greek_DELTA: number;
    const Greek_EPSILON: number;
    const Greek_EPSILONaccent: number;
    const Greek_ETA: number;
    const Greek_ETAaccent: number;
    const Greek_GAMMA: number;
    const Greek_IOTA: number;
    const Greek_IOTAaccent: number;
    const Greek_IOTAdiaeresis: number;
    const Greek_IOTAdieresis: number;
    const Greek_KAPPA: number;
    const Greek_LAMBDA: number;
    const Greek_LAMDA: number;
    const Greek_MU: number;
    const Greek_NU: number;
    const Greek_OMEGA: number;
    const Greek_OMEGAaccent: number;
    const Greek_OMICRON: number;
    const Greek_OMICRONaccent: number;
    const Greek_PHI: number;
    const Greek_PI: number;
    const Greek_PSI: number;
    const Greek_RHO: number;
    const Greek_SIGMA: number;
    const Greek_TAU: number;
    const Greek_THETA: number;
    const Greek_UPSILON: number;
    const Greek_UPSILONaccent: number;
    const Greek_UPSILONdieresis: number;
    const Greek_XI: number;
    const Greek_ZETA: number;
    const Greek_accentdieresis: number;
    const Greek_alpha: number;
    const Greek_alphaaccent: number;
    const Greek_beta: number;
    const Greek_chi: number;
    const Greek_delta: number;
    const Greek_epsilon: number;
    const Greek_epsilonaccent: number;
    const Greek_eta: number;
    const Greek_etaaccent: number;
    const Greek_finalsmallsigma: number;
    const Greek_gamma: number;
    const Greek_horizbar: number;
    const Greek_iota: number;
    const Greek_iotaaccent: number;
    const Greek_iotaaccentdieresis: number;
    const Greek_iotadieresis: number;
    const Greek_kappa: number;
    const Greek_lambda: number;
    const Greek_lamda: number;
    const Greek_mu: number;
    const Greek_nu: number;
    const Greek_omega: number;
    const Greek_omegaaccent: number;
    const Greek_omicron: number;
    const Greek_omicronaccent: number;
    const Greek_phi: number;
    const Greek_pi: number;
    const Greek_psi: number;
    const Greek_rho: number;
    const Greek_sigma: number;
    const Greek_switch: number;
    const Greek_tau: number;
    const Greek_theta: number;
    const Greek_upsilon: number;
    const Greek_upsilonaccent: number;
    const Greek_upsilonaccentdieresis: number;
    const Greek_upsilondieresis: number;
    const Greek_xi: number;
    const Greek_zeta: number;
    const Green: number;
    const H: number;
    const HAS_WAYLAND_COMPOSITOR_SUPPORT: number;
    const Hangul: number;
    const Hangul_A: number;
    const Hangul_AE: number;
    const Hangul_AraeA: number;
    const Hangul_AraeAE: number;
    const Hangul_Banja: number;
    const Hangul_Cieuc: number;
    const Hangul_Codeinput: number;
    const Hangul_Dikeud: number;
    const Hangul_E: number;
    const Hangul_EO: number;
    const Hangul_EU: number;
    const Hangul_End: number;
    const Hangul_Hanja: number;
    const Hangul_Hieuh: number;
    const Hangul_I: number;
    const Hangul_Ieung: number;
    const Hangul_J_Cieuc: number;
    const Hangul_J_Dikeud: number;
    const Hangul_J_Hieuh: number;
    const Hangul_J_Ieung: number;
    const Hangul_J_Jieuj: number;
    const Hangul_J_Khieuq: number;
    const Hangul_J_Kiyeog: number;
    const Hangul_J_KiyeogSios: number;
    const Hangul_J_KkogjiDalrinIeung: number;
    const Hangul_J_Mieum: number;
    const Hangul_J_Nieun: number;
    const Hangul_J_NieunHieuh: number;
    const Hangul_J_NieunJieuj: number;
    const Hangul_J_PanSios: number;
    const Hangul_J_Phieuf: number;
    const Hangul_J_Pieub: number;
    const Hangul_J_PieubSios: number;
    const Hangul_J_Rieul: number;
    const Hangul_J_RieulHieuh: number;
    const Hangul_J_RieulKiyeog: number;
    const Hangul_J_RieulMieum: number;
    const Hangul_J_RieulPhieuf: number;
    const Hangul_J_RieulPieub: number;
    const Hangul_J_RieulSios: number;
    const Hangul_J_RieulTieut: number;
    const Hangul_J_Sios: number;
    const Hangul_J_SsangKiyeog: number;
    const Hangul_J_SsangSios: number;
    const Hangul_J_Tieut: number;
    const Hangul_J_YeorinHieuh: number;
    const Hangul_Jamo: number;
    const Hangul_Jeonja: number;
    const Hangul_Jieuj: number;
    const Hangul_Khieuq: number;
    const Hangul_Kiyeog: number;
    const Hangul_KiyeogSios: number;
    const Hangul_KkogjiDalrinIeung: number;
    const Hangul_Mieum: number;
    const Hangul_MultipleCandidate: number;
    const Hangul_Nieun: number;
    const Hangul_NieunHieuh: number;
    const Hangul_NieunJieuj: number;
    const Hangul_O: number;
    const Hangul_OE: number;
    const Hangul_PanSios: number;
    const Hangul_Phieuf: number;
    const Hangul_Pieub: number;
    const Hangul_PieubSios: number;
    const Hangul_PostHanja: number;
    const Hangul_PreHanja: number;
    const Hangul_PreviousCandidate: number;
    const Hangul_Rieul: number;
    const Hangul_RieulHieuh: number;
    const Hangul_RieulKiyeog: number;
    const Hangul_RieulMieum: number;
    const Hangul_RieulPhieuf: number;
    const Hangul_RieulPieub: number;
    const Hangul_RieulSios: number;
    const Hangul_RieulTieut: number;
    const Hangul_RieulYeorinHieuh: number;
    const Hangul_Romaja: number;
    const Hangul_SingleCandidate: number;
    const Hangul_Sios: number;
    const Hangul_Special: number;
    const Hangul_SsangDikeud: number;
    const Hangul_SsangJieuj: number;
    const Hangul_SsangKiyeog: number;
    const Hangul_SsangPieub: number;
    const Hangul_SsangSios: number;
    const Hangul_Start: number;
    const Hangul_SunkyeongeumMieum: number;
    const Hangul_SunkyeongeumPhieuf: number;
    const Hangul_SunkyeongeumPieub: number;
    const Hangul_Tieut: number;
    const Hangul_U: number;
    const Hangul_WA: number;
    const Hangul_WAE: number;
    const Hangul_WE: number;
    const Hangul_WEO: number;
    const Hangul_WI: number;
    const Hangul_YA: number;
    const Hangul_YAE: number;
    const Hangul_YE: number;
    const Hangul_YEO: number;
    const Hangul_YI: number;
    const Hangul_YO: number;
    const Hangul_YU: number;
    const Hangul_YeorinHieuh: number;
    const Hangul_switch: number;
    const Hankaku: number;
    const Hcircumflex: number;
    const Hebrew_switch: number;
    const Help: number;
    const Henkan: number;
    const Henkan_Mode: number;
    const Hibernate: number;
    const Hiragana: number;
    const Hiragana_Katakana: number;
    const History: number;
    const Home: number;
    const HomePage: number;
    const HotLinks: number;
    const Hstroke: number;
    const Hyper_L: number;
    const Hyper_R: number;
    const I: number;
    const INPUT_EVDEV: string;
    const INPUT_GDK: string;
    const INPUT_NULL: string;
    const INPUT_WAYLAND: string;
    const INPUT_X11: string;
    const ISO_Center_Object: number;
    const ISO_Continuous_Underline: number;
    const ISO_Discontinuous_Underline: number;
    const ISO_Emphasize: number;
    const ISO_Enter: number;
    const ISO_Fast_Cursor_Down: number;
    const ISO_Fast_Cursor_Left: number;
    const ISO_Fast_Cursor_Right: number;
    const ISO_Fast_Cursor_Up: number;
    const ISO_First_Group: number;
    const ISO_First_Group_Lock: number;
    const ISO_Group_Latch: number;
    const ISO_Group_Lock: number;
    const ISO_Group_Shift: number;
    const ISO_Last_Group: number;
    const ISO_Last_Group_Lock: number;
    const ISO_Left_Tab: number;
    const ISO_Level2_Latch: number;
    const ISO_Level3_Latch: number;
    const ISO_Level3_Lock: number;
    const ISO_Level3_Shift: number;
    const ISO_Level5_Latch: number;
    const ISO_Level5_Lock: number;
    const ISO_Level5_Shift: number;
    const ISO_Lock: number;
    const ISO_Move_Line_Down: number;
    const ISO_Move_Line_Up: number;
    const ISO_Next_Group: number;
    const ISO_Next_Group_Lock: number;
    const ISO_Partial_Line_Down: number;
    const ISO_Partial_Line_Up: number;
    const ISO_Partial_Space_Left: number;
    const ISO_Partial_Space_Right: number;
    const ISO_Prev_Group: number;
    const ISO_Prev_Group_Lock: number;
    const ISO_Release_Both_Margins: number;
    const ISO_Release_Margin_Left: number;
    const ISO_Release_Margin_Right: number;
    const ISO_Set_Margin_Left: number;
    const ISO_Set_Margin_Right: number;
    const Iabovedot: number;
    const Iacute: number;
    const Ibelowdot: number;
    const Ibreve: number;
    const Icircumflex: number;
    const Idiaeresis: number;
    const Igrave: number;
    const Ihook: number;
    const Imacron: number;
    const Insert: number;
    const Iogonek: number;
    const Itilde: number;
    const J: number;
    const Jcircumflex: number;
    const K: number;
    const KEY_0: number;
    const KEY_1: number;
    const KEY_2: number;
    const KEY_3: number;
    const KEY_3270_AltCursor: number;
    const KEY_3270_Attn: number;
    const KEY_3270_BackTab: number;
    const KEY_3270_ChangeScreen: number;
    const KEY_3270_Copy: number;
    const KEY_3270_CursorBlink: number;
    const KEY_3270_CursorSelect: number;
    const KEY_3270_DeleteWord: number;
    const KEY_3270_Duplicate: number;
    const KEY_3270_Enter: number;
    const KEY_3270_EraseEOF: number;
    const KEY_3270_EraseInput: number;
    const KEY_3270_ExSelect: number;
    const KEY_3270_FieldMark: number;
    const KEY_3270_Ident: number;
    const KEY_3270_Jump: number;
    const KEY_3270_KeyClick: number;
    const KEY_3270_Left2: number;
    const KEY_3270_PA1: number;
    const KEY_3270_PA2: number;
    const KEY_3270_PA3: number;
    const KEY_3270_Play: number;
    const KEY_3270_PrintScreen: number;
    const KEY_3270_Quit: number;
    const KEY_3270_Record: number;
    const KEY_3270_Reset: number;
    const KEY_3270_Right2: number;
    const KEY_3270_Rule: number;
    const KEY_3270_Setup: number;
    const KEY_3270_Test: number;
    const KEY_4: number;
    const KEY_5: number;
    const KEY_6: number;
    const KEY_7: number;
    const KEY_8: number;
    const KEY_9: number;
    const KEY_A: number;
    const KEY_AE: number;
    const KEY_Aacute: number;
    const KEY_Abelowdot: number;
    const KEY_Abreve: number;
    const KEY_Abreveacute: number;
    const KEY_Abrevebelowdot: number;
    const KEY_Abrevegrave: number;
    const KEY_Abrevehook: number;
    const KEY_Abrevetilde: number;
    const KEY_AccessX_Enable: number;
    const KEY_AccessX_Feedback_Enable: number;
    const KEY_Acircumflex: number;
    const KEY_Acircumflexacute: number;
    const KEY_Acircumflexbelowdot: number;
    const KEY_Acircumflexgrave: number;
    const KEY_Acircumflexhook: number;
    const KEY_Acircumflextilde: number;
    const KEY_AddFavorite: number;
    const KEY_Adiaeresis: number;
    const KEY_Agrave: number;
    const KEY_Ahook: number;
    const KEY_Alt_L: number;
    const KEY_Alt_R: number;
    const KEY_Amacron: number;
    const KEY_Aogonek: number;
    const KEY_ApplicationLeft: number;
    const KEY_ApplicationRight: number;
    const KEY_Arabic_0: number;
    const KEY_Arabic_1: number;
    const KEY_Arabic_2: number;
    const KEY_Arabic_3: number;
    const KEY_Arabic_4: number;
    const KEY_Arabic_5: number;
    const KEY_Arabic_6: number;
    const KEY_Arabic_7: number;
    const KEY_Arabic_8: number;
    const KEY_Arabic_9: number;
    const KEY_Arabic_ain: number;
    const KEY_Arabic_alef: number;
    const KEY_Arabic_alefmaksura: number;
    const KEY_Arabic_beh: number;
    const KEY_Arabic_comma: number;
    const KEY_Arabic_dad: number;
    const KEY_Arabic_dal: number;
    const KEY_Arabic_damma: number;
    const KEY_Arabic_dammatan: number;
    const KEY_Arabic_ddal: number;
    const KEY_Arabic_farsi_yeh: number;
    const KEY_Arabic_fatha: number;
    const KEY_Arabic_fathatan: number;
    const KEY_Arabic_feh: number;
    const KEY_Arabic_fullstop: number;
    const KEY_Arabic_gaf: number;
    const KEY_Arabic_ghain: number;
    const KEY_Arabic_ha: number;
    const KEY_Arabic_hah: number;
    const KEY_Arabic_hamza: number;
    const KEY_Arabic_hamza_above: number;
    const KEY_Arabic_hamza_below: number;
    const KEY_Arabic_hamzaonalef: number;
    const KEY_Arabic_hamzaonwaw: number;
    const KEY_Arabic_hamzaonyeh: number;
    const KEY_Arabic_hamzaunderalef: number;
    const KEY_Arabic_heh: number;
    const KEY_Arabic_heh_doachashmee: number;
    const KEY_Arabic_heh_goal: number;
    const KEY_Arabic_jeem: number;
    const KEY_Arabic_jeh: number;
    const KEY_Arabic_kaf: number;
    const KEY_Arabic_kasra: number;
    const KEY_Arabic_kasratan: number;
    const KEY_Arabic_keheh: number;
    const KEY_Arabic_khah: number;
    const KEY_Arabic_lam: number;
    const KEY_Arabic_madda_above: number;
    const KEY_Arabic_maddaonalef: number;
    const KEY_Arabic_meem: number;
    const KEY_Arabic_noon: number;
    const KEY_Arabic_noon_ghunna: number;
    const KEY_Arabic_peh: number;
    const KEY_Arabic_percent: number;
    const KEY_Arabic_qaf: number;
    const KEY_Arabic_question_mark: number;
    const KEY_Arabic_ra: number;
    const KEY_Arabic_rreh: number;
    const KEY_Arabic_sad: number;
    const KEY_Arabic_seen: number;
    const KEY_Arabic_semicolon: number;
    const KEY_Arabic_shadda: number;
    const KEY_Arabic_sheen: number;
    const KEY_Arabic_sukun: number;
    const KEY_Arabic_superscript_alef: number;
    const KEY_Arabic_switch: number;
    const KEY_Arabic_tah: number;
    const KEY_Arabic_tatweel: number;
    const KEY_Arabic_tcheh: number;
    const KEY_Arabic_teh: number;
    const KEY_Arabic_tehmarbuta: number;
    const KEY_Arabic_thal: number;
    const KEY_Arabic_theh: number;
    const KEY_Arabic_tteh: number;
    const KEY_Arabic_veh: number;
    const KEY_Arabic_waw: number;
    const KEY_Arabic_yeh: number;
    const KEY_Arabic_yeh_baree: number;
    const KEY_Arabic_zah: number;
    const KEY_Arabic_zain: number;
    const KEY_Aring: number;
    const KEY_Armenian_AT: number;
    const KEY_Armenian_AYB: number;
    const KEY_Armenian_BEN: number;
    const KEY_Armenian_CHA: number;
    const KEY_Armenian_DA: number;
    const KEY_Armenian_DZA: number;
    const KEY_Armenian_E: number;
    const KEY_Armenian_FE: number;
    const KEY_Armenian_GHAT: number;
    const KEY_Armenian_GIM: number;
    const KEY_Armenian_HI: number;
    const KEY_Armenian_HO: number;
    const KEY_Armenian_INI: number;
    const KEY_Armenian_JE: number;
    const KEY_Armenian_KE: number;
    const KEY_Armenian_KEN: number;
    const KEY_Armenian_KHE: number;
    const KEY_Armenian_LYUN: number;
    const KEY_Armenian_MEN: number;
    const KEY_Armenian_NU: number;
    const KEY_Armenian_O: number;
    const KEY_Armenian_PE: number;
    const KEY_Armenian_PYUR: number;
    const KEY_Armenian_RA: number;
    const KEY_Armenian_RE: number;
    const KEY_Armenian_SE: number;
    const KEY_Armenian_SHA: number;
    const KEY_Armenian_TCHE: number;
    const KEY_Armenian_TO: number;
    const KEY_Armenian_TSA: number;
    const KEY_Armenian_TSO: number;
    const KEY_Armenian_TYUN: number;
    const KEY_Armenian_VEV: number;
    const KEY_Armenian_VO: number;
    const KEY_Armenian_VYUN: number;
    const KEY_Armenian_YECH: number;
    const KEY_Armenian_ZA: number;
    const KEY_Armenian_ZHE: number;
    const KEY_Armenian_accent: number;
    const KEY_Armenian_amanak: number;
    const KEY_Armenian_apostrophe: number;
    const KEY_Armenian_at: number;
    const KEY_Armenian_ayb: number;
    const KEY_Armenian_ben: number;
    const KEY_Armenian_but: number;
    const KEY_Armenian_cha: number;
    const KEY_Armenian_da: number;
    const KEY_Armenian_dza: number;
    const KEY_Armenian_e: number;
    const KEY_Armenian_exclam: number;
    const KEY_Armenian_fe: number;
    const KEY_Armenian_full_stop: number;
    const KEY_Armenian_ghat: number;
    const KEY_Armenian_gim: number;
    const KEY_Armenian_hi: number;
    const KEY_Armenian_ho: number;
    const KEY_Armenian_hyphen: number;
    const KEY_Armenian_ini: number;
    const KEY_Armenian_je: number;
    const KEY_Armenian_ke: number;
    const KEY_Armenian_ken: number;
    const KEY_Armenian_khe: number;
    const KEY_Armenian_ligature_ew: number;
    const KEY_Armenian_lyun: number;
    const KEY_Armenian_men: number;
    const KEY_Armenian_nu: number;
    const KEY_Armenian_o: number;
    const KEY_Armenian_paruyk: number;
    const KEY_Armenian_pe: number;
    const KEY_Armenian_pyur: number;
    const KEY_Armenian_question: number;
    const KEY_Armenian_ra: number;
    const KEY_Armenian_re: number;
    const KEY_Armenian_se: number;
    const KEY_Armenian_separation_mark: number;
    const KEY_Armenian_sha: number;
    const KEY_Armenian_shesht: number;
    const KEY_Armenian_tche: number;
    const KEY_Armenian_to: number;
    const KEY_Armenian_tsa: number;
    const KEY_Armenian_tso: number;
    const KEY_Armenian_tyun: number;
    const KEY_Armenian_verjaket: number;
    const KEY_Armenian_vev: number;
    const KEY_Armenian_vo: number;
    const KEY_Armenian_vyun: number;
    const KEY_Armenian_yech: number;
    const KEY_Armenian_yentamna: number;
    const KEY_Armenian_za: number;
    const KEY_Armenian_zhe: number;
    const KEY_Atilde: number;
    const KEY_AudibleBell_Enable: number;
    const KEY_AudioCycleTrack: number;
    const KEY_AudioForward: number;
    const KEY_AudioLowerVolume: number;
    const KEY_AudioMedia: number;
    const KEY_AudioMicMute: number;
    const KEY_AudioMute: number;
    const KEY_AudioNext: number;
    const KEY_AudioPause: number;
    const KEY_AudioPlay: number;
    const KEY_AudioPrev: number;
    const KEY_AudioRaiseVolume: number;
    const KEY_AudioRandomPlay: number;
    const KEY_AudioRecord: number;
    const KEY_AudioRepeat: number;
    const KEY_AudioRewind: number;
    const KEY_AudioStop: number;
    const KEY_Away: number;
    const KEY_B: number;
    const KEY_Babovedot: number;
    const KEY_Back: number;
    const KEY_BackForward: number;
    const KEY_BackSpace: number;
    const KEY_Battery: number;
    const KEY_Begin: number;
    const KEY_Blue: number;
    const KEY_Bluetooth: number;
    const KEY_Book: number;
    const KEY_BounceKeys_Enable: number;
    const KEY_Break: number;
    const KEY_BrightnessAdjust: number;
    const KEY_Byelorussian_SHORTU: number;
    const KEY_Byelorussian_shortu: number;
    const KEY_C: number;
    const KEY_CD: number;
    const KEY_CH: number;
    const KEY_C_H: number;
    const KEY_C_h: number;
    const KEY_Cabovedot: number;
    const KEY_Cacute: number;
    const KEY_Calculator: number;
    const KEY_Calendar: number;
    const KEY_Cancel: number;
    const KEY_Caps_Lock: number;
    const KEY_Ccaron: number;
    const KEY_Ccedilla: number;
    const KEY_Ccircumflex: number;
    const KEY_Ch: number;
    const KEY_Clear: number;
    const KEY_ClearGrab: number;
    const KEY_Close: number;
    const KEY_Codeinput: number;
    const KEY_ColonSign: number;
    const KEY_Community: number;
    const KEY_ContrastAdjust: number;
    const KEY_Control_L: number;
    const KEY_Control_R: number;
    const KEY_Copy: number;
    const KEY_CruzeiroSign: number;
    const KEY_Cut: number;
    const KEY_CycleAngle: number;
    const KEY_Cyrillic_A: number;
    const KEY_Cyrillic_BE: number;
    const KEY_Cyrillic_CHE: number;
    const KEY_Cyrillic_CHE_descender: number;
    const KEY_Cyrillic_CHE_vertstroke: number;
    const KEY_Cyrillic_DE: number;
    const KEY_Cyrillic_DZHE: number;
    const KEY_Cyrillic_E: number;
    const KEY_Cyrillic_EF: number;
    const KEY_Cyrillic_EL: number;
    const KEY_Cyrillic_EM: number;
    const KEY_Cyrillic_EN: number;
    const KEY_Cyrillic_EN_descender: number;
    const KEY_Cyrillic_ER: number;
    const KEY_Cyrillic_ES: number;
    const KEY_Cyrillic_GHE: number;
    const KEY_Cyrillic_GHE_bar: number;
    const KEY_Cyrillic_HA: number;
    const KEY_Cyrillic_HARDSIGN: number;
    const KEY_Cyrillic_HA_descender: number;
    const KEY_Cyrillic_I: number;
    const KEY_Cyrillic_IE: number;
    const KEY_Cyrillic_IO: number;
    const KEY_Cyrillic_I_macron: number;
    const KEY_Cyrillic_JE: number;
    const KEY_Cyrillic_KA: number;
    const KEY_Cyrillic_KA_descender: number;
    const KEY_Cyrillic_KA_vertstroke: number;
    const KEY_Cyrillic_LJE: number;
    const KEY_Cyrillic_NJE: number;
    const KEY_Cyrillic_O: number;
    const KEY_Cyrillic_O_bar: number;
    const KEY_Cyrillic_PE: number;
    const KEY_Cyrillic_SCHWA: number;
    const KEY_Cyrillic_SHA: number;
    const KEY_Cyrillic_SHCHA: number;
    const KEY_Cyrillic_SHHA: number;
    const KEY_Cyrillic_SHORTI: number;
    const KEY_Cyrillic_SOFTSIGN: number;
    const KEY_Cyrillic_TE: number;
    const KEY_Cyrillic_TSE: number;
    const KEY_Cyrillic_U: number;
    const KEY_Cyrillic_U_macron: number;
    const KEY_Cyrillic_U_straight: number;
    const KEY_Cyrillic_U_straight_bar: number;
    const KEY_Cyrillic_VE: number;
    const KEY_Cyrillic_YA: number;
    const KEY_Cyrillic_YERU: number;
    const KEY_Cyrillic_YU: number;
    const KEY_Cyrillic_ZE: number;
    const KEY_Cyrillic_ZHE: number;
    const KEY_Cyrillic_ZHE_descender: number;
    const KEY_Cyrillic_a: number;
    const KEY_Cyrillic_be: number;
    const KEY_Cyrillic_che: number;
    const KEY_Cyrillic_che_descender: number;
    const KEY_Cyrillic_che_vertstroke: number;
    const KEY_Cyrillic_de: number;
    const KEY_Cyrillic_dzhe: number;
    const KEY_Cyrillic_e: number;
    const KEY_Cyrillic_ef: number;
    const KEY_Cyrillic_el: number;
    const KEY_Cyrillic_em: number;
    const KEY_Cyrillic_en: number;
    const KEY_Cyrillic_en_descender: number;
    const KEY_Cyrillic_er: number;
    const KEY_Cyrillic_es: number;
    const KEY_Cyrillic_ghe: number;
    const KEY_Cyrillic_ghe_bar: number;
    const KEY_Cyrillic_ha: number;
    const KEY_Cyrillic_ha_descender: number;
    const KEY_Cyrillic_hardsign: number;
    const KEY_Cyrillic_i: number;
    const KEY_Cyrillic_i_macron: number;
    const KEY_Cyrillic_ie: number;
    const KEY_Cyrillic_io: number;
    const KEY_Cyrillic_je: number;
    const KEY_Cyrillic_ka: number;
    const KEY_Cyrillic_ka_descender: number;
    const KEY_Cyrillic_ka_vertstroke: number;
    const KEY_Cyrillic_lje: number;
    const KEY_Cyrillic_nje: number;
    const KEY_Cyrillic_o: number;
    const KEY_Cyrillic_o_bar: number;
    const KEY_Cyrillic_pe: number;
    const KEY_Cyrillic_schwa: number;
    const KEY_Cyrillic_sha: number;
    const KEY_Cyrillic_shcha: number;
    const KEY_Cyrillic_shha: number;
    const KEY_Cyrillic_shorti: number;
    const KEY_Cyrillic_softsign: number;
    const KEY_Cyrillic_te: number;
    const KEY_Cyrillic_tse: number;
    const KEY_Cyrillic_u: number;
    const KEY_Cyrillic_u_macron: number;
    const KEY_Cyrillic_u_straight: number;
    const KEY_Cyrillic_u_straight_bar: number;
    const KEY_Cyrillic_ve: number;
    const KEY_Cyrillic_ya: number;
    const KEY_Cyrillic_yeru: number;
    const KEY_Cyrillic_yu: number;
    const KEY_Cyrillic_ze: number;
    const KEY_Cyrillic_zhe: number;
    const KEY_Cyrillic_zhe_descender: number;
    const KEY_D: number;
    const KEY_DOS: number;
    const KEY_Dabovedot: number;
    const KEY_Dcaron: number;
    const KEY_Delete: number;
    const KEY_Display: number;
    const KEY_Documents: number;
    const KEY_DongSign: number;
    const KEY_Down: number;
    const KEY_Dstroke: number;
    const KEY_E: number;
    const KEY_ENG: number;
    const KEY_ETH: number;
    const KEY_EZH: number;
    const KEY_Eabovedot: number;
    const KEY_Eacute: number;
    const KEY_Ebelowdot: number;
    const KEY_Ecaron: number;
    const KEY_Ecircumflex: number;
    const KEY_Ecircumflexacute: number;
    const KEY_Ecircumflexbelowdot: number;
    const KEY_Ecircumflexgrave: number;
    const KEY_Ecircumflexhook: number;
    const KEY_Ecircumflextilde: number;
    const KEY_EcuSign: number;
    const KEY_Ediaeresis: number;
    const KEY_Egrave: number;
    const KEY_Ehook: number;
    const KEY_Eisu_Shift: number;
    const KEY_Eisu_toggle: number;
    const KEY_Eject: number;
    const KEY_Emacron: number;
    const KEY_End: number;
    const KEY_Eogonek: number;
    const KEY_Escape: number;
    const KEY_Eth: number;
    const KEY_Etilde: number;
    const KEY_EuroSign: number;
    const KEY_Excel: number;
    const KEY_Execute: number;
    const KEY_Explorer: number;
    const KEY_F: number;
    const KEY_F1: number;
    const KEY_F10: number;
    const KEY_F11: number;
    const KEY_F12: number;
    const KEY_F13: number;
    const KEY_F14: number;
    const KEY_F15: number;
    const KEY_F16: number;
    const KEY_F17: number;
    const KEY_F18: number;
    const KEY_F19: number;
    const KEY_F2: number;
    const KEY_F20: number;
    const KEY_F21: number;
    const KEY_F22: number;
    const KEY_F23: number;
    const KEY_F24: number;
    const KEY_F25: number;
    const KEY_F26: number;
    const KEY_F27: number;
    const KEY_F28: number;
    const KEY_F29: number;
    const KEY_F3: number;
    const KEY_F30: number;
    const KEY_F31: number;
    const KEY_F32: number;
    const KEY_F33: number;
    const KEY_F34: number;
    const KEY_F35: number;
    const KEY_F4: number;
    const KEY_F5: number;
    const KEY_F6: number;
    const KEY_F7: number;
    const KEY_F8: number;
    const KEY_F9: number;
    const KEY_FFrancSign: number;
    const KEY_Fabovedot: number;
    const KEY_Farsi_0: number;
    const KEY_Farsi_1: number;
    const KEY_Farsi_2: number;
    const KEY_Farsi_3: number;
    const KEY_Farsi_4: number;
    const KEY_Farsi_5: number;
    const KEY_Farsi_6: number;
    const KEY_Farsi_7: number;
    const KEY_Farsi_8: number;
    const KEY_Farsi_9: number;
    const KEY_Farsi_yeh: number;
    const KEY_Favorites: number;
    const KEY_Finance: number;
    const KEY_Find: number;
    const KEY_First_Virtual_Screen: number;
    const KEY_Forward: number;
    const KEY_FrameBack: number;
    const KEY_FrameForward: number;
    const KEY_G: number;
    const KEY_Gabovedot: number;
    const KEY_Game: number;
    const KEY_Gbreve: number;
    const KEY_Gcaron: number;
    const KEY_Gcedilla: number;
    const KEY_Gcircumflex: number;
    const KEY_Georgian_an: number;
    const KEY_Georgian_ban: number;
    const KEY_Georgian_can: number;
    const KEY_Georgian_char: number;
    const KEY_Georgian_chin: number;
    const KEY_Georgian_cil: number;
    const KEY_Georgian_don: number;
    const KEY_Georgian_en: number;
    const KEY_Georgian_fi: number;
    const KEY_Georgian_gan: number;
    const KEY_Georgian_ghan: number;
    const KEY_Georgian_hae: number;
    const KEY_Georgian_har: number;
    const KEY_Georgian_he: number;
    const KEY_Georgian_hie: number;
    const KEY_Georgian_hoe: number;
    const KEY_Georgian_in: number;
    const KEY_Georgian_jhan: number;
    const KEY_Georgian_jil: number;
    const KEY_Georgian_kan: number;
    const KEY_Georgian_khar: number;
    const KEY_Georgian_las: number;
    const KEY_Georgian_man: number;
    const KEY_Georgian_nar: number;
    const KEY_Georgian_on: number;
    const KEY_Georgian_par: number;
    const KEY_Georgian_phar: number;
    const KEY_Georgian_qar: number;
    const KEY_Georgian_rae: number;
    const KEY_Georgian_san: number;
    const KEY_Georgian_shin: number;
    const KEY_Georgian_tan: number;
    const KEY_Georgian_tar: number;
    const KEY_Georgian_un: number;
    const KEY_Georgian_vin: number;
    const KEY_Georgian_we: number;
    const KEY_Georgian_xan: number;
    const KEY_Georgian_zen: number;
    const KEY_Georgian_zhar: number;
    const KEY_Go: number;
    const KEY_Greek_ALPHA: number;
    const KEY_Greek_ALPHAaccent: number;
    const KEY_Greek_BETA: number;
    const KEY_Greek_CHI: number;
    const KEY_Greek_DELTA: number;
    const KEY_Greek_EPSILON: number;
    const KEY_Greek_EPSILONaccent: number;
    const KEY_Greek_ETA: number;
    const KEY_Greek_ETAaccent: number;
    const KEY_Greek_GAMMA: number;
    const KEY_Greek_IOTA: number;
    const KEY_Greek_IOTAaccent: number;
    const KEY_Greek_IOTAdiaeresis: number;
    const KEY_Greek_IOTAdieresis: number;
    const KEY_Greek_KAPPA: number;
    const KEY_Greek_LAMBDA: number;
    const KEY_Greek_LAMDA: number;
    const KEY_Greek_MU: number;
    const KEY_Greek_NU: number;
    const KEY_Greek_OMEGA: number;
    const KEY_Greek_OMEGAaccent: number;
    const KEY_Greek_OMICRON: number;
    const KEY_Greek_OMICRONaccent: number;
    const KEY_Greek_PHI: number;
    const KEY_Greek_PI: number;
    const KEY_Greek_PSI: number;
    const KEY_Greek_RHO: number;
    const KEY_Greek_SIGMA: number;
    const KEY_Greek_TAU: number;
    const KEY_Greek_THETA: number;
    const KEY_Greek_UPSILON: number;
    const KEY_Greek_UPSILONaccent: number;
    const KEY_Greek_UPSILONdieresis: number;
    const KEY_Greek_XI: number;
    const KEY_Greek_ZETA: number;
    const KEY_Greek_accentdieresis: number;
    const KEY_Greek_alpha: number;
    const KEY_Greek_alphaaccent: number;
    const KEY_Greek_beta: number;
    const KEY_Greek_chi: number;
    const KEY_Greek_delta: number;
    const KEY_Greek_epsilon: number;
    const KEY_Greek_epsilonaccent: number;
    const KEY_Greek_eta: number;
    const KEY_Greek_etaaccent: number;
    const KEY_Greek_finalsmallsigma: number;
    const KEY_Greek_gamma: number;
    const KEY_Greek_horizbar: number;
    const KEY_Greek_iota: number;
    const KEY_Greek_iotaaccent: number;
    const KEY_Greek_iotaaccentdieresis: number;
    const KEY_Greek_iotadieresis: number;
    const KEY_Greek_kappa: number;
    const KEY_Greek_lambda: number;
    const KEY_Greek_lamda: number;
    const KEY_Greek_mu: number;
    const KEY_Greek_nu: number;
    const KEY_Greek_omega: number;
    const KEY_Greek_omegaaccent: number;
    const KEY_Greek_omicron: number;
    const KEY_Greek_omicronaccent: number;
    const KEY_Greek_phi: number;
    const KEY_Greek_pi: number;
    const KEY_Greek_psi: number;
    const KEY_Greek_rho: number;
    const KEY_Greek_sigma: number;
    const KEY_Greek_switch: number;
    const KEY_Greek_tau: number;
    const KEY_Greek_theta: number;
    const KEY_Greek_upsilon: number;
    const KEY_Greek_upsilonaccent: number;
    const KEY_Greek_upsilonaccentdieresis: number;
    const KEY_Greek_upsilondieresis: number;
    const KEY_Greek_xi: number;
    const KEY_Greek_zeta: number;
    const KEY_Green: number;
    const KEY_H: number;
    const KEY_Hangul: number;
    const KEY_Hangul_A: number;
    const KEY_Hangul_AE: number;
    const KEY_Hangul_AraeA: number;
    const KEY_Hangul_AraeAE: number;
    const KEY_Hangul_Banja: number;
    const KEY_Hangul_Cieuc: number;
    const KEY_Hangul_Codeinput: number;
    const KEY_Hangul_Dikeud: number;
    const KEY_Hangul_E: number;
    const KEY_Hangul_EO: number;
    const KEY_Hangul_EU: number;
    const KEY_Hangul_End: number;
    const KEY_Hangul_Hanja: number;
    const KEY_Hangul_Hieuh: number;
    const KEY_Hangul_I: number;
    const KEY_Hangul_Ieung: number;
    const KEY_Hangul_J_Cieuc: number;
    const KEY_Hangul_J_Dikeud: number;
    const KEY_Hangul_J_Hieuh: number;
    const KEY_Hangul_J_Ieung: number;
    const KEY_Hangul_J_Jieuj: number;
    const KEY_Hangul_J_Khieuq: number;
    const KEY_Hangul_J_Kiyeog: number;
    const KEY_Hangul_J_KiyeogSios: number;
    const KEY_Hangul_J_KkogjiDalrinIeung: number;
    const KEY_Hangul_J_Mieum: number;
    const KEY_Hangul_J_Nieun: number;
    const KEY_Hangul_J_NieunHieuh: number;
    const KEY_Hangul_J_NieunJieuj: number;
    const KEY_Hangul_J_PanSios: number;
    const KEY_Hangul_J_Phieuf: number;
    const KEY_Hangul_J_Pieub: number;
    const KEY_Hangul_J_PieubSios: number;
    const KEY_Hangul_J_Rieul: number;
    const KEY_Hangul_J_RieulHieuh: number;
    const KEY_Hangul_J_RieulKiyeog: number;
    const KEY_Hangul_J_RieulMieum: number;
    const KEY_Hangul_J_RieulPhieuf: number;
    const KEY_Hangul_J_RieulPieub: number;
    const KEY_Hangul_J_RieulSios: number;
    const KEY_Hangul_J_RieulTieut: number;
    const KEY_Hangul_J_Sios: number;
    const KEY_Hangul_J_SsangKiyeog: number;
    const KEY_Hangul_J_SsangSios: number;
    const KEY_Hangul_J_Tieut: number;
    const KEY_Hangul_J_YeorinHieuh: number;
    const KEY_Hangul_Jamo: number;
    const KEY_Hangul_Jeonja: number;
    const KEY_Hangul_Jieuj: number;
    const KEY_Hangul_Khieuq: number;
    const KEY_Hangul_Kiyeog: number;
    const KEY_Hangul_KiyeogSios: number;
    const KEY_Hangul_KkogjiDalrinIeung: number;
    const KEY_Hangul_Mieum: number;
    const KEY_Hangul_MultipleCandidate: number;
    const KEY_Hangul_Nieun: number;
    const KEY_Hangul_NieunHieuh: number;
    const KEY_Hangul_NieunJieuj: number;
    const KEY_Hangul_O: number;
    const KEY_Hangul_OE: number;
    const KEY_Hangul_PanSios: number;
    const KEY_Hangul_Phieuf: number;
    const KEY_Hangul_Pieub: number;
    const KEY_Hangul_PieubSios: number;
    const KEY_Hangul_PostHanja: number;
    const KEY_Hangul_PreHanja: number;
    const KEY_Hangul_PreviousCandidate: number;
    const KEY_Hangul_Rieul: number;
    const KEY_Hangul_RieulHieuh: number;
    const KEY_Hangul_RieulKiyeog: number;
    const KEY_Hangul_RieulMieum: number;
    const KEY_Hangul_RieulPhieuf: number;
    const KEY_Hangul_RieulPieub: number;
    const KEY_Hangul_RieulSios: number;
    const KEY_Hangul_RieulTieut: number;
    const KEY_Hangul_RieulYeorinHieuh: number;
    const KEY_Hangul_Romaja: number;
    const KEY_Hangul_SingleCandidate: number;
    const KEY_Hangul_Sios: number;
    const KEY_Hangul_Special: number;
    const KEY_Hangul_SsangDikeud: number;
    const KEY_Hangul_SsangJieuj: number;
    const KEY_Hangul_SsangKiyeog: number;
    const KEY_Hangul_SsangPieub: number;
    const KEY_Hangul_SsangSios: number;
    const KEY_Hangul_Start: number;
    const KEY_Hangul_SunkyeongeumMieum: number;
    const KEY_Hangul_SunkyeongeumPhieuf: number;
    const KEY_Hangul_SunkyeongeumPieub: number;
    const KEY_Hangul_Tieut: number;
    const KEY_Hangul_U: number;
    const KEY_Hangul_WA: number;
    const KEY_Hangul_WAE: number;
    const KEY_Hangul_WE: number;
    const KEY_Hangul_WEO: number;
    const KEY_Hangul_WI: number;
    const KEY_Hangul_YA: number;
    const KEY_Hangul_YAE: number;
    const KEY_Hangul_YE: number;
    const KEY_Hangul_YEO: number;
    const KEY_Hangul_YI: number;
    const KEY_Hangul_YO: number;
    const KEY_Hangul_YU: number;
    const KEY_Hangul_YeorinHieuh: number;
    const KEY_Hangul_switch: number;
    const KEY_Hankaku: number;
    const KEY_Hcircumflex: number;
    const KEY_Hebrew_switch: number;
    const KEY_Help: number;
    const KEY_Henkan: number;
    const KEY_Henkan_Mode: number;
    const KEY_Hibernate: number;
    const KEY_Hiragana: number;
    const KEY_Hiragana_Katakana: number;
    const KEY_History: number;
    const KEY_Home: number;
    const KEY_HomePage: number;
    const KEY_HotLinks: number;
    const KEY_Hstroke: number;
    const KEY_Hyper_L: number;
    const KEY_Hyper_R: number;
    const KEY_I: number;
    const KEY_ISO_Center_Object: number;
    const KEY_ISO_Continuous_Underline: number;
    const KEY_ISO_Discontinuous_Underline: number;
    const KEY_ISO_Emphasize: number;
    const KEY_ISO_Enter: number;
    const KEY_ISO_Fast_Cursor_Down: number;
    const KEY_ISO_Fast_Cursor_Left: number;
    const KEY_ISO_Fast_Cursor_Right: number;
    const KEY_ISO_Fast_Cursor_Up: number;
    const KEY_ISO_First_Group: number;
    const KEY_ISO_First_Group_Lock: number;
    const KEY_ISO_Group_Latch: number;
    const KEY_ISO_Group_Lock: number;
    const KEY_ISO_Group_Shift: number;
    const KEY_ISO_Last_Group: number;
    const KEY_ISO_Last_Group_Lock: number;
    const KEY_ISO_Left_Tab: number;
    const KEY_ISO_Level2_Latch: number;
    const KEY_ISO_Level3_Latch: number;
    const KEY_ISO_Level3_Lock: number;
    const KEY_ISO_Level3_Shift: number;
    const KEY_ISO_Level5_Latch: number;
    const KEY_ISO_Level5_Lock: number;
    const KEY_ISO_Level5_Shift: number;
    const KEY_ISO_Lock: number;
    const KEY_ISO_Move_Line_Down: number;
    const KEY_ISO_Move_Line_Up: number;
    const KEY_ISO_Next_Group: number;
    const KEY_ISO_Next_Group_Lock: number;
    const KEY_ISO_Partial_Line_Down: number;
    const KEY_ISO_Partial_Line_Up: number;
    const KEY_ISO_Partial_Space_Left: number;
    const KEY_ISO_Partial_Space_Right: number;
    const KEY_ISO_Prev_Group: number;
    const KEY_ISO_Prev_Group_Lock: number;
    const KEY_ISO_Release_Both_Margins: number;
    const KEY_ISO_Release_Margin_Left: number;
    const KEY_ISO_Release_Margin_Right: number;
    const KEY_ISO_Set_Margin_Left: number;
    const KEY_ISO_Set_Margin_Right: number;
    const KEY_Iabovedot: number;
    const KEY_Iacute: number;
    const KEY_Ibelowdot: number;
    const KEY_Ibreve: number;
    const KEY_Icircumflex: number;
    const KEY_Idiaeresis: number;
    const KEY_Igrave: number;
    const KEY_Ihook: number;
    const KEY_Imacron: number;
    const KEY_Insert: number;
    const KEY_Iogonek: number;
    const KEY_Itilde: number;
    const KEY_J: number;
    const KEY_Jcircumflex: number;
    const KEY_K: number;
    const KEY_KP_0: number;
    const KEY_KP_1: number;
    const KEY_KP_2: number;
    const KEY_KP_3: number;
    const KEY_KP_4: number;
    const KEY_KP_5: number;
    const KEY_KP_6: number;
    const KEY_KP_7: number;
    const KEY_KP_8: number;
    const KEY_KP_9: number;
    const KEY_KP_Add: number;
    const KEY_KP_Begin: number;
    const KEY_KP_Decimal: number;
    const KEY_KP_Delete: number;
    const KEY_KP_Divide: number;
    const KEY_KP_Down: number;
    const KEY_KP_End: number;
    const KEY_KP_Enter: number;
    const KEY_KP_Equal: number;
    const KEY_KP_F1: number;
    const KEY_KP_F2: number;
    const KEY_KP_F3: number;
    const KEY_KP_F4: number;
    const KEY_KP_Home: number;
    const KEY_KP_Insert: number;
    const KEY_KP_Left: number;
    const KEY_KP_Multiply: number;
    const KEY_KP_Next: number;
    const KEY_KP_Page_Down: number;
    const KEY_KP_Page_Up: number;
    const KEY_KP_Prior: number;
    const KEY_KP_Right: number;
    const KEY_KP_Separator: number;
    const KEY_KP_Space: number;
    const KEY_KP_Subtract: number;
    const KEY_KP_Tab: number;
    const KEY_KP_Up: number;
    const KEY_Kana_Lock: number;
    const KEY_Kana_Shift: number;
    const KEY_Kanji: number;
    const KEY_Kanji_Bangou: number;
    const KEY_Katakana: number;
    const KEY_KbdBrightnessDown: number;
    const KEY_KbdBrightnessUp: number;
    const KEY_KbdLightOnOff: number;
    const KEY_Kcedilla: number;
    const KEY_Korean_Won: number;
    const KEY_L: number;
    const KEY_L1: number;
    const KEY_L10: number;
    const KEY_L2: number;
    const KEY_L3: number;
    const KEY_L4: number;
    const KEY_L5: number;
    const KEY_L6: number;
    const KEY_L7: number;
    const KEY_L8: number;
    const KEY_L9: number;
    const KEY_Lacute: number;
    const KEY_Last_Virtual_Screen: number;
    const KEY_Launch0: number;
    const KEY_Launch1: number;
    const KEY_Launch2: number;
    const KEY_Launch3: number;
    const KEY_Launch4: number;
    const KEY_Launch5: number;
    const KEY_Launch6: number;
    const KEY_Launch7: number;
    const KEY_Launch8: number;
    const KEY_Launch9: number;
    const KEY_LaunchA: number;
    const KEY_LaunchB: number;
    const KEY_LaunchC: number;
    const KEY_LaunchD: number;
    const KEY_LaunchE: number;
    const KEY_LaunchF: number;
    const KEY_Lbelowdot: number;
    const KEY_Lcaron: number;
    const KEY_Lcedilla: number;
    const KEY_Left: number;
    const KEY_LightBulb: number;
    const KEY_Linefeed: number;
    const KEY_LiraSign: number;
    const KEY_LogGrabInfo: number;
    const KEY_LogOff: number;
    const KEY_LogWindowTree: number;
    const KEY_Lstroke: number;
    const KEY_M: number;
    const KEY_Mabovedot: number;
    const KEY_Macedonia_DSE: number;
    const KEY_Macedonia_GJE: number;
    const KEY_Macedonia_KJE: number;
    const KEY_Macedonia_dse: number;
    const KEY_Macedonia_gje: number;
    const KEY_Macedonia_kje: number;
    const KEY_Mae_Koho: number;
    const KEY_Mail: number;
    const KEY_MailForward: number;
    const KEY_Market: number;
    const KEY_Massyo: number;
    const KEY_Meeting: number;
    const KEY_Memo: number;
    const KEY_Menu: number;
    const KEY_MenuKB: number;
    const KEY_MenuPB: number;
    const KEY_Messenger: number;
    const KEY_Meta_L: number;
    const KEY_Meta_R: number;
    const KEY_MillSign: number;
    const KEY_ModeLock: number;
    const KEY_Mode_switch: number;
    const KEY_MonBrightnessDown: number;
    const KEY_MonBrightnessUp: number;
    const KEY_MouseKeys_Accel_Enable: number;
    const KEY_MouseKeys_Enable: number;
    const KEY_Muhenkan: number;
    const KEY_Multi_key: number;
    const KEY_MultipleCandidate: number;
    const KEY_Music: number;
    const KEY_MyComputer: number;
    const KEY_MySites: number;
    const KEY_N: number;
    const KEY_Nacute: number;
    const KEY_NairaSign: number;
    const KEY_Ncaron: number;
    const KEY_Ncedilla: number;
    const KEY_New: number;
    const KEY_NewSheqelSign: number;
    const KEY_News: number;
    const KEY_Next: number;
    const KEY_Next_VMode: number;
    const KEY_Next_Virtual_Screen: number;
    const KEY_Ntilde: number;
    const KEY_Num_Lock: number;
    const KEY_O: number;
    const KEY_OE: number;
    const KEY_Oacute: number;
    const KEY_Obarred: number;
    const KEY_Obelowdot: number;
    const KEY_Ocaron: number;
    const KEY_Ocircumflex: number;
    const KEY_Ocircumflexacute: number;
    const KEY_Ocircumflexbelowdot: number;
    const KEY_Ocircumflexgrave: number;
    const KEY_Ocircumflexhook: number;
    const KEY_Ocircumflextilde: number;
    const KEY_Odiaeresis: number;
    const KEY_Odoubleacute: number;
    const KEY_OfficeHome: number;
    const KEY_Ograve: number;
    const KEY_Ohook: number;
    const KEY_Ohorn: number;
    const KEY_Ohornacute: number;
    const KEY_Ohornbelowdot: number;
    const KEY_Ohorngrave: number;
    const KEY_Ohornhook: number;
    const KEY_Ohorntilde: number;
    const KEY_Omacron: number;
    const KEY_Ooblique: number;
    const KEY_Open: number;
    const KEY_OpenURL: number;
    const KEY_Option: number;
    const KEY_Oslash: number;
    const KEY_Otilde: number;
    const KEY_Overlay1_Enable: number;
    const KEY_Overlay2_Enable: number;
    const KEY_P: number;
    const KEY_Pabovedot: number;
    const KEY_Page_Down: number;
    const KEY_Page_Up: number;
    const KEY_Paste: number;
    const KEY_Pause: number;
    const KEY_PesetaSign: number;
    const KEY_Phone: number;
    const KEY_Pictures: number;
    const KEY_Pointer_Accelerate: number;
    const KEY_Pointer_Button1: number;
    const KEY_Pointer_Button2: number;
    const KEY_Pointer_Button3: number;
    const KEY_Pointer_Button4: number;
    const KEY_Pointer_Button5: number;
    const KEY_Pointer_Button_Dflt: number;
    const KEY_Pointer_DblClick1: number;
    const KEY_Pointer_DblClick2: number;
    const KEY_Pointer_DblClick3: number;
    const KEY_Pointer_DblClick4: number;
    const KEY_Pointer_DblClick5: number;
    const KEY_Pointer_DblClick_Dflt: number;
    const KEY_Pointer_DfltBtnNext: number;
    const KEY_Pointer_DfltBtnPrev: number;
    const KEY_Pointer_Down: number;
    const KEY_Pointer_DownLeft: number;
    const KEY_Pointer_DownRight: number;
    const KEY_Pointer_Drag1: number;
    const KEY_Pointer_Drag2: number;
    const KEY_Pointer_Drag3: number;
    const KEY_Pointer_Drag4: number;
    const KEY_Pointer_Drag5: number;
    const KEY_Pointer_Drag_Dflt: number;
    const KEY_Pointer_EnableKeys: number;
    const KEY_Pointer_Left: number;
    const KEY_Pointer_Right: number;
    const KEY_Pointer_Up: number;
    const KEY_Pointer_UpLeft: number;
    const KEY_Pointer_UpRight: number;
    const KEY_PowerDown: number;
    const KEY_PowerOff: number;
    const KEY_Prev_VMode: number;
    const KEY_Prev_Virtual_Screen: number;
    const KEY_PreviousCandidate: number;
    const KEY_Print: number;
    const KEY_Prior: number;
    const KEY_Q: number;
    const KEY_R: number;
    const KEY_R1: number;
    const KEY_R10: number;
    const KEY_R11: number;
    const KEY_R12: number;
    const KEY_R13: number;
    const KEY_R14: number;
    const KEY_R15: number;
    const KEY_R2: number;
    const KEY_R3: number;
    const KEY_R4: number;
    const KEY_R5: number;
    const KEY_R6: number;
    const KEY_R7: number;
    const KEY_R8: number;
    const KEY_R9: number;
    const KEY_Racute: number;
    const KEY_Rcaron: number;
    const KEY_Rcedilla: number;
    const KEY_Red: number;
    const KEY_Redo: number;
    const KEY_Refresh: number;
    const KEY_Reload: number;
    const KEY_RepeatKeys_Enable: number;
    const KEY_Reply: number;
    const KEY_Return: number;
    const KEY_Right: number;
    const KEY_RockerDown: number;
    const KEY_RockerEnter: number;
    const KEY_RockerUp: number;
    const KEY_Romaji: number;
    const KEY_RotateWindows: number;
    const KEY_RotationKB: number;
    const KEY_RotationPB: number;
    const KEY_RupeeSign: number;
    const KEY_S: number;
    const KEY_SCHWA: number;
    const KEY_Sabovedot: number;
    const KEY_Sacute: number;
    const KEY_Save: number;
    const KEY_Scaron: number;
    const KEY_Scedilla: number;
    const KEY_Scircumflex: number;
    const KEY_ScreenSaver: number;
    const KEY_ScrollClick: number;
    const KEY_ScrollDown: number;
    const KEY_ScrollUp: number;
    const KEY_Scroll_Lock: number;
    const KEY_Search: number;
    const KEY_Select: number;
    const KEY_SelectButton: number;
    const KEY_Send: number;
    const KEY_Serbian_DJE: number;
    const KEY_Serbian_DZE: number;
    const KEY_Serbian_JE: number;
    const KEY_Serbian_LJE: number;
    const KEY_Serbian_NJE: number;
    const KEY_Serbian_TSHE: number;
    const KEY_Serbian_dje: number;
    const KEY_Serbian_dze: number;
    const KEY_Serbian_je: number;
    const KEY_Serbian_lje: number;
    const KEY_Serbian_nje: number;
    const KEY_Serbian_tshe: number;
    const KEY_Shift_L: number;
    const KEY_Shift_Lock: number;
    const KEY_Shift_R: number;
    const KEY_Shop: number;
    const KEY_SingleCandidate: number;
    const KEY_Sinh_a: number;
    const KEY_Sinh_aa: number;
    const KEY_Sinh_aa2: number;
    const KEY_Sinh_ae: number;
    const KEY_Sinh_ae2: number;
    const KEY_Sinh_aee: number;
    const KEY_Sinh_aee2: number;
    const KEY_Sinh_ai: number;
    const KEY_Sinh_ai2: number;
    const KEY_Sinh_al: number;
    const KEY_Sinh_au: number;
    const KEY_Sinh_au2: number;
    const KEY_Sinh_ba: number;
    const KEY_Sinh_bha: number;
    const KEY_Sinh_ca: number;
    const KEY_Sinh_cha: number;
    const KEY_Sinh_dda: number;
    const KEY_Sinh_ddha: number;
    const KEY_Sinh_dha: number;
    const KEY_Sinh_dhha: number;
    const KEY_Sinh_e: number;
    const KEY_Sinh_e2: number;
    const KEY_Sinh_ee: number;
    const KEY_Sinh_ee2: number;
    const KEY_Sinh_fa: number;
    const KEY_Sinh_ga: number;
    const KEY_Sinh_gha: number;
    const KEY_Sinh_h2: number;
    const KEY_Sinh_ha: number;
    const KEY_Sinh_i: number;
    const KEY_Sinh_i2: number;
    const KEY_Sinh_ii: number;
    const KEY_Sinh_ii2: number;
    const KEY_Sinh_ja: number;
    const KEY_Sinh_jha: number;
    const KEY_Sinh_jnya: number;
    const KEY_Sinh_ka: number;
    const KEY_Sinh_kha: number;
    const KEY_Sinh_kunddaliya: number;
    const KEY_Sinh_la: number;
    const KEY_Sinh_lla: number;
    const KEY_Sinh_lu: number;
    const KEY_Sinh_lu2: number;
    const KEY_Sinh_luu: number;
    const KEY_Sinh_luu2: number;
    const KEY_Sinh_ma: number;
    const KEY_Sinh_mba: number;
    const KEY_Sinh_na: number;
    const KEY_Sinh_ndda: number;
    const KEY_Sinh_ndha: number;
    const KEY_Sinh_ng: number;
    const KEY_Sinh_ng2: number;
    const KEY_Sinh_nga: number;
    const KEY_Sinh_nja: number;
    const KEY_Sinh_nna: number;
    const KEY_Sinh_nya: number;
    const KEY_Sinh_o: number;
    const KEY_Sinh_o2: number;
    const KEY_Sinh_oo: number;
    const KEY_Sinh_oo2: number;
    const KEY_Sinh_pa: number;
    const KEY_Sinh_pha: number;
    const KEY_Sinh_ra: number;
    const KEY_Sinh_ri: number;
    const KEY_Sinh_rii: number;
    const KEY_Sinh_ru2: number;
    const KEY_Sinh_ruu2: number;
    const KEY_Sinh_sa: number;
    const KEY_Sinh_sha: number;
    const KEY_Sinh_ssha: number;
    const KEY_Sinh_tha: number;
    const KEY_Sinh_thha: number;
    const KEY_Sinh_tta: number;
    const KEY_Sinh_ttha: number;
    const KEY_Sinh_u: number;
    const KEY_Sinh_u2: number;
    const KEY_Sinh_uu: number;
    const KEY_Sinh_uu2: number;
    const KEY_Sinh_va: number;
    const KEY_Sinh_ya: number;
    const KEY_Sleep: number;
    const KEY_SlowKeys_Enable: number;
    const KEY_Spell: number;
    const KEY_SplitScreen: number;
    const KEY_Standby: number;
    const KEY_Start: number;
    const KEY_StickyKeys_Enable: number;
    const KEY_Stop: number;
    const KEY_Subtitle: number;
    const KEY_Super_L: number;
    const KEY_Super_R: number;
    const KEY_Support: number;
    const KEY_Suspend: number;
    const KEY_Switch_VT_1: number;
    const KEY_Switch_VT_10: number;
    const KEY_Switch_VT_11: number;
    const KEY_Switch_VT_12: number;
    const KEY_Switch_VT_2: number;
    const KEY_Switch_VT_3: number;
    const KEY_Switch_VT_4: number;
    const KEY_Switch_VT_5: number;
    const KEY_Switch_VT_6: number;
    const KEY_Switch_VT_7: number;
    const KEY_Switch_VT_8: number;
    const KEY_Switch_VT_9: number;
    const KEY_Sys_Req: number;
    const KEY_T: number;
    const KEY_THORN: number;
    const KEY_Tab: number;
    const KEY_Tabovedot: number;
    const KEY_TaskPane: number;
    const KEY_Tcaron: number;
    const KEY_Tcedilla: number;
    const KEY_Terminal: number;
    const KEY_Terminate_Server: number;
    const KEY_Thai_baht: number;
    const KEY_Thai_bobaimai: number;
    const KEY_Thai_chochan: number;
    const KEY_Thai_chochang: number;
    const KEY_Thai_choching: number;
    const KEY_Thai_chochoe: number;
    const KEY_Thai_dochada: number;
    const KEY_Thai_dodek: number;
    const KEY_Thai_fofa: number;
    const KEY_Thai_fofan: number;
    const KEY_Thai_hohip: number;
    const KEY_Thai_honokhuk: number;
    const KEY_Thai_khokhai: number;
    const KEY_Thai_khokhon: number;
    const KEY_Thai_khokhuat: number;
    const KEY_Thai_khokhwai: number;
    const KEY_Thai_khorakhang: number;
    const KEY_Thai_kokai: number;
    const KEY_Thai_lakkhangyao: number;
    const KEY_Thai_lekchet: number;
    const KEY_Thai_lekha: number;
    const KEY_Thai_lekhok: number;
    const KEY_Thai_lekkao: number;
    const KEY_Thai_leknung: number;
    const KEY_Thai_lekpaet: number;
    const KEY_Thai_leksam: number;
    const KEY_Thai_leksi: number;
    const KEY_Thai_leksong: number;
    const KEY_Thai_leksun: number;
    const KEY_Thai_lochula: number;
    const KEY_Thai_loling: number;
    const KEY_Thai_lu: number;
    const KEY_Thai_maichattawa: number;
    const KEY_Thai_maiek: number;
    const KEY_Thai_maihanakat: number;
    const KEY_Thai_maihanakat_maitho: number;
    const KEY_Thai_maitaikhu: number;
    const KEY_Thai_maitho: number;
    const KEY_Thai_maitri: number;
    const KEY_Thai_maiyamok: number;
    const KEY_Thai_moma: number;
    const KEY_Thai_ngongu: number;
    const KEY_Thai_nikhahit: number;
    const KEY_Thai_nonen: number;
    const KEY_Thai_nonu: number;
    const KEY_Thai_oang: number;
    const KEY_Thai_paiyannoi: number;
    const KEY_Thai_phinthu: number;
    const KEY_Thai_phophan: number;
    const KEY_Thai_phophung: number;
    const KEY_Thai_phosamphao: number;
    const KEY_Thai_popla: number;
    const KEY_Thai_rorua: number;
    const KEY_Thai_ru: number;
    const KEY_Thai_saraa: number;
    const KEY_Thai_saraaa: number;
    const KEY_Thai_saraae: number;
    const KEY_Thai_saraaimaimalai: number;
    const KEY_Thai_saraaimaimuan: number;
    const KEY_Thai_saraam: number;
    const KEY_Thai_sarae: number;
    const KEY_Thai_sarai: number;
    const KEY_Thai_saraii: number;
    const KEY_Thai_sarao: number;
    const KEY_Thai_sarau: number;
    const KEY_Thai_saraue: number;
    const KEY_Thai_sarauee: number;
    const KEY_Thai_sarauu: number;
    const KEY_Thai_sorusi: number;
    const KEY_Thai_sosala: number;
    const KEY_Thai_soso: number;
    const KEY_Thai_sosua: number;
    const KEY_Thai_thanthakhat: number;
    const KEY_Thai_thonangmontho: number;
    const KEY_Thai_thophuthao: number;
    const KEY_Thai_thothahan: number;
    const KEY_Thai_thothan: number;
    const KEY_Thai_thothong: number;
    const KEY_Thai_thothung: number;
    const KEY_Thai_topatak: number;
    const KEY_Thai_totao: number;
    const KEY_Thai_wowaen: number;
    const KEY_Thai_yoyak: number;
    const KEY_Thai_yoying: number;
    const KEY_Thorn: number;
    const KEY_Time: number;
    const KEY_ToDoList: number;
    const KEY_Tools: number;
    const KEY_TopMenu: number;
    const KEY_TouchpadOff: number;
    const KEY_TouchpadOn: number;
    const KEY_TouchpadToggle: number;
    const KEY_Touroku: number;
    const KEY_Travel: number;
    const KEY_Tslash: number;
    const KEY_U: number;
    const KEY_UWB: number;
    const KEY_Uacute: number;
    const KEY_Ubelowdot: number;
    const KEY_Ubreve: number;
    const KEY_Ucircumflex: number;
    const KEY_Udiaeresis: number;
    const KEY_Udoubleacute: number;
    const KEY_Ugrave: number;
    const KEY_Uhook: number;
    const KEY_Uhorn: number;
    const KEY_Uhornacute: number;
    const KEY_Uhornbelowdot: number;
    const KEY_Uhorngrave: number;
    const KEY_Uhornhook: number;
    const KEY_Uhorntilde: number;
    const KEY_Ukrainian_GHE_WITH_UPTURN: number;
    const KEY_Ukrainian_I: number;
    const KEY_Ukrainian_IE: number;
    const KEY_Ukrainian_YI: number;
    const KEY_Ukrainian_ghe_with_upturn: number;
    const KEY_Ukrainian_i: number;
    const KEY_Ukrainian_ie: number;
    const KEY_Ukrainian_yi: number;
    const KEY_Ukranian_I: number;
    const KEY_Ukranian_JE: number;
    const KEY_Ukranian_YI: number;
    const KEY_Ukranian_i: number;
    const KEY_Ukranian_je: number;
    const KEY_Ukranian_yi: number;
    const KEY_Umacron: number;
    const KEY_Undo: number;
    const KEY_Ungrab: number;
    const KEY_Uogonek: number;
    const KEY_Up: number;
    const KEY_Uring: number;
    const KEY_User1KB: number;
    const KEY_User2KB: number;
    const KEY_UserPB: number;
    const KEY_Utilde: number;
    const KEY_V: number;
    const KEY_VendorHome: number;
    const KEY_Video: number;
    const KEY_View: number;
    const KEY_VoidSymbol: number;
    const KEY_W: number;
    const KEY_WLAN: number;
    const KEY_WWW: number;
    const KEY_Wacute: number;
    const KEY_WakeUp: number;
    const KEY_Wcircumflex: number;
    const KEY_Wdiaeresis: number;
    const KEY_WebCam: number;
    const KEY_Wgrave: number;
    const KEY_WheelButton: number;
    const KEY_WindowClear: number;
    const KEY_WonSign: number;
    const KEY_Word: number;
    const KEY_X: number;
    const KEY_Xabovedot: number;
    const KEY_Xfer: number;
    const KEY_Y: number;
    const KEY_Yacute: number;
    const KEY_Ybelowdot: number;
    const KEY_Ycircumflex: number;
    const KEY_Ydiaeresis: number;
    const KEY_Yellow: number;
    const KEY_Ygrave: number;
    const KEY_Yhook: number;
    const KEY_Ytilde: number;
    const KEY_Z: number;
    const KEY_Zabovedot: number;
    const KEY_Zacute: number;
    const KEY_Zcaron: number;
    const KEY_Zen_Koho: number;
    const KEY_Zenkaku: number;
    const KEY_Zenkaku_Hankaku: number;
    const KEY_ZoomIn: number;
    const KEY_ZoomOut: number;
    const KEY_Zstroke: number;
    const KEY_a: number;
    const KEY_aacute: number;
    const KEY_abelowdot: number;
    const KEY_abovedot: number;
    const KEY_abreve: number;
    const KEY_abreveacute: number;
    const KEY_abrevebelowdot: number;
    const KEY_abrevegrave: number;
    const KEY_abrevehook: number;
    const KEY_abrevetilde: number;
    const KEY_acircumflex: number;
    const KEY_acircumflexacute: number;
    const KEY_acircumflexbelowdot: number;
    const KEY_acircumflexgrave: number;
    const KEY_acircumflexhook: number;
    const KEY_acircumflextilde: number;
    const KEY_acute: number;
    const KEY_adiaeresis: number;
    const KEY_ae: number;
    const KEY_agrave: number;
    const KEY_ahook: number;
    const KEY_amacron: number;
    const KEY_ampersand: number;
    const KEY_aogonek: number;
    const KEY_apostrophe: number;
    const KEY_approxeq: number;
    const KEY_approximate: number;
    const KEY_aring: number;
    const KEY_asciicircum: number;
    const KEY_asciitilde: number;
    const KEY_asterisk: number;
    const KEY_at: number;
    const KEY_atilde: number;
    const KEY_b: number;
    const KEY_babovedot: number;
    const KEY_backslash: number;
    const KEY_ballotcross: number;
    const KEY_bar: number;
    const KEY_because: number;
    const KEY_blank: number;
    const KEY_botintegral: number;
    const KEY_botleftparens: number;
    const KEY_botleftsqbracket: number;
    const KEY_botleftsummation: number;
    const KEY_botrightparens: number;
    const KEY_botrightsqbracket: number;
    const KEY_botrightsummation: number;
    const KEY_bott: number;
    const KEY_botvertsummationconnector: number;
    const KEY_braceleft: number;
    const KEY_braceright: number;
    const KEY_bracketleft: number;
    const KEY_bracketright: number;
    const KEY_braille_blank: number;
    const KEY_braille_dot_1: number;
    const KEY_braille_dot_10: number;
    const KEY_braille_dot_2: number;
    const KEY_braille_dot_3: number;
    const KEY_braille_dot_4: number;
    const KEY_braille_dot_5: number;
    const KEY_braille_dot_6: number;
    const KEY_braille_dot_7: number;
    const KEY_braille_dot_8: number;
    const KEY_braille_dot_9: number;
    const KEY_braille_dots_1: number;
    const KEY_braille_dots_12: number;
    const KEY_braille_dots_123: number;
    const KEY_braille_dots_1234: number;
    const KEY_braille_dots_12345: number;
    const KEY_braille_dots_123456: number;
    const KEY_braille_dots_1234567: number;
    const KEY_braille_dots_12345678: number;
    const KEY_braille_dots_1234568: number;
    const KEY_braille_dots_123457: number;
    const KEY_braille_dots_1234578: number;
    const KEY_braille_dots_123458: number;
    const KEY_braille_dots_12346: number;
    const KEY_braille_dots_123467: number;
    const KEY_braille_dots_1234678: number;
    const KEY_braille_dots_123468: number;
    const KEY_braille_dots_12347: number;
    const KEY_braille_dots_123478: number;
    const KEY_braille_dots_12348: number;
    const KEY_braille_dots_1235: number;
    const KEY_braille_dots_12356: number;
    const KEY_braille_dots_123567: number;
    const KEY_braille_dots_1235678: number;
    const KEY_braille_dots_123568: number;
    const KEY_braille_dots_12357: number;
    const KEY_braille_dots_123578: number;
    const KEY_braille_dots_12358: number;
    const KEY_braille_dots_1236: number;
    const KEY_braille_dots_12367: number;
    const KEY_braille_dots_123678: number;
    const KEY_braille_dots_12368: number;
    const KEY_braille_dots_1237: number;
    const KEY_braille_dots_12378: number;
    const KEY_braille_dots_1238: number;
    const KEY_braille_dots_124: number;
    const KEY_braille_dots_1245: number;
    const KEY_braille_dots_12456: number;
    const KEY_braille_dots_124567: number;
    const KEY_braille_dots_1245678: number;
    const KEY_braille_dots_124568: number;
    const KEY_braille_dots_12457: number;
    const KEY_braille_dots_124578: number;
    const KEY_braille_dots_12458: number;
    const KEY_braille_dots_1246: number;
    const KEY_braille_dots_12467: number;
    const KEY_braille_dots_124678: number;
    const KEY_braille_dots_12468: number;
    const KEY_braille_dots_1247: number;
    const KEY_braille_dots_12478: number;
    const KEY_braille_dots_1248: number;
    const KEY_braille_dots_125: number;
    const KEY_braille_dots_1256: number;
    const KEY_braille_dots_12567: number;
    const KEY_braille_dots_125678: number;
    const KEY_braille_dots_12568: number;
    const KEY_braille_dots_1257: number;
    const KEY_braille_dots_12578: number;
    const KEY_braille_dots_1258: number;
    const KEY_braille_dots_126: number;
    const KEY_braille_dots_1267: number;
    const KEY_braille_dots_12678: number;
    const KEY_braille_dots_1268: number;
    const KEY_braille_dots_127: number;
    const KEY_braille_dots_1278: number;
    const KEY_braille_dots_128: number;
    const KEY_braille_dots_13: number;
    const KEY_braille_dots_134: number;
    const KEY_braille_dots_1345: number;
    const KEY_braille_dots_13456: number;
    const KEY_braille_dots_134567: number;
    const KEY_braille_dots_1345678: number;
    const KEY_braille_dots_134568: number;
    const KEY_braille_dots_13457: number;
    const KEY_braille_dots_134578: number;
    const KEY_braille_dots_13458: number;
    const KEY_braille_dots_1346: number;
    const KEY_braille_dots_13467: number;
    const KEY_braille_dots_134678: number;
    const KEY_braille_dots_13468: number;
    const KEY_braille_dots_1347: number;
    const KEY_braille_dots_13478: number;
    const KEY_braille_dots_1348: number;
    const KEY_braille_dots_135: number;
    const KEY_braille_dots_1356: number;
    const KEY_braille_dots_13567: number;
    const KEY_braille_dots_135678: number;
    const KEY_braille_dots_13568: number;
    const KEY_braille_dots_1357: number;
    const KEY_braille_dots_13578: number;
    const KEY_braille_dots_1358: number;
    const KEY_braille_dots_136: number;
    const KEY_braille_dots_1367: number;
    const KEY_braille_dots_13678: number;
    const KEY_braille_dots_1368: number;
    const KEY_braille_dots_137: number;
    const KEY_braille_dots_1378: number;
    const KEY_braille_dots_138: number;
    const KEY_braille_dots_14: number;
    const KEY_braille_dots_145: number;
    const KEY_braille_dots_1456: number;
    const KEY_braille_dots_14567: number;
    const KEY_braille_dots_145678: number;
    const KEY_braille_dots_14568: number;
    const KEY_braille_dots_1457: number;
    const KEY_braille_dots_14578: number;
    const KEY_braille_dots_1458: number;
    const KEY_braille_dots_146: number;
    const KEY_braille_dots_1467: number;
    const KEY_braille_dots_14678: number;
    const KEY_braille_dots_1468: number;
    const KEY_braille_dots_147: number;
    const KEY_braille_dots_1478: number;
    const KEY_braille_dots_148: number;
    const KEY_braille_dots_15: number;
    const KEY_braille_dots_156: number;
    const KEY_braille_dots_1567: number;
    const KEY_braille_dots_15678: number;
    const KEY_braille_dots_1568: number;
    const KEY_braille_dots_157: number;
    const KEY_braille_dots_1578: number;
    const KEY_braille_dots_158: number;
    const KEY_braille_dots_16: number;
    const KEY_braille_dots_167: number;
    const KEY_braille_dots_1678: number;
    const KEY_braille_dots_168: number;
    const KEY_braille_dots_17: number;
    const KEY_braille_dots_178: number;
    const KEY_braille_dots_18: number;
    const KEY_braille_dots_2: number;
    const KEY_braille_dots_23: number;
    const KEY_braille_dots_234: number;
    const KEY_braille_dots_2345: number;
    const KEY_braille_dots_23456: number;
    const KEY_braille_dots_234567: number;
    const KEY_braille_dots_2345678: number;
    const KEY_braille_dots_234568: number;
    const KEY_braille_dots_23457: number;
    const KEY_braille_dots_234578: number;
    const KEY_braille_dots_23458: number;
    const KEY_braille_dots_2346: number;
    const KEY_braille_dots_23467: number;
    const KEY_braille_dots_234678: number;
    const KEY_braille_dots_23468: number;
    const KEY_braille_dots_2347: number;
    const KEY_braille_dots_23478: number;
    const KEY_braille_dots_2348: number;
    const KEY_braille_dots_235: number;
    const KEY_braille_dots_2356: number;
    const KEY_braille_dots_23567: number;
    const KEY_braille_dots_235678: number;
    const KEY_braille_dots_23568: number;
    const KEY_braille_dots_2357: number;
    const KEY_braille_dots_23578: number;
    const KEY_braille_dots_2358: number;
    const KEY_braille_dots_236: number;
    const KEY_braille_dots_2367: number;
    const KEY_braille_dots_23678: number;
    const KEY_braille_dots_2368: number;
    const KEY_braille_dots_237: number;
    const KEY_braille_dots_2378: number;
    const KEY_braille_dots_238: number;
    const KEY_braille_dots_24: number;
    const KEY_braille_dots_245: number;
    const KEY_braille_dots_2456: number;
    const KEY_braille_dots_24567: number;
    const KEY_braille_dots_245678: number;
    const KEY_braille_dots_24568: number;
    const KEY_braille_dots_2457: number;
    const KEY_braille_dots_24578: number;
    const KEY_braille_dots_2458: number;
    const KEY_braille_dots_246: number;
    const KEY_braille_dots_2467: number;
    const KEY_braille_dots_24678: number;
    const KEY_braille_dots_2468: number;
    const KEY_braille_dots_247: number;
    const KEY_braille_dots_2478: number;
    const KEY_braille_dots_248: number;
    const KEY_braille_dots_25: number;
    const KEY_braille_dots_256: number;
    const KEY_braille_dots_2567: number;
    const KEY_braille_dots_25678: number;
    const KEY_braille_dots_2568: number;
    const KEY_braille_dots_257: number;
    const KEY_braille_dots_2578: number;
    const KEY_braille_dots_258: number;
    const KEY_braille_dots_26: number;
    const KEY_braille_dots_267: number;
    const KEY_braille_dots_2678: number;
    const KEY_braille_dots_268: number;
    const KEY_braille_dots_27: number;
    const KEY_braille_dots_278: number;
    const KEY_braille_dots_28: number;
    const KEY_braille_dots_3: number;
    const KEY_braille_dots_34: number;
    const KEY_braille_dots_345: number;
    const KEY_braille_dots_3456: number;
    const KEY_braille_dots_34567: number;
    const KEY_braille_dots_345678: number;
    const KEY_braille_dots_34568: number;
    const KEY_braille_dots_3457: number;
    const KEY_braille_dots_34578: number;
    const KEY_braille_dots_3458: number;
    const KEY_braille_dots_346: number;
    const KEY_braille_dots_3467: number;
    const KEY_braille_dots_34678: number;
    const KEY_braille_dots_3468: number;
    const KEY_braille_dots_347: number;
    const KEY_braille_dots_3478: number;
    const KEY_braille_dots_348: number;
    const KEY_braille_dots_35: number;
    const KEY_braille_dots_356: number;
    const KEY_braille_dots_3567: number;
    const KEY_braille_dots_35678: number;
    const KEY_braille_dots_3568: number;
    const KEY_braille_dots_357: number;
    const KEY_braille_dots_3578: number;
    const KEY_braille_dots_358: number;
    const KEY_braille_dots_36: number;
    const KEY_braille_dots_367: number;
    const KEY_braille_dots_3678: number;
    const KEY_braille_dots_368: number;
    const KEY_braille_dots_37: number;
    const KEY_braille_dots_378: number;
    const KEY_braille_dots_38: number;
    const KEY_braille_dots_4: number;
    const KEY_braille_dots_45: number;
    const KEY_braille_dots_456: number;
    const KEY_braille_dots_4567: number;
    const KEY_braille_dots_45678: number;
    const KEY_braille_dots_4568: number;
    const KEY_braille_dots_457: number;
    const KEY_braille_dots_4578: number;
    const KEY_braille_dots_458: number;
    const KEY_braille_dots_46: number;
    const KEY_braille_dots_467: number;
    const KEY_braille_dots_4678: number;
    const KEY_braille_dots_468: number;
    const KEY_braille_dots_47: number;
    const KEY_braille_dots_478: number;
    const KEY_braille_dots_48: number;
    const KEY_braille_dots_5: number;
    const KEY_braille_dots_56: number;
    const KEY_braille_dots_567: number;
    const KEY_braille_dots_5678: number;
    const KEY_braille_dots_568: number;
    const KEY_braille_dots_57: number;
    const KEY_braille_dots_578: number;
    const KEY_braille_dots_58: number;
    const KEY_braille_dots_6: number;
    const KEY_braille_dots_67: number;
    const KEY_braille_dots_678: number;
    const KEY_braille_dots_68: number;
    const KEY_braille_dots_7: number;
    const KEY_braille_dots_78: number;
    const KEY_braille_dots_8: number;
    const KEY_breve: number;
    const KEY_brokenbar: number;
    const KEY_c: number;
    const KEY_c_h: number;
    const KEY_cabovedot: number;
    const KEY_cacute: number;
    const KEY_careof: number;
    const KEY_caret: number;
    const KEY_caron: number;
    const KEY_ccaron: number;
    const KEY_ccedilla: number;
    const KEY_ccircumflex: number;
    const KEY_cedilla: number;
    const KEY_cent: number;
    const KEY_ch: number;
    const KEY_checkerboard: number;
    const KEY_checkmark: number;
    const KEY_circle: number;
    const KEY_club: number;
    const KEY_colon: number;
    const KEY_comma: number;
    const KEY_containsas: number;
    const KEY_copyright: number;
    const KEY_cr: number;
    const KEY_crossinglines: number;
    const KEY_cuberoot: number;
    const KEY_currency: number;
    const KEY_cursor: number;
    const KEY_d: number;
    const KEY_dabovedot: number;
    const KEY_dagger: number;
    const KEY_dcaron: number;
    const KEY_dead_A: number;
    const KEY_dead_E: number;
    const KEY_dead_I: number;
    const KEY_dead_O: number;
    const KEY_dead_U: number;
    const KEY_dead_a: number;
    const KEY_dead_abovecomma: number;
    const KEY_dead_abovedot: number;
    const KEY_dead_abovereversedcomma: number;
    const KEY_dead_abovering: number;
    const KEY_dead_aboveverticalline: number;
    const KEY_dead_acute: number;
    const KEY_dead_belowbreve: number;
    const KEY_dead_belowcircumflex: number;
    const KEY_dead_belowcomma: number;
    const KEY_dead_belowdiaeresis: number;
    const KEY_dead_belowdot: number;
    const KEY_dead_belowmacron: number;
    const KEY_dead_belowring: number;
    const KEY_dead_belowtilde: number;
    const KEY_dead_belowverticalline: number;
    const KEY_dead_breve: number;
    const KEY_dead_capital_schwa: number;
    const KEY_dead_caron: number;
    const KEY_dead_cedilla: number;
    const KEY_dead_circumflex: number;
    const KEY_dead_currency: number;
    const KEY_dead_dasia: number;
    const KEY_dead_diaeresis: number;
    const KEY_dead_doubleacute: number;
    const KEY_dead_doublegrave: number;
    const KEY_dead_e: number;
    const KEY_dead_grave: number;
    const KEY_dead_greek: number;
    const KEY_dead_hook: number;
    const KEY_dead_horn: number;
    const KEY_dead_i: number;
    const KEY_dead_invertedbreve: number;
    const KEY_dead_iota: number;
    const KEY_dead_longsolidusoverlay: number;
    const KEY_dead_lowline: number;
    const KEY_dead_macron: number;
    const KEY_dead_o: number;
    const KEY_dead_ogonek: number;
    const KEY_dead_perispomeni: number;
    const KEY_dead_psili: number;
    const KEY_dead_semivoiced_sound: number;
    const KEY_dead_small_schwa: number;
    const KEY_dead_stroke: number;
    const KEY_dead_tilde: number;
    const KEY_dead_u: number;
    const KEY_dead_voiced_sound: number;
    const KEY_decimalpoint: number;
    const KEY_degree: number;
    const KEY_diaeresis: number;
    const KEY_diamond: number;
    const KEY_digitspace: number;
    const KEY_dintegral: number;
    const KEY_division: number;
    const KEY_dollar: number;
    const KEY_doubbaselinedot: number;
    const KEY_doubleacute: number;
    const KEY_doubledagger: number;
    const KEY_doublelowquotemark: number;
    const KEY_downarrow: number;
    const KEY_downcaret: number;
    const KEY_downshoe: number;
    const KEY_downstile: number;
    const KEY_downtack: number;
    const KEY_dstroke: number;
    const KEY_e: number;
    const KEY_eabovedot: number;
    const KEY_eacute: number;
    const KEY_ebelowdot: number;
    const KEY_ecaron: number;
    const KEY_ecircumflex: number;
    const KEY_ecircumflexacute: number;
    const KEY_ecircumflexbelowdot: number;
    const KEY_ecircumflexgrave: number;
    const KEY_ecircumflexhook: number;
    const KEY_ecircumflextilde: number;
    const KEY_ediaeresis: number;
    const KEY_egrave: number;
    const KEY_ehook: number;
    const KEY_eightsubscript: number;
    const KEY_eightsuperior: number;
    const KEY_elementof: number;
    const KEY_ellipsis: number;
    const KEY_em3space: number;
    const KEY_em4space: number;
    const KEY_emacron: number;
    const KEY_emdash: number;
    const KEY_emfilledcircle: number;
    const KEY_emfilledrect: number;
    const KEY_emopencircle: number;
    const KEY_emopenrectangle: number;
    const KEY_emptyset: number;
    const KEY_emspace: number;
    const KEY_endash: number;
    const KEY_enfilledcircbullet: number;
    const KEY_enfilledsqbullet: number;
    const KEY_eng: number;
    const KEY_enopencircbullet: number;
    const KEY_enopensquarebullet: number;
    const KEY_enspace: number;
    const KEY_eogonek: number;
    const KEY_equal: number;
    const KEY_eth: number;
    const KEY_etilde: number;
    const KEY_exclam: number;
    const KEY_exclamdown: number;
    const KEY_ezh: number;
    const KEY_f: number;
    const KEY_fabovedot: number;
    const KEY_femalesymbol: number;
    const KEY_ff: number;
    const KEY_figdash: number;
    const KEY_filledlefttribullet: number;
    const KEY_filledrectbullet: number;
    const KEY_filledrighttribullet: number;
    const KEY_filledtribulletdown: number;
    const KEY_filledtribulletup: number;
    const KEY_fiveeighths: number;
    const KEY_fivesixths: number;
    const KEY_fivesubscript: number;
    const KEY_fivesuperior: number;
    const KEY_fourfifths: number;
    const KEY_foursubscript: number;
    const KEY_foursuperior: number;
    const KEY_fourthroot: number;
    const KEY_function: number;
    const KEY_g: number;
    const KEY_gabovedot: number;
    const KEY_gbreve: number;
    const KEY_gcaron: number;
    const KEY_gcedilla: number;
    const KEY_gcircumflex: number;
    const KEY_grave: number;
    const KEY_greater: number;
    const KEY_greaterthanequal: number;
    const KEY_guillemotleft: number;
    const KEY_guillemotright: number;
    const KEY_h: number;
    const KEY_hairspace: number;
    const KEY_hcircumflex: number;
    const KEY_heart: number;
    const KEY_hebrew_aleph: number;
    const KEY_hebrew_ayin: number;
    const KEY_hebrew_bet: number;
    const KEY_hebrew_beth: number;
    const KEY_hebrew_chet: number;
    const KEY_hebrew_dalet: number;
    const KEY_hebrew_daleth: number;
    const KEY_hebrew_doublelowline: number;
    const KEY_hebrew_finalkaph: number;
    const KEY_hebrew_finalmem: number;
    const KEY_hebrew_finalnun: number;
    const KEY_hebrew_finalpe: number;
    const KEY_hebrew_finalzade: number;
    const KEY_hebrew_finalzadi: number;
    const KEY_hebrew_gimel: number;
    const KEY_hebrew_gimmel: number;
    const KEY_hebrew_he: number;
    const KEY_hebrew_het: number;
    const KEY_hebrew_kaph: number;
    const KEY_hebrew_kuf: number;
    const KEY_hebrew_lamed: number;
    const KEY_hebrew_mem: number;
    const KEY_hebrew_nun: number;
    const KEY_hebrew_pe: number;
    const KEY_hebrew_qoph: number;
    const KEY_hebrew_resh: number;
    const KEY_hebrew_samech: number;
    const KEY_hebrew_samekh: number;
    const KEY_hebrew_shin: number;
    const KEY_hebrew_taf: number;
    const KEY_hebrew_taw: number;
    const KEY_hebrew_tet: number;
    const KEY_hebrew_teth: number;
    const KEY_hebrew_waw: number;
    const KEY_hebrew_yod: number;
    const KEY_hebrew_zade: number;
    const KEY_hebrew_zadi: number;
    const KEY_hebrew_zain: number;
    const KEY_hebrew_zayin: number;
    const KEY_hexagram: number;
    const KEY_horizconnector: number;
    const KEY_horizlinescan1: number;
    const KEY_horizlinescan3: number;
    const KEY_horizlinescan5: number;
    const KEY_horizlinescan7: number;
    const KEY_horizlinescan9: number;
    const KEY_hstroke: number;
    const KEY_ht: number;
    const KEY_hyphen: number;
    const KEY_i: number;
    const KEY_iTouch: number;
    const KEY_iacute: number;
    const KEY_ibelowdot: number;
    const KEY_ibreve: number;
    const KEY_icircumflex: number;
    const KEY_identical: number;
    const KEY_idiaeresis: number;
    const KEY_idotless: number;
    const KEY_ifonlyif: number;
    const KEY_igrave: number;
    const KEY_ihook: number;
    const KEY_imacron: number;
    const KEY_implies: number;
    const KEY_includedin: number;
    const KEY_includes: number;
    const KEY_infinity: number;
    const KEY_integral: number;
    const KEY_intersection: number;
    const KEY_iogonek: number;
    const KEY_itilde: number;
    const KEY_j: number;
    const KEY_jcircumflex: number;
    const KEY_jot: number;
    const KEY_k: number;
    const KEY_kana_A: number;
    const KEY_kana_CHI: number;
    const KEY_kana_E: number;
    const KEY_kana_FU: number;
    const KEY_kana_HA: number;
    const KEY_kana_HE: number;
    const KEY_kana_HI: number;
    const KEY_kana_HO: number;
    const KEY_kana_HU: number;
    const KEY_kana_I: number;
    const KEY_kana_KA: number;
    const KEY_kana_KE: number;
    const KEY_kana_KI: number;
    const KEY_kana_KO: number;
    const KEY_kana_KU: number;
    const KEY_kana_MA: number;
    const KEY_kana_ME: number;
    const KEY_kana_MI: number;
    const KEY_kana_MO: number;
    const KEY_kana_MU: number;
    const KEY_kana_N: number;
    const KEY_kana_NA: number;
    const KEY_kana_NE: number;
    const KEY_kana_NI: number;
    const KEY_kana_NO: number;
    const KEY_kana_NU: number;
    const KEY_kana_O: number;
    const KEY_kana_RA: number;
    const KEY_kana_RE: number;
    const KEY_kana_RI: number;
    const KEY_kana_RO: number;
    const KEY_kana_RU: number;
    const KEY_kana_SA: number;
    const KEY_kana_SE: number;
    const KEY_kana_SHI: number;
    const KEY_kana_SO: number;
    const KEY_kana_SU: number;
    const KEY_kana_TA: number;
    const KEY_kana_TE: number;
    const KEY_kana_TI: number;
    const KEY_kana_TO: number;
    const KEY_kana_TSU: number;
    const KEY_kana_TU: number;
    const KEY_kana_U: number;
    const KEY_kana_WA: number;
    const KEY_kana_WO: number;
    const KEY_kana_YA: number;
    const KEY_kana_YO: number;
    const KEY_kana_YU: number;
    const KEY_kana_a: number;
    const KEY_kana_closingbracket: number;
    const KEY_kana_comma: number;
    const KEY_kana_conjunctive: number;
    const KEY_kana_e: number;
    const KEY_kana_fullstop: number;
    const KEY_kana_i: number;
    const KEY_kana_middledot: number;
    const KEY_kana_o: number;
    const KEY_kana_openingbracket: number;
    const KEY_kana_switch: number;
    const KEY_kana_tsu: number;
    const KEY_kana_tu: number;
    const KEY_kana_u: number;
    const KEY_kana_ya: number;
    const KEY_kana_yo: number;
    const KEY_kana_yu: number;
    const KEY_kappa: number;
    const KEY_kcedilla: number;
    const KEY_kra: number;
    const KEY_l: number;
    const KEY_lacute: number;
    const KEY_latincross: number;
    const KEY_lbelowdot: number;
    const KEY_lcaron: number;
    const KEY_lcedilla: number;
    const KEY_leftanglebracket: number;
    const KEY_leftarrow: number;
    const KEY_leftcaret: number;
    const KEY_leftdoublequotemark: number;
    const KEY_leftmiddlecurlybrace: number;
    const KEY_leftopentriangle: number;
    const KEY_leftpointer: number;
    const KEY_leftradical: number;
    const KEY_leftshoe: number;
    const KEY_leftsinglequotemark: number;
    const KEY_leftt: number;
    const KEY_lefttack: number;
    const KEY_less: number;
    const KEY_lessthanequal: number;
    const KEY_lf: number;
    const KEY_logicaland: number;
    const KEY_logicalor: number;
    const KEY_lowleftcorner: number;
    const KEY_lowrightcorner: number;
    const KEY_lstroke: number;
    const KEY_m: number;
    const KEY_mabovedot: number;
    const KEY_macron: number;
    const KEY_malesymbol: number;
    const KEY_maltesecross: number;
    const KEY_marker: number;
    const KEY_masculine: number;
    const KEY_minus: number;
    const KEY_minutes: number;
    const KEY_mu: number;
    const KEY_multiply: number;
    const KEY_musicalflat: number;
    const KEY_musicalsharp: number;
    const KEY_n: number;
    const KEY_nabla: number;
    const KEY_nacute: number;
    const KEY_ncaron: number;
    const KEY_ncedilla: number;
    const KEY_ninesubscript: number;
    const KEY_ninesuperior: number;
    const KEY_nl: number;
    const KEY_nobreakspace: number;
    const KEY_notapproxeq: number;
    const KEY_notelementof: number;
    const KEY_notequal: number;
    const KEY_notidentical: number;
    const KEY_notsign: number;
    const KEY_ntilde: number;
    const KEY_numbersign: number;
    const KEY_numerosign: number;
    const KEY_o: number;
    const KEY_oacute: number;
    const KEY_obarred: number;
    const KEY_obelowdot: number;
    const KEY_ocaron: number;
    const KEY_ocircumflex: number;
    const KEY_ocircumflexacute: number;
    const KEY_ocircumflexbelowdot: number;
    const KEY_ocircumflexgrave: number;
    const KEY_ocircumflexhook: number;
    const KEY_ocircumflextilde: number;
    const KEY_odiaeresis: number;
    const KEY_odoubleacute: number;
    const KEY_oe: number;
    const KEY_ogonek: number;
    const KEY_ograve: number;
    const KEY_ohook: number;
    const KEY_ohorn: number;
    const KEY_ohornacute: number;
    const KEY_ohornbelowdot: number;
    const KEY_ohorngrave: number;
    const KEY_ohornhook: number;
    const KEY_ohorntilde: number;
    const KEY_omacron: number;
    const KEY_oneeighth: number;
    const KEY_onefifth: number;
    const KEY_onehalf: number;
    const KEY_onequarter: number;
    const KEY_onesixth: number;
    const KEY_onesubscript: number;
    const KEY_onesuperior: number;
    const KEY_onethird: number;
    const KEY_ooblique: number;
    const KEY_openrectbullet: number;
    const KEY_openstar: number;
    const KEY_opentribulletdown: number;
    const KEY_opentribulletup: number;
    const KEY_ordfeminine: number;
    const KEY_oslash: number;
    const KEY_otilde: number;
    const KEY_overbar: number;
    const KEY_overline: number;
    const KEY_p: number;
    const KEY_pabovedot: number;
    const KEY_paragraph: number;
    const KEY_parenleft: number;
    const KEY_parenright: number;
    const KEY_partdifferential: number;
    const KEY_partialderivative: number;
    const KEY_percent: number;
    const KEY_period: number;
    const KEY_periodcentered: number;
    const KEY_permille: number;
    const KEY_phonographcopyright: number;
    const KEY_plus: number;
    const KEY_plusminus: number;
    const KEY_prescription: number;
    const KEY_prolongedsound: number;
    const KEY_punctspace: number;
    const KEY_q: number;
    const KEY_quad: number;
    const KEY_question: number;
    const KEY_questiondown: number;
    const KEY_quotedbl: number;
    const KEY_quoteleft: number;
    const KEY_quoteright: number;
    const KEY_r: number;
    const KEY_racute: number;
    const KEY_radical: number;
    const KEY_rcaron: number;
    const KEY_rcedilla: number;
    const KEY_registered: number;
    const KEY_rightanglebracket: number;
    const KEY_rightarrow: number;
    const KEY_rightcaret: number;
    const KEY_rightdoublequotemark: number;
    const KEY_rightmiddlecurlybrace: number;
    const KEY_rightmiddlesummation: number;
    const KEY_rightopentriangle: number;
    const KEY_rightpointer: number;
    const KEY_rightshoe: number;
    const KEY_rightsinglequotemark: number;
    const KEY_rightt: number;
    const KEY_righttack: number;
    const KEY_s: number;
    const KEY_sabovedot: number;
    const KEY_sacute: number;
    const KEY_scaron: number;
    const KEY_scedilla: number;
    const KEY_schwa: number;
    const KEY_scircumflex: number;
    const KEY_script_switch: number;
    const KEY_seconds: number;
    const KEY_section: number;
    const KEY_semicolon: number;
    const KEY_semivoicedsound: number;
    const KEY_seveneighths: number;
    const KEY_sevensubscript: number;
    const KEY_sevensuperior: number;
    const KEY_signaturemark: number;
    const KEY_signifblank: number;
    const KEY_similarequal: number;
    const KEY_singlelowquotemark: number;
    const KEY_sixsubscript: number;
    const KEY_sixsuperior: number;
    const KEY_slash: number;
    const KEY_soliddiamond: number;
    const KEY_space: number;
    const KEY_squareroot: number;
    const KEY_ssharp: number;
    const KEY_sterling: number;
    const KEY_stricteq: number;
    const KEY_t: number;
    const KEY_tabovedot: number;
    const KEY_tcaron: number;
    const KEY_tcedilla: number;
    const KEY_telephone: number;
    const KEY_telephonerecorder: number;
    const KEY_therefore: number;
    const KEY_thinspace: number;
    const KEY_thorn: number;
    const KEY_threeeighths: number;
    const KEY_threefifths: number;
    const KEY_threequarters: number;
    const KEY_threesubscript: number;
    const KEY_threesuperior: number;
    const KEY_tintegral: number;
    const KEY_topintegral: number;
    const KEY_topleftparens: number;
    const KEY_topleftradical: number;
    const KEY_topleftsqbracket: number;
    const KEY_topleftsummation: number;
    const KEY_toprightparens: number;
    const KEY_toprightsqbracket: number;
    const KEY_toprightsummation: number;
    const KEY_topt: number;
    const KEY_topvertsummationconnector: number;
    const KEY_trademark: number;
    const KEY_trademarkincircle: number;
    const KEY_tslash: number;
    const KEY_twofifths: number;
    const KEY_twosubscript: number;
    const KEY_twosuperior: number;
    const KEY_twothirds: number;
    const KEY_u: number;
    const KEY_uacute: number;
    const KEY_ubelowdot: number;
    const KEY_ubreve: number;
    const KEY_ucircumflex: number;
    const KEY_udiaeresis: number;
    const KEY_udoubleacute: number;
    const KEY_ugrave: number;
    const KEY_uhook: number;
    const KEY_uhorn: number;
    const KEY_uhornacute: number;
    const KEY_uhornbelowdot: number;
    const KEY_uhorngrave: number;
    const KEY_uhornhook: number;
    const KEY_uhorntilde: number;
    const KEY_umacron: number;
    const KEY_underbar: number;
    const KEY_underscore: number;
    const KEY_union: number;
    const KEY_uogonek: number;
    const KEY_uparrow: number;
    const KEY_upcaret: number;
    const KEY_upleftcorner: number;
    const KEY_uprightcorner: number;
    const KEY_upshoe: number;
    const KEY_upstile: number;
    const KEY_uptack: number;
    const KEY_uring: number;
    const KEY_utilde: number;
    const KEY_v: number;
    const KEY_variation: number;
    const KEY_vertbar: number;
    const KEY_vertconnector: number;
    const KEY_voicedsound: number;
    const KEY_vt: number;
    const KEY_w: number;
    const KEY_wacute: number;
    const KEY_wcircumflex: number;
    const KEY_wdiaeresis: number;
    const KEY_wgrave: number;
    const KEY_x: number;
    const KEY_xabovedot: number;
    const KEY_y: number;
    const KEY_yacute: number;
    const KEY_ybelowdot: number;
    const KEY_ycircumflex: number;
    const KEY_ydiaeresis: number;
    const KEY_yen: number;
    const KEY_ygrave: number;
    const KEY_yhook: number;
    const KEY_ytilde: number;
    const KEY_z: number;
    const KEY_zabovedot: number;
    const KEY_zacute: number;
    const KEY_zcaron: number;
    const KEY_zerosubscript: number;
    const KEY_zerosuperior: number;
    const KEY_zstroke: number;
    const KP_0: number;
    const KP_1: number;
    const KP_2: number;
    const KP_3: number;
    const KP_4: number;
    const KP_5: number;
    const KP_6: number;
    const KP_7: number;
    const KP_8: number;
    const KP_9: number;
    const KP_Add: number;
    const KP_Begin: number;
    const KP_Decimal: number;
    const KP_Delete: number;
    const KP_Divide: number;
    const KP_Down: number;
    const KP_End: number;
    const KP_Enter: number;
    const KP_Equal: number;
    const KP_F1: number;
    const KP_F2: number;
    const KP_F3: number;
    const KP_F4: number;
    const KP_Home: number;
    const KP_Insert: number;
    const KP_Left: number;
    const KP_Multiply: number;
    const KP_Next: number;
    const KP_Page_Down: number;
    const KP_Page_Up: number;
    const KP_Prior: number;
    const KP_Right: number;
    const KP_Separator: number;
    const KP_Space: number;
    const KP_Subtract: number;
    const KP_Tab: number;
    const KP_Up: number;
    const Kana_Lock: number;
    const Kana_Shift: number;
    const Kanji: number;
    const Kanji_Bangou: number;
    const Katakana: number;
    const KbdBrightnessDown: number;
    const KbdBrightnessUp: number;
    const KbdLightOnOff: number;
    const Kcedilla: number;
    const Korean_Won: number;
    const L: number;
    const L1: number;
    const L10: number;
    const L2: number;
    const L3: number;
    const L4: number;
    const L5: number;
    const L6: number;
    const L7: number;
    const L8: number;
    const L9: number;
    const Lacute: number;
    const Last_Virtual_Screen: number;
    const Launch0: number;
    const Launch1: number;
    const Launch2: number;
    const Launch3: number;
    const Launch4: number;
    const Launch5: number;
    const Launch6: number;
    const Launch7: number;
    const Launch8: number;
    const Launch9: number;
    const LaunchA: number;
    const LaunchB: number;
    const LaunchC: number;
    const LaunchD: number;
    const LaunchE: number;
    const LaunchF: number;
    const Lbelowdot: number;
    const Lcaron: number;
    const Lcedilla: number;
    const Left: number;
    const LightBulb: number;
    const Linefeed: number;
    const LiraSign: number;
    const LogGrabInfo: number;
    const LogOff: number;
    const LogWindowTree: number;
    const Lstroke: number;
    const M: number;
    /**
     * The major version of the Clutter library (1, if %CLUTTER_VERSION is 1.2.3)
     */
    const MAJOR_VERSION: number;
    /**
     * The micro version of the Clutter library (3, if %CLUTTER_VERSION is 1.2.3)
     */
    const MICRO_VERSION: number;
    /**
     * The minor version of the Clutter library (2, if %CLUTTER_VERSION is 1.2.3)
     */
    const MINOR_VERSION: number;
    const Mabovedot: number;
    const Macedonia_DSE: number;
    const Macedonia_GJE: number;
    const Macedonia_KJE: number;
    const Macedonia_dse: number;
    const Macedonia_gje: number;
    const Macedonia_kje: number;
    const Mae_Koho: number;
    const Mail: number;
    const MailForward: number;
    const Market: number;
    const Massyo: number;
    const Meeting: number;
    const Memo: number;
    const Menu: number;
    const MenuKB: number;
    const MenuPB: number;
    const Messenger: number;
    const Meta_L: number;
    const Meta_R: number;
    const MillSign: number;
    const ModeLock: number;
    const Mode_switch: number;
    const MonBrightnessDown: number;
    const MonBrightnessUp: number;
    const MouseKeys_Accel_Enable: number;
    const MouseKeys_Enable: number;
    const Muhenkan: number;
    const Multi_key: number;
    const MultipleCandidate: number;
    const Music: number;
    const MyComputer: number;
    const MySites: number;
    const N: number;
    /**
     * Set to 1 if Clutter was built without FPU (i.e fixed math), 0 otherwise
     */
    const NO_FPU: number;
    const Nacute: number;
    const NairaSign: number;
    const Ncaron: number;
    const Ncedilla: number;
    const New: number;
    const NewSheqelSign: number;
    const News: number;
    const Next: number;
    const Next_VMode: number;
    const Next_Virtual_Screen: number;
    const Ntilde: number;
    const Num_Lock: number;
    const O: number;
    const OE: number;
    const Oacute: number;
    const Obarred: number;
    const Obelowdot: number;
    const Ocaron: number;
    const Ocircumflex: number;
    const Ocircumflexacute: number;
    const Ocircumflexbelowdot: number;
    const Ocircumflexgrave: number;
    const Ocircumflexhook: number;
    const Ocircumflextilde: number;
    const Odiaeresis: number;
    const Odoubleacute: number;
    const OfficeHome: number;
    const Ograve: number;
    const Ohook: number;
    const Ohorn: number;
    const Ohornacute: number;
    const Ohornbelowdot: number;
    const Ohorngrave: number;
    const Ohornhook: number;
    const Ohorntilde: number;
    const Omacron: number;
    const Ooblique: number;
    const Open: number;
    const OpenURL: number;
    const Option: number;
    const Oslash: number;
    const Otilde: number;
    const Overlay1_Enable: number;
    const Overlay2_Enable: number;
    const P: number;
    const PATH_RELATIVE: number;
    /**
     * Priority of the redraws. This is chosen to be lower than the GTK+
     * redraw and resize priorities, because in application with both
     * GTK+ and Clutter it's more likely that the Clutter part will be
     * continually animating (and thus able to starve GTK+) than
     * vice-versa.
     */
    const PRIORITY_REDRAW: number;
    const Pabovedot: number;
    const Page_Down: number;
    const Page_Up: number;
    const Paste: number;
    const Pause: number;
    const PesetaSign: number;
    const Phone: number;
    const Pictures: number;
    const Pointer_Accelerate: number;
    const Pointer_Button1: number;
    const Pointer_Button2: number;
    const Pointer_Button3: number;
    const Pointer_Button4: number;
    const Pointer_Button5: number;
    const Pointer_Button_Dflt: number;
    const Pointer_DblClick1: number;
    const Pointer_DblClick2: number;
    const Pointer_DblClick3: number;
    const Pointer_DblClick4: number;
    const Pointer_DblClick5: number;
    const Pointer_DblClick_Dflt: number;
    const Pointer_DfltBtnNext: number;
    const Pointer_DfltBtnPrev: number;
    const Pointer_Down: number;
    const Pointer_DownLeft: number;
    const Pointer_DownRight: number;
    const Pointer_Drag1: number;
    const Pointer_Drag2: number;
    const Pointer_Drag3: number;
    const Pointer_Drag4: number;
    const Pointer_Drag5: number;
    const Pointer_Drag_Dflt: number;
    const Pointer_EnableKeys: number;
    const Pointer_Left: number;
    const Pointer_Right: number;
    const Pointer_Up: number;
    const Pointer_UpLeft: number;
    const Pointer_UpRight: number;
    const PowerDown: number;
    const PowerOff: number;
    const Prev_VMode: number;
    const Prev_Virtual_Screen: number;
    const PreviousCandidate: number;
    const Print: number;
    const Prior: number;
    const Q: number;
    const R: number;
    const R1: number;
    const R10: number;
    const R11: number;
    const R12: number;
    const R13: number;
    const R14: number;
    const R15: number;
    const R2: number;
    const R3: number;
    const R4: number;
    const R5: number;
    const R6: number;
    const R7: number;
    const R8: number;
    const R9: number;
    const Racute: number;
    const Rcaron: number;
    const Rcedilla: number;
    const Red: number;
    const Redo: number;
    const Refresh: number;
    const Reload: number;
    const RepeatKeys_Enable: number;
    const Reply: number;
    const Return: number;
    const Right: number;
    const RockerDown: number;
    const RockerEnter: number;
    const RockerUp: number;
    const Romaji: number;
    const RotateWindows: number;
    const RotationKB: number;
    const RotationPB: number;
    const RupeeSign: number;
    const S: number;
    const SCHWA: number;
    /**
     * The default GObject type for the Clutter stage.
     */
    const STAGE_TYPE: string;
    const Sabovedot: number;
    const Sacute: number;
    const Save: number;
    const Scaron: number;
    const Scedilla: number;
    const Scircumflex: number;
    const ScreenSaver: number;
    const ScrollClick: number;
    const ScrollDown: number;
    const ScrollUp: number;
    const Scroll_Lock: number;
    const Search: number;
    const Select: number;
    const SelectButton: number;
    const Send: number;
    const Serbian_DJE: number;
    const Serbian_DZE: number;
    const Serbian_JE: number;
    const Serbian_LJE: number;
    const Serbian_NJE: number;
    const Serbian_TSHE: number;
    const Serbian_dje: number;
    const Serbian_dze: number;
    const Serbian_je: number;
    const Serbian_lje: number;
    const Serbian_nje: number;
    const Serbian_tshe: number;
    const Shift_L: number;
    const Shift_Lock: number;
    const Shift_R: number;
    const Shop: number;
    const SingleCandidate: number;
    const Sinh_a: number;
    const Sinh_aa: number;
    const Sinh_aa2: number;
    const Sinh_ae: number;
    const Sinh_ae2: number;
    const Sinh_aee: number;
    const Sinh_aee2: number;
    const Sinh_ai: number;
    const Sinh_ai2: number;
    const Sinh_al: number;
    const Sinh_au: number;
    const Sinh_au2: number;
    const Sinh_ba: number;
    const Sinh_bha: number;
    const Sinh_ca: number;
    const Sinh_cha: number;
    const Sinh_dda: number;
    const Sinh_ddha: number;
    const Sinh_dha: number;
    const Sinh_dhha: number;
    const Sinh_e: number;
    const Sinh_e2: number;
    const Sinh_ee: number;
    const Sinh_ee2: number;
    const Sinh_fa: number;
    const Sinh_ga: number;
    const Sinh_gha: number;
    const Sinh_h2: number;
    const Sinh_ha: number;
    const Sinh_i: number;
    const Sinh_i2: number;
    const Sinh_ii: number;
    const Sinh_ii2: number;
    const Sinh_ja: number;
    const Sinh_jha: number;
    const Sinh_jnya: number;
    const Sinh_ka: number;
    const Sinh_kha: number;
    const Sinh_kunddaliya: number;
    const Sinh_la: number;
    const Sinh_lla: number;
    const Sinh_lu: number;
    const Sinh_lu2: number;
    const Sinh_luu: number;
    const Sinh_luu2: number;
    const Sinh_ma: number;
    const Sinh_mba: number;
    const Sinh_na: number;
    const Sinh_ndda: number;
    const Sinh_ndha: number;
    const Sinh_ng: number;
    const Sinh_ng2: number;
    const Sinh_nga: number;
    const Sinh_nja: number;
    const Sinh_nna: number;
    const Sinh_nya: number;
    const Sinh_o: number;
    const Sinh_o2: number;
    const Sinh_oo: number;
    const Sinh_oo2: number;
    const Sinh_pa: number;
    const Sinh_pha: number;
    const Sinh_ra: number;
    const Sinh_ri: number;
    const Sinh_rii: number;
    const Sinh_ru2: number;
    const Sinh_ruu2: number;
    const Sinh_sa: number;
    const Sinh_sha: number;
    const Sinh_ssha: number;
    const Sinh_tha: number;
    const Sinh_thha: number;
    const Sinh_tta: number;
    const Sinh_ttha: number;
    const Sinh_u: number;
    const Sinh_u2: number;
    const Sinh_uu: number;
    const Sinh_uu2: number;
    const Sinh_va: number;
    const Sinh_ya: number;
    const Sleep: number;
    const SlowKeys_Enable: number;
    const Spell: number;
    const SplitScreen: number;
    const Standby: number;
    const Start: number;
    const StickyKeys_Enable: number;
    const Stop: number;
    const Subtitle: number;
    const Super_L: number;
    const Super_R: number;
    const Support: number;
    const Suspend: number;
    const Switch_VT_1: number;
    const Switch_VT_10: number;
    const Switch_VT_11: number;
    const Switch_VT_12: number;
    const Switch_VT_2: number;
    const Switch_VT_3: number;
    const Switch_VT_4: number;
    const Switch_VT_5: number;
    const Switch_VT_6: number;
    const Switch_VT_7: number;
    const Switch_VT_8: number;
    const Switch_VT_9: number;
    const Sys_Req: number;
    const T: number;
    const THORN: number;
    const Tab: number;
    const Tabovedot: number;
    const TaskPane: number;
    const Tcaron: number;
    const Tcedilla: number;
    const Terminal: number;
    const Terminate_Server: number;
    const Thai_baht: number;
    const Thai_bobaimai: number;
    const Thai_chochan: number;
    const Thai_chochang: number;
    const Thai_choching: number;
    const Thai_chochoe: number;
    const Thai_dochada: number;
    const Thai_dodek: number;
    const Thai_fofa: number;
    const Thai_fofan: number;
    const Thai_hohip: number;
    const Thai_honokhuk: number;
    const Thai_khokhai: number;
    const Thai_khokhon: number;
    const Thai_khokhuat: number;
    const Thai_khokhwai: number;
    const Thai_khorakhang: number;
    const Thai_kokai: number;
    const Thai_lakkhangyao: number;
    const Thai_lekchet: number;
    const Thai_lekha: number;
    const Thai_lekhok: number;
    const Thai_lekkao: number;
    const Thai_leknung: number;
    const Thai_lekpaet: number;
    const Thai_leksam: number;
    const Thai_leksi: number;
    const Thai_leksong: number;
    const Thai_leksun: number;
    const Thai_lochula: number;
    const Thai_loling: number;
    const Thai_lu: number;
    const Thai_maichattawa: number;
    const Thai_maiek: number;
    const Thai_maihanakat: number;
    const Thai_maihanakat_maitho: number;
    const Thai_maitaikhu: number;
    const Thai_maitho: number;
    const Thai_maitri: number;
    const Thai_maiyamok: number;
    const Thai_moma: number;
    const Thai_ngongu: number;
    const Thai_nikhahit: number;
    const Thai_nonen: number;
    const Thai_nonu: number;
    const Thai_oang: number;
    const Thai_paiyannoi: number;
    const Thai_phinthu: number;
    const Thai_phophan: number;
    const Thai_phophung: number;
    const Thai_phosamphao: number;
    const Thai_popla: number;
    const Thai_rorua: number;
    const Thai_ru: number;
    const Thai_saraa: number;
    const Thai_saraaa: number;
    const Thai_saraae: number;
    const Thai_saraaimaimalai: number;
    const Thai_saraaimaimuan: number;
    const Thai_saraam: number;
    const Thai_sarae: number;
    const Thai_sarai: number;
    const Thai_saraii: number;
    const Thai_sarao: number;
    const Thai_sarau: number;
    const Thai_saraue: number;
    const Thai_sarauee: number;
    const Thai_sarauu: number;
    const Thai_sorusi: number;
    const Thai_sosala: number;
    const Thai_soso: number;
    const Thai_sosua: number;
    const Thai_thanthakhat: number;
    const Thai_thonangmontho: number;
    const Thai_thophuthao: number;
    const Thai_thothahan: number;
    const Thai_thothan: number;
    const Thai_thothong: number;
    const Thai_thothung: number;
    const Thai_topatak: number;
    const Thai_totao: number;
    const Thai_wowaen: number;
    const Thai_yoyak: number;
    const Thai_yoying: number;
    const Thorn: number;
    const Time: number;
    const ToDoList: number;
    const Tools: number;
    const TopMenu: number;
    const TouchpadOff: number;
    const TouchpadOn: number;
    const TouchpadToggle: number;
    const Touroku: number;
    const Travel: number;
    const Tslash: number;
    const U: number;
    const UWB: number;
    const Uacute: number;
    const Ubelowdot: number;
    const Ubreve: number;
    const Ucircumflex: number;
    const Udiaeresis: number;
    const Udoubleacute: number;
    const Ugrave: number;
    const Uhook: number;
    const Uhorn: number;
    const Uhornacute: number;
    const Uhornbelowdot: number;
    const Uhorngrave: number;
    const Uhornhook: number;
    const Uhorntilde: number;
    const Ukrainian_GHE_WITH_UPTURN: number;
    const Ukrainian_I: number;
    const Ukrainian_IE: number;
    const Ukrainian_YI: number;
    const Ukrainian_ghe_with_upturn: number;
    const Ukrainian_i: number;
    const Ukrainian_ie: number;
    const Ukrainian_yi: number;
    const Ukranian_I: number;
    const Ukranian_JE: number;
    const Ukranian_YI: number;
    const Ukranian_i: number;
    const Ukranian_je: number;
    const Ukranian_yi: number;
    const Umacron: number;
    const Undo: number;
    const Ungrab: number;
    const Uogonek: number;
    const Up: number;
    const Uring: number;
    const User1KB: number;
    const User2KB: number;
    const UserPB: number;
    const Utilde: number;
    const V: number;
    /**
     * The full version of the Clutter library, like 1.2.3
     */
    const VERSION: number;
    /**
     * Numerically encoded version of the Clutter library, like 0x010203
     */
    const VERSION_HEX: number;
    /**
     * The full version of the Clutter library, in string form (suited for
     * string concatenation)
     */
    const VERSION_S: string;
    const VendorHome: number;
    const Video: number;
    const View: number;
    const VoidSymbol: number;
    const W: number;
    const WINDOWING_EGL: string;
    const WINDOWING_GDK: string;
    const WINDOWING_GLX: string;
    const WINDOWING_WAYLAND: string;
    const WINDOWING_X11: string;
    const WLAN: number;
    const WWW: number;
    const Wacute: number;
    const WakeUp: number;
    const Wcircumflex: number;
    const Wdiaeresis: number;
    const WebCam: number;
    const Wgrave: number;
    const WheelButton: number;
    const WindowClear: number;
    const WonSign: number;
    const Word: number;
    const X: number;
    const Xabovedot: number;
    const Xfer: number;
    const Y: number;
    const Yacute: number;
    const Ybelowdot: number;
    const Ycircumflex: number;
    const Ydiaeresis: number;
    const Yellow: number;
    const Ygrave: number;
    const Yhook: number;
    const Ytilde: number;
    const Z: number;
    const Zabovedot: number;
    const Zacute: number;
    const Zcaron: number;
    const Zen_Koho: number;
    const Zenkaku: number;
    const Zenkaku_Hankaku: number;
    const ZoomIn: number;
    const ZoomOut: number;
    const Zstroke: number;
    const a: number;
    const aacute: number;
    const abelowdot: number;
    const abovedot: number;
    const abreve: number;
    const abreveacute: number;
    const abrevebelowdot: number;
    const abrevegrave: number;
    const abrevehook: number;
    const abrevetilde: number;
    const acircumflex: number;
    const acircumflexacute: number;
    const acircumflexbelowdot: number;
    const acircumflexgrave: number;
    const acircumflexhook: number;
    const acircumflextilde: number;
    const acute: number;
    const adiaeresis: number;
    const ae: number;
    const agrave: number;
    const ahook: number;
    const amacron: number;
    const ampersand: number;
    const aogonek: number;
    const apostrophe: number;
    const approxeq: number;
    const approximate: number;
    const aring: number;
    const asciicircum: number;
    const asciitilde: number;
    const asterisk: number;
    const at: number;
    const atilde: number;
    const b: number;
    const babovedot: number;
    const backslash: number;
    const ballotcross: number;
    const bar: number;
    const because: number;
    const blank: number;
    const botintegral: number;
    const botleftparens: number;
    const botleftsqbracket: number;
    const botleftsummation: number;
    const botrightparens: number;
    const botrightsqbracket: number;
    const botrightsummation: number;
    const bott: number;
    const botvertsummationconnector: number;
    const braceleft: number;
    const braceright: number;
    const bracketleft: number;
    const bracketright: number;
    const braille_blank: number;
    const braille_dot_1: number;
    const braille_dot_10: number;
    const braille_dot_2: number;
    const braille_dot_3: number;
    const braille_dot_4: number;
    const braille_dot_5: number;
    const braille_dot_6: number;
    const braille_dot_7: number;
    const braille_dot_8: number;
    const braille_dot_9: number;
    const braille_dots_1: number;
    const braille_dots_12: number;
    const braille_dots_123: number;
    const braille_dots_1234: number;
    const braille_dots_12345: number;
    const braille_dots_123456: number;
    const braille_dots_1234567: number;
    const braille_dots_12345678: number;
    const braille_dots_1234568: number;
    const braille_dots_123457: number;
    const braille_dots_1234578: number;
    const braille_dots_123458: number;
    const braille_dots_12346: number;
    const braille_dots_123467: number;
    const braille_dots_1234678: number;
    const braille_dots_123468: number;
    const braille_dots_12347: number;
    const braille_dots_123478: number;
    const braille_dots_12348: number;
    const braille_dots_1235: number;
    const braille_dots_12356: number;
    const braille_dots_123567: number;
    const braille_dots_1235678: number;
    const braille_dots_123568: number;
    const braille_dots_12357: number;
    const braille_dots_123578: number;
    const braille_dots_12358: number;
    const braille_dots_1236: number;
    const braille_dots_12367: number;
    const braille_dots_123678: number;
    const braille_dots_12368: number;
    const braille_dots_1237: number;
    const braille_dots_12378: number;
    const braille_dots_1238: number;
    const braille_dots_124: number;
    const braille_dots_1245: number;
    const braille_dots_12456: number;
    const braille_dots_124567: number;
    const braille_dots_1245678: number;
    const braille_dots_124568: number;
    const braille_dots_12457: number;
    const braille_dots_124578: number;
    const braille_dots_12458: number;
    const braille_dots_1246: number;
    const braille_dots_12467: number;
    const braille_dots_124678: number;
    const braille_dots_12468: number;
    const braille_dots_1247: number;
    const braille_dots_12478: number;
    const braille_dots_1248: number;
    const braille_dots_125: number;
    const braille_dots_1256: number;
    const braille_dots_12567: number;
    const braille_dots_125678: number;
    const braille_dots_12568: number;
    const braille_dots_1257: number;
    const braille_dots_12578: number;
    const braille_dots_1258: number;
    const braille_dots_126: number;
    const braille_dots_1267: number;
    const braille_dots_12678: number;
    const braille_dots_1268: number;
    const braille_dots_127: number;
    const braille_dots_1278: number;
    const braille_dots_128: number;
    const braille_dots_13: number;
    const braille_dots_134: number;
    const braille_dots_1345: number;
    const braille_dots_13456: number;
    const braille_dots_134567: number;
    const braille_dots_1345678: number;
    const braille_dots_134568: number;
    const braille_dots_13457: number;
    const braille_dots_134578: number;
    const braille_dots_13458: number;
    const braille_dots_1346: number;
    const braille_dots_13467: number;
    const braille_dots_134678: number;
    const braille_dots_13468: number;
    const braille_dots_1347: number;
    const braille_dots_13478: number;
    const braille_dots_1348: number;
    const braille_dots_135: number;
    const braille_dots_1356: number;
    const braille_dots_13567: number;
    const braille_dots_135678: number;
    const braille_dots_13568: number;
    const braille_dots_1357: number;
    const braille_dots_13578: number;
    const braille_dots_1358: number;
    const braille_dots_136: number;
    const braille_dots_1367: number;
    const braille_dots_13678: number;
    const braille_dots_1368: number;
    const braille_dots_137: number;
    const braille_dots_1378: number;
    const braille_dots_138: number;
    const braille_dots_14: number;
    const braille_dots_145: number;
    const braille_dots_1456: number;
    const braille_dots_14567: number;
    const braille_dots_145678: number;
    const braille_dots_14568: number;
    const braille_dots_1457: number;
    const braille_dots_14578: number;
    const braille_dots_1458: number;
    const braille_dots_146: number;
    const braille_dots_1467: number;
    const braille_dots_14678: number;
    const braille_dots_1468: number;
    const braille_dots_147: number;
    const braille_dots_1478: number;
    const braille_dots_148: number;
    const braille_dots_15: number;
    const braille_dots_156: number;
    const braille_dots_1567: number;
    const braille_dots_15678: number;
    const braille_dots_1568: number;
    const braille_dots_157: number;
    const braille_dots_1578: number;
    const braille_dots_158: number;
    const braille_dots_16: number;
    const braille_dots_167: number;
    const braille_dots_1678: number;
    const braille_dots_168: number;
    const braille_dots_17: number;
    const braille_dots_178: number;
    const braille_dots_18: number;
    const braille_dots_2: number;
    const braille_dots_23: number;
    const braille_dots_234: number;
    const braille_dots_2345: number;
    const braille_dots_23456: number;
    const braille_dots_234567: number;
    const braille_dots_2345678: number;
    const braille_dots_234568: number;
    const braille_dots_23457: number;
    const braille_dots_234578: number;
    const braille_dots_23458: number;
    const braille_dots_2346: number;
    const braille_dots_23467: number;
    const braille_dots_234678: number;
    const braille_dots_23468: number;
    const braille_dots_2347: number;
    const braille_dots_23478: number;
    const braille_dots_2348: number;
    const braille_dots_235: number;
    const braille_dots_2356: number;
    const braille_dots_23567: number;
    const braille_dots_235678: number;
    const braille_dots_23568: number;
    const braille_dots_2357: number;
    const braille_dots_23578: number;
    const braille_dots_2358: number;
    const braille_dots_236: number;
    const braille_dots_2367: number;
    const braille_dots_23678: number;
    const braille_dots_2368: number;
    const braille_dots_237: number;
    const braille_dots_2378: number;
    const braille_dots_238: number;
    const braille_dots_24: number;
    const braille_dots_245: number;
    const braille_dots_2456: number;
    const braille_dots_24567: number;
    const braille_dots_245678: number;
    const braille_dots_24568: number;
    const braille_dots_2457: number;
    const braille_dots_24578: number;
    const braille_dots_2458: number;
    const braille_dots_246: number;
    const braille_dots_2467: number;
    const braille_dots_24678: number;
    const braille_dots_2468: number;
    const braille_dots_247: number;
    const braille_dots_2478: number;
    const braille_dots_248: number;
    const braille_dots_25: number;
    const braille_dots_256: number;
    const braille_dots_2567: number;
    const braille_dots_25678: number;
    const braille_dots_2568: number;
    const braille_dots_257: number;
    const braille_dots_2578: number;
    const braille_dots_258: number;
    const braille_dots_26: number;
    const braille_dots_267: number;
    const braille_dots_2678: number;
    const braille_dots_268: number;
    const braille_dots_27: number;
    const braille_dots_278: number;
    const braille_dots_28: number;
    const braille_dots_3: number;
    const braille_dots_34: number;
    const braille_dots_345: number;
    const braille_dots_3456: number;
    const braille_dots_34567: number;
    const braille_dots_345678: number;
    const braille_dots_34568: number;
    const braille_dots_3457: number;
    const braille_dots_34578: number;
    const braille_dots_3458: number;
    const braille_dots_346: number;
    const braille_dots_3467: number;
    const braille_dots_34678: number;
    const braille_dots_3468: number;
    const braille_dots_347: number;
    const braille_dots_3478: number;
    const braille_dots_348: number;
    const braille_dots_35: number;
    const braille_dots_356: number;
    const braille_dots_3567: number;
    const braille_dots_35678: number;
    const braille_dots_3568: number;
    const braille_dots_357: number;
    const braille_dots_3578: number;
    const braille_dots_358: number;
    const braille_dots_36: number;
    const braille_dots_367: number;
    const braille_dots_3678: number;
    const braille_dots_368: number;
    const braille_dots_37: number;
    const braille_dots_378: number;
    const braille_dots_38: number;
    const braille_dots_4: number;
    const braille_dots_45: number;
    const braille_dots_456: number;
    const braille_dots_4567: number;
    const braille_dots_45678: number;
    const braille_dots_4568: number;
    const braille_dots_457: number;
    const braille_dots_4578: number;
    const braille_dots_458: number;
    const braille_dots_46: number;
    const braille_dots_467: number;
    const braille_dots_4678: number;
    const braille_dots_468: number;
    const braille_dots_47: number;
    const braille_dots_478: number;
    const braille_dots_48: number;
    const braille_dots_5: number;
    const braille_dots_56: number;
    const braille_dots_567: number;
    const braille_dots_5678: number;
    const braille_dots_568: number;
    const braille_dots_57: number;
    const braille_dots_578: number;
    const braille_dots_58: number;
    const braille_dots_6: number;
    const braille_dots_67: number;
    const braille_dots_678: number;
    const braille_dots_68: number;
    const braille_dots_7: number;
    const braille_dots_78: number;
    const braille_dots_8: number;
    const breve: number;
    const brokenbar: number;
    const c: number;
    const c_h: number;
    const cabovedot: number;
    const cacute: number;
    const careof: number;
    const caret: number;
    const caron: number;
    const ccaron: number;
    const ccedilla: number;
    const ccircumflex: number;
    const cedilla: number;
    const cent: number;
    const ch: number;
    const checkerboard: number;
    const checkmark: number;
    const circle: number;
    const club: number;
    const colon: number;
    const comma: number;
    const containsas: number;
    const copyright: number;
    const cr: number;
    const crossinglines: number;
    const cuberoot: number;
    const currency: number;
    const cursor: number;
    const d: number;
    const dabovedot: number;
    const dagger: number;
    const dcaron: number;
    const dead_A: number;
    const dead_E: number;
    const dead_I: number;
    const dead_O: number;
    const dead_U: number;
    const dead_a: number;
    const dead_abovecomma: number;
    const dead_abovedot: number;
    const dead_abovereversedcomma: number;
    const dead_abovering: number;
    const dead_aboveverticalline: number;
    const dead_acute: number;
    const dead_belowbreve: number;
    const dead_belowcircumflex: number;
    const dead_belowcomma: number;
    const dead_belowdiaeresis: number;
    const dead_belowdot: number;
    const dead_belowmacron: number;
    const dead_belowring: number;
    const dead_belowtilde: number;
    const dead_belowverticalline: number;
    const dead_breve: number;
    const dead_capital_schwa: number;
    const dead_caron: number;
    const dead_cedilla: number;
    const dead_circumflex: number;
    const dead_currency: number;
    const dead_dasia: number;
    const dead_diaeresis: number;
    const dead_doubleacute: number;
    const dead_doublegrave: number;
    const dead_e: number;
    const dead_grave: number;
    const dead_greek: number;
    const dead_hook: number;
    const dead_horn: number;
    const dead_i: number;
    const dead_invertedbreve: number;
    const dead_iota: number;
    const dead_longsolidusoverlay: number;
    const dead_lowline: number;
    const dead_macron: number;
    const dead_o: number;
    const dead_ogonek: number;
    const dead_perispomeni: number;
    const dead_psili: number;
    const dead_semivoiced_sound: number;
    const dead_small_schwa: number;
    const dead_stroke: number;
    const dead_tilde: number;
    const dead_u: number;
    const dead_voiced_sound: number;
    const decimalpoint: number;
    const degree: number;
    const diaeresis: number;
    const diamond: number;
    const digitspace: number;
    const dintegral: number;
    const division: number;
    const dollar: number;
    const doubbaselinedot: number;
    const doubleacute: number;
    const doubledagger: number;
    const doublelowquotemark: number;
    const downarrow: number;
    const downcaret: number;
    const downshoe: number;
    const downstile: number;
    const downtack: number;
    const dstroke: number;
    const e: number;
    const eabovedot: number;
    const eacute: number;
    const ebelowdot: number;
    const ecaron: number;
    const ecircumflex: number;
    const ecircumflexacute: number;
    const ecircumflexbelowdot: number;
    const ecircumflexgrave: number;
    const ecircumflexhook: number;
    const ecircumflextilde: number;
    const ediaeresis: number;
    const egrave: number;
    const ehook: number;
    const eightsubscript: number;
    const eightsuperior: number;
    const elementof: number;
    const ellipsis: number;
    const em3space: number;
    const em4space: number;
    const emacron: number;
    const emdash: number;
    const emfilledcircle: number;
    const emfilledrect: number;
    const emopencircle: number;
    const emopenrectangle: number;
    const emptyset: number;
    const emspace: number;
    const endash: number;
    const enfilledcircbullet: number;
    const enfilledsqbullet: number;
    const eng: number;
    const enopencircbullet: number;
    const enopensquarebullet: number;
    const enspace: number;
    const eogonek: number;
    const equal: number;
    const eth: number;
    const etilde: number;
    const exclam: number;
    const exclamdown: number;
    const ezh: number;
    const f: number;
    const fabovedot: number;
    const femalesymbol: number;
    const ff: number;
    const figdash: number;
    const filledlefttribullet: number;
    const filledrectbullet: number;
    const filledrighttribullet: number;
    const filledtribulletdown: number;
    const filledtribulletup: number;
    const fiveeighths: number;
    const fivesixths: number;
    const fivesubscript: number;
    const fivesuperior: number;
    const fourfifths: number;
    const foursubscript: number;
    const foursuperior: number;
    const fourthroot: number;
    const __function: number;
    const g: number;
    const gabovedot: number;
    const gbreve: number;
    const gcaron: number;
    const gcedilla: number;
    const gcircumflex: number;
    const grave: number;
    const greater: number;
    const greaterthanequal: number;
    const guillemotleft: number;
    const guillemotright: number;
    const h: number;
    const hairspace: number;
    const hcircumflex: number;
    const heart: number;
    const hebrew_aleph: number;
    const hebrew_ayin: number;
    const hebrew_bet: number;
    const hebrew_beth: number;
    const hebrew_chet: number;
    const hebrew_dalet: number;
    const hebrew_daleth: number;
    const hebrew_doublelowline: number;
    const hebrew_finalkaph: number;
    const hebrew_finalmem: number;
    const hebrew_finalnun: number;
    const hebrew_finalpe: number;
    const hebrew_finalzade: number;
    const hebrew_finalzadi: number;
    const hebrew_gimel: number;
    const hebrew_gimmel: number;
    const hebrew_he: number;
    const hebrew_het: number;
    const hebrew_kaph: number;
    const hebrew_kuf: number;
    const hebrew_lamed: number;
    const hebrew_mem: number;
    const hebrew_nun: number;
    const hebrew_pe: number;
    const hebrew_qoph: number;
    const hebrew_resh: number;
    const hebrew_samech: number;
    const hebrew_samekh: number;
    const hebrew_shin: number;
    const hebrew_taf: number;
    const hebrew_taw: number;
    const hebrew_tet: number;
    const hebrew_teth: number;
    const hebrew_waw: number;
    const hebrew_yod: number;
    const hebrew_zade: number;
    const hebrew_zadi: number;
    const hebrew_zain: number;
    const hebrew_zayin: number;
    const hexagram: number;
    const horizconnector: number;
    const horizlinescan1: number;
    const horizlinescan3: number;
    const horizlinescan5: number;
    const horizlinescan7: number;
    const horizlinescan9: number;
    const hstroke: number;
    const ht: number;
    const hyphen: number;
    const i: number;
    const iTouch: number;
    const iacute: number;
    const ibelowdot: number;
    const ibreve: number;
    const icircumflex: number;
    const identical: number;
    const idiaeresis: number;
    const idotless: number;
    const ifonlyif: number;
    const igrave: number;
    const ihook: number;
    const imacron: number;
    const implies: number;
    const includedin: number;
    const includes: number;
    const infinity: number;
    const integral: number;
    const intersection: number;
    const iogonek: number;
    const itilde: number;
    const j: number;
    const jcircumflex: number;
    const jot: number;
    const k: number;
    const kana_A: number;
    const kana_CHI: number;
    const kana_E: number;
    const kana_FU: number;
    const kana_HA: number;
    const kana_HE: number;
    const kana_HI: number;
    const kana_HO: number;
    const kana_HU: number;
    const kana_I: number;
    const kana_KA: number;
    const kana_KE: number;
    const kana_KI: number;
    const kana_KO: number;
    const kana_KU: number;
    const kana_MA: number;
    const kana_ME: number;
    const kana_MI: number;
    const kana_MO: number;
    const kana_MU: number;
    const kana_N: number;
    const kana_NA: number;
    const kana_NE: number;
    const kana_NI: number;
    const kana_NO: number;
    const kana_NU: number;
    const kana_O: number;
    const kana_RA: number;
    const kana_RE: number;
    const kana_RI: number;
    const kana_RO: number;
    const kana_RU: number;
    const kana_SA: number;
    const kana_SE: number;
    const kana_SHI: number;
    const kana_SO: number;
    const kana_SU: number;
    const kana_TA: number;
    const kana_TE: number;
    const kana_TI: number;
    const kana_TO: number;
    const kana_TSU: number;
    const kana_TU: number;
    const kana_U: number;
    const kana_WA: number;
    const kana_WO: number;
    const kana_YA: number;
    const kana_YO: number;
    const kana_YU: number;
    const kana_a: number;
    const kana_closingbracket: number;
    const kana_comma: number;
    const kana_conjunctive: number;
    const kana_e: number;
    const kana_fullstop: number;
    const kana_i: number;
    const kana_middledot: number;
    const kana_o: number;
    const kana_openingbracket: number;
    const kana_switch: number;
    const kana_tsu: number;
    const kana_tu: number;
    const kana_u: number;
    const kana_ya: number;
    const kana_yo: number;
    const kana_yu: number;
    const kappa: number;
    const kcedilla: number;
    const kra: number;
    const l: number;
    const lacute: number;
    const latincross: number;
    const lbelowdot: number;
    const lcaron: number;
    const lcedilla: number;
    const leftanglebracket: number;
    const leftarrow: number;
    const leftcaret: number;
    const leftdoublequotemark: number;
    const leftmiddlecurlybrace: number;
    const leftopentriangle: number;
    const leftpointer: number;
    const leftradical: number;
    const leftshoe: number;
    const leftsinglequotemark: number;
    const leftt: number;
    const lefttack: number;
    const less: number;
    const lessthanequal: number;
    const lf: number;
    const logicaland: number;
    const logicalor: number;
    const lowleftcorner: number;
    const lowrightcorner: number;
    const lstroke: number;
    const m: number;
    const mabovedot: number;
    const macron: number;
    const malesymbol: number;
    const maltesecross: number;
    const marker: number;
    const masculine: number;
    const minus: number;
    const minutes: number;
    const mu: number;
    const multiply: number;
    const musicalflat: number;
    const musicalsharp: number;
    const n: number;
    const nabla: number;
    const nacute: number;
    const ncaron: number;
    const ncedilla: number;
    const ninesubscript: number;
    const ninesuperior: number;
    const nl: number;
    const nobreakspace: number;
    const notapproxeq: number;
    const notelementof: number;
    const notequal: number;
    const notidentical: number;
    const notsign: number;
    const ntilde: number;
    const numbersign: number;
    const numerosign: number;
    const o: number;
    const oacute: number;
    const obarred: number;
    const obelowdot: number;
    const ocaron: number;
    const ocircumflex: number;
    const ocircumflexacute: number;
    const ocircumflexbelowdot: number;
    const ocircumflexgrave: number;
    const ocircumflexhook: number;
    const ocircumflextilde: number;
    const odiaeresis: number;
    const odoubleacute: number;
    const oe: number;
    const ogonek: number;
    const ograve: number;
    const ohook: number;
    const ohorn: number;
    const ohornacute: number;
    const ohornbelowdot: number;
    const ohorngrave: number;
    const ohornhook: number;
    const ohorntilde: number;
    const omacron: number;
    const oneeighth: number;
    const onefifth: number;
    const onehalf: number;
    const onequarter: number;
    const onesixth: number;
    const onesubscript: number;
    const onesuperior: number;
    const onethird: number;
    const ooblique: number;
    const openrectbullet: number;
    const openstar: number;
    const opentribulletdown: number;
    const opentribulletup: number;
    const ordfeminine: number;
    const oslash: number;
    const otilde: number;
    const overbar: number;
    const overline: number;
    const p: number;
    const pabovedot: number;
    const paragraph: number;
    const parenleft: number;
    const parenright: number;
    const partdifferential: number;
    const partialderivative: number;
    const percent: number;
    const period: number;
    const periodcentered: number;
    const permille: number;
    const phonographcopyright: number;
    const plus: number;
    const plusminus: number;
    const prescription: number;
    const prolongedsound: number;
    const punctspace: number;
    const q: number;
    const quad: number;
    const question: number;
    const questiondown: number;
    const quotedbl: number;
    const quoteleft: number;
    const quoteright: number;
    const r: number;
    const racute: number;
    const radical: number;
    const rcaron: number;
    const rcedilla: number;
    const registered: number;
    const rightanglebracket: number;
    const rightarrow: number;
    const rightcaret: number;
    const rightdoublequotemark: number;
    const rightmiddlecurlybrace: number;
    const rightmiddlesummation: number;
    const rightopentriangle: number;
    const rightpointer: number;
    const rightshoe: number;
    const rightsinglequotemark: number;
    const rightt: number;
    const righttack: number;
    const s: number;
    const sabovedot: number;
    const sacute: number;
    const scaron: number;
    const scedilla: number;
    const schwa: number;
    const scircumflex: number;
    const script_switch: number;
    const seconds: number;
    const section: number;
    const semicolon: number;
    const semivoicedsound: number;
    const seveneighths: number;
    const sevensubscript: number;
    const sevensuperior: number;
    const signaturemark: number;
    const signifblank: number;
    const similarequal: number;
    const singlelowquotemark: number;
    const sixsubscript: number;
    const sixsuperior: number;
    const slash: number;
    const soliddiamond: number;
    const space: number;
    const squareroot: number;
    const ssharp: number;
    const sterling: number;
    const stricteq: number;
    const t: number;
    const tabovedot: number;
    const tcaron: number;
    const tcedilla: number;
    const telephone: number;
    const telephonerecorder: number;
    const therefore: number;
    const thinspace: number;
    const thorn: number;
    const threeeighths: number;
    const threefifths: number;
    const threequarters: number;
    const threesubscript: number;
    const threesuperior: number;
    const tintegral: number;
    const topintegral: number;
    const topleftparens: number;
    const topleftradical: number;
    const topleftsqbracket: number;
    const topleftsummation: number;
    const toprightparens: number;
    const toprightsqbracket: number;
    const toprightsummation: number;
    const topt: number;
    const topvertsummationconnector: number;
    const trademark: number;
    const trademarkincircle: number;
    const tslash: number;
    const twofifths: number;
    const twosubscript: number;
    const twosuperior: number;
    const twothirds: number;
    const u: number;
    const uacute: number;
    const ubelowdot: number;
    const ubreve: number;
    const ucircumflex: number;
    const udiaeresis: number;
    const udoubleacute: number;
    const ugrave: number;
    const uhook: number;
    const uhorn: number;
    const uhornacute: number;
    const uhornbelowdot: number;
    const uhorngrave: number;
    const uhornhook: number;
    const uhorntilde: number;
    const umacron: number;
    const underbar: number;
    const underscore: number;
    const union: number;
    const uogonek: number;
    const uparrow: number;
    const upcaret: number;
    const upleftcorner: number;
    const uprightcorner: number;
    const upshoe: number;
    const upstile: number;
    const uptack: number;
    const uring: number;
    const utilde: number;
    const v: number;
    const variation: number;
    const vertbar: number;
    const vertconnector: number;
    const voicedsound: number;
    const vt: number;
    const w: number;
    const wacute: number;
    const wcircumflex: number;
    const wdiaeresis: number;
    const wgrave: number;
    const x: number;
    const xabovedot: number;
    const y: number;
    const yacute: number;
    const ybelowdot: number;
    const ycircumflex: number;
    const ydiaeresis: number;
    const yen: number;
    const ygrave: number;
    const yhook: number;
    const ytilde: number;
    const z: number;
    const zabovedot: number;
    const zacute: number;
    const zcaron: number;
    const zerosubscript: number;
    const zerosuperior: number;
    const zstroke: number;
    /**
     * Allocates a new #ClutterActorBox.
     * @returns the newly allocated #ClutterActorBox.   Use clutter_actor_box_free() to free its resources
     */
    function actor_box_alloc(): ActorBox;
    function base_init(): void;
    /**
     * Utility function to clear a Cairo context.
     * @param cr a Cairo context
     */
    function cairo_clear(cr: cairo.Context): void;
    /**
     * Utility function for setting the source color of `cr` using
     * a #ClutterColor. This function is the equivalent of:
     *
     *
     * ```
     *   cairo_set_source_rgba (cr,
     *                          color->red / 255.0,
     *                          color->green / 255.0,
     *                          color->blue / 255.0,
     *                          color->alpha / 255.0);
     * ```
     *
     * @param cr a Cairo context
     * @param color a #ClutterColor
     */
    function cairo_set_source_color(cr: cairo.Context, color: Color): void;
    /**
     * Run-time version check, to check the version the Clutter library
     * that an application is currently linked against
     *
     * This is the run-time equivalent of the compile-time %CLUTTER_CHECK_VERSION
     * pre-processor macro
     * @param major major version, like 1 in 1.2.3
     * @param minor minor version, like 2 in 1.2.3
     * @param micro micro version, like 3 in 1.2.3
     * @returns %TRUE if the version of the Clutter library is   greater than (@major, @minor, @micro), and %FALSE otherwise
     */
    function check_version(major: number, minor: number, micro: number): boolean;
    /**
     * Checks the run-time name of the Clutter windowing system backend, using
     * the symbolic macros like %CLUTTER_WINDOWING_WIN32 or
     * %CLUTTER_WINDOWING_X11.
     *
     * This function should be used in conjuction with the compile-time macros
     * inside applications and libraries that are using the platform-specific
     * windowing system API, to ensure that they are running on the correct
     * windowing system; for instance:
     *
     *
     * ```
     * #ifdef CLUTTER_WINDOWING_X11
     *   if (clutter_check_windowing_backend (CLUTTER_WINDOWING_X11))
     *     {
     *       // it is safe to use the clutter_x11_* API
     *     }
     *   else
     * #endif
     * #ifdef CLUTTER_WINDOWING_WIN32
     *   if (clutter_check_windowing_backend (CLUTTER_WINDOWING_WIN32))
     *     {
     *       // it is safe to use the clutter_win32_* API
     *     }
     *   else
     * #endif
     *     g_error ("Unknown Clutter backend.");
     * ```
     *
     * @param backend_type the name of the backend to check
     * @returns %TRUE if the current Clutter windowing system backend is   the one checked, and %FALSE otherwise
     */
    function check_windowing_backend(backend_type: string): boolean;
    /**
     * Clears the internal cache of glyphs used by the Pango
     * renderer. This will free up some memory and GL texture
     * resources. The cache will be automatically refilled as more text is
     * drawn.
     */
    function clear_glyph_cache(): void;
    /**
     * Converts a color expressed in HLS (hue, luminance and saturation)
     * values into a #ClutterColor.
     * @param hue hue value, in the 0 .. 360 range
     * @param luminance luminance value, in the 0 .. 1 range
     * @param saturation saturation value, in the 0 .. 1 range
     */
    function color_from_hls(hue: number, luminance: number, saturation: number): Color;
    /**
     * Converts `pixel` from the packed representation of a four 8 bit channel
     * color to a #ClutterColor.
     * @param pixel a 32 bit packed integer containing a color
     */
    function color_from_pixel(pixel: number): Color;
    /**
     * Parses a string definition of a color, filling the #ClutterColor.red,
     * #ClutterColor.green, #ClutterColor.blue and #ClutterColor.alpha fields
     * of `color`.
     *
     * The `color` is not allocated.
     *
     * The format of `str` can be either one of:
     *
     *   - a standard name (as taken from the X11 rgb.txt file)
     *   - an hexadecimal value in the form: `#rgb`, `#rrggbb`, `#rgba`, or `#rrggbbaa`
     *   - a RGB color in the form: `rgb(r, g, b)`
     *   - a RGB color in the form: `rgba(r, g, b, a)`
     *   - a HSL color in the form: `hsl(h, s, l)`
     *    -a HSL color in the form: `hsla(h, s, l, a)`
     *
     * where 'r', 'g', 'b' and 'a' are (respectively) the red, green, blue color
     * intensities and the opacity. The 'h', 's' and 'l' are (respectively) the
     * hue, saturation and luminance values.
     *
     * In the rgb() and rgba() formats, the 'r', 'g', and 'b' values are either
     * integers between 0 and 255, or percentage values in the range between 0%
     * and 100%; the percentages require the '%' character. The 'a' value, if
     * specified, can only be a floating point value between 0.0 and 1.0.
     *
     * In the hls() and hlsa() formats, the 'h' value (hue) is an angle between
     * 0 and 360.0 degrees; the 'l' and 's' values (luminance and saturation) are
     * percentage values in the range between 0% and 100%. The 'a' value, if specified,
     * can only be a floating point value between 0.0 and 1.0.
     *
     * Whitespace inside the definitions is ignored; no leading whitespace
     * is allowed.
     *
     * If the alpha component is not specified then it is assumed to be set to
     * be fully opaque.
     * @param str a string specifiying a color
     * @returns %TRUE if parsing succeeded, and %FALSE otherwise
     */
    function color_from_string(str: string): [boolean, Color];
    /**
     * Retrieves a static color for the given `color` name
     *
     * Static colors are created by Clutter and are guaranteed to always be
     * available and valid
     * @param color the named global color
     * @returns a pointer to a static color; the returned pointer   is owned by Clutter and it should never be modified or freed
     */
    function color_get_static(color: StaticColor | null): Color;
    /**
     * Looks up the #GParamSpec for a child property of `klass`.
     * @param klass a #GObjectClass implementing the #ClutterContainer interface.
     * @param property_name a property name.
     * @returns The #GParamSpec for the property or %NULL   if no such property exist.
     */
    function container_class_find_child_property(
        klass: typeof GObject.Object,
        property_name: string,
    ): GObject.ParamSpec;
    /**
     * Returns an array of #GParamSpec for all child properties.
     * @param klass a #GObjectClass implementing the #ClutterContainer interface.
     * @returns an array   of #GParamSpec<!-- -->s which should be freed after use.
     */
    function container_class_list_child_properties(klass: typeof GObject.Object): GObject.ParamSpec[];
    /**
     * Disable loading the accessibility support. It has the same effect
     * as setting the environment variable
     * CLUTTER_DISABLE_ACCESSIBILITY. For the same reason, this method
     * should be called before clutter_init().
     */
    function disable_accessibility(): void;
    /**
     * Processes an event.
     *
     * The `event` must be a valid #ClutterEvent and have a #ClutterStage
     * associated to it.
     *
     * This function is only useful when embedding Clutter inside another
     * toolkit, and it should never be called by applications.
     * @param event a #ClutterEvent.
     */
    function do_event(event: Event): void;
    /**
     * Adds a function which will be called for all events that Clutter
     * processes. The function will be called before any signals are
     * emitted for the event and it will take precedence over any grabs.
     * @param stage The #ClutterStage to capture events for
     * @param func The callback function which will be passed all events.
     * @returns an identifier for the event filter, to be used   with clutter_event_remove_filter().
     */
    function event_add_filter(stage: Stage | null, func: EventFilterFunc): number;
    /**
     * Pops an event off the event queue. Applications should not need to call
     * this.
     * @returns A #ClutterEvent or NULL if queue empty
     */
    function event_get(): Event;
    /**
     * Returns a pointer to the first event from the event queue but
     * does not remove it.
     * @returns A #ClutterEvent or NULL if queue empty.
     */
    function event_peek(): Event;
    /**
     * Removes an event filter that was previously added with
     * clutter_event_add_filter().
     * @param id The ID of the event filter, as returned from clutter_event_add_filter()
     */
    function event_remove_filter(id: number): void;
    /**
     * Checks if events are pending in the event queue.
     * @returns TRUE if there are pending events, FALSE otherwise.
     */
    function events_pending(): boolean;
    /**
     * Checks whether `feature` is available.  `feature` can be a logical
     * OR of #ClutterFeatureFlags.
     * @param feature a #ClutterFeatureFlags
     * @returns %TRUE if a feature is available
     */
    function feature_available(feature: FeatureFlags | null): boolean;
    /**
     * Returns all the supported features.
     * @returns a logical OR of all the supported features.
     */
    function feature_get_all(): FeatureFlags;
    /**
     * Sets a function to be called at regular intervals with the given
     * priority.  The function is called repeatedly until it returns
     * %FALSE, at which point the timeout is automatically destroyed and
     * the function will not be called again.  The `notify` function is
     * called when the timeout is destroyed.  The first call to the
     * function will be at the end of the first `interval`.
     *
     * This function is similar to g_timeout_add_full() except that it
     * will try to compensate for delays. For example, if `func` takes half
     * the interval time to execute then the function will be called again
     * half the interval time after it finished. In contrast
     * g_timeout_add_full() would not fire until a full interval after the
     * function completes so the delay between calls would be 1.0 / `fps` *
     * 1.5. This function does not however try to invoke the function
     * multiple times to catch up missing frames if `func` takes more than
     * `interval` ms to execute.
     * @param priority the priority of the frame source. Typically this will be in the   range between %G_PRIORITY_DEFAULT and %G_PRIORITY_HIGH.
     * @param fps the number of times per second to call the function
     * @param func function to call
     * @returns the ID (greater than 0) of the event source.
     */
    function frame_source_add(priority: number, fps: number, func: GLib.SourceFunc): number;
    /**
     * Returns whether Clutter has accessibility support enabled.  As
     * least, a value of TRUE means that there are a proper AtkUtil
     * implementation available
     * @returns %TRUE if Clutter has accessibility support enabled
     */
    function get_accessibility_enabled(): boolean;
    /**
     * Retrieves the #ClutterActor with `id_`.
     * @param id_ a #ClutterActor unique id.
     * @returns the actor with the passed id or %NULL.   The returned actor does not have its reference count increased.
     */
    function get_actor_by_gid(id_: number): Actor;
    /**
     * If an event is currently being processed, return that event.
     * This function is intended to be used to access event state
     * that might not be exposed by higher-level widgets.  For
     * example, to get the key modifier state from a Button 'clicked'
     * event.
     * @returns The current ClutterEvent, or %NULL if none
     */
    function get_current_event(): Event;
    /**
     * Retrieves the timestamp of the last event, if there is an
     * event or if the event has a timestamp.
     * @returns the event timestamp, or %CLUTTER_CURRENT_TIME
     */
    function get_current_event_time(): number;
    /**
     * Check if Clutter has debugging enabled.
     * @returns %FALSE
     */
    function get_debug_enabled(): boolean;
    /**
     * Retrieves the default #ClutterBackend used by Clutter. The
     * #ClutterBackend holds backend-specific configuration options.
     * @returns the default backend. You should   not ref or unref the returned object. Applications should rarely   need to use this.
     */
    function get_default_backend(): Backend;
    /**
     * Retrieves the default frame rate. See clutter_set_default_frame_rate().
     * @returns the default frame rate
     */
    function get_default_frame_rate(): number;
    /**
     * Retrieves the default direction for the text. The text direction is
     * determined by the locale and/or by the `CLUTTER_TEXT_DIRECTION`
     * environment variable.
     *
     * The default text direction can be overridden on a per-actor basis by using
     * clutter_actor_set_text_direction().
     * @returns the default text direction
     */
    function get_default_text_direction(): TextDirection;
    /**
     * Gets the current font flags for rendering text. See
     * clutter_set_font_flags().
     * @returns The font flags
     */
    function get_font_flags(): FontFlags;
    /**
     * Retrieves the #PangoFontMap instance used by Clutter.
     * You can use the global font map object with the COGL
     * Pango API.
     * @returns the #PangoFontMap instance. The returned   value is owned by Clutter and it should never be unreferenced.
     */
    function get_font_map(): Pango.FontMap;
    /**
     * Retrieves the #ClutterInputDevice from its `id_`. This is a convenience
     * wrapper for clutter_device_manager_get_device() and it is functionally
     * equivalent to:
     *
     *
     * ```
     *   ClutterDeviceManager *manager;
     *   ClutterInputDevice *device;
     *
     *   manager = clutter_device_manager_get_default ();
     *   device = clutter_device_manager_get_device (manager, id);
     * ```
     *
     * @param id_ the unique id for a device
     * @returns a #ClutterInputDevice, or %NULL
     */
    function get_input_device_for_id(id_: number): InputDevice;
    /**
     * Queries the current keyboard grab of clutter.
     * @returns the actor currently holding the keyboard grab, or NULL if there is no grab.
     */
    function get_keyboard_grab(): Actor;
    /**
     * Gets whether the per-actor motion events are enabled.
     * @returns %TRUE if the motion events are enabled
     */
    function get_motion_events_enabled(): boolean;
    /**
     * Queries the current pointer grab of clutter.
     * @returns the actor currently holding the pointer grab, or NULL if there is no grab.
     */
    function get_pointer_grab(): Actor;
    /**
     * Retrieves the Clutter script id, if any.
     * @param gobject a #GObject
     * @returns the script id, or %NULL if @object was not defined inside   a UI definition file. The returned string is owned by the object and   should never be modified or freed.
     */
    function get_script_id(gobject: GObject.Object): string;
    /**
     * Returns whether Clutter should print out the frames per second on the
     * console. You can enable this setting either using the
     * <literal>CLUTTER_SHOW_FPS</literal> environment variable or passing
     * the <literal>--clutter-show-fps</literal> command line argument. *
     * @returns %TRUE if Clutter should show the FPS.
     */
    function get_show_fps(): boolean;
    /**
     * Returns the approximate number of microseconds passed since Clutter was
     * intialised.
     *
     * This function shdould not be used by application code.
     *
     * The output of this function depends on whether Clutter was configured to
     * enable its debugging code paths, so it's less useful than intended.
     *
     * Since Clutter 1.10, this function is an alias to g_get_monotonic_time()
     * if Clutter was configured to enable the debugging code paths.
     * @returns Number of microseconds since clutter_init() was called, or   zero if Clutter was not configured with debugging code paths.
     */
    function get_timestamp(): number;
    /**
     * Grabs keyboard events, after the grab is done keyboard
     * events (#ClutterActor::key-press-event and #ClutterActor::key-release-event)
     * are delivered to this actor directly. The source set in the event will be
     * the actor that would have received the event if the keyboard grab was not
     * in effect.
     *
     * Like pointer grabs, keyboard grabs should only be used as a last
     * resource.
     *
     * See also clutter_stage_set_key_focus() and clutter_actor_grab_key_focus()
     * to perform a "soft" key grab and assign key focus to a specific actor.
     * @param actor a #ClutterActor
     */
    function grab_keyboard(actor: Actor): void;
    /**
     * Grabs pointer events, after the grab is done all pointer related events
     * (press, motion, release, enter, leave and scroll) are delivered to this
     * actor directly without passing through both capture and bubble phases of
     * the event delivery chain. The source set in the event will be the actor
     * that would have received the event if the pointer grab was not in effect.
     *
     * Grabs completely override the entire event delivery chain
     * done by Clutter. Pointer grabs should only be used as a last resource;
     * using the #ClutterActor::captured-event signal should always be the
     * preferred way to intercept event delivery to reactive actors.
     *
     * This function should rarely be used.
     *
     * If a grab is required, you are strongly encouraged to use a specific
     * input device by calling clutter_input_device_grab().
     * @param actor a #ClutterActor
     */
    function grab_pointer(actor: Actor): void;
    /**
     * Grabs all the pointer events coming from the device `id` for `actor`.
     *
     * If `id` is -1 then this function is equivalent to clutter_grab_pointer().
     * @param actor a #ClutterActor
     * @param id_ a device id, or -1
     */
    function grab_pointer_for_device(actor: Actor, id_: number): void;
    function image_error_quark(): GLib.Quark;
    /**
     * Initialises everything needed to operate with Clutter and parses some
     * standard command line options; `argc` and `argv` are adjusted accordingly
     * so your own code will never see those standard arguments.
     *
     * It is safe to call this function multiple times.
     *
     * This function will not abort in case of errors during
     * initialization; clutter_init() will print out the error message on
     * stderr, and will return an error code. It is up to the application
     * code to handle this case. If you need to display the error message
     * yourself, you can use clutter_init_with_args(), which takes a #GError
     * pointer.
     *
     * If this function fails, and returns an error code, any subsequent
     * Clutter API will have undefined behaviour - including segmentation
     * faults and assertion failures. Make sure to handle the returned
     * #ClutterInitError enumeration value.
     * @param argv A pointer to an array   of arguments.
     * @returns a #ClutterInitError value
     */
    function init(argv?: string[] | null): [InitError, string[] | null];
    function init_error_quark(): GLib.Quark;
    /**
     * This function does the same work as clutter_init(). Additionally,
     * it allows you to add your own command line options, and it
     * automatically generates nicely formatted <option>--help</option>
     * output. Note that your program will be terminated after writing
     * out the help output. Also note that, in case of error, the
     * error message will be placed inside `error` instead of being
     * printed on the display.
     *
     * Just like clutter_init(), if this function returns an error code then
     * any subsequent call to any other Clutter API will result in undefined
     * behaviour - including segmentation faults.
     * @param argv a pointer to the array   of command line arguments
     * @param parameter_string a string which is displayed in the   first line of <option>--help</option> output, after   <literal><replaceable>programname</replaceable> [OPTION...]</literal>
     * @param entries a %NULL terminated array of   #GOptionEntry<!-- -->s describing the options of your program
     * @param translation_domain a translation domain to use for   translating the <option>--help</option> output for the options in   @entries with gettext(), or %NULL
     * @returns %CLUTTER_INIT_SUCCESS if Clutter has been successfully   initialised, or other values or #ClutterInitError in case of   error.
     */
    function init_with_args(
        argv?: string[] | null,
        parameter_string?: string | null,
        entries?: GLib.OptionEntry[] | null,
        translation_domain?: string | null,
    ): [InitError, string[] | null];
    /**
     * Converts `keyval` from a Clutter key symbol to the corresponding
     * ISO10646 (Unicode) character.
     * @param keyval a key symbol
     * @returns a Unicode character, or 0 if there  is no corresponding   character.
     */
    function keysym_to_unicode(keyval: number): number;
    /**
     * Starts the Clutter mainloop.
     */
    function main(): void;
    /**
     * Retrieves the depth of the Clutter mainloop.
     * @returns The level of the mainloop.
     */
    function main_level(): number;
    /**
     * Terminates the Clutter mainloop.
     */
    function main_quit(): void;
    /**
     * Allocates enough memory to hold a #ClutterMatrix.
     * @returns the newly allocated #ClutterMatrix
     */
    function matrix_alloc(): Matrix;
    /**
     * A point centered at (0, 0).
     *
     * The returned value can be used as a guard.
     * @returns a point centered in (0, 0); the returned #ClutterPoint   is owned by Clutter and it should not be modified or freed.
     */
    function point_zero(): Point;
    /**
     * A #ClutterRect with #ClutterRect.origin set at (0, 0) and a size
     * of 0.
     *
     * The returned value can be used as a guard.
     * @returns a rectangle with origin in (0, 0) and a size of 0.   The returned #ClutterRect is owned by Clutter and it should not   be modified or freed.
     */
    function rect_zero(): Rect;
    /**
     * Forces a redraw of the entire stage. Applications should never use this
     * function, but queue a redraw using clutter_actor_queue_redraw().
     *
     * This function should only be used by libraries integrating Clutter from
     * within another toolkit.
     * @param stage
     */
    function redraw(stage: Stage): void;
    function script_error_quark(): GLib.Quark;
    /**
     * Sets the default frame rate. This frame rate will be used to limit
     * the number of frames drawn if Clutter is not able to synchronize
     * with the vertical refresh rate of the display. When synchronization
     * is possible, this value is ignored.
     * @param frames_per_sec the new default frame rate
     */
    function set_default_frame_rate(frames_per_sec: number): void;
    /**
     * Sets the font quality options for subsequent text rendering
     * operations.
     *
     * Using mipmapped textures will improve the quality for scaled down
     * text but will use more texture memory.
     *
     * Enabling hinting improves text quality for static text but may
     * introduce some artifacts if the text is animated.
     * @param flags The new flags
     */
    function set_font_flags(flags: FontFlags | null): void;
    /**
     * Sets whether per-actor motion events should be enabled or not on
     * all #ClutterStage<!-- -->s managed by Clutter.
     *
     * If `enable` is %FALSE the following events will not work:
     *
     *  - ClutterActor::motion-event, except on the #ClutterStage
     *  - ClutterActor::enter-event
     *  - ClutterActor::leave-event
     * @param enable %TRUE to enable per-actor motion events
     */
    function set_motion_events_enabled(enable: boolean): void;
    /**
     * Restricts Clutter to only use the specified backend or list of backends.
     *
     * You can use one of the `CLUTTER_WINDOWING_*` symbols, e.g.
     *
     *
     * ```c
     *   clutter_set_windowing_backend (CLUTTER_WINDOWING_X11);
     * ```
     *
     *
     * Will force Clutter to use the X11 windowing and input backend, and terminate
     * if the X11 backend could not be initialized successfully.
     *
     * Since Clutter 1.26, you can also use a comma-separated list of windowing
     * system backends to provide a fallback in case backends are not available or
     * enabled, e.g.:
     *
     *
     * ```c
     *   clutter_set_windowing_backend ("gdk,wayland,x11");
     * ```
     *
     *
     * Will make Clutter test for the GDK, Wayland, and X11 backends in that order.
     *
     * You can use the `*` special value to ask Clutter to use the internally
     * defined list of backends. For instance:
     *
     *
     * ```c
     *   clutter_set_windowing_backend ("x11,wayland,*");
     * ```
     *
     *
     * Will make Clutter test the X11 and Wayland backends, and then fall back
     * to the internal list of available backends.
     *
     * This function must be called before the first API call to Clutter, including
     * clutter_get_option_context()
     * @param backend_type a comma separated list of windowing backends
     */
    function set_windowing_backend(backend_type: string): void;
    function shader_error_quark(): GLib.Quark;
    /**
     * Adds a test unit to the Clutter test environment.
     *
     * See also: g_test_add_data_func_full()
     * @param test_path unique path for identifying the test
     * @param test_func function containing the test
     */
    function test_add_data_full(test_path: string, test_func: GLib.TestDataFunc): void;
    /**
     * Checks the given coordinates of the `stage` and compares the
     * actor found there with the given `actor`.
     * @param stage a #ClutterStage
     * @param point coordinates to check
     * @param actor the expected actor at the given coordinates
     * @returns %TRUE if the actor at the given coordinates matches
     */
    function test_check_actor_at_point(stage: Actor, point: Point, actor: Actor): [boolean, Actor | null];
    /**
     * Checks the color at the given coordinates on `stage,` and matches
     * it with the red, green, and blue channels of `color`. The alpha
     * component of `color` and `result` is ignored.
     * @param stage a #ClutterStage
     * @param point coordinates to check
     * @param color expected color
     * @returns %TRUE if the colors match
     */
    function test_check_color_at_point(stage: Actor, point: Point, color: Color): [boolean, Color];
    /**
     * Retrieves the #ClutterStage used for testing.
     * @returns the stage used for testing
     */
    function test_get_stage(): Actor;
    function test_init(argc: number, argv: string): void;
    /**
     * Runs the test suite using the units added by calling
     * clutter_test_add().
     *
     * The typical test suite is composed of a list of functions
     * called by clutter_test_run(), for instance:
     *
     *
     * ```
     * static void unit_foo (void) { ... }
     *
     * static void unit_bar (void) { ... }
     *
     * static void unit_baz (void) { ... }
     *
     * int
     * main (int argc, char *argv[])
     * {
     *   clutter_test_init (&argc, &argv);
     *
     *   clutter_test_add ("/unit/foo", unit_foo);
     *   clutter_test_add ("/unit/bar", unit_bar);
     *   clutter_test_add ("/unit/baz", unit_baz);
     *
     *   return clutter_test_run ();
     * }
     * ```
     *
     * @returns the exit code for the test suite
     */
    function test_run(): number;
    function texture_error_quark(): GLib.Quark;
    /**
     * Sets a function to be called at regular intervals holding the Clutter
     * threads lock, with the given priority. The function is called repeatedly
     * until it returns %FALSE, at which point the timeout is automatically
     * removed and the function will not be called again. The `notify` function
     * is called when the timeout is removed.
     *
     * This function is similar to clutter_threads_add_timeout_full()
     * except that it will try to compensate for delays. For example, if
     * `func` takes half the interval time to execute then the function
     * will be called again half the interval time after it finished. In
     * contrast clutter_threads_add_timeout_full() would not fire until a
     * full interval after the function completes so the delay between
     * calls would be `interval` * 1.5. This function does not however try
     * to invoke the function multiple times to catch up missing frames if
     * `func` takes more than `interval` ms to execute.
     *
     * See also clutter_threads_add_idle_full().
     * @param priority the priority of the frame source. Typically this will be in the   range between %G_PRIORITY_DEFAULT and %G_PRIORITY_HIGH.
     * @param fps the number of times per second to call the function
     * @param func function to call
     * @returns the ID (greater than 0) of the event source.
     */
    function threads_add_frame_source(priority: number, fps: number, func: GLib.SourceFunc): number;
    /**
     * Adds a function to be called whenever there are no higher priority
     * events pending. If the function returns %FALSE it is automatically
     * removed from the list of event sources and will not be called again.
     *
     * This function can be considered a thread-safe variant of g_idle_add_full():
     * it will call `function` while holding the Clutter lock. It is logically
     * equivalent to the following implementation:
     *
     *
     * ```
     * static gboolean
     * idle_safe_callback (gpointer data)
     * {
     *    SafeClosure *closure = data;
     *    gboolean res = FALSE;
     *
     *    // mark the critical section //
     *
     *    clutter_threads_enter();
     *
     *    // the callback does not need to acquire the Clutter
     *     / lock itself, as it is held by the this proxy handler
     *     //
     *    res = closure->callback (closure->data);
     *
     *    clutter_threads_leave();
     *
     *    return res;
     * }
     * static gulong
     * add_safe_idle (GSourceFunc callback,
     *                gpointer    data)
     * {
     *   SafeClosure *closure = g_new0 (SafeClosure, 1);
     *
     *   closure->callback = callback;
     *   closure->data = data;
     *
     *   return g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,
     *                           idle_safe_callback,
     *                           closure,
     *                           g_free)
     * }
     * ```
     *
     *
     * This function should be used by threaded applications to make sure
     * that `func` is emitted under the Clutter threads lock and invoked
     * from the same thread that started the Clutter main loop. For instance,
     * it can be used to update the UI using the results from a worker
     * thread:
     *
     *
     * ```
     * static gboolean
     * update_ui (gpointer data)
     * {
     *   SomeClosure *closure = data;
     *
     *   // it is safe to call Clutter API from this function because
     *    / it is invoked from the same thread that started the main
     *    / loop and under the Clutter thread lock
     *    //
     *   clutter_label_set_text (CLUTTER_LABEL (closure->label),
     *                           closure->text);
     *
     *   g_object_unref (closure->label);
     *   g_free (closure);
     *
     *   return FALSE;
     * }
     *
     *   // within another thread //
     *   closure = g_new0 (SomeClosure, 1);
     *   // always take a reference on GObject instances //
     *   closure->label = g_object_ref (my_application->label);
     *   closure->text = g_strdup (processed_text_to_update_the_label);
     *
     *   clutter_threads_add_idle_full (G_PRIORITY_HIGH_IDLE,
     *                                  update_ui,
     *                                  closure,
     *                                  NULL);
     * ```
     *
     * @param priority the priority of the timeout source. Typically this will be in the    range between #G_PRIORITY_DEFAULT_IDLE and #G_PRIORITY_HIGH_IDLE
     * @param func function to call
     * @returns the ID (greater than 0) of the event source.
     */
    function threads_add_idle(priority: number, func: GLib.SourceFunc): number;
    /**
     * Adds a function to be called whenever Clutter is processing a new
     * frame.
     *
     * If the function returns %FALSE it is automatically removed from the
     * list of repaint functions and will not be called again.
     *
     * This function is guaranteed to be called from within the same thread
     * that called clutter_main(), and while the Clutter lock is being held;
     * the function will be called within the main loop, so it is imperative
     * that it does not block, otherwise the frame time budget may be lost.
     *
     * A repaint function is useful to ensure that an update of the scenegraph
     * is performed before the scenegraph is repainted; for instance, uploading
     * a frame from a video into a #ClutterTexture. By default, a repaint
     * function added using this function will be invoked prior to the frame
     * being processed.
     *
     * Adding a repaint function does not automatically ensure that a new
     * frame will be queued.
     *
     * When the repaint function is removed (either because it returned %FALSE
     * or because clutter_threads_remove_repaint_func() has been called) the
     * `notify` function will be called, if any is set.
     *
     * See also: clutter_threads_add_repaint_func_full()
     * @param func the function to be called within the paint cycle
     * @returns the ID (greater than 0) of the repaint function. You   can use the returned integer to remove the repaint function by   calling clutter_threads_remove_repaint_func().
     */
    function threads_add_repaint_func(func: GLib.SourceFunc): number;
    /**
     * Adds a function to be called whenever Clutter is processing a new
     * frame.
     *
     * If the function returns %FALSE it is automatically removed from the
     * list of repaint functions and will not be called again.
     *
     * This function is guaranteed to be called from within the same thread
     * that called clutter_main(), and while the Clutter lock is being held;
     * the function will be called within the main loop, so it is imperative
     * that it does not block, otherwise the frame time budget may be lost.
     *
     * A repaint function is useful to ensure that an update of the scenegraph
     * is performed before the scenegraph is repainted; for instance, uploading
     * a frame from a video into a #ClutterTexture. The `flags` passed to this
     * function will determine the section of the frame processing that will
     * result in `func` being called.
     *
     * Adding a repaint function does not automatically ensure that a new
     * frame will be queued.
     *
     * When the repaint function is removed (either because it returned %FALSE
     * or because clutter_threads_remove_repaint_func() has been called) the
     * `notify` function will be called, if any is set.
     * @param flags flags for the repaint function
     * @param func the function to be called within the paint cycle
     * @returns the ID (greater than 0) of the repaint function. You   can use the returned integer to remove the repaint function by   calling clutter_threads_remove_repaint_func().
     */
    function threads_add_repaint_func_full(flags: RepaintFlags | null, func: GLib.SourceFunc): number;
    /**
     * Sets a function to be called at regular intervals holding the Clutter
     * threads lock, with the given priority. The function is called repeatedly
     * until it returns %FALSE, at which point the timeout is automatically
     * removed and the function will not be called again. The `notify` function
     * is called when the timeout is removed.
     *
     * The first call to the function will be at the end of the first `interval`.
     *
     * It is important to note that, due to how the Clutter main loop is
     * implemented, the timing will not be accurate and it will not try to
     * "keep up" with the interval.
     *
     * See also clutter_threads_add_idle_full().
     * @param priority the priority of the timeout source. Typically this will be in the            range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
     * @param interval the time between calls to the function, in milliseconds
     * @param func function to call
     * @returns the ID (greater than 0) of the event source.
     */
    function threads_add_timeout(priority: number, interval: number, func: GLib.SourceFunc): number;
    /**
     * Locks the Clutter thread lock.
     */
    function threads_enter(): void;
    /**
     * Initialises the Clutter threading mechanism, so that Clutter API can be
     * called by multiple threads, using clutter_threads_enter() and
     * clutter_threads_leave() to mark the critical sections.
     *
     * You must call g_thread_init() before this function.
     *
     * This function must be called before clutter_init().
     *
     * It is safe to call this function multiple times.
     */
    function threads_init(): void;
    /**
     * Unlocks the Clutter thread lock.
     */
    function threads_leave(): void;
    /**
     * Removes the repaint function with `handle_id` as its id
     * @param handle_id an unsigned integer greater than zero
     */
    function threads_remove_repaint_func(handle_id: number): void;
    /**
     * Removes an existing grab of the keyboard.
     */
    function ungrab_keyboard(): void;
    /**
     * Removes an existing grab of the pointer.
     */
    function ungrab_pointer(): void;
    /**
     * Removes an existing grab of the pointer events for device `id_`.
     * @param id_ a device id
     */
    function ungrab_pointer_for_device(id_: number): void;
    /**
     * Convert from a ISO10646 character to a key symbol.
     * @param wc a ISO10646 encoded character
     * @returns the corresponding Clutter key symbol, if one exists.   or, if there is no corresponding symbol, wc | 0x01000000
     */
    function unicode_to_keysym(wc: number): number;
    /**
     * Stores a value in centimeters inside `units`
     * @param cm centimeters
     */
    function units_from_cm(cm: number): Units;
    /**
     * Stores a value in em inside `units,` using the default font
     * name as returned by clutter_backend_get_font_name()
     * @param em em
     */
    function units_from_em(em: number): Units;
    /**
     * Stores a value in em inside `units` using `font_name`
     * @param font_name the font name and size
     * @param em em
     */
    function units_from_em_for_font(font_name: string | null, em: number): Units;
    /**
     * Stores a value in millimiters inside `units`
     * @param mm millimeters
     */
    function units_from_mm(mm: number): Units;
    /**
     * Stores a value in pixels inside `units`
     * @param px pixels
     */
    function units_from_pixels(px: number): Units;
    /**
     * Stores a value in typographic points inside `units`
     * @param pt typographic points
     */
    function units_from_pt(pt: number): Units;
    /**
     * Parses a value and updates `units` with it
     *
     * A #ClutterUnits expressed in string should match:
     *
     *
     * ```
     *   units: wsp* unit-value wsp* unit-name? wsp*
     *   unit-value: number
     *   unit-name: 'px' | 'pt' | 'mm' | 'em' | 'cm'
     *   number: digit+
     *           | digit* sep digit+
     *   sep: '.' | ','
     *   digit: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
     *   wsp: (#0x20 | #0x9 | #0xA | #0xB | #0xC | #0xD)+
     * ```
     *
     *
     * For instance, these are valid strings:
     *
     *
     * ```
     *   10 px
     *   5.1 em
     *   24 pt
     *   12.6 mm
     *   .3 cm
     * ```
     *
     *
     * While these are not:
     *
     *
     * ```
     *   42 cats
     *   omg!1!ponies
     * ```
     *
     *
     * If no unit is specified, pixels are assumed.
     * @param str the string to convert
     * @returns %TRUE if the string was successfully parsed,   and %FALSE otherwise
     */
    function units_from_string(str: string): [boolean, Units];
    /**
     * Calculates the nearest power of two, greater than or equal to `a`.
     * @param a Value to get the next power
     * @returns The nearest power of two, greater or equal to @a.
     */
    function util_next_p2(a: number): number;
    /**
     * Retrieves a pointer to the #ClutterPaintNode contained inside
     * the passed #GValue, and if not %NULL it will increase the
     * reference count.
     * @param value a #GValue initialized with %CLUTTER_TYPE_PAINT_NODE
     * @returns a pointer   to the #ClutterPaintNode, with its reference count increased,   or %NULL
     */
    function value_dup_paint_node(value: GObject.Value | any): PaintNode;
    /**
     * Gets the #ClutterColor contained in `value`.
     * @param value a #GValue initialized to #CLUTTER_TYPE_COLOR
     * @returns the color inside the passed #GValue
     */
    function value_get_color(value: GObject.Value | any): Color;
    /**
     * Retrieves a pointer to the #ClutterPaintNode contained inside
     * the passed #GValue.
     * @param value a #GValue initialized with %CLUTTER_TYPE_PAINT_NODE
     * @returns a pointer to   a #ClutterPaintNode, or %NULL
     */
    function value_get_paint_node(value: GObject.Value | any): PaintNode;
    /**
     * Retrieves the list of floating point values stored inside
     * the passed #GValue. `value` must have been initialized with
     * %CLUTTER_TYPE_SHADER_FLOAT.
     * @param value a #GValue
     * @returns the pointer to a list of   floating point values.  The returned value is owned by the   #GValue and should never be modified or freed.
     */
    function value_get_shader_float(value: GObject.Value | any): number[];
    /**
     * Retrieves the list of integer values stored inside the passed
     * #GValue. `value` must have been initialized with
     * %CLUTTER_TYPE_SHADER_INT.
     * @param value a #GValue
     * @returns the pointer to a list of   integer values.  The returned value is owned by the #GValue and   should never be modified or freed.
     */
    function value_get_shader_int(value: GObject.Value | any): number[];
    /**
     * Retrieves a matrix of floating point values stored inside
     * the passed #GValue. `value` must have been initialized with
     * %CLUTTER_TYPE_SHADER_MATRIX.
     * @param value a #GValue
     * @returns the pointer to a matrix   of floating point values. The returned value is owned by the #GValue and   should never be modified or freed.
     */
    function value_get_shader_matrix(value: GObject.Value | any): number[];
    /**
     * Gets the #ClutterUnits contained in `value`.
     * @param value a #GValue initialized to %CLUTTER_TYPE_UNITS
     * @returns the units inside the passed #GValue
     */
    function value_get_units(value: GObject.Value | any): Units;
    /**
     * Sets `value` to `color`.
     * @param value a #GValue initialized to #CLUTTER_TYPE_COLOR
     * @param color the color to set
     */
    function value_set_color(value: GObject.Value | any, color: Color): void;
    /**
     * Sets the contents of a #GValue initialized with %CLUTTER_TYPE_PAINT_NODE.
     *
     * This function increased the reference count of `node;` if you do not wish
     * to increase the reference count, use clutter_value_take_paint_node()
     * instead. The reference count will be released by g_value_unset().
     * @param value a #GValue initialized with %CLUTTER_TYPE_PAINT_NODE
     * @param node a #ClutterPaintNode, or %NULL
     */
    function value_set_paint_node(value: GObject.Value | any, node?: PaintNode | null): void;
    /**
     * Sets `floats` as the contents of `value`. The passed #GValue
     * must have been initialized using %CLUTTER_TYPE_SHADER_FLOAT.
     * @param value a #GValue
     * @param floats an array of floating point values
     */
    function value_set_shader_float(value: GObject.Value | any, floats: number[]): void;
    /**
     * Sets `ints` as the contents of `value`. The passed #GValue
     * must have been initialized using %CLUTTER_TYPE_SHADER_INT.
     * @param value a #GValue
     * @param ints an array of integer values
     */
    function value_set_shader_int(value: GObject.Value | any, ints: number[]): void;
    /**
     * Sets `matrix` as the contents of `value`. The passed #GValue
     * must have been initialized using %CLUTTER_TYPE_SHADER_MATRIX.
     * @param value a #GValue
     * @param matrix a matrix of floating point values
     */
    function value_set_shader_matrix(value: GObject.Value | any, matrix: number[]): void;
    /**
     * Sets `value` to `units`
     * @param value a #GValue initialized to %CLUTTER_TYPE_UNITS
     * @param units the units to set
     */
    function value_set_units(value: GObject.Value | any, units: Units): void;
    /**
     * Sets the contents of a #GValue initialized with %CLUTTER_TYPE_PAINT_NODE.
     *
     * Unlike clutter_value_set_paint_node(), this function will not take a
     * reference on the passed `node:` instead, it will take ownership of the
     * current reference count.
     * @param value a #GValue, initialized with %CLUTTER_TYPE_PAINT_NODE
     * @param node a #ClutterPaintNode, or %NULL
     */
    function value_take_paint_node(value: GObject.Value | any, node?: PaintNode | null): void;
    interface ActorCreateChildFunc<A = GObject.Object> {
        (item: A): Actor;
    }
    interface AlphaFunc {
        (alpha: Alpha): number;
    }
    interface BehaviourForeachFunc {
        (behaviour: Behaviour, actor: Actor): void;
    }
    interface BindingActionFunc<A = GObject.Object> {
        (gobject: A, action_name: string, key_val: number, modifiers: ModifierType): boolean;
    }
    interface Callback {
        (actor: Actor): void;
    }
    interface EventFilterFunc {
        (event: Event): boolean;
    }
    interface ModelFilterFunc {
        (model: Model, iter: ModelIter): boolean;
    }
    interface ModelForeachFunc {
        (model: Model, iter: ModelIter): boolean;
    }
    interface ModelSortFunc {
        (model: Model, a: GObject.Value | any, b: GObject.Value | any): number;
    }
    interface PathCallback {
        (node: PathNode): void;
    }
    interface ProgressFunc {
        (a: GObject.Value | any, b: GObject.Value | any, progress: number, retval: GObject.Value | any): boolean;
    }
    interface ScriptConnectFunc<A = GObject.Object, B = GObject.Object> {
        (
            script: Script,
            object: A,
            signal_name: string,
            handler_name: string,
            connect_object: B,
            flags: GObject.ConnectFlags,
        ): void;
    }
    interface TimelineProgressFunc {
        (timeline: Timeline, elapsed: number, total: number): number;
    }
    /**
     * Flags used to signal the state of an actor.
     */

    /**
     * Flags used to signal the state of an actor.
     */
    export namespace ActorFlags {
        export const $gtype: GObject.GType<ActorFlags>;
    }

    enum ActorFlags {
        /**
         * the actor will be painted (is visible, and inside
         *   a toplevel, and all parents visible)
         */
        MAPPED,
        /**
         * the resources associated to the actor have been
         *   allocated
         */
        REALIZED,
        /**
         * the actor 'reacts' to mouse events emmitting event
         *   signals
         */
        REACTIVE,
        /**
         * the actor has been shown by the application program
         */
        VISIBLE,
        /**
         * the actor provides an explicit layout management
         *   policy for its children; this flag will prevent Clutter from automatic
         *   queueing of relayout and will defer all layouting to the actor itself
         */
        NO_LAYOUT,
    }
    /**
     * Flags passed to the #ClutterActorClass.allocate() virtual function
     * and to the clutter_actor_allocate() function.
     */

    /**
     * Flags passed to the #ClutterActorClass.allocate() virtual function
     * and to the clutter_actor_allocate() function.
     */
    export namespace AllocationFlags {
        export const $gtype: GObject.GType<AllocationFlags>;
    }

    enum AllocationFlags {
        /**
         * No flag set
         */
        ALLOCATION_NONE,
        /**
         * Whether the absolute origin of the
         *   actor has changed; this implies that any ancestor of the actor has
         *   been moved.
         */
        ABSOLUTE_ORIGIN_CHANGED,
        /**
         * Whether the allocation should be delegated
         *   to the #ClutterLayoutManager instance stored inside the
         *   #ClutterActor:layout-manager property of #ClutterActor. This flag
         *   should only be used if you are subclassing #ClutterActor and
         *   overriding the #ClutterActorClass.allocate() virtual function, but
         *   you wish to use the default implementation of the virtual function
         *   inside #ClutterActor. Added in Clutter 1.10.
         */
        DELEGATE_LAYOUT,
    }
    /**
     * Content repeat modes.
     */

    /**
     * Content repeat modes.
     */
    export namespace ContentRepeat {
        export const $gtype: GObject.GType<ContentRepeat>;
    }

    enum ContentRepeat {
        /**
         * No repeat
         */
        NONE,
        /**
         * Repeat the content on the X axis
         */
        X_AXIS,
        /**
         * Repeat the content on the Y axis
         */
        Y_AXIS,
        /**
         * Repeat the content on both axis
         */
        BOTH,
    }
    /**
     * Flags passed to the paint or pick method of #ClutterEffect.
     */

    /**
     * Flags passed to the paint or pick method of #ClutterEffect.
     */
    export namespace EffectPaintFlags {
        export const $gtype: GObject.GType<EffectPaintFlags>;
    }

    enum EffectPaintFlags {
        /**
         * The actor or one of its children
         *   has queued a redraw before this paint. This implies that the effect
         *   should call clutter_actor_continue_paint() to chain to the next
         *   effect and can not cache any results from a previous paint.
         */
        ACTOR_DIRTY,
    }
    /**
     * Flags for the #ClutterEvent
     */

    /**
     * Flags for the #ClutterEvent
     */
    export namespace EventFlags {
        export const $gtype: GObject.GType<EventFlags>;
    }

    enum EventFlags {
        /**
         * No flag set
         */
        NONE,
        /**
         * Synthetic event
         */
        FLAG_SYNTHETIC,
    }
    /**
     * Runtime flags indicating specific features available via Clutter window
     * system and graphics backend.
     */

    /**
     * Runtime flags indicating specific features available via Clutter window
     * system and graphics backend.
     */
    export namespace FeatureFlags {
        export const $gtype: GObject.GType<FeatureFlags>;
    }

    enum FeatureFlags {
        /**
         * Set if NPOTS textures supported.
         */
        TEXTURE_NPOT,
        /**
         * Set if vblank syncing supported.
         */
        SYNC_TO_VBLANK,
        /**
         * Set if YUV based textures supported.
         */
        TEXTURE_YUV,
        /**
         * Set if texture pixels can be read.
         */
        TEXTURE_READ_PIXELS,
        /**
         * Set if stage size if fixed (i.e framebuffer)
         */
        STAGE_STATIC,
        /**
         * Set if stage is able to be user resized.
         */
        STAGE_USER_RESIZE,
        /**
         * Set if stage has a graphical cursor.
         */
        STAGE_CURSOR,
        /**
         * Set if the backend supports GLSL shaders.
         */
        SHADERS_GLSL,
        /**
         * Set if the backend supports offscreen rendering.
         */
        OFFSCREEN,
        /**
         * Set if multiple stages are supported.
         */
        STAGE_MULTIPLE,
        /**
         * Set if the GLX_INTEL_swap_event is supported.
         */
        SWAP_EVENTS,
    }
    /**
     * Runtime flags to change the font quality. To be used with
     * clutter_set_font_flags().
     */

    /**
     * Runtime flags to change the font quality. To be used with
     * clutter_set_font_flags().
     */
    export namespace FontFlags {
        export const $gtype: GObject.GType<FontFlags>;
    }

    enum FontFlags {
        /**
         * Set to use mipmaps for the glyph cache textures.
         */
        MIPMAPPING,
        /**
         * Set to enable hinting on the glyphs.
         */
        HINTING,
    }
    /**
     * Masks applied to a #ClutterEvent by modifiers.
     *
     * Note that Clutter may add internal values to events which include
     * reserved values such as %CLUTTER_MODIFIER_RESERVED_13_MASK.  Your code
     * should preserve and ignore them.  You can use %CLUTTER_MODIFIER_MASK to
     * remove all reserved values.
     */

    /**
     * Masks applied to a #ClutterEvent by modifiers.
     *
     * Note that Clutter may add internal values to events which include
     * reserved values such as %CLUTTER_MODIFIER_RESERVED_13_MASK.  Your code
     * should preserve and ignore them.  You can use %CLUTTER_MODIFIER_MASK to
     * remove all reserved values.
     */
    export namespace ModifierType {
        export const $gtype: GObject.GType<ModifierType>;
    }

    enum ModifierType {
        /**
         * Mask applied by the Shift key
         */
        SHIFT_MASK,
        /**
         * Mask applied by the Caps Lock key
         */
        LOCK_MASK,
        /**
         * Mask applied by the Control key
         */
        CONTROL_MASK,
        /**
         * Mask applied by the first Mod key
         */
        MOD1_MASK,
        /**
         * Mask applied by the second Mod key
         */
        MOD2_MASK,
        /**
         * Mask applied by the third Mod key
         */
        MOD3_MASK,
        /**
         * Mask applied by the fourth Mod key
         */
        MOD4_MASK,
        /**
         * Mask applied by the fifth Mod key
         */
        MOD5_MASK,
        /**
         * Mask applied by the first pointer button
         */
        BUTTON1_MASK,
        /**
         * Mask applied by the second pointer button
         */
        BUTTON2_MASK,
        /**
         * Mask applied by the third pointer button
         */
        BUTTON3_MASK,
        /**
         * Mask applied by the fourth pointer button
         */
        BUTTON4_MASK,
        /**
         * Mask applied by the fifth pointer button
         */
        BUTTON5_MASK,
        MODIFIER_RESERVED_13_MASK,
        MODIFIER_RESERVED_14_MASK,
        MODIFIER_RESERVED_15_MASK,
        MODIFIER_RESERVED_16_MASK,
        MODIFIER_RESERVED_17_MASK,
        MODIFIER_RESERVED_18_MASK,
        MODIFIER_RESERVED_19_MASK,
        MODIFIER_RESERVED_20_MASK,
        MODIFIER_RESERVED_21_MASK,
        MODIFIER_RESERVED_22_MASK,
        MODIFIER_RESERVED_23_MASK,
        MODIFIER_RESERVED_24_MASK,
        MODIFIER_RESERVED_25_MASK,
        /**
         * Mask applied by the Super key
         */
        SUPER_MASK,
        /**
         * Mask applied by the Hyper key
         */
        HYPER_MASK,
        /**
         * Mask applied by the Meta key
         */
        META_MASK,
        MODIFIER_RESERVED_29_MASK,
        /**
         * Mask applied during release
         */
        RELEASE_MASK,
        /**
         * A mask covering all modifier types
         */
        MODIFIER_MASK,
    }
    /**
     * Possible flags to pass to clutter_actor_set_offscreen_redirect().
     */

    /**
     * Possible flags to pass to clutter_actor_set_offscreen_redirect().
     */
    export namespace OffscreenRedirect {
        export const $gtype: GObject.GType<OffscreenRedirect>;
    }

    enum OffscreenRedirect {
        /**
         * Only redirect
         *   the actor if it is semi-transparent and its has_overlaps()
         *   virtual returns %TRUE. This is the default.
         */
        AUTOMATIC_FOR_OPACITY,
        /**
         * Always redirect the actor to an
         *   offscreen buffer even if it is fully opaque.
         */
        ALWAYS,
    }
    /**
     * Flags to pass to clutter_threads_add_repaint_func_full().
     */

    /**
     * Flags to pass to clutter_threads_add_repaint_func_full().
     */
    export namespace RepaintFlags {
        export const $gtype: GObject.GType<RepaintFlags>;
    }

    enum RepaintFlags {
        /**
         * Run the repaint function prior to
         *   painting the stages
         */
        PRE_PAINT,
        /**
         * Run the repaint function after
         *   painting the stages
         */
        POST_PAINT,
        /**
         * Ensure that a new frame
         *   is queued after adding the repaint function
         */
        QUEUE_REDRAW_ON_ADD,
    }
    /**
     * Flags used to notify the axes that were stopped in a #ClutterScrollEvent.
     * These can be used to trigger post-scroll effects like kinetic scrolling.
     */

    /**
     * Flags used to notify the axes that were stopped in a #ClutterScrollEvent.
     * These can be used to trigger post-scroll effects like kinetic scrolling.
     */
    export namespace ScrollFinishFlags {
        export const $gtype: GObject.GType<ScrollFinishFlags>;
    }

    enum ScrollFinishFlags {
        /**
         * no axis was stopped.
         */
        NONE,
        /**
         * The horizontal axis stopped.
         */
        HORIZONTAL,
        /**
         * The vertical axis stopped.
         */
        VERTICAL,
    }
    /**
     * Scroll modes.
     */

    /**
     * Scroll modes.
     */
    export namespace ScrollMode {
        export const $gtype: GObject.GType<ScrollMode>;
    }

    enum ScrollMode {
        /**
         * Ignore scrolling
         */
        NONE,
        /**
         * Scroll only horizontally
         */
        HORIZONTALLY,
        /**
         * Scroll only vertically
         */
        VERTICALLY,
        /**
         * Scroll in both directions
         */
        BOTH,
    }
    /**
     * Stage state masks, used by the #ClutterEvent of type %CLUTTER_STAGE_STATE.
     */

    /**
     * Stage state masks, used by the #ClutterEvent of type %CLUTTER_STAGE_STATE.
     */
    export namespace StageState {
        export const $gtype: GObject.GType<StageState>;
    }

    enum StageState {
        /**
         * Fullscreen mask
         */
        FULLSCREEN,
        /**
         * Offscreen mask (deprecated)
         */
        OFFSCREEN,
        /**
         * Activated mask
         */
        ACTIVATED,
    }
    /**
     * The main direction of the swipe gesture
     */

    /**
     * The main direction of the swipe gesture
     */
    export namespace SwipeDirection {
        export const $gtype: GObject.GType<SwipeDirection>;
    }

    enum SwipeDirection {
        /**
         * Upwards swipe gesture
         */
        UP,
        /**
         * Downwards swipe gesture
         */
        DOWN,
        /**
         * Leftwards swipe gesture
         */
        LEFT,
        /**
         * Rightwards swipe gesture
         */
        RIGHT,
    }
    /**
     * Flags for clutter_texture_set_from_rgb_data() and
     * clutter_texture_set_from_yuv_data().
     */

    /**
     * Flags for clutter_texture_set_from_rgb_data() and
     * clutter_texture_set_from_yuv_data().
     */
    export namespace TextureFlags {
        export const $gtype: GObject.GType<TextureFlags>;
    }

    enum TextureFlags {
        /**
         * No flags
         */
        NONE,
        /**
         * Unused flag
         */
        RGB_FLAG_BGR,
        /**
         * Unused flag
         */
        RGB_FLAG_PREMULT,
        /**
         * Unused flag
         */
        YUV_FLAG_YUV2,
    }
    namespace Action {
        // Signal signatures
        interface SignalSignatures extends ActorMeta.SignalSignatures {
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends ActorMeta.ConstructorProps {}
    }

    /**
     * The #ClutterAction structure contains only private data and
     * should be accessed using the provided API.
     */
    abstract class Action extends ActorMeta {
        static $gtype: GObject.GType<Action>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Action.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Action.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof Action.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Action.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Action.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Action.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Action.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Action.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace Actor {
        // Signal signatures
        interface SignalSignatures extends GObject.InitiallyUnowned.SignalSignatures {
            'allocation-changed': (arg0: ActorBox, arg1: AllocationFlags) => void;
            'button-press-event': (arg0: ButtonEvent) => boolean | void;
            'button-release-event': (arg0: ButtonEvent) => boolean | void;
            'captured-event': (arg0: Event) => boolean | void;
            destroy: () => void;
            'enter-event': (arg0: CrossingEvent) => boolean | void;
            event: (arg0: Event) => boolean | void;
            hide: () => void;
            'key-focus-in': () => void;
            'key-focus-out': () => void;
            'key-press-event': (arg0: KeyEvent) => boolean | void;
            'key-release-event': (arg0: KeyEvent) => boolean | void;
            'leave-event': (arg0: CrossingEvent) => boolean | void;
            'motion-event': (arg0: MotionEvent) => boolean | void;
            paint: () => void;
            'parent-set': (arg0: Actor | null) => void;
            pick: (arg0: Color) => void;
            'queue-redraw': (arg0: Actor) => void;
            'queue-relayout': () => void;
            realize: () => void;
            'scroll-event': (arg0: ScrollEvent) => boolean | void;
            show: () => void;
            'touch-event': (arg0: Event) => boolean | void;
            'transition-stopped': (arg0: string, arg1: boolean) => void;
            'transitions-completed': () => void;
            unrealize: () => void;
            'notify::actions': (pspec: GObject.ParamSpec) => void;
            'notify::allocation': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-x': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-y': (pspec: GObject.ParamSpec) => void;
            'notify::background-color': (pspec: GObject.ParamSpec) => void;
            'notify::background-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::clip': (pspec: GObject.ParamSpec) => void;
            'notify::clip-rect': (pspec: GObject.ParamSpec) => void;
            'notify::clip-to-allocation': (pspec: GObject.ParamSpec) => void;
            'notify::constraints': (pspec: GObject.ParamSpec) => void;
            'notify::content': (pspec: GObject.ParamSpec) => void;
            'notify::content-box': (pspec: GObject.ParamSpec) => void;
            'notify::content-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::content-repeat': (pspec: GObject.ParamSpec) => void;
            'notify::depth': (pspec: GObject.ParamSpec) => void;
            'notify::effect': (pspec: GObject.ParamSpec) => void;
            'notify::first-child': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-position-set': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-x': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-y': (pspec: GObject.ParamSpec) => void;
            'notify::has-clip': (pspec: GObject.ParamSpec) => void;
            'notify::has-pointer': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::last-child': (pspec: GObject.ParamSpec) => void;
            'notify::layout-manager': (pspec: GObject.ParamSpec) => void;
            'notify::magnification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::mapped': (pspec: GObject.ParamSpec) => void;
            'notify::margin-bottom': (pspec: GObject.ParamSpec) => void;
            'notify::margin-left': (pspec: GObject.ParamSpec) => void;
            'notify::margin-right': (pspec: GObject.ParamSpec) => void;
            'notify::margin-top': (pspec: GObject.ParamSpec) => void;
            'notify::min-height': (pspec: GObject.ParamSpec) => void;
            'notify::min-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::min-width': (pspec: GObject.ParamSpec) => void;
            'notify::min-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::minification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::offscreen-redirect': (pspec: GObject.ParamSpec) => void;
            'notify::opacity': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point-z': (pspec: GObject.ParamSpec) => void;
            'notify::position': (pspec: GObject.ParamSpec) => void;
            'notify::reactive': (pspec: GObject.ParamSpec) => void;
            'notify::realized': (pspec: GObject.ParamSpec) => void;
            'notify::request-mode': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-zgravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-z': (pspec: GObject.ParamSpec) => void;
            'notify::show-on-set-parent': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::text-direction': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::translation-x': (pspec: GObject.ParamSpec) => void;
            'notify::translation-y': (pspec: GObject.ParamSpec) => void;
            'notify::translation-z': (pspec: GObject.ParamSpec) => void;
            'notify::visible': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::x-align': (pspec: GObject.ParamSpec) => void;
            'notify::x-expand': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::y-align': (pspec: GObject.ParamSpec) => void;
            'notify::y-expand': (pspec: GObject.ParamSpec) => void;
            'notify::z-position': (pspec: GObject.ParamSpec) => void;
            'transition-stopped::actions': (arg0: string, arg1: boolean) => void;
            'transition-stopped::allocation': (arg0: string, arg1: boolean) => void;
            'transition-stopped::anchor-gravity': (arg0: string, arg1: boolean) => void;
            'transition-stopped::anchor-x': (arg0: string, arg1: boolean) => void;
            'transition-stopped::anchor-y': (arg0: string, arg1: boolean) => void;
            'transition-stopped::background-color': (arg0: string, arg1: boolean) => void;
            'transition-stopped::background-color-set': (arg0: string, arg1: boolean) => void;
            'transition-stopped::child-transform': (arg0: string, arg1: boolean) => void;
            'transition-stopped::child-transform-set': (arg0: string, arg1: boolean) => void;
            'transition-stopped::clip': (arg0: string, arg1: boolean) => void;
            'transition-stopped::clip-rect': (arg0: string, arg1: boolean) => void;
            'transition-stopped::clip-to-allocation': (arg0: string, arg1: boolean) => void;
            'transition-stopped::constraints': (arg0: string, arg1: boolean) => void;
            'transition-stopped::content': (arg0: string, arg1: boolean) => void;
            'transition-stopped::content-box': (arg0: string, arg1: boolean) => void;
            'transition-stopped::content-gravity': (arg0: string, arg1: boolean) => void;
            'transition-stopped::content-repeat': (arg0: string, arg1: boolean) => void;
            'transition-stopped::depth': (arg0: string, arg1: boolean) => void;
            'transition-stopped::effect': (arg0: string, arg1: boolean) => void;
            'transition-stopped::first-child': (arg0: string, arg1: boolean) => void;
            'transition-stopped::fixed-position-set': (arg0: string, arg1: boolean) => void;
            'transition-stopped::fixed-x': (arg0: string, arg1: boolean) => void;
            'transition-stopped::fixed-y': (arg0: string, arg1: boolean) => void;
            'transition-stopped::has-clip': (arg0: string, arg1: boolean) => void;
            'transition-stopped::has-pointer': (arg0: string, arg1: boolean) => void;
            'transition-stopped::height': (arg0: string, arg1: boolean) => void;
            'transition-stopped::last-child': (arg0: string, arg1: boolean) => void;
            'transition-stopped::layout-manager': (arg0: string, arg1: boolean) => void;
            'transition-stopped::magnification-filter': (arg0: string, arg1: boolean) => void;
            'transition-stopped::mapped': (arg0: string, arg1: boolean) => void;
            'transition-stopped::margin-bottom': (arg0: string, arg1: boolean) => void;
            'transition-stopped::margin-left': (arg0: string, arg1: boolean) => void;
            'transition-stopped::margin-right': (arg0: string, arg1: boolean) => void;
            'transition-stopped::margin-top': (arg0: string, arg1: boolean) => void;
            'transition-stopped::min-height': (arg0: string, arg1: boolean) => void;
            'transition-stopped::min-height-set': (arg0: string, arg1: boolean) => void;
            'transition-stopped::min-width': (arg0: string, arg1: boolean) => void;
            'transition-stopped::min-width-set': (arg0: string, arg1: boolean) => void;
            'transition-stopped::minification-filter': (arg0: string, arg1: boolean) => void;
            'transition-stopped::name': (arg0: string, arg1: boolean) => void;
            'transition-stopped::natural-height': (arg0: string, arg1: boolean) => void;
            'transition-stopped::natural-height-set': (arg0: string, arg1: boolean) => void;
            'transition-stopped::natural-width': (arg0: string, arg1: boolean) => void;
            'transition-stopped::natural-width-set': (arg0: string, arg1: boolean) => void;
            'transition-stopped::offscreen-redirect': (arg0: string, arg1: boolean) => void;
            'transition-stopped::opacity': (arg0: string, arg1: boolean) => void;
            'transition-stopped::pivot-point': (arg0: string, arg1: boolean) => void;
            'transition-stopped::pivot-point-z': (arg0: string, arg1: boolean) => void;
            'transition-stopped::position': (arg0: string, arg1: boolean) => void;
            'transition-stopped::reactive': (arg0: string, arg1: boolean) => void;
            'transition-stopped::realized': (arg0: string, arg1: boolean) => void;
            'transition-stopped::request-mode': (arg0: string, arg1: boolean) => void;
            'transition-stopped::rotation-angle-x': (arg0: string, arg1: boolean) => void;
            'transition-stopped::rotation-angle-y': (arg0: string, arg1: boolean) => void;
            'transition-stopped::rotation-angle-z': (arg0: string, arg1: boolean) => void;
            'transition-stopped::rotation-center-x': (arg0: string, arg1: boolean) => void;
            'transition-stopped::rotation-center-y': (arg0: string, arg1: boolean) => void;
            'transition-stopped::rotation-center-z': (arg0: string, arg1: boolean) => void;
            'transition-stopped::rotation-center-z-gravity': (arg0: string, arg1: boolean) => void;
            'transition-stopped::rotation-center-zgravity': (arg0: string, arg1: boolean) => void;
            'transition-stopped::scale-center-x': (arg0: string, arg1: boolean) => void;
            'transition-stopped::scale-center-y': (arg0: string, arg1: boolean) => void;
            'transition-stopped::scale-gravity': (arg0: string, arg1: boolean) => void;
            'transition-stopped::scale-x': (arg0: string, arg1: boolean) => void;
            'transition-stopped::scale-y': (arg0: string, arg1: boolean) => void;
            'transition-stopped::scale-z': (arg0: string, arg1: boolean) => void;
            'transition-stopped::show-on-set-parent': (arg0: string, arg1: boolean) => void;
            'transition-stopped::size': (arg0: string, arg1: boolean) => void;
            'transition-stopped::text-direction': (arg0: string, arg1: boolean) => void;
            'transition-stopped::transform': (arg0: string, arg1: boolean) => void;
            'transition-stopped::transform-set': (arg0: string, arg1: boolean) => void;
            'transition-stopped::translation-x': (arg0: string, arg1: boolean) => void;
            'transition-stopped::translation-y': (arg0: string, arg1: boolean) => void;
            'transition-stopped::translation-z': (arg0: string, arg1: boolean) => void;
            'transition-stopped::visible': (arg0: string, arg1: boolean) => void;
            'transition-stopped::width': (arg0: string, arg1: boolean) => void;
            'transition-stopped::x': (arg0: string, arg1: boolean) => void;
            'transition-stopped::x-align': (arg0: string, arg1: boolean) => void;
            'transition-stopped::x-expand': (arg0: string, arg1: boolean) => void;
            'transition-stopped::y': (arg0: string, arg1: boolean) => void;
            'transition-stopped::y-align': (arg0: string, arg1: boolean) => void;
            'transition-stopped::y-expand': (arg0: string, arg1: boolean) => void;
            'transition-stopped::z-position': (arg0: string, arg1: boolean) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends GObject.InitiallyUnowned.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Animatable.ConstructorProps,
                Container.ConstructorProps,
                Scriptable.ConstructorProps {
            actions: Action;
            allocation: ActorBox;
            anchor_gravity: Gravity;
            anchorGravity: Gravity;
            anchor_x: number;
            anchorX: number;
            anchor_y: number;
            anchorY: number;
            background_color: Color;
            backgroundColor: Color;
            background_color_set: boolean;
            backgroundColorSet: boolean;
            child_transform: Matrix;
            childTransform: Matrix;
            child_transform_set: boolean;
            childTransformSet: boolean;
            clip: Geometry;
            clip_rect: Rect;
            clipRect: Rect;
            clip_to_allocation: boolean;
            clipToAllocation: boolean;
            constraints: Constraint;
            content: Content;
            content_box: ActorBox;
            contentBox: ActorBox;
            content_gravity: ContentGravity;
            contentGravity: ContentGravity;
            content_repeat: ContentRepeat;
            contentRepeat: ContentRepeat;
            depth: number;
            effect: Effect;
            first_child: Actor;
            firstChild: Actor;
            fixed_position_set: boolean;
            fixedPositionSet: boolean;
            fixed_x: number;
            fixedX: number;
            fixed_y: number;
            fixedY: number;
            has_clip: boolean;
            hasClip: boolean;
            has_pointer: boolean;
            hasPointer: boolean;
            height: number;
            last_child: Actor;
            lastChild: Actor;
            layout_manager: LayoutManager;
            layoutManager: LayoutManager;
            magnification_filter: ScalingFilter;
            magnificationFilter: ScalingFilter;
            mapped: boolean;
            margin_bottom: number;
            marginBottom: number;
            margin_left: number;
            marginLeft: number;
            margin_right: number;
            marginRight: number;
            margin_top: number;
            marginTop: number;
            min_height: number;
            minHeight: number;
            min_height_set: boolean;
            minHeightSet: boolean;
            min_width: number;
            minWidth: number;
            min_width_set: boolean;
            minWidthSet: boolean;
            minification_filter: ScalingFilter;
            minificationFilter: ScalingFilter;
            name: string;
            natural_height: number;
            naturalHeight: number;
            natural_height_set: boolean;
            naturalHeightSet: boolean;
            natural_width: number;
            naturalWidth: number;
            natural_width_set: boolean;
            naturalWidthSet: boolean;
            offscreen_redirect: OffscreenRedirect;
            offscreenRedirect: OffscreenRedirect;
            opacity: number;
            pivot_point: Point;
            pivotPoint: Point;
            pivot_point_z: number;
            pivotPointZ: number;
            position: Point;
            reactive: boolean;
            realized: boolean;
            request_mode: RequestMode;
            requestMode: RequestMode;
            rotation_angle_x: number;
            rotationAngleX: number;
            rotation_angle_y: number;
            rotationAngleY: number;
            rotation_angle_z: number;
            rotationAngleZ: number;
            rotation_center_x: Vertex;
            rotationCenterX: Vertex;
            rotation_center_y: Vertex;
            rotationCenterY: Vertex;
            rotation_center_z: Vertex;
            rotationCenterZ: Vertex;
            rotation_center_z_gravity: Gravity;
            rotationCenterZGravity: Gravity;
            scale_center_x: number;
            scaleCenterX: number;
            scale_center_y: number;
            scaleCenterY: number;
            scale_gravity: Gravity;
            scaleGravity: Gravity;
            scale_x: number;
            scaleX: number;
            scale_y: number;
            scaleY: number;
            scale_z: number;
            scaleZ: number;
            show_on_set_parent: boolean;
            showOnSetParent: boolean;
            size: Size;
            text_direction: TextDirection;
            textDirection: TextDirection;
            transform: Matrix;
            transform_set: boolean;
            transformSet: boolean;
            translation_x: number;
            translationX: number;
            translation_y: number;
            translationY: number;
            translation_z: number;
            translationZ: number;
            visible: boolean;
            width: number;
            x: number;
            x_align: ActorAlign;
            xAlign: ActorAlign;
            x_expand: boolean;
            xExpand: boolean;
            y: number;
            y_align: ActorAlign;
            yAlign: ActorAlign;
            y_expand: boolean;
            yExpand: boolean;
            z_position: number;
            zPosition: number;
        }
    }

    /**
     * Base class for actors.
     */
    class Actor extends GObject.InitiallyUnowned implements Atk.ImplementorIface, Animatable, Container, Scriptable {
        static $gtype: GObject.GType<Actor>;

        // Properties

        /**
         * Adds a #ClutterAction to the actor
         */
        set actions(val: Action);
        /**
         * The allocation for the actor, in pixels
         *
         * This is property is read-only, but you might monitor it to know when an
         * actor moves or resizes
         */
        get allocation(): ActorBox;
        /**
         * The anchor point expressed as a #ClutterGravity
         *
         * It is highly recommended not to use #ClutterActor:anchor-x,
         * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
         * written code; the anchor point adds an additional translation that
         * will affect the actor's relative position with regards to its
         * parent, as well as the position of its children. This change needs
         * to always be taken into account when positioning the actor. It is
         * recommended to use the #ClutterActor:pivot-point property instead,
         * as it will affect only the transformations.
         */
        get anchor_gravity(): Gravity;
        set anchor_gravity(val: Gravity);
        /**
         * The anchor point expressed as a #ClutterGravity
         *
         * It is highly recommended not to use #ClutterActor:anchor-x,
         * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
         * written code; the anchor point adds an additional translation that
         * will affect the actor's relative position with regards to its
         * parent, as well as the position of its children. This change needs
         * to always be taken into account when positioning the actor. It is
         * recommended to use the #ClutterActor:pivot-point property instead,
         * as it will affect only the transformations.
         */
        get anchorGravity(): Gravity;
        set anchorGravity(val: Gravity);
        /**
         * The X coordinate of an actor's anchor point, relative to
         * the actor coordinate space, in pixels.
         *
         * It is highly recommended not to use #ClutterActor:anchor-x,
         * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
         * written code; the anchor point adds an additional translation that
         * will affect the actor's relative position with regards to its
         * parent, as well as the position of its children. This change needs
         * to always be taken into account when positioning the actor. It is
         * recommended to use the #ClutterActor:pivot-point property instead,
         * as it will affect only the transformations.
         */
        get anchor_x(): number;
        set anchor_x(val: number);
        /**
         * The X coordinate of an actor's anchor point, relative to
         * the actor coordinate space, in pixels.
         *
         * It is highly recommended not to use #ClutterActor:anchor-x,
         * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
         * written code; the anchor point adds an additional translation that
         * will affect the actor's relative position with regards to its
         * parent, as well as the position of its children. This change needs
         * to always be taken into account when positioning the actor. It is
         * recommended to use the #ClutterActor:pivot-point property instead,
         * as it will affect only the transformations.
         */
        get anchorX(): number;
        set anchorX(val: number);
        /**
         * The Y coordinate of an actor's anchor point, relative to
         * the actor coordinate space, in pixels
         *
         * It is highly recommended not to use #ClutterActor:anchor-x,
         * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
         * written code; the anchor point adds an additional translation that
         * will affect the actor's relative position with regards to its
         * parent, as well as the position of its children. This change needs
         * to always be taken into account when positioning the actor. It is
         * recommended to use the #ClutterActor:pivot-point property instead,
         * as it will affect only the transformations.
         */
        get anchor_y(): number;
        set anchor_y(val: number);
        /**
         * The Y coordinate of an actor's anchor point, relative to
         * the actor coordinate space, in pixels
         *
         * It is highly recommended not to use #ClutterActor:anchor-x,
         * #ClutterActor:anchor-y, and #ClutterActor:anchor-gravity in newly
         * written code; the anchor point adds an additional translation that
         * will affect the actor's relative position with regards to its
         * parent, as well as the position of its children. This change needs
         * to always be taken into account when positioning the actor. It is
         * recommended to use the #ClutterActor:pivot-point property instead,
         * as it will affect only the transformations.
         */
        get anchorY(): number;
        set anchorY(val: number);
        /**
         * Paints a solid fill of the actor's allocation using the specified
         * color.
         *
         * The #ClutterActor:background-color property is animatable.
         */
        get background_color(): Color;
        set background_color(val: Color);
        /**
         * Paints a solid fill of the actor's allocation using the specified
         * color.
         *
         * The #ClutterActor:background-color property is animatable.
         */
        get backgroundColor(): Color;
        set backgroundColor(val: Color);
        /**
         * Whether the #ClutterActor:background-color property has been set.
         */
        get background_color_set(): boolean;
        /**
         * Whether the #ClutterActor:background-color property has been set.
         */
        get backgroundColorSet(): boolean;
        /**
         * Applies a transformation matrix on each child of an actor.
         *
         * Setting this property with a #ClutterMatrix will set the
         * #ClutterActor:child-transform-set property to %TRUE as a side effect;
         * setting this property with %NULL will set the
         * #ClutterActor:child-transform-set property to %FALSE.
         *
         * The #ClutterActor:child-transform property is animatable.
         */
        get child_transform(): Matrix;
        set child_transform(val: Matrix);
        /**
         * Applies a transformation matrix on each child of an actor.
         *
         * Setting this property with a #ClutterMatrix will set the
         * #ClutterActor:child-transform-set property to %TRUE as a side effect;
         * setting this property with %NULL will set the
         * #ClutterActor:child-transform-set property to %FALSE.
         *
         * The #ClutterActor:child-transform property is animatable.
         */
        get childTransform(): Matrix;
        set childTransform(val: Matrix);
        /**
         * Whether the #ClutterActor:child-transform property is set.
         */
        get child_transform_set(): boolean;
        /**
         * Whether the #ClutterActor:child-transform property is set.
         */
        get childTransformSet(): boolean;
        /**
         * The visible region of the actor, in actor-relative coordinates
         */
        get clip(): Geometry;
        set clip(val: Geometry);
        /**
         * The visible region of the actor, in actor-relative coordinates,
         * expressed as a #ClutterRect.
         *
         * Setting this property to %NULL will unset the existing clip.
         *
         * Setting this property will change the #ClutterActor:has-clip
         * property as a side effect.
         */
        get clip_rect(): Rect;
        set clip_rect(val: Rect);
        /**
         * The visible region of the actor, in actor-relative coordinates,
         * expressed as a #ClutterRect.
         *
         * Setting this property to %NULL will unset the existing clip.
         *
         * Setting this property will change the #ClutterActor:has-clip
         * property as a side effect.
         */
        get clipRect(): Rect;
        set clipRect(val: Rect);
        /**
         * Whether the clip region should track the allocated area
         * of the actor.
         *
         * This property is ignored if a clip area has been explicitly
         * set using clutter_actor_set_clip().
         */
        get clip_to_allocation(): boolean;
        set clip_to_allocation(val: boolean);
        /**
         * Whether the clip region should track the allocated area
         * of the actor.
         *
         * This property is ignored if a clip area has been explicitly
         * set using clutter_actor_set_clip().
         */
        get clipToAllocation(): boolean;
        set clipToAllocation(val: boolean);
        /**
         * Adds a #ClutterConstraint to the actor
         */
        set constraints(val: Constraint);
        /**
         * The #ClutterContent implementation that controls the content
         * of the actor.
         */
        get content(): Content;
        set content(val: Content);
        /**
         * The bounding box for the #ClutterContent used by the actor.
         *
         * The value of this property is controlled by the #ClutterActor:allocation
         * and #ClutterActor:content-gravity properties of #ClutterActor.
         *
         * The bounding box for the content is guaranteed to never exceed the
         * allocation's of the actor.
         */
        get content_box(): ActorBox;
        /**
         * The bounding box for the #ClutterContent used by the actor.
         *
         * The value of this property is controlled by the #ClutterActor:allocation
         * and #ClutterActor:content-gravity properties of #ClutterActor.
         *
         * The bounding box for the content is guaranteed to never exceed the
         * allocation's of the actor.
         */
        get contentBox(): ActorBox;
        /**
         * The alignment that should be honoured by the #ClutterContent
         * set with the #ClutterActor:content property.
         *
         * Changing the value of this property will change the bounding box of
         * the content; you can use the #ClutterActor:content-box property to
         * get the position and size of the content within the actor's
         * allocation.
         *
         * This property is meaningful only for #ClutterContent implementations
         * that have a preferred size, and if the preferred size is smaller than
         * the actor's allocation.
         *
         * The #ClutterActor:content-gravity property is animatable.
         */
        get content_gravity(): ContentGravity;
        set content_gravity(val: ContentGravity);
        /**
         * The alignment that should be honoured by the #ClutterContent
         * set with the #ClutterActor:content property.
         *
         * Changing the value of this property will change the bounding box of
         * the content; you can use the #ClutterActor:content-box property to
         * get the position and size of the content within the actor's
         * allocation.
         *
         * This property is meaningful only for #ClutterContent implementations
         * that have a preferred size, and if the preferred size is smaller than
         * the actor's allocation.
         *
         * The #ClutterActor:content-gravity property is animatable.
         */
        get contentGravity(): ContentGravity;
        set contentGravity(val: ContentGravity);
        /**
         * The repeat policy for the actor's #ClutterActor:content.
         */
        get content_repeat(): ContentRepeat;
        set content_repeat(val: ContentRepeat);
        /**
         * The repeat policy for the actor's #ClutterActor:content.
         */
        get contentRepeat(): ContentRepeat;
        set contentRepeat(val: ContentRepeat);
        /**
         * The position of the actor on the Z axis.
         *
         * The #ClutterActor:depth property is relative to the parent's
         * modelview matrix.
         *
         * Setting this property will call #ClutterContainerIface.sort_depth_order()
         * which is usually a no-op, and it's most likely not what you want.
         *
         * The #ClutterActor:depth property is animatable.
         */
        get depth(): number;
        set depth(val: number);
        /**
         * Adds #ClutterEffect to the list of effects be applied on a #ClutterActor
         */
        set effect(val: Effect);
        /**
         * The actor's first child.
         */
        get first_child(): Actor;
        /**
         * The actor's first child.
         */
        get firstChild(): Actor;
        /**
         * This flag controls whether the #ClutterActor:fixed-x and
         * #ClutterActor:fixed-y properties are used
         */
        get fixed_position_set(): boolean;
        set fixed_position_set(val: boolean);
        /**
         * This flag controls whether the #ClutterActor:fixed-x and
         * #ClutterActor:fixed-y properties are used
         */
        get fixedPositionSet(): boolean;
        set fixedPositionSet(val: boolean);
        /**
         * The fixed X position of the actor in pixels.
         *
         * Writing this property sets #ClutterActor:fixed-position-set
         * property as well, as a side effect
         */
        get fixed_x(): number;
        set fixed_x(val: number);
        /**
         * The fixed X position of the actor in pixels.
         *
         * Writing this property sets #ClutterActor:fixed-position-set
         * property as well, as a side effect
         */
        get fixedX(): number;
        set fixedX(val: number);
        /**
         * The fixed Y position of the actor in pixels.
         *
         * Writing this property sets the #ClutterActor:fixed-position-set
         * property as well, as a side effect
         */
        get fixed_y(): number;
        set fixed_y(val: number);
        /**
         * The fixed Y position of the actor in pixels.
         *
         * Writing this property sets the #ClutterActor:fixed-position-set
         * property as well, as a side effect
         */
        get fixedY(): number;
        set fixedY(val: number);
        /**
         * Whether the actor has the #ClutterActor:clip property set or not
         */
        get has_clip(): boolean;
        /**
         * Whether the actor has the #ClutterActor:clip property set or not
         */
        get hasClip(): boolean;
        /**
         * Whether the actor contains the pointer of a #ClutterInputDevice
         * or not.
         */
        get has_pointer(): boolean;
        /**
         * Whether the actor contains the pointer of a #ClutterInputDevice
         * or not.
         */
        get hasPointer(): boolean;
        /**
         * Height of the actor (in pixels).  If written, forces the minimum and
         * natural size request of the actor to the given height. If read, returns
         * the allocated height if available, otherwise the height request.
         *
         * The #ClutterActor:height property is animatable.
         */
        get height(): number;
        set height(val: number);
        /**
         * The actor's last child.
         */
        get last_child(): Actor;
        /**
         * The actor's last child.
         */
        get lastChild(): Actor;
        /**
         * A delegate object for controlling the layout of the children of
         * an actor.
         */
        get layout_manager(): LayoutManager;
        set layout_manager(val: LayoutManager);
        /**
         * A delegate object for controlling the layout of the children of
         * an actor.
         */
        get layoutManager(): LayoutManager;
        set layoutManager(val: LayoutManager);
        get magnification_filter(): ScalingFilter;
        set magnification_filter(val: ScalingFilter);
        get magnificationFilter(): ScalingFilter;
        set magnificationFilter(val: ScalingFilter);
        /**
         * Whether the actor is mapped (will be painted when the stage
         * to which it belongs is mapped)
         */
        get mapped(): boolean;
        /**
         * The margin (in pixels) from the bottom of the actor.
         *
         * This property adds a margin to the actor's preferred size; the margin
         * will be automatically taken into account when allocating the actor.
         *
         * The #ClutterActor:margin-bottom property is animatable.
         */
        get margin_bottom(): number;
        set margin_bottom(val: number);
        /**
         * The margin (in pixels) from the bottom of the actor.
         *
         * This property adds a margin to the actor's preferred size; the margin
         * will be automatically taken into account when allocating the actor.
         *
         * The #ClutterActor:margin-bottom property is animatable.
         */
        get marginBottom(): number;
        set marginBottom(val: number);
        /**
         * The margin (in pixels) from the left of the actor.
         *
         * This property adds a margin to the actor's preferred size; the margin
         * will be automatically taken into account when allocating the actor.
         *
         * The #ClutterActor:margin-left property is animatable.
         */
        get margin_left(): number;
        set margin_left(val: number);
        /**
         * The margin (in pixels) from the left of the actor.
         *
         * This property adds a margin to the actor's preferred size; the margin
         * will be automatically taken into account when allocating the actor.
         *
         * The #ClutterActor:margin-left property is animatable.
         */
        get marginLeft(): number;
        set marginLeft(val: number);
        /**
         * The margin (in pixels) from the right of the actor.
         *
         * This property adds a margin to the actor's preferred size; the margin
         * will be automatically taken into account when allocating the actor.
         *
         * The #ClutterActor:margin-right property is animatable.
         */
        get margin_right(): number;
        set margin_right(val: number);
        /**
         * The margin (in pixels) from the right of the actor.
         *
         * This property adds a margin to the actor's preferred size; the margin
         * will be automatically taken into account when allocating the actor.
         *
         * The #ClutterActor:margin-right property is animatable.
         */
        get marginRight(): number;
        set marginRight(val: number);
        /**
         * The margin (in pixels) from the top of the actor.
         *
         * This property adds a margin to the actor's preferred size; the margin
         * will be automatically taken into account when allocating the actor.
         *
         * The #ClutterActor:margin-top property is animatable.
         */
        get margin_top(): number;
        set margin_top(val: number);
        /**
         * The margin (in pixels) from the top of the actor.
         *
         * This property adds a margin to the actor's preferred size; the margin
         * will be automatically taken into account when allocating the actor.
         *
         * The #ClutterActor:margin-top property is animatable.
         */
        get marginTop(): number;
        set marginTop(val: number);
        /**
         * A forced minimum height request for the actor, in pixels
         *
         * Writing this property sets the #ClutterActor:min-height-set property
         * as well, as a side effect. This property overrides the usual height
         * request of the actor.
         */
        get min_height(): number;
        set min_height(val: number);
        /**
         * A forced minimum height request for the actor, in pixels
         *
         * Writing this property sets the #ClutterActor:min-height-set property
         * as well, as a side effect. This property overrides the usual height
         * request of the actor.
         */
        get minHeight(): number;
        set minHeight(val: number);
        /**
         * This flag controls whether the #ClutterActor:min-height property
         * is used
         */
        get min_height_set(): boolean;
        set min_height_set(val: boolean);
        /**
         * This flag controls whether the #ClutterActor:min-height property
         * is used
         */
        get minHeightSet(): boolean;
        set minHeightSet(val: boolean);
        /**
         * A forced minimum width request for the actor, in pixels
         *
         * Writing this property sets the #ClutterActor:min-width-set property
         * as well, as a side effect.
         *
         * This property overrides the usual width request of the actor.
         */
        get min_width(): number;
        set min_width(val: number);
        /**
         * A forced minimum width request for the actor, in pixels
         *
         * Writing this property sets the #ClutterActor:min-width-set property
         * as well, as a side effect.
         *
         * This property overrides the usual width request of the actor.
         */
        get minWidth(): number;
        set minWidth(val: number);
        /**
         * This flag controls whether the #ClutterActor:min-width property
         * is used
         */
        get min_width_set(): boolean;
        set min_width_set(val: boolean);
        /**
         * This flag controls whether the #ClutterActor:min-width property
         * is used
         */
        get minWidthSet(): boolean;
        set minWidthSet(val: boolean);
        get minification_filter(): ScalingFilter;
        set minification_filter(val: ScalingFilter);
        get minificationFilter(): ScalingFilter;
        set minificationFilter(val: ScalingFilter);
        /**
         * The name of the actor
         */
        get name(): string;
        set name(val: string);
        /**
         * A forced natural height request for the actor, in pixels
         *
         * Writing this property sets the #ClutterActor:natural-height-set
         * property as well, as a side effect. This property overrides the
         * usual height request of the actor
         */
        get natural_height(): number;
        set natural_height(val: number);
        /**
         * A forced natural height request for the actor, in pixels
         *
         * Writing this property sets the #ClutterActor:natural-height-set
         * property as well, as a side effect. This property overrides the
         * usual height request of the actor
         */
        get naturalHeight(): number;
        set naturalHeight(val: number);
        /**
         * This flag controls whether the #ClutterActor:natural-height property
         * is used
         */
        get natural_height_set(): boolean;
        set natural_height_set(val: boolean);
        /**
         * This flag controls whether the #ClutterActor:natural-height property
         * is used
         */
        get naturalHeightSet(): boolean;
        set naturalHeightSet(val: boolean);
        /**
         * A forced natural width request for the actor, in pixels
         *
         * Writing this property sets the #ClutterActor:natural-width-set
         * property as well, as a side effect. This property overrides the
         * usual width request of the actor
         */
        get natural_width(): number;
        set natural_width(val: number);
        /**
         * A forced natural width request for the actor, in pixels
         *
         * Writing this property sets the #ClutterActor:natural-width-set
         * property as well, as a side effect. This property overrides the
         * usual width request of the actor
         */
        get naturalWidth(): number;
        set naturalWidth(val: number);
        /**
         * This flag controls whether the #ClutterActor:natural-width property
         * is used
         */
        get natural_width_set(): boolean;
        set natural_width_set(val: boolean);
        /**
         * This flag controls whether the #ClutterActor:natural-width property
         * is used
         */
        get naturalWidthSet(): boolean;
        set naturalWidthSet(val: boolean);
        /**
         * Determines the conditions in which the actor will be redirected
         * to an offscreen framebuffer while being painted. For example this
         * can be used to cache an actor in a framebuffer or for improved
         * handling of transparent actors. See
         * clutter_actor_set_offscreen_redirect() for details.
         */
        get offscreen_redirect(): OffscreenRedirect;
        set offscreen_redirect(val: OffscreenRedirect);
        /**
         * Determines the conditions in which the actor will be redirected
         * to an offscreen framebuffer while being painted. For example this
         * can be used to cache an actor in a framebuffer or for improved
         * handling of transparent actors. See
         * clutter_actor_set_offscreen_redirect() for details.
         */
        get offscreenRedirect(): OffscreenRedirect;
        set offscreenRedirect(val: OffscreenRedirect);
        /**
         * Opacity of an actor, between 0 (fully transparent) and
         * 255 (fully opaque)
         *
         * The #ClutterActor:opacity property is animatable.
         */
        get opacity(): number;
        set opacity(val: number);
        /**
         * The point around which the scaling and rotation transformations occur.
         *
         * The pivot point is expressed in normalized coordinates space, with (0, 0)
         * being the top left corner of the actor and (1, 1) the bottom right corner
         * of the actor.
         *
         * The default pivot point is located at (0, 0).
         *
         * The #ClutterActor:pivot-point property is animatable.
         */
        get pivot_point(): Point;
        set pivot_point(val: Point);
        /**
         * The point around which the scaling and rotation transformations occur.
         *
         * The pivot point is expressed in normalized coordinates space, with (0, 0)
         * being the top left corner of the actor and (1, 1) the bottom right corner
         * of the actor.
         *
         * The default pivot point is located at (0, 0).
         *
         * The #ClutterActor:pivot-point property is animatable.
         */
        get pivotPoint(): Point;
        set pivotPoint(val: Point);
        /**
         * The Z component of the #ClutterActor:pivot-point, expressed as a value
         * along the Z axis.
         *
         * The #ClutterActor:pivot-point-z property is animatable.
         */
        get pivot_point_z(): number;
        set pivot_point_z(val: number);
        /**
         * The Z component of the #ClutterActor:pivot-point, expressed as a value
         * along the Z axis.
         *
         * The #ClutterActor:pivot-point-z property is animatable.
         */
        get pivotPointZ(): number;
        set pivotPointZ(val: number);
        /**
         * The position of the origin of the actor.
         *
         * This property is a shorthand for setting and getting the
         * #ClutterActor:x and #ClutterActor:y properties at the same
         * time.
         *
         * The #ClutterActor:position property is animatable.
         */
        get position(): Point;
        set position(val: Point);
        /**
         * Whether the actor is reactive to events or not
         *
         * Only reactive actors will emit event-related signals
         */
        get reactive(): boolean;
        set reactive(val: boolean);
        /**
         * Whether the actor has been realized
         */
        get realized(): boolean;
        /**
         * Request mode for the #ClutterActor. The request mode determines the
         * type of geometry management used by the actor, either height for width
         * (the default) or width for height.
         *
         * For actors implementing height for width, the parent container should get
         * the preferred width first, and then the preferred height for that width.
         *
         * For actors implementing width for height, the parent container should get
         * the preferred height first, and then the preferred width for that height.
         *
         * For instance:
         *
         *
         * ```c
         *   ClutterRequestMode mode;
         *   gfloat natural_width, min_width;
         *   gfloat natural_height, min_height;
         *
         *   mode = clutter_actor_get_request_mode (child);
         *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
         *     {
         *       clutter_actor_get_preferred_width (child, -1,
         *                                          &min_width,
         *                                          &natural_width);
         *       clutter_actor_get_preferred_height (child, natural_width,
         *                                           &min_height,
         *                                           &natural_height);
         *     }
         *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
         *     {
         *       clutter_actor_get_preferred_height (child, -1,
         *                                           &min_height,
         *                                           &natural_height);
         *       clutter_actor_get_preferred_width (child, natural_height,
         *                                          &min_width,
         *                                          &natural_width);
         *     }
         *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
         *     {
         *       ClutterContent *content = clutter_actor_get_content (child);
         *
         *       min_width, min_height = 0;
         *       natural_width = natural_height = 0;
         *
         *       if (content != NULL)
         *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
         *     }
         * ```
         *
         *
         * will retrieve the minimum and natural width and height depending on the
         * preferred request mode of the #ClutterActor "child".
         *
         * The clutter_actor_get_preferred_size() function will implement this
         * check for you.
         */
        get request_mode(): RequestMode;
        set request_mode(val: RequestMode);
        /**
         * Request mode for the #ClutterActor. The request mode determines the
         * type of geometry management used by the actor, either height for width
         * (the default) or width for height.
         *
         * For actors implementing height for width, the parent container should get
         * the preferred width first, and then the preferred height for that width.
         *
         * For actors implementing width for height, the parent container should get
         * the preferred height first, and then the preferred width for that height.
         *
         * For instance:
         *
         *
         * ```c
         *   ClutterRequestMode mode;
         *   gfloat natural_width, min_width;
         *   gfloat natural_height, min_height;
         *
         *   mode = clutter_actor_get_request_mode (child);
         *   if (mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
         *     {
         *       clutter_actor_get_preferred_width (child, -1,
         *                                          &min_width,
         *                                          &natural_width);
         *       clutter_actor_get_preferred_height (child, natural_width,
         *                                           &min_height,
         *                                           &natural_height);
         *     }
         *   else if (mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
         *     {
         *       clutter_actor_get_preferred_height (child, -1,
         *                                           &min_height,
         *                                           &natural_height);
         *       clutter_actor_get_preferred_width (child, natural_height,
         *                                          &min_width,
         *                                          &natural_width);
         *     }
         *   else if (mode == CLUTTER_REQUEST_CONTENT_SIZE)
         *     {
         *       ClutterContent *content = clutter_actor_get_content (child);
         *
         *       min_width, min_height = 0;
         *       natural_width = natural_height = 0;
         *
         *       if (content != NULL)
         *         clutter_content_get_preferred_size (content, &natural_width, &natural_height);
         *     }
         * ```
         *
         *
         * will retrieve the minimum and natural width and height depending on the
         * preferred request mode of the #ClutterActor "child".
         *
         * The clutter_actor_get_preferred_size() function will implement this
         * check for you.
         */
        get requestMode(): RequestMode;
        set requestMode(val: RequestMode);
        /**
         * The rotation angle on the X axis.
         *
         * The #ClutterActor:rotation-angle-x property is animatable.
         */
        get rotation_angle_x(): number;
        set rotation_angle_x(val: number);
        /**
         * The rotation angle on the X axis.
         *
         * The #ClutterActor:rotation-angle-x property is animatable.
         */
        get rotationAngleX(): number;
        set rotationAngleX(val: number);
        /**
         * The rotation angle on the Y axis
         *
         * The #ClutterActor:rotation-angle-y property is animatable.
         */
        get rotation_angle_y(): number;
        set rotation_angle_y(val: number);
        /**
         * The rotation angle on the Y axis
         *
         * The #ClutterActor:rotation-angle-y property is animatable.
         */
        get rotationAngleY(): number;
        set rotationAngleY(val: number);
        /**
         * The rotation angle on the Z axis
         *
         * The #ClutterActor:rotation-angle-z property is animatable.
         */
        get rotation_angle_z(): number;
        set rotation_angle_z(val: number);
        /**
         * The rotation angle on the Z axis
         *
         * The #ClutterActor:rotation-angle-z property is animatable.
         */
        get rotationAngleZ(): number;
        set rotationAngleZ(val: number);
        /**
         * The rotation center on the X axis.
         */
        get rotation_center_x(): Vertex;
        set rotation_center_x(val: Vertex);
        /**
         * The rotation center on the X axis.
         */
        get rotationCenterX(): Vertex;
        set rotationCenterX(val: Vertex);
        /**
         * The rotation center on the Y axis.
         */
        get rotation_center_y(): Vertex;
        set rotation_center_y(val: Vertex);
        /**
         * The rotation center on the Y axis.
         */
        get rotationCenterY(): Vertex;
        set rotationCenterY(val: Vertex);
        /**
         * The rotation center on the Z axis.
         */
        get rotation_center_z(): Vertex;
        set rotation_center_z(val: Vertex);
        /**
         * The rotation center on the Z axis.
         */
        get rotationCenterZ(): Vertex;
        set rotationCenterZ(val: Vertex);
        /**
         * The rotation center on the Z axis expressed as a #ClutterGravity.
         */
        get rotation_center_z_gravity(): Gravity;
        set rotation_center_z_gravity(val: Gravity);
        /**
         * The rotation center on the Z axis expressed as a #ClutterGravity.
         */
        get rotationCenterZGravity(): Gravity;
        set rotationCenterZGravity(val: Gravity);
        /**
         * The horizontal center point for scaling
         */
        get scale_center_x(): number;
        set scale_center_x(val: number);
        /**
         * The horizontal center point for scaling
         */
        get scaleCenterX(): number;
        set scaleCenterX(val: number);
        /**
         * The vertical center point for scaling
         */
        get scale_center_y(): number;
        set scale_center_y(val: number);
        /**
         * The vertical center point for scaling
         */
        get scaleCenterY(): number;
        set scaleCenterY(val: number);
        /**
         * The center point for scaling expressed as a #ClutterGravity
         */
        get scale_gravity(): Gravity;
        set scale_gravity(val: Gravity);
        /**
         * The center point for scaling expressed as a #ClutterGravity
         */
        get scaleGravity(): Gravity;
        set scaleGravity(val: Gravity);
        /**
         * The horizontal scale of the actor.
         *
         * The #ClutterActor:scale-x property is animatable.
         */
        get scale_x(): number;
        set scale_x(val: number);
        /**
         * The horizontal scale of the actor.
         *
         * The #ClutterActor:scale-x property is animatable.
         */
        get scaleX(): number;
        set scaleX(val: number);
        /**
         * The vertical scale of the actor.
         *
         * The #ClutterActor:scale-y property is animatable.
         */
        get scale_y(): number;
        set scale_y(val: number);
        /**
         * The vertical scale of the actor.
         *
         * The #ClutterActor:scale-y property is animatable.
         */
        get scaleY(): number;
        set scaleY(val: number);
        /**
         * The scale factor of the actor along the Z axis.
         *
         * The #ClutterActor:scale-y property is animatable.
         */
        get scale_z(): number;
        set scale_z(val: number);
        /**
         * The scale factor of the actor along the Z axis.
         *
         * The #ClutterActor:scale-y property is animatable.
         */
        get scaleZ(): number;
        set scaleZ(val: number);
        /**
         * If %TRUE, the actor is automatically shown when parented.
         *
         * Calling clutter_actor_hide() on an actor which has not been
         * parented will set this property to %FALSE as a side effect.
         */
        get show_on_set_parent(): boolean;
        set show_on_set_parent(val: boolean);
        /**
         * If %TRUE, the actor is automatically shown when parented.
         *
         * Calling clutter_actor_hide() on an actor which has not been
         * parented will set this property to %FALSE as a side effect.
         */
        get showOnSetParent(): boolean;
        set showOnSetParent(val: boolean);
        /**
         * The size of the actor.
         *
         * This property is a shorthand for setting and getting the
         * #ClutterActor:width and #ClutterActor:height at the same time.
         *
         * The #ClutterActor:size property is animatable.
         */
        get size(): Size;
        set size(val: Size);
        /**
         * The direction of the text inside a #ClutterActor.
         */
        get text_direction(): TextDirection;
        set text_direction(val: TextDirection);
        /**
         * The direction of the text inside a #ClutterActor.
         */
        get textDirection(): TextDirection;
        set textDirection(val: TextDirection);
        /**
         * Overrides the transformations of a #ClutterActor with a custom
         * matrix.
         *
         * The matrix specified by the #ClutterActor:transform property is
         * applied to the actor and its children relative to the actor's
         * #ClutterActor:allocation and #ClutterActor:pivot-point.
         *
         * Application code should rarely need to use this function directly.
         *
         * Setting this property with a #ClutterMatrix will set the
         * #ClutterActor:transform-set property to %TRUE as a side effect;
         * setting this property with %NULL will set the
         * #ClutterActor:transform-set property to %FALSE.
         *
         * The #ClutterActor:transform property is animatable.
         */
        get transform(): Matrix;
        set transform(val: Matrix);
        /**
         * Whether the #ClutterActor:transform property is set.
         */
        get transform_set(): boolean;
        /**
         * Whether the #ClutterActor:transform property is set.
         */
        get transformSet(): boolean;
        /**
         * An additional translation applied along the X axis, relative
         * to the actor's #ClutterActor:pivot-point.
         *
         * The #ClutterActor:translation-x property is animatable.
         */
        get translation_x(): number;
        set translation_x(val: number);
        /**
         * An additional translation applied along the X axis, relative
         * to the actor's #ClutterActor:pivot-point.
         *
         * The #ClutterActor:translation-x property is animatable.
         */
        get translationX(): number;
        set translationX(val: number);
        /**
         * An additional translation applied along the Y axis, relative
         * to the actor's #ClutterActor:pivot-point.
         *
         * The #ClutterActor:translation-y property is animatable.
         */
        get translation_y(): number;
        set translation_y(val: number);
        /**
         * An additional translation applied along the Y axis, relative
         * to the actor's #ClutterActor:pivot-point.
         *
         * The #ClutterActor:translation-y property is animatable.
         */
        get translationY(): number;
        set translationY(val: number);
        /**
         * An additional translation applied along the Z axis, relative
         * to the actor's #ClutterActor:pivot-point.
         *
         * The #ClutterActor:translation-z property is animatable.
         */
        get translation_z(): number;
        set translation_z(val: number);
        /**
         * An additional translation applied along the Z axis, relative
         * to the actor's #ClutterActor:pivot-point.
         *
         * The #ClutterActor:translation-z property is animatable.
         */
        get translationZ(): number;
        set translationZ(val: number);
        /**
         * Whether the actor is set to be visible or not
         *
         * See also #ClutterActor:mapped
         */
        get visible(): boolean;
        set visible(val: boolean);
        /**
         * Width of the actor (in pixels). If written, forces the minimum and
         * natural size request of the actor to the given width. If read, returns
         * the allocated width if available, otherwise the width request.
         *
         * The #ClutterActor:width property is animatable.
         */
        get width(): number;
        set width(val: number);
        /**
         * X coordinate of the actor in pixels. If written, forces a fixed
         * position for the actor. If read, returns the fixed position if any,
         * otherwise the allocation if available, otherwise 0.
         *
         * The #ClutterActor:x property is animatable.
         */
        get x(): number;
        set x(val: number);
        /**
         * The alignment of an actor on the X axis, if the actor has been given
         * extra space for its allocation. See also the #ClutterActor:x-expand
         * property.
         */
        get x_align(): ActorAlign;
        set x_align(val: ActorAlign);
        /**
         * The alignment of an actor on the X axis, if the actor has been given
         * extra space for its allocation. See also the #ClutterActor:x-expand
         * property.
         */
        get xAlign(): ActorAlign;
        set xAlign(val: ActorAlign);
        /**
         * Whether a layout manager should assign more space to the actor on
         * the X axis.
         */
        get x_expand(): boolean;
        set x_expand(val: boolean);
        /**
         * Whether a layout manager should assign more space to the actor on
         * the X axis.
         */
        get xExpand(): boolean;
        set xExpand(val: boolean);
        /**
         * Y coordinate of the actor in pixels. If written, forces a fixed
         * position for the actor.  If read, returns the fixed position if
         * any, otherwise the allocation if available, otherwise 0.
         *
         * The #ClutterActor:y property is animatable.
         */
        get y(): number;
        set y(val: number);
        /**
         * The alignment of an actor on the Y axis, if the actor has been given
         * extra space for its allocation.
         */
        get y_align(): ActorAlign;
        set y_align(val: ActorAlign);
        /**
         * The alignment of an actor on the Y axis, if the actor has been given
         * extra space for its allocation.
         */
        get yAlign(): ActorAlign;
        set yAlign(val: ActorAlign);
        /**
         * Whether a layout manager should assign more space to the actor on
         * the Y axis.
         */
        get y_expand(): boolean;
        set y_expand(val: boolean);
        /**
         * Whether a layout manager should assign more space to the actor on
         * the Y axis.
         */
        get yExpand(): boolean;
        set yExpand(val: boolean);
        /**
         * The actor's position on the Z axis, relative to the parent's
         * transformations.
         *
         * Positive values will bring the actor's position nearer to the user,
         * whereas negative values will bring the actor's position farther from
         * the user.
         *
         * The #ClutterActor:z-position does not affect the paint or allocation
         * order.
         *
         * The #ClutterActor:z-position property is animatable.
         */
        get z_position(): number;
        set z_position(val: number);
        /**
         * The actor's position on the Z axis, relative to the parent's
         * transformations.
         *
         * Positive values will bring the actor's position nearer to the user,
         * whereas negative values will bring the actor's position farther from
         * the user.
         *
         * The #ClutterActor:z-position does not affect the paint or allocation
         * order.
         *
         * The #ClutterActor:z-position property is animatable.
         */
        get zPosition(): number;
        set zPosition(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Actor.SignalSignatures;

        // Fields

        flags: number;

        // Constructors

        constructor(properties?: Partial<Actor.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Actor;

        // Signals

        connect<K extends keyof Actor.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Actor.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Actor.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Actor.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Actor.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Actor.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        /**
         * Assigns the size of a #ClutterActor from the given `box`.
         *
         * This function should only be called on the children of an actor when
         * overriding the #ClutterActorClass.allocate() virtual function.
         *
         * This function will adjust the stored allocation to take into account
         * the alignment flags set in the #ClutterActor:x-align and
         * #ClutterActor:y-align properties, as well as the margin values set in
         * the #ClutterActor:margin-top, #ClutterActor:margin-right,
         * #ClutterActor:margin-bottom, and #ClutterActor:margin-left properties.
         *
         * This function will respect the easing state of the #ClutterActor and
         * interpolate between the current allocation and the new one if the
         * easing state duration is a positive value.
         *
         * Actors can know from their allocation box whether they have moved
         * with respect to their parent actor. The `flags` parameter describes
         * additional information about the allocation, for instance whether
         * the parent has moved with respect to the stage, for example because
         * a grandparent's origin has moved.
         * @param box new allocation of the actor, in parent-relative coordinates
         * @param flags flags that control the allocation
         */
        vfunc_allocate(box: ActorBox, flags: AllocationFlags): void;
        vfunc_apply_transform(matrix: Matrix): void;
        vfunc_button_press_event(event: ButtonEvent): boolean;
        vfunc_button_release_event(event: ButtonEvent): boolean;
        vfunc_captured_event(event: Event): boolean;
        /**
         * Destroys an actor.  When an actor is destroyed, it will break any
         * references it holds to other objects.  If the actor is inside a
         * container, the actor will be removed.
         *
         * When you destroy a container, its children will be destroyed as well.
         *
         * Note: you cannot destroy the #ClutterStage returned by
         * clutter_stage_get_default().
         */
        vfunc_destroy(): void;
        vfunc_enter_event(event: CrossingEvent): boolean;
        vfunc_event(event: Event): boolean;
        /**
         * Returns the accessible object that describes the actor to an
         * assistive technology.
         *
         * If no class-specific #AtkObject implementation is available for the
         * actor instance in question, it will inherit an #AtkObject
         * implementation from the first ancestor class for which such an
         * implementation is defined.
         *
         * The documentation of the <ulink
         * url="http://developer.gnome.org/doc/API/2.0/atk/index.html">ATK</ulink>
         * library contains more information about accessible objects and
         * their uses.
         */
        vfunc_get_accessible(): Atk.Object;
        vfunc_get_paint_volume(volume: PaintVolume): boolean;
        /**
         * Computes the requested minimum and natural heights for an actor,
         * or if they are already computed, returns the cached values.
         *
         * An actor may not get its request - depending on the layout
         * manager that's in effect.
         *
         * A request should not incorporate the actor's scale or anchor point;
         * those transformations do not affect layout, only rendering.
         * @param for_width available width to assume in computing desired height,   or a negative value to indicate that no width is defined
         */
        vfunc_get_preferred_height(for_width: number): [number, number];
        /**
         * Computes the requested minimum and natural widths for an actor,
         * optionally depending on the specified height, or if they are
         * already computed, returns the cached values.
         *
         * An actor may not get its request - depending on the layout
         * manager that's in effect.
         *
         * A request should not incorporate the actor's scale or anchor point;
         * those transformations do not affect layout, only rendering.
         * @param for_height available height when computing the preferred width,   or a negative value to indicate that no height is defined
         */
        vfunc_get_preferred_width(for_height: number): [number, number];
        /**
         * Asks the actor's implementation whether it may contain overlapping
         * primitives.
         *
         * For example; Clutter may use this to determine whether the painting
         * should be redirected to an offscreen buffer to correctly implement
         * the opacity property.
         *
         * Custom actors can override the default response by implementing the
         * #ClutterActorClass.has_overlaps() virtual function. See
         * clutter_actor_set_offscreen_redirect() for more information.
         */
        vfunc_has_overlaps(): boolean;
        /**
         * Flags an actor to be hidden. A hidden actor will not be
         * rendered on the stage.
         *
         * Actors are visible by default.
         *
         * If this function is called on an actor without a parent, the
         * #ClutterActor:show-on-set-parent property will be set to %FALSE
         * as a side-effect.
         */
        vfunc_hide(): void;
        /**
         * Calls clutter_actor_hide() on all child actors (if any).
         */
        vfunc_hide_all(): void;
        vfunc_key_focus_in(): void;
        vfunc_key_focus_out(): void;
        vfunc_key_press_event(event: KeyEvent): boolean;
        vfunc_key_release_event(event: KeyEvent): boolean;
        vfunc_leave_event(event: CrossingEvent): boolean;
        /**
         * Sets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly maps
         * and realizes its children if they are visible. Does nothing if the
         * actor is not visible.
         *
         * Calling this function is strongly disencouraged: the default
         * implementation of #ClutterActorClass.map() will map all the children
         * of an actor when mapping its parent.
         *
         * When overriding map, it is mandatory to chain up to the parent
         * implementation.
         */
        vfunc_map(): void;
        vfunc_motion_event(event: MotionEvent): boolean;
        /**
         * Renders the actor to display.
         *
         * This function should not be called directly by applications.
         * Call clutter_actor_queue_redraw() to queue paints, instead.
         *
         * This function is context-aware, and will either cause a
         * regular paint or a pick paint.
         *
         * This function will emit the #ClutterActor::paint signal or
         * the #ClutterActor::pick signal, depending on the context.
         *
         * This function does not paint the actor if the actor is set to 0,
         * unless it is performing a pick paint.
         */
        vfunc_paint(): void;
        vfunc_paint_node(root: PaintNode): void;
        vfunc_parent_set(old_parent: Actor): void;
        vfunc_pick(color: Color): void;
        vfunc_queue_redraw(leaf_that_queued: Actor): void;
        /**
         * Indicates that the actor's size request or other layout-affecting
         * properties may have changed. This function is used inside #ClutterActor
         * subclass implementations, not by applications directly.
         *
         * Queueing a new layout automatically queues a redraw as well.
         */
        vfunc_queue_relayout(): void;
        /**
         * Realization informs the actor that it is attached to a stage. It
         * can use this to allocate resources if it wanted to delay allocation
         * until it would be rendered. However it is perfectly acceptable for
         * an actor to create resources before being realized because Clutter
         * only ever has a single rendering context so that actor is free to
         * be moved from one stage to another.
         *
         * This function does nothing if the actor is already realized.
         *
         * Because a realized actor must have realized parent actors, calling
         * clutter_actor_realize() will also realize all parents of the actor.
         *
         * This function does not realize child actors, except in the special
         * case that realizing the stage, when the stage is visible, will
         * suddenly map (and thus realize) the children of the stage.
         */
        vfunc_realize(): void;
        vfunc_scroll_event(event: ScrollEvent): boolean;
        /**
         * Flags an actor to be displayed. An actor that isn't shown will not
         * be rendered on the stage.
         *
         * Actors are visible by default.
         *
         * If this function is called on an actor without a parent, the
         * #ClutterActor:show-on-set-parent will be set to %TRUE as a side
         * effect.
         */
        vfunc_show(): void;
        /**
         * Calls clutter_actor_show() on all children of an actor (if any).
         */
        vfunc_show_all(): void;
        vfunc_touch_event(event: TouchEvent): boolean;
        /**
         * Unsets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly
         * unmaps its children if they were mapped.
         *
         * Calling this function is not encouraged: the default #ClutterActor
         * implementation of #ClutterActorClass.unmap() will also unmap any
         * eventual children by default when their parent is unmapped.
         *
         * When overriding #ClutterActorClass.unmap(), it is mandatory to
         * chain up to the parent implementation.
         *
         * It is important to note that the implementation of the
         * #ClutterActorClass.unmap() virtual function may be called after
         * the #ClutterActorClass.destroy() or the #GObjectClass.dispose()
         * implementation, but it is guaranteed to be called before the
         * #GObjectClass.finalize() implementation.
         */
        vfunc_unmap(): void;
        /**
         * Unrealization informs the actor that it may be being destroyed or
         * moved to another stage. The actor may want to destroy any
         * underlying graphics resources at this point. However it is
         * perfectly acceptable for it to retain the resources until the actor
         * is destroyed because Clutter only ever uses a single rendering
         * context and all of the graphics resources are valid on any stage.
         *
         * Because mapped actors must be realized, actors may not be
         * unrealized if they are mapped. This function hides the actor to be
         * sure it isn't mapped, an application-visible side effect that you
         * may not be expecting.
         *
         * This function should not be called by application code.
         *
         * This function should not really be in the public API, because
         * there isn't a good reason to call it. ClutterActor will already
         * unrealize things for you when it's important to do so.
         *
         * If you were using clutter_actor_unrealize() in a dispose
         * implementation, then don't, just chain up to ClutterActor's
         * dispose.
         *
         * If you were using clutter_actor_unrealize() to implement
         * unrealizing children of your container, then don't, ClutterActor
         * will already take care of that.
         */
        vfunc_unrealize(): void;

        // Methods

        /**
         * Adds `action` to the list of actions applied to `self`
         *
         * A #ClutterAction can only belong to one actor at a time
         *
         * The #ClutterActor will hold a reference on `action` until either
         * clutter_actor_remove_action() or clutter_actor_clear_actions()
         * is called
         * @param action a #ClutterAction
         */
        add_action(action: Action): void;
        /**
         * A convenience function for setting the name of a #ClutterAction
         * while adding it to the list of actions applied to `self`
         *
         * This function is the logical equivalent of:
         *
         *
         * ```c
         *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (action), name);
         *   clutter_actor_add_action (self, action);
         * ```
         *
         * @param name the name to set on the action
         * @param action a #ClutterAction
         */
        add_action_with_name(name: string, action: Action): void;
        /**
         * Adds `child` to the children of `self`.
         *
         * This function will acquire a reference on `child` that will only
         * be released when calling clutter_actor_remove_child().
         *
         * This function will take into consideration the #ClutterActor:depth
         * of `child,` and will keep the list of children sorted.
         *
         * This function will emit the #ClutterContainer::actor-added signal
         * on `self`.
         * @param child a #ClutterActor
         */
        add_child(child: Actor): void;
        /**
         * Adds `constraint` to the list of #ClutterConstraint<!-- -->s applied
         * to `self`
         *
         * The #ClutterActor will hold a reference on the `constraint` until
         * either clutter_actor_remove_constraint() or
         * clutter_actor_clear_constraints() is called.
         * @param constraint a #ClutterConstraint
         */
        add_constraint(constraint: Constraint): void;
        /**
         * A convenience function for setting the name of a #ClutterConstraint
         * while adding it to the list of constraints applied to `self`
         *
         * This function is the logical equivalent of:
         *
         *
         * ```c
         *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (constraint), name);
         *   clutter_actor_add_constraint (self, constraint);
         * ```
         *
         * @param name the name to set on the constraint
         * @param constraint a #ClutterConstraint
         */
        add_constraint_with_name(name: string, constraint: Constraint): void;
        /**
         * Adds `effect` to the list of #ClutterEffect<!-- -->s applied to `self`
         *
         * The #ClutterActor will hold a reference on the `effect` until either
         * clutter_actor_remove_effect() or clutter_actor_clear_effects() is
         * called.
         *
         * Note that as #ClutterEffect is initially unowned,
         * clutter_actor_add_effect() will sink any floating reference on `effect`.
         * @param effect a #ClutterEffect
         */
        add_effect(effect: Effect): void;
        /**
         * A convenience function for setting the name of a #ClutterEffect
         * while adding it to the list of effects applied to `self`.
         *
         * Note that as #ClutterEffect is initially unowned,
         * clutter_actor_add_effect_with_name() will sink any floating
         * reference on `effect`.
         *
         * This function is the logical equivalent of:
         *
         *
         * ```c
         *   clutter_actor_meta_set_name (CLUTTER_ACTOR_META (effect), name);
         *   clutter_actor_add_effect (self, effect);
         * ```
         *
         * @param name the name to set on the effect
         * @param effect a #ClutterEffect
         */
        add_effect_with_name(name: string, effect: Effect): void;
        /**
         * Adds a `transition` to the #ClutterActor's list of animations.
         *
         * The `name` string is a per-actor unique identifier of the `transition:` only
         * one #ClutterTransition can be associated to the specified `name`.
         *
         * The `transition` will be started once added.
         *
         * This function will take a reference on the `transition`.
         *
         * This function is usually called implicitly when modifying an animatable
         * property.
         * @param name the name of the transition to add
         * @param transition the #ClutterTransition to add
         */
        add_transition(name: string, transition: Transition): void;
        /**
         * Assigns the size of a #ClutterActor from the given `box`.
         *
         * This function should only be called on the children of an actor when
         * overriding the #ClutterActorClass.allocate() virtual function.
         *
         * This function will adjust the stored allocation to take into account
         * the alignment flags set in the #ClutterActor:x-align and
         * #ClutterActor:y-align properties, as well as the margin values set in
         * the #ClutterActor:margin-top, #ClutterActor:margin-right,
         * #ClutterActor:margin-bottom, and #ClutterActor:margin-left properties.
         *
         * This function will respect the easing state of the #ClutterActor and
         * interpolate between the current allocation and the new one if the
         * easing state duration is a positive value.
         *
         * Actors can know from their allocation box whether they have moved
         * with respect to their parent actor. The `flags` parameter describes
         * additional information about the allocation, for instance whether
         * the parent has moved with respect to the stage, for example because
         * a grandparent's origin has moved.
         * @param box new allocation of the actor, in parent-relative coordinates
         * @param flags flags that control the allocation
         */
        allocate(box: ActorBox, flags: AllocationFlags | null): void;
        /**
         * Allocates `self` by taking into consideration the available allocation
         * area; an alignment factor on either axis; and whether the actor should
         * fill the allocation on either axis.
         *
         * The `box` should contain the available allocation width and height;
         * if the x1 and y1 members of #ClutterActorBox are not set to 0, the
         * allocation will be offset by their value.
         *
         * This function takes into consideration the geometry request specified by
         * the #ClutterActor:request-mode property, and the text direction.
         *
         * This function is useful for fluid layout managers using legacy alignment
         * flags. Newly written layout managers should use the #ClutterActor:x-align
         * and #ClutterActor:y-align properties, instead, and just call
         * clutter_actor_allocate() inside their #ClutterActorClass.allocate()
         * implementation.
         * @param box a #ClutterActorBox, containing the available width and height
         * @param x_align the horizontal alignment, between 0 and 1
         * @param y_align the vertical alignment, between 0 and 1
         * @param x_fill whether the actor should fill horizontally
         * @param y_fill whether the actor should fill vertically
         * @param flags allocation flags to be passed to clutter_actor_allocate()
         */
        allocate_align_fill(
            box: ActorBox,
            x_align: number,
            y_align: number,
            x_fill: boolean,
            y_fill: boolean,
            flags: AllocationFlags | null,
        ): void;
        /**
         * Allocates `self` taking into account the #ClutterActor's
         * preferred size, but limiting it to the maximum available width
         * and height provided.
         *
         * This function will do the right thing when dealing with the
         * actor's request mode.
         *
         * The implementation of this function is equivalent to:
         *
         *
         * ```c
         *   if (request_mode == CLUTTER_REQUEST_HEIGHT_FOR_WIDTH)
         *     {
         *       clutter_actor_get_preferred_width (self, available_height,
         *                                          &min_width,
         *                                          &natural_width);
         *       width = CLAMP (natural_width, min_width, available_width);
         *
         *       clutter_actor_get_preferred_height (self, width,
         *                                           &min_height,
         *                                           &natural_height);
         *       height = CLAMP (natural_height, min_height, available_height);
         *     }
         *   else if (request_mode == CLUTTER_REQUEST_WIDTH_FOR_HEIGHT)
         *     {
         *       clutter_actor_get_preferred_height (self, available_width,
         *                                           &min_height,
         *                                           &natural_height);
         *       height = CLAMP (natural_height, min_height, available_height);
         *
         *       clutter_actor_get_preferred_width (self, height,
         *                                          &min_width,
         *                                          &natural_width);
         *       width = CLAMP (natural_width, min_width, available_width);
         *     }
         *   else if (request_mode == CLUTTER_REQUEST_CONTENT_SIZE)
         *     {
         *       clutter_content_get_preferred_size (content, &natural_width, &natural_height);
         *
         *       width = CLAMP (natural_width, 0, available_width);
         *       height = CLAMP (natural_height, 0, available_height);
         *     }
         *
         *   box.x1 = x; box.y1 = y;
         *   box.x2 = box.x1 + available_width;
         *   box.y2 = box.y1 + available_height;
         *   clutter_actor_allocate (self, &box, flags);
         * ```
         *
         *
         * This function can be used by fluid layout managers to allocate
         * an actor's preferred size without making it bigger than the area
         * available for the container.
         * @param x the actor's X coordinate
         * @param y the actor's Y coordinate
         * @param available_width the maximum available width, or -1 to use the   actor's natural width
         * @param available_height the maximum available height, or -1 to use the   actor's natural height
         * @param flags flags controlling the allocation
         */
        allocate_available_size(
            x: number,
            y: number,
            available_width: number,
            available_height: number,
            flags: AllocationFlags | null,
        ): void;
        /**
         * Allocates the natural size of `self`.
         *
         * This function is a utility call for #ClutterActor implementations
         * that allocates the actor's preferred natural size. It can be used
         * by fixed layout managers (like #ClutterGroup or so called
         * 'composite actors') inside the ClutterActor::allocate
         * implementation to give each child exactly how much space it
         * requires, regardless of the size of the parent.
         *
         * This function is not meant to be used by applications. It is also
         * not meant to be used outside the implementation of the
         * #ClutterActorClass.allocate virtual function.
         * @param flags flags controlling the allocation
         */
        allocate_preferred_size(flags: AllocationFlags | null): void;
        /**
         * Animates the given list of properties of `actor` between the current
         * value for each property and a new final value. The animation has a
         * definite behaviour given by the passed `alpha`.
         *
         * See clutter_actor_animate() for further details.
         *
         * This function is useful if you want to use an existing #ClutterAlpha
         * to animate `actor`.
         *
         * This is the vector-based variant of clutter_actor_animate_with_alpha(),
         * useful for language bindings.
         *
         * Unlike clutter_actor_animate_with_alpha(), this function will
         * not allow you to specify "signal::" names and callbacks.
         * @param alpha a #ClutterAlpha
         * @param properties a vector    containing the property names to set
         * @param values a vector containing the    property values to set
         * @returns a #ClutterAnimation object. The object is owned by the   #ClutterActor and should not be unreferenced with g_object_unref()
         */
        animate_with_alphav(alpha: Alpha, properties: string[], values: (GObject.Value | any)[]): Animation;
        /**
         * Animates the given list of properties of `actor` between the current
         * value for each property and a new final value. The animation has a
         * definite duration given by `timeline` and a speed given by the `mode`.
         *
         * See clutter_actor_animate() for further details.
         *
         * This function is useful if you want to use an existing timeline
         * to animate `actor`.
         *
         * This is the vector-based variant of clutter_actor_animate_with_timeline(),
         * useful for language bindings.
         *
         * Unlike clutter_actor_animate_with_timeline(), this function
         * will not allow you to specify "signal::" names and callbacks.
         * @param mode an animation mode logical id
         * @param timeline a #ClutterTimeline
         * @param properties a vector    containing the property names to set
         * @param values a vector containing the    property values to set
         * @returns a #ClutterAnimation object. The object is    owned by the #ClutterActor and should not be unreferenced with    g_object_unref()
         */
        animate_with_timelinev(
            mode: number,
            timeline: Timeline,
            properties: string[],
            values: (GObject.Value | any)[],
        ): Animation;
        /**
         * Animates the given list of properties of `actor` between the current
         * value for each property and a new final value. The animation has a
         * definite duration and a speed given by the `mode`.
         *
         * This is the vector-based variant of clutter_actor_animate(), useful
         * for language bindings.
         *
         * Unlike clutter_actor_animate(), this function will not
         * allow you to specify "signal::" names and callbacks.
         * @param mode an animation mode logical id
         * @param duration duration of the animation, in milliseconds
         * @param properties a vector    containing the property names to set
         * @param values a vector containing the    property values to set
         * @returns a #ClutterAnimation object. The object is   owned by the #ClutterActor and should not be unreferenced with   g_object_unref()
         */
        animatev(mode: number, duration: number, properties: string[], values: (GObject.Value | any)[]): Animation;
        /**
         * Transforms `point` in coordinates relative to the actor into
         * ancestor-relative coordinates using the relevant transform
         * stack (i.e. scale, rotation, etc).
         *
         * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
         * this case, the coordinates returned will be the coordinates on
         * the stage before the projection is applied. This is different from
         * the behaviour of clutter_actor_apply_transform_to_point().
         * @param ancestor A #ClutterActor ancestor, or %NULL to use the   default #ClutterStage
         * @param point A point as #ClutterVertex
         */
        apply_relative_transform_to_point(ancestor: Actor | null, point: Vertex): Vertex;
        /**
         * Transforms `point` in coordinates relative to the actor
         * into screen-relative coordinates with the current actor
         * transformation (i.e. scale, rotation, etc)
         * @param point A point as #ClutterVertex
         */
        apply_transform_to_point(point: Vertex): Vertex;
        /**
         * Binds a #GListModel to a #ClutterActor.
         *
         * If the #ClutterActor was already bound to a #GListModel, the previous
         * binding is destroyed.
         *
         * The existing children of #ClutterActor are destroyed when setting a
         * model, and new children are created and added, representing the contents
         * of the `model`. The #ClutterActor is updated whenever the `model` changes.
         * If `model` is %NULL, the #ClutterActor is left empty.
         *
         * When a #ClutterActor is bound to a model, adding and removing children
         * directly is undefined behaviour.
         * @param model a #GListModel
         * @param create_child_func a function that creates #ClutterActor instances   from the contents of the @model
         */
        bind_model(model: Gio.ListModel | null, create_child_func: ActorCreateChildFunc): void;
        /**
         * Clears the list of actions applied to `self`
         */
        clear_actions(): void;
        /**
         * Clears the list of constraints applied to `self`
         */
        clear_constraints(): void;
        /**
         * Clears the list of effects applied to `self`
         */
        clear_effects(): void;
        /**
         * Determines if `descendant` is contained inside `self` (either as an
         * immediate child, or as a deeper descendant). If `self` and
         * `descendant` point to the same actor then it will also return %TRUE.
         * @param descendant A #ClutterActor, possibly contained in @self
         * @returns whether @descendent is contained within @self
         */
        contains(descendant: Actor): boolean;
        /**
         * Run the next stage of the paint sequence. This function should only
         * be called within the implementation of the run virtual of a
         * #ClutterEffect. It will cause the run method of the next effect to
         * be applied, or it will paint the actual actor if the current effect
         * is the last effect in the chain.
         */
        continue_paint(): void;
        /**
         * Creates a #PangoContext for the given actor. The #PangoContext
         * is already configured using the appropriate font map, resolution
         * and font options.
         *
         * See also clutter_actor_get_pango_context().
         * @returns the newly created #PangoContext.   Use g_object_unref() on the returned value to deallocate its   resources
         */
        create_pango_context(): Pango.Context;
        /**
         * Creates a new #PangoLayout from the same #PangoContext used
         * by the #ClutterActor. The #PangoLayout is already configured
         * with the font map, resolution and font options, and the
         * given `text`.
         *
         * If you want to keep around a #PangoLayout created by this
         * function you will have to connect to the #ClutterBackend::font-changed
         * and #ClutterBackend::resolution-changed signals, and call
         * pango_layout_context_changed() in response to them.
         * @param text the text to set on the #PangoLayout, or %NULL
         * @returns the newly created #PangoLayout.   Use g_object_unref() when done
         */
        create_pango_layout(text?: string | null): Pango.Layout;
        /**
         * Destroys an actor.  When an actor is destroyed, it will break any
         * references it holds to other objects.  If the actor is inside a
         * container, the actor will be removed.
         *
         * When you destroy a container, its children will be destroyed as well.
         *
         * Note: you cannot destroy the #ClutterStage returned by
         * clutter_stage_get_default().
         */
        destroy(): void;
        /**
         * Destroys all children of `self`.
         *
         * This function releases the reference added by inserting a child
         * actor in the list of children of `self,` and ensures that the
         * #ClutterActor::destroy signal is emitted on each child of the
         * actor.
         *
         * By default, #ClutterActor will emit the #ClutterActor::destroy signal
         * when its reference count drops to 0; the default handler of the
         * #ClutterActor::destroy signal will destroy all the children of an
         * actor. This function ensures that all children are destroyed, instead
         * of just removed from `self,` unlike clutter_actor_remove_all_children()
         * which will merely release the reference and remove each child.
         *
         * Unless you acquired an additional reference on each child of `self`
         * prior to calling clutter_actor_remove_all_children() and want to reuse
         * the actors, you should use clutter_actor_destroy_all_children() in
         * order to make sure that children are destroyed and signal handlers
         * are disconnected even in cases where circular references prevent this
         * from automatically happening through reference counting alone.
         */
        destroy_all_children(): void;
        /**
         * Detaches the #ClutterAnimation used by `actor,` if clutter_actor_animate()
         * has been called on `actor`.
         *
         * Once the animation has been detached, it loses a reference. If it was
         * the only reference then the #ClutterAnimation becomes invalid.
         *
         * The #ClutterAnimation::completed signal will not be emitted.
         */
        detach_animation(): void;
        /**
         * This function is used to emit an event on the main stage.
         * You should rarely need to use this function, except for
         * synthetising events.
         * @param event a #ClutterEvent
         * @param capture %TRUE if event in in capture phase, %FALSE otherwise.
         * @returns the return value from the signal emission: %TRUE   if the actor handled the event, or %FALSE if the event was   not handled
         */
        event(event: Event, capture: boolean): boolean;
        /**
         * Calculates the transformed screen coordinates of the four corners of
         * the actor; the returned vertices relate to the #ClutterActorBox
         * coordinates  as follows:
         *
         *  - v[0] contains (x1, y1)
         *  - v[1] contains (x2, y1)
         *  - v[2] contains (x1, y2)
         *  - v[3] contains (x2, y2)
         */
        get_abs_allocation_vertices(): Vertex[];
        /**
         * Returns the accessible object that describes the actor to an
         * assistive technology.
         *
         * If no class-specific #AtkObject implementation is available for the
         * actor instance in question, it will inherit an #AtkObject
         * implementation from the first ancestor class for which such an
         * implementation is defined.
         *
         * The documentation of the <ulink
         * url="http://developer.gnome.org/doc/API/2.0/atk/index.html">ATK</ulink>
         * library contains more information about accessible objects and
         * their uses.
         * @returns the #AtkObject associated with @actor
         */
        get_accessible(): Atk.Object;
        /**
         * Retrieves the #ClutterAction with the given name in the list
         * of actions applied to `self`
         * @param name the name of the action to retrieve
         * @returns a #ClutterAction for the given   name, or %NULL. The returned #ClutterAction is owned by the   actor and it should not be unreferenced directly
         */
        get_action(name: string): Action;
        /**
         * Retrieves the list of actions applied to `self`
         * @returns a copy   of the list of #ClutterAction<!-- -->s. The contents of the list are   owned by the #ClutterActor. Use g_list_free() to free the resources   allocated by the returned #GList
         */
        get_actions(): Action[];
        /**
         * Gets the layout box an actor has been assigned. The allocation can
         * only be assumed valid inside a paint() method; anywhere else, it
         * may be out-of-date.
         *
         * An allocation does not incorporate the actor's scale or anchor point;
         * those transformations do not affect layout, only rendering.
         *
         * Do not call any of the clutter_actor_get_allocation_*() family
         * of functions inside the implementation of the get_preferred_width()
         * or get_preferred_height() virtual functions.
         */
        get_allocation_box(): ActorBox;
        /**
         * Gets the layout box an actor has been assigned.  The allocation can
         * only be assumed valid inside a paint() method; anywhere else, it
         * may be out-of-date.
         *
         * An allocation does not incorporate the actor's scale or anchor point;
         * those transformations do not affect layout, only rendering.
         *
         * The returned rectangle is in pixels.
         */
        get_allocation_geometry(): Geometry;
        /**
         * Calculates the transformed coordinates of the four corners of the
         * actor in the plane of `ancestor`. The returned vertices relate to
         * the #ClutterActorBox coordinates as follows:
         *
         *  - `verts[`0] contains (x1, y1)
         *  - `verts[`1] contains (x2, y1)
         *  - `verts[`2] contains (x1, y2)
         *  - `verts[`3] contains (x2, y2)
         *
         * If `ancestor` is %NULL the ancestor will be the #ClutterStage. In
         * this case, the coordinates returned will be the coordinates on
         * the stage before the projection is applied. This is different from
         * the behaviour of clutter_actor_get_abs_allocation_vertices().
         * @param ancestor A #ClutterActor to calculate the vertices   against, or %NULL to use the #ClutterStage
         */
        get_allocation_vertices(ancestor: Actor | null): Vertex[];
        /**
         * Gets the current anchor point of the `actor` in pixels.
         */
        get_anchor_point(): [number, number];
        /**
         * Retrieves the anchor position expressed as a #ClutterGravity. If
         * the anchor point was specified using pixels or units this will
         * return %CLUTTER_GRAVITY_NONE.
         * @returns the #ClutterGravity used by the anchor point
         */
        get_anchor_point_gravity(): Gravity;
        /**
         * Retrieves the #ClutterAnimation used by `actor,` if clutter_actor_animate()
         * has been called on `actor`.
         * @returns a #ClutterAnimation, or %NULL
         */
        get_animation(): Animation;
        /**
         * Retrieves the color set using clutter_actor_set_background_color().
         */
        get_background_color(): Color;
        /**
         * Retrieves the actor at the given `index_` inside the list of
         * children of `self`.
         * @param index_ the position in the list of children
         * @returns a pointer to a #ClutterActor, or %NULL
         */
        get_child_at_index(index_: number): Actor;
        /**
         * Retrieves the child transformation matrix set using
         * clutter_actor_set_child_transform(); if none is currently set,
         * the `transform` matrix will be initialized to the identity matrix.
         */
        get_child_transform(): Matrix;
        /**
         * Retrieves the list of children of `self`.
         * @returns A newly   allocated #GList of #ClutterActor<!-- -->s. Use g_list_free() when   done.
         */
        get_children(): Actor[];
        /**
         * Gets the clip area for `self,` if any is set.
         */
        get_clip(): [number, number, number, number];
        /**
         * Retrieves the value set using clutter_actor_set_clip_to_allocation()
         * @returns %TRUE if the #ClutterActor is clipped to its allocation
         */
        get_clip_to_allocation(): boolean;
        /**
         * Retrieves the #ClutterConstraint with the given name in the list
         * of constraints applied to `self`
         * @param name the name of the constraint to retrieve
         * @returns a #ClutterConstraint for the given   name, or %NULL. The returned #ClutterConstraint is owned by the   actor and it should not be unreferenced directly
         */
        get_constraint(name: string): Constraint;
        /**
         * Retrieves the list of constraints applied to `self`
         * @returns a copy   of the list of #ClutterConstraint<!-- -->s. The contents of the list are   owned by the #ClutterActor. Use g_list_free() to free the resources   allocated by the returned #GList
         */
        get_constraints(): Constraint[];
        /**
         * Retrieves the contents of `self`.
         * @returns a pointer to the #ClutterContent instance,   or %NULL if none was set
         */
        get_content(): Content;
        /**
         * Retrieves the bounding box for the #ClutterContent of `self`.
         *
         * The bounding box is relative to the actor's allocation.
         *
         * If no #ClutterContent is set for `self,` or if `self` has not been
         * allocated yet, then the result is undefined.
         *
         * The content box is guaranteed to be, at most, as big as the allocation
         * of the #ClutterActor.
         *
         * If the #ClutterContent used by the actor has a preferred size, then
         * it is possible to modify the content box by using the
         * #ClutterActor:content-gravity property.
         */
        get_content_box(): ActorBox;
        /**
         * Retrieves the content gravity as set using
         * clutter_actor_set_content_gravity().
         * @returns the content gravity
         */
        get_content_gravity(): ContentGravity;
        /**
         * Retrieves the repeat policy for a #ClutterActor set by
         * clutter_actor_set_content_repeat().
         * @returns the content repeat policy
         */
        get_content_repeat(): ContentRepeat;
        /**
         * Retrieves the values set using clutter_actor_set_content_scaling_filters().
         */
        get_content_scaling_filters(): [ScalingFilter | null, ScalingFilter | null];
        /**
         * Retrieves the default paint volume for `self`.
         *
         * This function provides the same #ClutterPaintVolume that would be
         * computed by the default implementation inside #ClutterActor of the
         * #ClutterActorClass.get_paint_volume() virtual function.
         *
         * This function should only be used by #ClutterActor subclasses that
         * cannot chain up to the parent implementation when computing their
         * paint volume.
         * @returns a pointer to the default   #ClutterPaintVolume, relative to the #ClutterActor, or %NULL if   the actor could not compute a valid paint volume. The returned value   is not guaranteed to be stable across multiple frames, so if you   want to retain it, you will need to copy it using   clutter_paint_volume_copy().
         */
        get_default_paint_volume(): PaintVolume;
        /**
         * Retrieves the depth of `self`.
         * @returns the depth of the actor
         */
        get_depth(): number;
        /**
         * Retrieves the delay that should be applied when tweening animatable
         * properties.
         * @returns a delay, in milliseconds
         */
        get_easing_delay(): number;
        /**
         * Retrieves the duration of the tweening for animatable
         * properties of `self` for the current easing state.
         * @returns the duration of the tweening, in milliseconds
         */
        get_easing_duration(): number;
        /**
         * Retrieves the easing mode for the tweening of animatable properties
         * of `self` for the current easing state.
         * @returns an easing mode
         */
        get_easing_mode(): AnimationMode;
        /**
         * Retrieves the #ClutterEffect with the given name in the list
         * of effects applied to `self`
         * @param name the name of the effect to retrieve
         * @returns a #ClutterEffect for the given   name, or %NULL. The returned #ClutterEffect is owned by the   actor and it should not be unreferenced directly
         */
        get_effect(name: string): Effect;
        /**
         * Retrieves the #ClutterEffect<!-- -->s applied on `self,` if any
         * @returns a list   of #ClutterEffect<!-- -->s, or %NULL. The elements of the returned   list are owned by Clutter and they should not be freed. You should   free the returned list using g_list_free() when done
         */
        get_effects(): Effect[];
        /**
         * Retrieves the first child of `self`.
         *
         * The returned pointer is only valid until the scene graph changes; it
         * is not safe to modify the list of children of `self` while iterating
         * it.
         * @returns a pointer to a #ClutterActor, or %NULL
         */
        get_first_child(): Actor;
        /**
         * Checks whether an actor has a fixed position set (and will thus be
         * unaffected by any layout manager).
         * @returns %TRUE if the fixed position is set on the actor
         */
        get_fixed_position_set(): boolean;
        /**
         * Retrieves the flags set on `self`
         * @returns a bitwise or of #ClutterActorFlags or 0
         */
        get_flags(): ActorFlags;
        /**
         * Gets the size and position of an actor relative to its parent
         * actor. This is the same as calling clutter_actor_get_position() and
         * clutter_actor_get_size(). It tries to "do what you mean" and get the
         * requested size and position if the actor's allocation is invalid.
         */
        get_geometry(): Geometry;
        /**
         * Retrieves the unique id for `self`.
         * @returns Globally unique value for this object instance.
         */
        get_gid(): number;
        /**
         * Retrieves the height of a #ClutterActor.
         *
         * If the actor has a valid allocation, this function will return the
         * height of the allocated area given to the actor.
         *
         * If the actor does not have a valid allocation, this function will
         * return the actor's natural height, that is the preferred height of
         * the actor.
         *
         * If you care whether you get the preferred height or the height that
         * has been assigned to the actor, you should probably call a different
         * function like clutter_actor_get_allocation_box() to retrieve the
         * allocated size or clutter_actor_get_preferred_height() to retrieve the
         * preferred height.
         *
         * If an actor has a fixed height, for instance a height that has been
         * assigned using clutter_actor_set_height(), the height returned will
         * be the same value.
         * @returns the height of the actor, in pixels
         */
        get_height(): number;
        /**
         * Retrieves the last child of `self`.
         *
         * The returned pointer is only valid until the scene graph changes; it
         * is not safe to modify the list of children of `self` while iterating
         * it.
         * @returns a pointer to a #ClutterActor, or %NULL
         */
        get_last_child(): Actor;
        /**
         * Retrieves the #ClutterLayoutManager used by `self`.
         * @returns a pointer to the #ClutterLayoutManager,   or %NULL
         */
        get_layout_manager(): LayoutManager;
        /**
         * Retrieves all the components of the margin of a #ClutterActor.
         */
        get_margin(): Margin;
        /**
         * Retrieves the bottom margin of a #ClutterActor.
         * @returns the bottom margin
         */
        get_margin_bottom(): number;
        /**
         * Retrieves the left margin of a #ClutterActor.
         * @returns the left margin
         */
        get_margin_left(): number;
        /**
         * Retrieves the right margin of a #ClutterActor.
         * @returns the right margin
         */
        get_margin_right(): number;
        /**
         * Retrieves the top margin of a #ClutterActor.
         * @returns the top margin
         */
        get_margin_top(): number;
        /**
         * Retrieves the number of children of `self`.
         * @returns the number of children of an actor
         */
        get_n_children(): number;
        /**
         * Retrieves the name of `self`.
         * @returns the name of the actor, or %NULL. The returned string is   owned by the actor and should not be modified or freed.
         */
        get_name(): string;
        /**
         * Retrieves the sibling of `self` that comes after it in the list
         * of children of `self'`s parent.
         *
         * The returned pointer is only valid until the scene graph changes; it
         * is not safe to modify the list of children of `self` while iterating
         * it.
         * @returns a pointer to a #ClutterActor, or %NULL
         */
        get_next_sibling(): Actor;
        /**
         * Retrieves whether to redirect the actor to an offscreen buffer, as
         * set by clutter_actor_set_offscreen_redirect().
         * @returns the value of the offscreen-redirect property of the actor
         */
        get_offscreen_redirect(): OffscreenRedirect;
        /**
         * Retrieves the opacity value of an actor, as set by
         * clutter_actor_set_opacity().
         *
         * For retrieving the absolute opacity of the actor inside a paint
         * virtual function, see clutter_actor_get_paint_opacity().
         * @returns the opacity of the actor
         */
        get_opacity(): number;
        /**
         * Retrieves the paint volume of the passed #ClutterActor, and
         * transforms it into a 2D bounding box in stage coordinates.
         *
         * This function is useful to determine the on screen area occupied by
         * the actor. The box is only an approximation and may often be
         * considerably larger due to the optimizations used to calculate the
         * box. The box is never smaller though, so it can reliably be used
         * for culling.
         *
         * There are times when a 2D paint box can't be determined, e.g.
         * because the actor isn't yet parented under a stage or because
         * the actor is unable to determine a paint volume.
         * @returns %TRUE if a 2D paint box could be determined, else %FALSE.
         */
        get_paint_box(): [boolean, ActorBox];
        /**
         * Retrieves the absolute opacity of the actor, as it appears on the stage.
         *
         * This function traverses the hierarchy chain and composites the opacity of
         * the actor with that of its parents.
         *
         * This function is intended for subclasses to use in the paint virtual
         * function, to paint themselves with the correct opacity.
         * @returns The actor opacity value.
         */
        get_paint_opacity(): number;
        /**
         * Retrieves the 'paint' visibility of an actor recursively checking for non
         * visible parents.
         *
         * This is by definition the same as %CLUTTER_ACTOR_IS_MAPPED.
         * @returns %TRUE if the actor is visibile and will be painted.
         */
        get_paint_visibility(): boolean;
        /**
         * Retrieves the paint volume of the passed #ClutterActor, or %NULL
         * when a paint volume can't be determined.
         *
         * The paint volume is defined as the 3D space occupied by an actor
         * when being painted.
         *
         * This function will call the #ClutterActorClass.get_paint_volume()
         * virtual function of the #ClutterActor class. Sub-classes of #ClutterActor
         * should not usually care about overriding the default implementation,
         * unless they are, for instance: painting outside their allocation, or
         * actors with a depth factor (not in terms of #ClutterActor:depth but real
         * 3D depth).
         *
         * Note: 2D actors overriding #ClutterActorClass.get_paint_volume()
         * should ensure that their volume has a depth of 0. (This will be true
         * as long as you don't call clutter_paint_volume_set_depth().)
         * @returns a pointer to a #ClutterPaintVolume,   or %NULL if no volume could be determined. The returned pointer   is not guaranteed to be valid across multiple frames; if you want   to keep it, you will need to copy it using clutter_paint_volume_copy().
         */
        get_paint_volume(): PaintVolume;
        /**
         * Retrieves the #PangoContext for `self`. The actor's #PangoContext
         * is already configured using the appropriate font map, resolution
         * and font options.
         *
         * Unlike clutter_actor_create_pango_context(), this context is owend
         * by the #ClutterActor and it will be updated each time the options
         * stored by the #ClutterBackend change.
         *
         * You can use the returned #PangoContext to create a #PangoLayout
         * and render text using cogl_pango_render_layout() to reuse the
         * glyphs cache also used by Clutter.
         * @returns the #PangoContext for a #ClutterActor.   The returned #PangoContext is owned by the actor and should not be   unreferenced by the application code
         */
        get_pango_context(): Pango.Context;
        /**
         * Retrieves the parent of `self`.
         * @returns The #ClutterActor parent, or %NULL  if no parent is set
         */
        get_parent(): Actor;
        /**
         * Retrieves the coordinates of the #ClutterActor:pivot-point.
         */
        get_pivot_point(): [number, number];
        /**
         * Retrieves the Z component of the #ClutterActor:pivot-point.
         */
        get_pivot_point_z(): number;
        /**
         * This function tries to "do what you mean" and tell you where the
         * actor is, prior to any transformations. Retrieves the fixed
         * position of an actor in pixels, if one has been set; otherwise, if
         * the allocation is valid, returns the actor's allocated position;
         * otherwise, returns 0,0.
         *
         * The returned position is in pixels.
         */
        get_position(): [number, number];
        /**
         * Computes the requested minimum and natural heights for an actor,
         * or if they are already computed, returns the cached values.
         *
         * An actor may not get its request - depending on the layout
         * manager that's in effect.
         *
         * A request should not incorporate the actor's scale or anchor point;
         * those transformations do not affect layout, only rendering.
         * @param for_width available width to assume in computing desired height,   or a negative value to indicate that no width is defined
         */
        get_preferred_height(for_width: number): [number, number];
        /**
         * Computes the preferred minimum and natural size of an actor, taking into
         * account the actor's geometry management (either height-for-width
         * or width-for-height).
         *
         * The width and height used to compute the preferred height and preferred
         * width are the actor's natural ones.
         *
         * If you need to control the height for the preferred width, or the width for
         * the preferred height, you should use clutter_actor_get_preferred_width()
         * and clutter_actor_get_preferred_height(), and check the actor's preferred
         * geometry management using the #ClutterActor:request-mode property.
         */
        get_preferred_size(): [number, number, number, number];
        /**
         * Computes the requested minimum and natural widths for an actor,
         * optionally depending on the specified height, or if they are
         * already computed, returns the cached values.
         *
         * An actor may not get its request - depending on the layout
         * manager that's in effect.
         *
         * A request should not incorporate the actor's scale or anchor point;
         * those transformations do not affect layout, only rendering.
         * @param for_height available height when computing the preferred width,   or a negative value to indicate that no height is defined
         */
        get_preferred_width(for_height: number): [number, number];
        /**
         * Retrieves the sibling of `self` that comes before it in the list
         * of children of `self'`s parent.
         *
         * The returned pointer is only valid until the scene graph changes; it
         * is not safe to modify the list of children of `self` while iterating
         * it.
         * @returns a pointer to a #ClutterActor, or %NULL
         */
        get_previous_sibling(): Actor;
        /**
         * Checks whether `actor` is marked as reactive.
         * @returns %TRUE if the actor is reactive
         */
        get_reactive(): boolean;
        /**
         * Retrieves the geometry request mode of `self`
         * @returns the request mode for the actor
         */
        get_request_mode(): RequestMode;
        /**
         * Retrieves the angle and center of rotation on the given axis,
         * set using clutter_actor_set_rotation().
         * @param axis the axis of rotation
         * @returns the angle of rotation
         */
        get_rotation(axis: RotateAxis | null): [number, number, number, number];
        /**
         * Retrieves the angle of rotation set by clutter_actor_set_rotation_angle().
         * @param axis the axis of the rotation
         * @returns the angle of rotation, in degrees
         */
        get_rotation_angle(axis: RotateAxis | null): number;
        /**
         * Retrieves an actors scale factors.
         */
        get_scale(): [number, number];
        /**
         * Retrieves the scale center coordinate in pixels relative to the top
         * left corner of the actor. If the scale center was specified using a
         * #ClutterGravity this will calculate the pixel offset using the
         * current size of the actor.
         */
        get_scale_center(): [number, number];
        /**
         * Retrieves the scale center as a compass direction. If the scale
         * center was specified in pixels or units this will return
         * %CLUTTER_GRAVITY_NONE.
         * @returns the scale gravity
         */
        get_scale_gravity(): Gravity;
        /**
         * Retrieves the scaling factor along the Z axis, as set using
         * clutter_actor_set_scale_z().
         * @returns the scaling factor along the Z axis
         */
        get_scale_z(): number;
        /**
         * Queries the currently set #ClutterShader on `self`.
         * @returns The currently set #ClutterShader   or %NULL if no shader is set.
         */
        get_shader(): Shader;
        /**
         * This function tries to "do what you mean" and return
         * the size an actor will have. If the actor has a valid
         * allocation, the allocation will be returned; otherwise,
         * the actors natural size request will be returned.
         *
         * If you care whether you get the request vs. the allocation, you
         * should probably call a different function like
         * clutter_actor_get_allocation_box() or
         * clutter_actor_get_preferred_width().
         */
        get_size(): [number, number];
        /**
         * Retrieves the #ClutterStage where `actor` is contained.
         * @returns the stage   containing the actor, or %NULL
         */
        get_stage(): Stage;
        /**
         * Retrieves the value set using clutter_actor_set_text_direction()
         *
         * If no text direction has been previously set, the default text
         * direction, as returned by clutter_get_default_text_direction(), will
         * be returned instead
         * @returns the #ClutterTextDirection for the actor
         */
        get_text_direction(): TextDirection;
        /**
         * Retrieves the current transformation matrix of a #ClutterActor.
         */
        get_transform(): Matrix;
        /**
         * Retrieves the transformations applied to `self` relative to its
         * parent.
         */
        get_transformation_matrix(): Matrix;
        /**
         * Retrieves the 3D paint volume of an actor like
         * clutter_actor_get_paint_volume() does (Please refer to the
         * documentation of clutter_actor_get_paint_volume() for more
         * details.) and it additionally transforms the paint volume into the
         * coordinate space of `relative_to_ancestor`. (Or the stage if %NULL
         * is passed for `relative_to_ancestor)`
         *
         * This can be used by containers that base their paint volume on
         * the volume of their children. Such containers can query the
         * transformed paint volume of all of its children and union them
         * together using clutter_paint_volume_union().
         * @param relative_to_ancestor A #ClutterActor that is an ancestor of @self    (or %NULL for the stage)
         * @returns a pointer to a #ClutterPaintVolume,   or %NULL if no volume could be determined. The returned pointer is   not guaranteed to be valid across multiple frames; if you wish to   keep it, you will have to copy it using clutter_paint_volume_copy().
         */
        get_transformed_paint_volume(relative_to_ancestor: Actor): PaintVolume;
        /**
         * Gets the absolute position of an actor, in pixels relative to the stage.
         */
        get_transformed_position(): [number, number];
        /**
         * Gets the absolute size of an actor in pixels, taking into account the
         * scaling factors.
         *
         * If the actor has a valid allocation, the allocated size will be used.
         * If the actor has not a valid allocation then the preferred size will
         * be transformed and returned.
         *
         * If you want the transformed allocation, see
         * clutter_actor_get_abs_allocation_vertices() instead.
         *
         * When the actor (or one of its ancestors) is rotated around the
         * X or Y axis, it no longer appears as on the stage as a rectangle, but
         * as a generic quadrangle; in that case this function returns the size
         * of the smallest rectangle that encapsulates the entire quad. Please
         * note that in this case no assumptions can be made about the relative
         * position of this envelope to the absolute position of the actor, as
         * returned by clutter_actor_get_transformed_position(); if you need this
         * information, you need to use clutter_actor_get_abs_allocation_vertices()
         * to get the coords of the actual quadrangle.
         */
        get_transformed_size(): [number, number];
        /**
         * Retrieves the #ClutterTransition of a #ClutterActor by using the
         * transition `name`.
         *
         * Transitions created for animatable properties use the name of the
         * property itself, for instance the code below:
         *
         *
         * ```c
         *   clutter_actor_set_easing_duration (actor, 1000);
         *   clutter_actor_set_rotation (actor, CLUTTER_Y_AXIS, 360.0, x, y, z);
         *
         *   transition = clutter_actor_get_transition (actor, "rotation-angle-y");
         *   g_signal_connect (transition, "stopped",
         *                     G_CALLBACK (on_transition_stopped),
         *                     actor);
         * ```
         *
         *
         * will call the `on_transition_stopped` callback when the transition
         * is finished.
         *
         * If you just want to get notifications of the completion of a transition,
         * you should use the #ClutterActor::transition-stopped signal, using the
         * transition name as the signal detail.
         * @param name the name of the transition
         * @returns a #ClutterTransition, or %NULL is none   was found to match the passed name; the returned instance is owned   by Clutter and it should not be freed
         */
        get_transition(name: string): Transition;
        /**
         * Retrieves the translation set using clutter_actor_set_translation().
         */
        get_translation(): [number, number, number];
        /**
         * Retrieves the width of a #ClutterActor.
         *
         * If the actor has a valid allocation, this function will return the
         * width of the allocated area given to the actor.
         *
         * If the actor does not have a valid allocation, this function will
         * return the actor's natural width, that is the preferred width of
         * the actor.
         *
         * If you care whether you get the preferred width or the width that
         * has been assigned to the actor, you should probably call a different
         * function like clutter_actor_get_allocation_box() to retrieve the
         * allocated size or clutter_actor_get_preferred_width() to retrieve the
         * preferred width.
         *
         * If an actor has a fixed width, for instance a width that has been
         * assigned using clutter_actor_set_width(), the width returned will
         * be the same value.
         * @returns the width of the actor, in pixels
         */
        get_width(): number;
        /**
         * Retrieves the X coordinate of a #ClutterActor.
         *
         * This function tries to "do what you mean", by returning the
         * correct value depending on the actor's state.
         *
         * If the actor has a valid allocation, this function will return
         * the X coordinate of the origin of the allocation box.
         *
         * If the actor has any fixed coordinate set using clutter_actor_set_x(),
         * clutter_actor_set_position() or clutter_actor_set_geometry(), this
         * function will return that coordinate.
         *
         * If both the allocation and a fixed position are missing, this function
         * will return 0.
         * @returns the X coordinate, in pixels, ignoring any   transformation (i.e. scaling, rotation)
         */
        get_x(): number;
        /**
         * Retrieves the horizontal alignment policy set using
         * clutter_actor_set_x_align().
         * @returns the horizontal alignment policy.
         */
        get_x_align(): ActorAlign;
        /**
         * Retrieves the value set with clutter_actor_set_x_expand().
         *
         * See also: clutter_actor_needs_expand()
         * @returns %TRUE if the actor has been set to expand
         */
        get_x_expand(): boolean;
        /**
         * Retrieves the Y coordinate of a #ClutterActor.
         *
         * This function tries to "do what you mean", by returning the
         * correct value depending on the actor's state.
         *
         * If the actor has a valid allocation, this function will return
         * the Y coordinate of the origin of the allocation box.
         *
         * If the actor has any fixed coordinate set using clutter_actor_set_y(),
         * clutter_actor_set_position() or clutter_actor_set_geometry(), this
         * function will return that coordinate.
         *
         * If both the allocation and a fixed position are missing, this function
         * will return 0.
         * @returns the Y coordinate, in pixels, ignoring any   transformation (i.e. scaling, rotation)
         */
        get_y(): number;
        /**
         * Retrieves the vertical alignment policy set using
         * clutter_actor_set_y_align().
         * @returns the vertical alignment policy.
         */
        get_y_align(): ActorAlign;
        /**
         * Retrieves the value set with clutter_actor_set_y_expand().
         *
         * See also: clutter_actor_needs_expand()
         * @returns %TRUE if the actor has been set to expand
         */
        get_y_expand(): boolean;
        /**
         * Retrieves the actor's position on the Z axis.
         * @returns the position on the Z axis.
         */
        get_z_position(): number;
        /**
         * Retrieves the center for the rotation around the Z axis as a
         * compass direction. If the center was specified in pixels or units
         * this will return %CLUTTER_GRAVITY_NONE.
         * @returns the Z rotation center
         */
        get_z_rotation_gravity(): Gravity;
        /**
         * Sets the key focus of the #ClutterStage including `self`
         * to this #ClutterActor.
         */
        grab_key_focus(): void;
        /**
         * Returns whether the actor has any actions applied.
         * @returns %TRUE if the actor has any actions,   %FALSE otherwise
         */
        has_actions(): boolean;
        /**
         * Checks if the actor has an up-to-date allocation assigned to
         * it. This means that the actor should have an allocation: it's
         * visible and has a parent. It also means that there is no
         * outstanding relayout request in progress for the actor or its
         * children (There might be other outstanding layout requests in
         * progress that will cause the actor to get a new allocation
         * when the stage is laid out, however).
         *
         * If this function returns %FALSE, then the actor will normally
         * be allocated before it is next drawn on the screen.
         * @returns %TRUE if the actor has an up-to-date allocation
         */
        has_allocation(): boolean;
        /**
         * Returns whether the actor has any constraints applied.
         * @returns %TRUE if the actor has any constraints,   %FALSE otherwise
         */
        has_constraints(): boolean;
        /**
         * Returns whether the actor has any effects applied.
         * @returns %TRUE if the actor has any effects,   %FALSE otherwise
         */
        has_effects(): boolean;
        /**
         * Checks whether `self` is the #ClutterActor that has key focus
         * @returns %TRUE if the actor has key focus, and %FALSE otherwise
         */
        has_key_focus(): boolean;
        /**
         * Asks the actor's implementation whether it may contain overlapping
         * primitives.
         *
         * For example; Clutter may use this to determine whether the painting
         * should be redirected to an offscreen buffer to correctly implement
         * the opacity property.
         *
         * Custom actors can override the default response by implementing the
         * #ClutterActorClass.has_overlaps() virtual function. See
         * clutter_actor_set_offscreen_redirect() for more information.
         * @returns %TRUE if the actor may have overlapping primitives, and   %FALSE otherwise
         */
        has_overlaps(): boolean;
        /**
         * Flags an actor to be hidden. A hidden actor will not be
         * rendered on the stage.
         *
         * Actors are visible by default.
         *
         * If this function is called on an actor without a parent, the
         * #ClutterActor:show-on-set-parent property will be set to %FALSE
         * as a side-effect.
         */
        hide(): void;
        /**
         * Calls clutter_actor_hide() on all child actors (if any).
         */
        hide_all(): void;
        /**
         * Inserts `child` into the list of children of `self,` above another
         * child of `self` or, if `sibling` is %NULL, above all the children
         * of `self`.
         *
         * This function will acquire a reference on `child` that will only
         * be released when calling clutter_actor_remove_child().
         *
         * This function will not take into consideration the #ClutterActor:depth
         * of `child`.
         *
         * This function will emit the #ClutterContainer::actor-added signal
         * on `self`.
         * @param child a #ClutterActor
         * @param sibling a child of @self, or %NULL
         */
        insert_child_above(child: Actor, sibling?: Actor | null): void;
        /**
         * Inserts `child` into the list of children of `self,` using the
         * given `index_`. If `index_` is greater than the number of children
         * in `self,` or is less than 0, then the new child is added at the end.
         *
         * This function will acquire a reference on `child` that will only
         * be released when calling clutter_actor_remove_child().
         *
         * This function will not take into consideration the #ClutterActor:depth
         * of `child`.
         *
         * This function will emit the #ClutterContainer::actor-added signal
         * on `self`.
         * @param child a #ClutterActor
         * @param index_ the index
         */
        insert_child_at_index(child: Actor, index_: number): void;
        /**
         * Inserts `child` into the list of children of `self,` below another
         * child of `self` or, if `sibling` is %NULL, below all the children
         * of `self`.
         *
         * This function will acquire a reference on `child` that will only
         * be released when calling clutter_actor_remove_child().
         *
         * This function will not take into consideration the #ClutterActor:depth
         * of `child`.
         *
         * This function will emit the #ClutterContainer::actor-added signal
         * on `self`.
         * @param child a #ClutterActor
         * @param sibling a child of @self, or %NULL
         */
        insert_child_below(child: Actor, sibling?: Actor | null): void;
        /**
         * Checks whether `self` is being currently painted by a #ClutterClone
         *
         * This function is useful only inside the ::paint virtual function
         * implementations or within handlers for the #ClutterActor::paint
         * signal
         *
         * This function should not be used by applications
         * @returns %TRUE if the #ClutterActor is currently being painted   by a #ClutterClone, and %FALSE otherwise
         */
        is_in_clone_paint(): boolean;
        /**
         * Checks whether a #ClutterActor has been set as mapped.
         *
         * See also %CLUTTER_ACTOR_IS_MAPPED and #ClutterActor:mapped
         * @returns %TRUE if the actor is mapped
         */
        is_mapped(): boolean;
        /**
         * Checks whether a #ClutterActor is realized.
         *
         * See also %CLUTTER_ACTOR_IS_REALIZED and #ClutterActor:realized.
         * @returns %TRUE if the actor is realized
         */
        is_realized(): boolean;
        /**
         * Checks whether any rotation is applied to the actor.
         * @returns %TRUE if the actor is rotated.
         */
        is_rotated(): boolean;
        /**
         * Checks whether the actor is scaled in either dimension.
         * @returns %TRUE if the actor is scaled.
         */
        is_scaled(): boolean;
        /**
         * Checks whether an actor is marked as visible.
         *
         * See also %CLUTTER_ACTOR_IS_VISIBLE and #ClutterActor:visible.
         * @returns %TRUE if the actor visible
         */
        is_visible(): boolean;
        /**
         * Puts `self` below `above`.
         *
         * Both actors must have the same parent, and the parent must implement
         * the #ClutterContainer interface.
         *
         * This function calls clutter_container_lower_child() internally.
         * @param above A #ClutterActor to lower below
         */
        lower(above?: Actor | null): void;
        /**
         * Lowers `self` to the bottom.
         *
         * This function calls clutter_actor_lower() internally.
         */
        lower_bottom(): void;
        /**
         * Sets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly maps
         * and realizes its children if they are visible. Does nothing if the
         * actor is not visible.
         *
         * Calling this function is strongly disencouraged: the default
         * implementation of #ClutterActorClass.map() will map all the children
         * of an actor when mapping its parent.
         *
         * When overriding map, it is mandatory to chain up to the parent
         * implementation.
         */
        map(): void;
        /**
         * Sets an anchor point for the actor, and adjusts the actor postion so that
         * the relative position of the actor toward its parent remains the same.
         * @param anchor_x X coordinate of the anchor point
         * @param anchor_y Y coordinate of the anchor point
         */
        move_anchor_point(anchor_x: number, anchor_y: number): void;
        /**
         * Sets an anchor point on the actor based on the given gravity, adjusting the
         * actor postion so that its relative position within its parent remains
         * unchanged.
         *
         * Since version 1.0 the anchor point will be stored as a gravity so
         * that if the actor changes size then the anchor point will move. For
         * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
         * and later double the size of the actor, the anchor point will move
         * to the bottom right.
         * @param gravity #ClutterGravity.
         */
        move_anchor_point_from_gravity(gravity: Gravity | null): void;
        /**
         * Moves an actor by the specified distance relative to its current
         * position in pixels.
         *
         * This function modifies the fixed position of an actor and thus removes
         * it from any layout management. Another way to move an actor is with an
         * anchor point, see clutter_actor_set_anchor_point(), or with an additional
         * translation, using clutter_actor_set_translation().
         * @param dx Distance to move Actor on X axis.
         * @param dy Distance to move Actor on Y axis.
         */
        move_by(dx: number, dy: number): void;
        /**
         * Checks whether an actor, or any of its children, is set to expand
         * horizontally or vertically.
         *
         * This function should only be called by layout managers that can
         * assign extra space to their children.
         *
         * If you want to know whether the actor was explicitly set to expand,
         * use clutter_actor_get_x_expand() or clutter_actor_get_y_expand().
         * @param orientation the direction of expansion
         * @returns %TRUE if the actor should expand
         */
        needs_expand(orientation: Orientation | null): boolean;
        /**
         * Renders the actor to display.
         *
         * This function should not be called directly by applications.
         * Call clutter_actor_queue_redraw() to queue paints, instead.
         *
         * This function is context-aware, and will either cause a
         * regular paint or a pick paint.
         *
         * This function will emit the #ClutterActor::paint signal or
         * the #ClutterActor::pick signal, depending on the context.
         *
         * This function does not paint the actor if the actor is set to 0,
         * unless it is performing a pick paint.
         */
        paint(): void;
        /**
         * Disables the effects of clutter_actor_push_internal().
         */
        pop_internal(): void;
        /**
         * Should be used by actors implementing the #ClutterContainer and with
         * internal children added through clutter_actor_set_parent(), for instance:
         *
         *
         * ```c
         *   static void
         *   my_actor_init (MyActor *self)
         *   {
         *     self->priv = my_actor_get_instance_private (self);
         *
         *     clutter_actor_push_internal (CLUTTER_ACTOR (self));
         *
         *     // calling clutter_actor_set_parent() now will result in
         *     // the internal flag being set on a child of MyActor
         *
         *     // internal child - a background texture
         *     self->priv->background_tex = clutter_texture_new ();
         *     clutter_actor_set_parent (self->priv->background_tex,
         *                               CLUTTER_ACTOR (self));
         *
         *     // internal child - a label
         *     self->priv->label = clutter_text_new ();
         *     clutter_actor_set_parent (self->priv->label,
         *                               CLUTTER_ACTOR (self));
         *
         *     clutter_actor_pop_internal (CLUTTER_ACTOR (self));
         *
         *     // calling clutter_actor_set_parent() now will not result in
         *     // the internal flag being set on a child of MyActor
         *   }
         * ```
         *
         *
         * This function will be used by Clutter to toggle an "internal child"
         * flag whenever clutter_actor_set_parent() is called; internal children
         * are handled differently by Clutter, specifically when destroying their
         * parent.
         *
         * Call clutter_actor_pop_internal() when you finished adding internal
         * children.
         *
         * Nested calls to clutter_actor_push_internal() are allowed, but each
         * one must by followed by a clutter_actor_pop_internal() call.
         */
        push_internal(): void;
        /**
         * Queues up a redraw of an actor and any children. The redraw occurs
         * once the main loop becomes idle (after the current batch of events
         * has been processed, roughly).
         *
         * Applications rarely need to call this, as redraws are handled
         * automatically by modification functions.
         *
         * This function will not do anything if `self` is not visible, or
         * if the actor is inside an invisible part of the scenegraph.
         *
         * Also be aware that painting is a NOP for actors with an opacity of
         * 0
         *
         * When you are implementing a custom actor you must queue a redraw
         * whenever some private state changes that will affect painting or
         * picking of your actor.
         */
        queue_redraw(): void;
        /**
         * Queues a redraw on `self` limited to a specific, actor-relative
         * rectangular area.
         *
         * If `clip` is %NULL this function is equivalent to
         * clutter_actor_queue_redraw().
         * @param clip a rectangular clip region, or %NULL
         */
        queue_redraw_with_clip(clip?: cairo.RectangleInt | null): void;
        /**
         * Indicates that the actor's size request or other layout-affecting
         * properties may have changed. This function is used inside #ClutterActor
         * subclass implementations, not by applications directly.
         *
         * Queueing a new layout automatically queues a redraw as well.
         */
        queue_relayout(): void;
        /**
         * Puts `self` above `below`.
         *
         * Both actors must have the same parent, and the parent must implement
         * the #ClutterContainer interface
         *
         * This function calls clutter_container_raise_child() internally.
         * @param below A #ClutterActor to raise above.
         */
        raise(below?: Actor | null): void;
        /**
         * Raises `self` to the top.
         *
         * This function calls clutter_actor_raise() internally.
         */
        raise_top(): void;
        /**
         * Realization informs the actor that it is attached to a stage. It
         * can use this to allocate resources if it wanted to delay allocation
         * until it would be rendered. However it is perfectly acceptable for
         * an actor to create resources before being realized because Clutter
         * only ever has a single rendering context so that actor is free to
         * be moved from one stage to another.
         *
         * This function does nothing if the actor is already realized.
         *
         * Because a realized actor must have realized parent actors, calling
         * clutter_actor_realize() will also realize all parents of the actor.
         *
         * This function does not realize child actors, except in the special
         * case that realizing the stage, when the stage is visible, will
         * suddenly map (and thus realize) the children of the stage.
         */
        realize(): void;
        /**
         * Removes `action` from the list of actions applied to `self`
         *
         * The reference held by `self` on the #ClutterAction will be released
         * @param action a #ClutterAction
         */
        remove_action(action: Action): void;
        /**
         * Removes the #ClutterAction with the given name from the list
         * of actions applied to `self`
         * @param name the name of the action to remove
         */
        remove_action_by_name(name: string): void;
        /**
         * Removes all children of `self`.
         *
         * This function releases the reference added by inserting a child actor
         * in the list of children of `self`.
         *
         * If the reference count of a child drops to zero, the child will be
         * destroyed. If you want to ensure the destruction of all the children
         * of `self,` use clutter_actor_destroy_all_children().
         */
        remove_all_children(): void;
        /**
         * Removes all transitions associated to `self`.
         */
        remove_all_transitions(): void;
        /**
         * Removes `child` from the children of `self`.
         *
         * This function will release the reference added by
         * clutter_actor_add_child(), so if you want to keep using `child`
         * you will have to acquire a referenced on it before calling this
         * function.
         *
         * This function will emit the #ClutterContainer::actor-removed
         * signal on `self`.
         * @param child a #ClutterActor
         */
        remove_child(child: Actor): void;
        /**
         * Removes clip area from `self`.
         */
        remove_clip(): void;
        /**
         * Removes `constraint` from the list of constraints applied to `self`
         *
         * The reference held by `self` on the #ClutterConstraint will be released
         * @param constraint a #ClutterConstraint
         */
        remove_constraint(constraint: Constraint): void;
        /**
         * Removes the #ClutterConstraint with the given name from the list
         * of constraints applied to `self`
         * @param name the name of the constraint to remove
         */
        remove_constraint_by_name(name: string): void;
        /**
         * Removes `effect` from the list of effects applied to `self`
         *
         * The reference held by `self` on the #ClutterEffect will be released
         * @param effect a #ClutterEffect
         */
        remove_effect(effect: Effect): void;
        /**
         * Removes the #ClutterEffect with the given name from the list
         * of effects applied to `self`
         * @param name the name of the effect to remove
         */
        remove_effect_by_name(name: string): void;
        /**
         * Removes the transition stored inside a #ClutterActor using `name`
         * identifier.
         *
         * If the transition is currently in progress, it will be stopped.
         *
         * This function releases the reference acquired when the transition
         * was added to the #ClutterActor.
         * @param name the name of the transition to remove
         */
        remove_transition(name: string): void;
        /**
         * Resets the parent actor of `self`.
         *
         * This function is logically equivalent to calling clutter_actor_unparent()
         * and clutter_actor_set_parent(), but more efficiently implemented, as it
         * ensures the child is not finalized when unparented, and emits the
         * #ClutterActor::parent-set signal only once.
         *
         * In reality, calling this function is less useful than it sounds, as some
         * application code may rely on changes in the intermediate state between
         * removal and addition of the actor from its old parent to the `new_parent`.
         * Thus, it is strongly encouraged to avoid using this function in application
         * code.
         * @param new_parent the new #ClutterActor parent
         */
        reparent(new_parent: Actor): void;
        /**
         * Replaces `old_child` with `new_child` in the list of children of `self`.
         * @param old_child the child of @self to replace
         * @param new_child the #ClutterActor to replace @old_child
         */
        replace_child(old_child: Actor, new_child: Actor): void;
        /**
         * Restores the easing state as it was prior to a call to
         * clutter_actor_save_easing_state().
         */
        restore_easing_state(): void;
        /**
         * Saves the current easing state for animatable properties, and creates
         * a new state with the default values for easing mode and duration.
         *
         * New transitions created after calling this function will inherit the
         * duration, easing mode, and delay of the new easing state; this also
         * applies to transitions modified in flight.
         */
        save_easing_state(): void;
        /**
         * Stores the allocation of `self` as defined by `box`.
         *
         * This function can only be called from within the implementation of
         * the #ClutterActorClass.allocate() virtual function.
         *
         * The allocation should have been adjusted to take into account constraints,
         * alignment, and margin properties. If you are implementing a #ClutterActor
         * subclass that provides its own layout management policy for its children
         * instead of using a #ClutterLayoutManager delegate, you should not call
         * this function on the children of `self;` instead, you should call
         * clutter_actor_allocate(), which will adjust the allocation box for
         * you.
         *
         * This function should only be used by subclasses of #ClutterActor
         * that wish to store their allocation but cannot chain up to the
         * parent's implementation; the default implementation of the
         * #ClutterActorClass.allocate() virtual function will call this
         * function.
         *
         * It is important to note that, while chaining up was the recommended
         * behaviour for #ClutterActor subclasses prior to the introduction of
         * this function, it is recommended to call clutter_actor_set_allocation()
         * instead.
         *
         * If the #ClutterActor is using a #ClutterLayoutManager delegate object
         * to handle the allocation of its children, this function will call
         * the clutter_layout_manager_allocate() function only if the
         * %CLUTTER_DELEGATE_LAYOUT flag is set on `flags,` otherwise it is
         * expected that the subclass will call clutter_layout_manager_allocate()
         * by itself. For instance, the following code:
         *
         *
         * ```c
         * static void
         * my_actor_allocate (ClutterActor *actor,
         *                    const ClutterActorBox *allocation,
         *                    ClutterAllocationFlags flags)
         * {
         *   ClutterActorBox new_alloc;
         *   ClutterAllocationFlags new_flags;
         *
         *   adjust_allocation (allocation, &new_alloc);
         *
         *   new_flags = flags | CLUTTER_DELEGATE_LAYOUT;
         *
         *   // this will use the layout manager set on the actor
         *   clutter_actor_set_allocation (actor, &new_alloc, new_flags);
         * }
         * ```
         *
         *
         * is equivalent to this:
         *
         *
         * ```c
         * static void
         * my_actor_allocate (ClutterActor *actor,
         *                    const ClutterActorBox *allocation,
         *                    ClutterAllocationFlags flags)
         * {
         *   ClutterLayoutManager *layout;
         *   ClutterActorBox new_alloc;
         *
         *   adjust_allocation (allocation, &new_alloc);
         *
         *   clutter_actor_set_allocation (actor, &new_alloc, flags);
         *
         *   layout = clutter_actor_get_layout_manager (actor);
         *   clutter_layout_manager_allocate (layout,
         *                                    CLUTTER_CONTAINER (actor),
         *                                    &new_alloc,
         *                                    flags);
         * }
         * ```
         *
         * @param box a #ClutterActorBox
         * @param flags allocation flags
         */
        set_allocation(box: ActorBox, flags: AllocationFlags | null): void;
        /**
         * Sets an anchor point for `self`. The anchor point is a point in the
         * coordinate space of an actor to which the actor position within its
         * parent is relative; the default is (0, 0), i.e. the top-left corner
         * of the actor.
         * @param anchor_x X coordinate of the anchor point
         * @param anchor_y Y coordinate of the anchor point
         */
        set_anchor_point(anchor_x: number, anchor_y: number): void;
        /**
         * Sets an anchor point on the actor, based on the given gravity (this is a
         * convenience function wrapping clutter_actor_set_anchor_point()).
         *
         * Since version 1.0 the anchor point will be stored as a gravity so
         * that if the actor changes size then the anchor point will move. For
         * example, if you set the anchor point to %CLUTTER_GRAVITY_SOUTH_EAST
         * and later double the size of the actor, the anchor point will move
         * to the bottom right.
         * @param gravity #ClutterGravity.
         */
        set_anchor_point_from_gravity(gravity: Gravity | null): void;
        /**
         * Sets the background color of a #ClutterActor.
         *
         * The background color will be used to cover the whole allocation of the
         * actor. The default background color of an actor is transparent.
         *
         * To check whether an actor has a background color, you can use the
         * #ClutterActor:background-color-set actor property.
         *
         * The #ClutterActor:background-color property is animatable.
         * @param color a #ClutterColor, or %NULL to unset a previously  set color
         */
        set_background_color(color?: Color | null): void;
        /**
         * Sets `child` to be above `sibling` in the list of children of `self`.
         *
         * If `sibling` is %NULL, `child` will be the new last child of `self`.
         *
         * This function is logically equivalent to removing `child` and using
         * clutter_actor_insert_child_above(), but it will not emit signals
         * or change state on `child`.
         * @param child a #ClutterActor child of @self
         * @param sibling a #ClutterActor child of @self, or %NULL
         */
        set_child_above_sibling(child: Actor, sibling?: Actor | null): void;
        /**
         * Changes the index of `child` in the list of children of `self`.
         *
         * This function is logically equivalent to removing `child` and
         * calling clutter_actor_insert_child_at_index(), but it will not
         * emit signals or change state on `child`.
         * @param child a #ClutterActor child of @self
         * @param index_ the new index for @child
         */
        set_child_at_index(child: Actor, index_: number): void;
        /**
         * Sets `child` to be below `sibling` in the list of children of `self`.
         *
         * If `sibling` is %NULL, `child` will be the new first child of `self`.
         *
         * This function is logically equivalent to removing `self` and using
         * clutter_actor_insert_child_below(), but it will not emit signals
         * or change state on `child`.
         * @param child a #ClutterActor child of @self
         * @param sibling a #ClutterActor child of @self, or %NULL
         */
        set_child_below_sibling(child: Actor, sibling?: Actor | null): void;
        /**
         * Sets the transformation matrix to be applied to all the children
         * of `self` prior to their own transformations. The default child
         * transformation is the identity matrix.
         *
         * If `transform` is %NULL, the child transform will be unset.
         *
         * The #ClutterActor:child-transform property is animatable.
         * @param transform a #ClutterMatrix, or %NULL
         */
        set_child_transform(transform?: Matrix | null): void;
        /**
         * Sets clip area for `self`. The clip area is always computed from the
         * upper left corner of the actor, even if the anchor point is set
         * otherwise.
         * @param xoff X offset of the clip rectangle
         * @param yoff Y offset of the clip rectangle
         * @param width Width of the clip rectangle
         * @param height Height of the clip rectangle
         */
        set_clip(xoff: number, yoff: number, width: number, height: number): void;
        /**
         * Sets whether `self` should be clipped to the same size as its
         * allocation
         * @param clip_set %TRUE to apply a clip tracking the allocation
         */
        set_clip_to_allocation(clip_set: boolean): void;
        /**
         * Sets the contents of a #ClutterActor.
         * @param content a #ClutterContent, or %NULL
         */
        set_content(content?: Content | null): void;
        /**
         * Sets the gravity of the #ClutterContent used by `self`.
         *
         * See the description of the #ClutterActor:content-gravity property for
         * more information.
         *
         * The #ClutterActor:content-gravity property is animatable.
         * @param gravity the #ClutterContentGravity
         */
        set_content_gravity(gravity: ContentGravity | null): void;
        /**
         * Sets the policy for repeating the #ClutterActor:content of a
         * #ClutterActor. The behaviour is deferred to the #ClutterContent
         * implementation.
         * @param repeat the repeat policy
         */
        set_content_repeat(repeat: ContentRepeat | null): void;
        /**
         * Sets the minification and magnification filter to be applied when
         * scaling the #ClutterActor:content of a #ClutterActor.
         *
         * The #ClutterActor:minification-filter will be used when reducing
         * the size of the content; the #ClutterActor:magnification-filter
         * will be used when increasing the size of the content.
         * @param min_filter the minification filter for the content
         * @param mag_filter the magnification filter for the content
         */
        set_content_scaling_filters(min_filter: ScalingFilter | null, mag_filter: ScalingFilter | null): void;
        /**
         * Sets the Z coordinate of `self` to `depth`.
         *
         * The unit used by `depth` is dependant on the perspective setup. See
         * also clutter_stage_set_perspective().
         * @param depth Z co-ord
         */
        set_depth(depth: number): void;
        /**
         * Sets the delay that should be applied before tweening animatable
         * properties.
         * @param msecs the delay before the start of the tweening, in milliseconds
         */
        set_easing_delay(msecs: number): void;
        /**
         * Sets the duration of the tweening for animatable properties
         * of `self` for the current easing state.
         * @param msecs the duration of the easing, or %NULL
         */
        set_easing_duration(msecs: number): void;
        /**
         * Sets the easing mode for the tweening of animatable properties
         * of `self`.
         * @param mode an easing mode, excluding %CLUTTER_CUSTOM_MODE
         */
        set_easing_mode(mode: AnimationMode | null): void;
        /**
         * Sets whether an actor has a fixed position set (and will thus be
         * unaffected by any layout manager).
         * @param is_set whether to use fixed position
         */
        set_fixed_position_set(is_set: boolean): void;
        /**
         * Sets `flags` on `self`
         *
         * This function will emit notifications for the changed properties
         * @param flags the flags to set
         */
        set_flags(flags: ActorFlags | null): void;
        /**
         * Sets the actor's fixed position and forces its minimum and natural
         * size, in pixels. This means the untransformed actor will have the
         * given geometry. This is the same as calling clutter_actor_set_position()
         * and clutter_actor_set_size().
         * @param geometry A #ClutterGeometry
         */
        set_geometry(geometry: Geometry): void;
        /**
         * Forces a height on an actor, causing the actor's preferred width
         * and height (if any) to be ignored.
         *
         * If `height` is -1 the actor will use its preferred height instead of
         * overriding it, i.e. you can "unset" the height with -1.
         *
         * This function sets both the minimum and natural size of the actor.
         * @param height Requested new height for the actor, in pixels, or -1
         */
        set_height(height: number): void;
        /**
         * Sets the #ClutterLayoutManager delegate object that will be used to
         * lay out the children of `self`.
         *
         * The #ClutterActor will take a reference on the passed `manager` which
         * will be released either when the layout manager is removed, or when
         * the actor is destroyed.
         * @param manager a #ClutterLayoutManager, or %NULL to unset it
         */
        set_layout_manager(manager?: LayoutManager | null): void;
        /**
         * Sets all the components of the margin of a #ClutterActor.
         * @param margin a #ClutterMargin
         */
        set_margin(margin: Margin): void;
        /**
         * Sets the margin from the bottom of a #ClutterActor.
         *
         * The #ClutterActor:margin-bottom property is animatable.
         * @param margin the bottom margin
         */
        set_margin_bottom(margin: number): void;
        /**
         * Sets the margin from the left of a #ClutterActor.
         *
         * The #ClutterActor:margin-left property is animatable.
         * @param margin the left margin
         */
        set_margin_left(margin: number): void;
        /**
         * Sets the margin from the right of a #ClutterActor.
         *
         * The #ClutterActor:margin-right property is animatable.
         * @param margin the right margin
         */
        set_margin_right(margin: number): void;
        /**
         * Sets the margin from the top of a #ClutterActor.
         *
         * The #ClutterActor:margin-top property is animatable.
         * @param margin the top margin
         */
        set_margin_top(margin: number): void;
        /**
         * Sets the given name to `self`. The name can be used to identify
         * a #ClutterActor.
         * @param name Textual tag to apply to actor
         */
        set_name(name: string): void;
        /**
         * Defines the circumstances where the actor should be redirected into
         * an offscreen image. The offscreen image is used to flatten the
         * actor into a single image while painting for two main reasons.
         * Firstly, when the actor is painted a second time without any of its
         * contents changing it can simply repaint the cached image without
         * descending further down the actor hierarchy. Secondly, it will make
         * the opacity look correct even if there are overlapping primitives
         * in the actor.
         *
         * Caching the actor could in some cases be a performance win and in
         * some cases be a performance lose so it is important to determine
         * which value is right for an actor before modifying this value. For
         * example, there is never any reason to flatten an actor that is just
         * a single texture (such as a #ClutterTexture) because it is
         * effectively already cached in an image so the offscreen would be
         * redundant. Also if the actor contains primitives that are far apart
         * with a large transparent area in the middle (such as a large
         * CluterGroup with a small actor in the top left and a small actor in
         * the bottom right) then the cached image will contain the entire
         * image of the large area and the paint will waste time blending all
         * of the transparent pixels in the middle.
         *
         * The default method of implementing opacity on a container simply
         * forwards on the opacity to all of the children. If the children are
         * overlapping then it will appear as if they are two separate glassy
         * objects and there will be a break in the color where they
         * overlap. By redirecting to an offscreen buffer it will be as if the
         * two opaque objects are combined into one and then made transparent
         * which is usually what is expected.
         *
         * The image below demonstrates the difference between redirecting and
         * not. The image shows two Clutter groups, each containing a red and
         * a green rectangle which overlap. The opacity on the group is set to
         * 128 (which is 50%). When the offscreen redirect is not used, the
         * red rectangle can be seen through the blue rectangle as if the two
         * rectangles were separately transparent. When the redirect is used
         * the group as a whole is transparent instead so the red rectangle is
         * not visible where they overlap.
         *
         * <figure id="offscreen-redirect">
         *   <title>Sample of using an offscreen redirect for transparency</title>
         *   <graphic fileref="offscreen-redirect.png" format="PNG"/>
         * </figure>
         *
         * The default value for this property is 0, so we effectively will
         * never redirect an actor offscreen by default. This means that there
         * are times that transparent actors may look glassy as described
         * above. The reason this is the default is because there is a
         * performance trade off between quality and performance here. In many
         * cases the default form of glassy opacity looks good enough, but if
         * it's not you will need to set the
         * %CLUTTER_OFFSCREEN_REDIRECT_AUTOMATIC_FOR_OPACITY flag to enable
         * redirection for opacity.
         *
         * Custom actors that don't contain any overlapping primitives are
         * recommended to override the has_overlaps() virtual to return %FALSE
         * for maximum efficiency.
         * @param redirect New offscreen redirect flags for the actor.
         */
        set_offscreen_redirect(redirect: OffscreenRedirect | null): void;
        /**
         * Sets the actor's opacity, with zero being completely transparent and
         * 255 (0xff) being fully opaque.
         *
         * The #ClutterActor:opacity property is animatable.
         * @param opacity New opacity value for the actor.
         */
        set_opacity(opacity: number): void;
        /**
         * Sets the parent of `self` to `parent`.
         *
         * This function will result in `parent` acquiring a reference on `self,`
         * eventually by sinking its floating reference first. The reference
         * will be released by clutter_actor_unparent().
         *
         * This function should only be called by legacy #ClutterActor<!-- -->s
         * implementing the #ClutterContainer interface.
         * @param parent A new #ClutterActor parent
         */
        set_parent(parent: Actor): void;
        /**
         * Sets the position of the #ClutterActor:pivot-point around which the
         * scaling and rotation transformations occur.
         *
         * The pivot point's coordinates are in normalized space, with the (0, 0)
         * point being the top left corner of the actor, and the (1, 1) point being
         * the bottom right corner.
         * @param pivot_x the normalized X coordinate of the pivot point
         * @param pivot_y the normalized Y coordinate of the pivot point
         */
        set_pivot_point(pivot_x: number, pivot_y: number): void;
        /**
         * Sets the component on the Z axis of the #ClutterActor:pivot-point around
         * which the scaling and rotation transformations occur.
         *
         * The `pivot_z` value is expressed as a distance along the Z axis.
         * @param pivot_z the Z coordinate of the actor's pivot point
         */
        set_pivot_point_z(pivot_z: number): void;
        /**
         * Sets the actor's fixed position in pixels relative to any parent
         * actor.
         *
         * If a layout manager is in use, this position will override the
         * layout manager and force a fixed position.
         * @param x New left position of actor in pixels.
         * @param y New top position of actor in pixels.
         */
        set_position(x: number, y: number): void;
        /**
         * Sets `actor` as reactive. Reactive actors will receive events.
         * @param reactive whether the actor should be reactive to events
         */
        set_reactive(reactive: boolean): void;
        /**
         * Sets the geometry request mode of `self`.
         *
         * The `mode` determines the order for invoking
         * clutter_actor_get_preferred_width() and
         * clutter_actor_get_preferred_height()
         * @param mode the request mode
         */
        set_request_mode(mode: RequestMode | null): void;
        /**
         * Sets the rotation angle of `self` around the given axis.
         *
         * The rotation center coordinates used depend on the value of `axis:`
         *
         *  - %CLUTTER_X_AXIS requires `y` and `z`
         *  - %CLUTTER_Y_AXIS requires `x` and `z`
         *  - %CLUTTER_Z_AXIS requires `x` and `y`
         *
         * The rotation coordinates are relative to the anchor point of the
         * actor, set using clutter_actor_set_anchor_point(). If no anchor
         * point is set, the upper left corner is assumed as the origin.
         * @param axis the axis of rotation
         * @param angle the angle of rotation
         * @param x X coordinate of the rotation center
         * @param y Y coordinate of the rotation center
         * @param z Z coordinate of the rotation center
         */
        set_rotation(axis: RotateAxis | null, angle: number, x: number, y: number, z: number): void;
        /**
         * Sets the `angle` of rotation of a #ClutterActor on the given `axis`.
         *
         * This function is a convenience for setting the rotation properties
         * #ClutterActor:rotation-angle-x, #ClutterActor:rotation-angle-y,
         * and #ClutterActor:rotation-angle-z.
         *
         * The center of rotation is established by the #ClutterActor:pivot-point
         * property.
         * @param axis the axis to set the angle one
         * @param angle the angle of rotation, in degrees
         */
        set_rotation_angle(axis: RotateAxis | null, angle: number): void;
        /**
         * Scales an actor with the given factors.
         *
         * The scale transformation is relative the the #ClutterActor:pivot-point.
         *
         * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
         * animatable.
         * @param scale_x double factor to scale actor by horizontally.
         * @param scale_y double factor to scale actor by vertically.
         */
        set_scale(scale_x: number, scale_y: number): void;
        /**
         * Scales an actor with the given factors around the given center
         * point. The center point is specified in pixels relative to the
         * anchor point (usually the top left corner of the actor).
         *
         * The #ClutterActor:scale-x and #ClutterActor:scale-y properties
         * are animatable.
         * @param scale_x double factor to scale actor by horizontally.
         * @param scale_y double factor to scale actor by vertically.
         * @param center_x X coordinate of the center of the scaling
         * @param center_y Y coordinate of the center of the scaling
         */
        set_scale_full(scale_x: number, scale_y: number, center_x: number, center_y: number): void;
        /**
         * Scales an actor with the given factors around the given
         * center point. The center point is specified as one of the compass
         * directions in #ClutterGravity. For example, setting it to north
         * will cause the top of the actor to remain unchanged and the rest of
         * the actor to expand left, right and downwards.
         *
         * The #ClutterActor:scale-x and #ClutterActor:scale-y properties are
         * animatable.
         * @param scale_x double factor to scale actor by horizontally.
         * @param scale_y double factor to scale actor by vertically.
         * @param gravity the location of the scale center expressed as a compass   direction.
         */
        set_scale_with_gravity(scale_x: number, scale_y: number, gravity: Gravity | null): void;
        /**
         * Scales an actor on the Z axis by the given `scale_z` factor.
         *
         * The scale transformation is relative the the #ClutterActor:pivot-point.
         *
         * The #ClutterActor:scale-z property is animatable.
         * @param scale_z the scaling factor along the Z axis
         */
        set_scale_z(scale_z: number): void;
        /**
         * Sets the #ClutterShader to be used when rendering `self`.
         *
         * If `shader` is %NULL this function will unset any currently set shader
         * for the actor.
         *
         * Any #ClutterEffect applied to `self` will take the precedence
         * over the #ClutterShader set using this function.
         * @param shader a #ClutterShader or %NULL to unset the shader.
         * @returns %TRUE if the shader was successfully applied   or removed
         */
        set_shader(shader?: Shader | null): boolean;
        /**
         * Sets the value for a named parameter of the shader applied
         * to `actor`.
         * @param param the name of the parameter
         * @param value the value of the parameter
         */
        set_shader_param(param: string, value: GObject.Value | any): void;
        /**
         * Sets the value for a named float parameter of the shader applied
         * to `actor`.
         * @param param the name of the parameter
         * @param value the value of the parameter
         */
        set_shader_param_float(param: string, value: number): void;
        /**
         * Sets the value for a named int parameter of the shader applied to
         * `actor`.
         * @param param the name of the parameter
         * @param value the value of the parameter
         */
        set_shader_param_int(param: string, value: number): void;
        /**
         * Sets the actor's size request in pixels. This overrides any
         * "normal" size request the actor would have. For example
         * a text actor might normally request the size of the text;
         * this function would force a specific size instead.
         *
         * If `width` and/or `height` are -1 the actor will use its
         * "normal" size request instead of overriding it, i.e.
         * you can "unset" the size with -1.
         *
         * This function sets or unsets both the minimum and natural size.
         * @param width New width of actor in pixels, or -1
         * @param height New height of actor in pixels, or -1
         */
        set_size(width: number, height: number): void;
        /**
         * Sets the #ClutterTextDirection for an actor
         *
         * The passed text direction must not be %CLUTTER_TEXT_DIRECTION_DEFAULT
         *
         * If `self` implements #ClutterContainer then this function will recurse
         * inside all the children of `self` (including the internal ones).
         *
         * Composite actors not implementing #ClutterContainer, or actors requiring
         * special handling when the text direction changes, should connect to
         * the #GObject::notify signal for the #ClutterActor:text-direction property
         * @param text_dir the text direction for @self
         */
        set_text_direction(text_dir: TextDirection | null): void;
        /**
         * Overrides the transformations of a #ClutterActor with a custom
         * matrix, which will be applied relative to the origin of the
         * actor's allocation and to the actor's pivot point.
         *
         * The #ClutterActor:transform property is animatable.
         * @param transform a #ClutterMatrix, or %NULL to   unset a custom transformation
         */
        set_transform(transform?: Matrix | null): void;
        /**
         * Sets an additional translation transformation on a #ClutterActor,
         * relative to the #ClutterActor:pivot-point.
         * @param translate_x the translation along the X axis
         * @param translate_y the translation along the Y axis
         * @param translate_z the translation along the Z axis
         */
        set_translation(translate_x: number, translate_y: number, translate_z: number): void;
        /**
         * Forces a width on an actor, causing the actor's preferred width
         * and height (if any) to be ignored.
         *
         * If `width` is -1 the actor will use its preferred width request
         * instead of overriding it, i.e. you can "unset" the width with -1.
         *
         * This function sets both the minimum and natural size of the actor.
         * @param width Requested new width for the actor, in pixels, or -1
         */
        set_width(width: number): void;
        /**
         * Sets the actor's X coordinate, relative to its parent, in pixels.
         *
         * Overrides any layout manager and forces a fixed position for
         * the actor.
         *
         * The #ClutterActor:x property is animatable.
         * @param x the actor's position on the X axis
         */
        set_x(x: number): void;
        /**
         * Sets the horizontal alignment policy of a #ClutterActor, in case the
         * actor received extra horizontal space.
         *
         * See also the #ClutterActor:x-align property.
         * @param x_align the horizontal alignment policy
         */
        set_x_align(x_align: ActorAlign | null): void;
        /**
         * Sets whether a #ClutterActor should expand horizontally; this means
         * that layout manager should allocate extra space for the actor, if
         * possible.
         *
         * Setting an actor to expand will also make all its parent expand, so
         * that it's possible to build an actor tree and only set this flag on
         * its leaves and not on every single actor.
         * @param expand whether the actor should expand horizontally
         */
        set_x_expand(expand: boolean): void;
        /**
         * Sets the actor's Y coordinate, relative to its parent, in pixels.#
         *
         * Overrides any layout manager and forces a fixed position for
         * the actor.
         *
         * The #ClutterActor:y property is animatable.
         * @param y the actor's position on the Y axis
         */
        set_y(y: number): void;
        /**
         * Sets the vertical alignment policy of a #ClutterActor, in case the
         * actor received extra vertical space.
         *
         * See also the #ClutterActor:y-align property.
         * @param y_align the vertical alignment policy
         */
        set_y_align(y_align: ActorAlign | null): void;
        /**
         * Sets whether a #ClutterActor should expand horizontally; this means
         * that layout manager should allocate extra space for the actor, if
         * possible.
         *
         * Setting an actor to expand will also make all its parent expand, so
         * that it's possible to build an actor tree and only set this flag on
         * its leaves and not on every single actor.
         * @param expand whether the actor should expand vertically
         */
        set_y_expand(expand: boolean): void;
        /**
         * Sets the actor's position on the Z axis.
         *
         * See #ClutterActor:z-position.
         * @param z_position the position on the Z axis
         */
        set_z_position(z_position: number): void;
        /**
         * Sets the rotation angle of `self` around the Z axis using the center
         * point specified as a compass point. For example to rotate such that
         * the center of the actor remains static you can use
         * %CLUTTER_GRAVITY_CENTER. If the actor changes size the center point
         * will move accordingly.
         * @param angle the angle of rotation
         * @param gravity the center point of the rotation
         */
        set_z_rotation_from_gravity(angle: number, gravity: Gravity | null): void;
        /**
         * Should be called inside the implementation of the
         * #ClutterActor::pick virtual function in order to check whether
         * the actor should paint itself in pick mode or not.
         *
         * This function should never be called directly by applications.
         * @returns %TRUE if the actor should paint its silhouette,   %FALSE otherwise
         */
        should_pick_paint(): boolean;
        /**
         * Flags an actor to be displayed. An actor that isn't shown will not
         * be rendered on the stage.
         *
         * Actors are visible by default.
         *
         * If this function is called on an actor without a parent, the
         * #ClutterActor:show-on-set-parent will be set to %TRUE as a side
         * effect.
         */
        show(): void;
        /**
         * Calls clutter_actor_show() on all children of an actor (if any).
         */
        show_all(): void;
        /**
         * This function translates screen coordinates (`x,` `y)` to
         * coordinates relative to the actor. For example, it can be used to translate
         * screen events from global screen coordinates into actor-local coordinates.
         *
         * The conversion can fail, notably if the transform stack results in the
         * actor being projected on the screen as a mere line.
         *
         * The conversion should not be expected to be pixel-perfect due to the
         * nature of the operation. In general the error grows when the skewing
         * of the actor rectangle on screen increases.
         *
         * This function can be computationally intensive.
         *
         * This function only works when the allocation is up-to-date, i.e. inside of
         * the #ClutterActorClass.paint() implementation
         * @param x x screen coordinate of the point to unproject
         * @param y y screen coordinate of the point to unproject
         * @returns %TRUE if conversion was successful.
         */
        transform_stage_point(x: number, y: number): [boolean, number, number];
        /**
         * Unsets the %CLUTTER_ACTOR_MAPPED flag on the actor and possibly
         * unmaps its children if they were mapped.
         *
         * Calling this function is not encouraged: the default #ClutterActor
         * implementation of #ClutterActorClass.unmap() will also unmap any
         * eventual children by default when their parent is unmapped.
         *
         * When overriding #ClutterActorClass.unmap(), it is mandatory to
         * chain up to the parent implementation.
         *
         * It is important to note that the implementation of the
         * #ClutterActorClass.unmap() virtual function may be called after
         * the #ClutterActorClass.destroy() or the #GObjectClass.dispose()
         * implementation, but it is guaranteed to be called before the
         * #GObjectClass.finalize() implementation.
         */
        unmap(): void;
        /**
         * Removes the parent of `self`.
         *
         * This will cause the parent of `self` to release the reference
         * acquired when calling clutter_actor_set_parent(), so if you
         * want to keep `self` you will have to acquire a reference of
         * your own, through g_object_ref().
         *
         * This function should only be called by legacy #ClutterActor<!-- -->s
         * implementing the #ClutterContainer interface.
         */
        unparent(): void;
        /**
         * Unrealization informs the actor that it may be being destroyed or
         * moved to another stage. The actor may want to destroy any
         * underlying graphics resources at this point. However it is
         * perfectly acceptable for it to retain the resources until the actor
         * is destroyed because Clutter only ever uses a single rendering
         * context and all of the graphics resources are valid on any stage.
         *
         * Because mapped actors must be realized, actors may not be
         * unrealized if they are mapped. This function hides the actor to be
         * sure it isn't mapped, an application-visible side effect that you
         * may not be expecting.
         *
         * This function should not be called by application code.
         *
         * This function should not really be in the public API, because
         * there isn't a good reason to call it. ClutterActor will already
         * unrealize things for you when it's important to do so.
         *
         * If you were using clutter_actor_unrealize() in a dispose
         * implementation, then don't, just chain up to ClutterActor's
         * dispose.
         *
         * If you were using clutter_actor_unrealize() to implement
         * unrealizing children of your container, then don't, ClutterActor
         * will already take care of that.
         */
        unrealize(): void;
        /**
         * Unsets `flags` on `self`
         *
         * This function will emit notifications for the changed properties
         * @param flags the flags to unset
         */
        unset_flags(flags: ActorFlags | null): void;

        // Inherited methods
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         * @returns %TRUE if the value has been validated and can   be applied to the #ClutterAnimatable, and %FALSE otherwise
         */
        animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         * @returns The #GParamSpec for the given property   or %NULL
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         * @returns %TRUE if the interpolation was successful,   and %FALSE otherwise
         */
        interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         */
        vfunc_animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         */
        vfunc_find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        vfunc_get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         */
        vfunc_interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        vfunc_set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        add_actor(actor: Actor): void;
        /**
         * Gets a container specific property of a child of `container,` In general,
         * a copy is made of the property contents and the caller is responsible for
         * freeing the memory by calling g_value_unset().
         *
         * Note that clutter_container_child_set_property() is really intended for
         * language bindings, clutter_container_child_set() is much more convenient
         * for C programming.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_get_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Sets a container-specific property on a child of `container`.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_set_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        destroy_child_meta(actor: Actor): void;
        /**
         * Finds a child actor of a container by its name. Search recurses
         * into any child container.
         * @param child_name the name of the requested child.
         * @returns The child actor with the requested name,   or %NULL if no actor with that name was found.
         */
        find_child_by_name(child_name: string): Actor;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         * @returns the #ClutterChildMeta for the @actor child   of @container or %NULL if the specifiec actor does not exist or the   container is not configured to provide #ClutterChildMeta<!-- -->s
         */
        get_child_meta(actor: Actor): ChildMeta;
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        lower_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        raise_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        remove_actor(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        sort_depth_order(): void;
        vfunc_actor_added(actor: Actor): void;
        vfunc_actor_removed(actor: Actor): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        vfunc_add(actor: Actor): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        vfunc_child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_destroy_child_meta(actor: Actor): void;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         */
        vfunc_get_child_meta(actor: Actor): ChildMeta;
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        vfunc_lower(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        vfunc_raise(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        vfunc_remove(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        vfunc_sort_depth_order(): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace ActorMeta {
        // Signal signatures
        interface SignalSignatures extends GObject.InitiallyUnowned.SignalSignatures {
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.InitiallyUnowned.ConstructorProps {
            actor: Actor;
            enabled: boolean;
            name: string;
        }
    }

    /**
     * The #ClutterActorMeta structure contains only
     * private data and should be accessed using the provided API
     */
    abstract class ActorMeta extends GObject.InitiallyUnowned {
        static $gtype: GObject.GType<ActorMeta>;

        // Properties

        /**
         * The #ClutterActor attached to the #ClutterActorMeta instance
         */
        get actor(): Actor;
        /**
         * Whether or not the #ClutterActorMeta is enabled
         */
        get enabled(): boolean;
        set enabled(val: boolean);
        /**
         * The unique name to access the #ClutterActorMeta
         */
        get name(): string;
        set name(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ActorMeta.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ActorMeta.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof ActorMeta.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ActorMeta.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ActorMeta.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ActorMeta.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ActorMeta.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ActorMeta.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        /**
         * Virtual function, called when `meta` is attached or detached
         * from a #ClutterActor.
         * @param actor the actor attached to @meta, or %NULL
         */
        vfunc_set_actor(actor?: Actor | null): void;

        // Methods

        /**
         * Retrieves a pointer to the #ClutterActor that owns `meta`
         * @returns a pointer to a #ClutterActor or %NULL
         */
        get_actor(): Actor;
        /**
         * Retrieves whether `meta` is enabled
         * @returns %TRUE if the #ClutterActorMeta instance is enabled
         */
        get_enabled(): boolean;
        /**
         * Retrieves the name set using clutter_actor_meta_set_name()
         * @returns the name of the #ClutterActorMeta   instance, or %NULL if none was set. The returned string is owned   by the #ClutterActorMeta instance and it should not be modified   or freed
         */
        get_name(): string;
        /**
         * Sets whether `meta` should be enabled or not
         * @param is_enabled whether @meta is enabled
         */
        set_enabled(is_enabled: boolean): void;
        /**
         * Sets the name of `meta`
         *
         * The name can be used to identify the #ClutterActorMeta instance
         * @param name the name of @meta
         */
        set_name(name: string): void;
    }

    namespace AlignConstraint {
        // Signal signatures
        interface SignalSignatures extends Constraint.SignalSignatures {
            'notify::align-axis': (pspec: GObject.ParamSpec) => void;
            'notify::factor': (pspec: GObject.ParamSpec) => void;
            'notify::source': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Constraint.ConstructorProps {
            align_axis: AlignAxis;
            alignAxis: AlignAxis;
            factor: number;
            source: Actor;
        }
    }

    /**
     * #ClutterAlignConstraint is an opaque structure
     * whose members cannot be directly accesses
     */
    class AlignConstraint extends Constraint {
        static $gtype: GObject.GType<AlignConstraint>;

        // Properties

        /**
         * The axis to be used to compute the alignment
         */
        get align_axis(): AlignAxis;
        set align_axis(val: AlignAxis);
        /**
         * The axis to be used to compute the alignment
         */
        get alignAxis(): AlignAxis;
        set alignAxis(val: AlignAxis);
        /**
         * The alignment factor, as a normalized value between 0.0 and 1.0
         *
         * The factor depends on the #ClutterAlignConstraint:align-axis property:
         * with an align-axis value of %CLUTTER_ALIGN_X_AXIS, 0.0 means left and
         * 1.0 means right; with a value of %CLUTTER_ALIGN_Y_AXIS, 0.0 means top
         * and 1.0 means bottom.
         */
        get factor(): number;
        set factor(val: number);
        /**
         * The #ClutterActor used as the source for the alignment.
         *
         * The #ClutterActor must not be a child or a grandchild of the actor
         * using the constraint.
         */
        get source(): Actor;
        set source(val: Actor);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: AlignConstraint.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<AlignConstraint.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](source: Actor | null, axis: AlignAxis, factor: number): AlignConstraint;

        // Signals

        connect<K extends keyof AlignConstraint.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, AlignConstraint.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof AlignConstraint.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, AlignConstraint.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof AlignConstraint.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<AlignConstraint.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the value set using clutter_align_constraint_set_align_axis()
         * @returns the alignment axis
         */
        get_align_axis(): AlignAxis;
        /**
         * Retrieves the factor set using clutter_align_constraint_set_factor()
         * @returns the alignment factor
         */
        get_factor(): number;
        /**
         * Retrieves the source of the alignment
         * @returns the #ClutterActor used as the source   of the alignment
         */
        get_source(): Actor;
        /**
         * Sets the axis to which the alignment refers to
         * @param axis the axis to which the alignment refers to
         */
        set_align_axis(axis: AlignAxis | null): void;
        /**
         * Sets the alignment factor of the constraint
         *
         * The factor depends on the #ClutterAlignConstraint:align-axis property
         * and it is a value between 0.0 (meaning left, when
         * #ClutterAlignConstraint:align-axis is set to %CLUTTER_ALIGN_X_AXIS; or
         * meaning top, when #ClutterAlignConstraint:align-axis is set to
         * %CLUTTER_ALIGN_Y_AXIS) and 1.0 (meaning right, when
         * #ClutterAlignConstraint:align-axis is set to %CLUTTER_ALIGN_X_AXIS; or
         * meaning bottom, when #ClutterAlignConstraint:align-axis is set to
         * %CLUTTER_ALIGN_Y_AXIS). A value of 0.5 aligns in the middle in either
         * cases
         * @param factor the alignment factor, between 0.0 and 1.0
         */
        set_factor(factor: number): void;
        /**
         * Sets the source of the alignment constraint
         * @param source a #ClutterActor, or %NULL to unset the source
         */
        set_source(source?: Actor | null): void;
    }

    namespace Alpha {
        // Signal signatures
        interface SignalSignatures extends GObject.InitiallyUnowned.SignalSignatures {
            'notify::alpha': (pspec: GObject.ParamSpec) => void;
            'notify::mode': (pspec: GObject.ParamSpec) => void;
            'notify::timeline': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.InitiallyUnowned.ConstructorProps, Scriptable.ConstructorProps {
            alpha: number;
            mode: number;
            timeline: Timeline;
        }
    }

    /**
     * #ClutterAlpha combines a #ClutterTimeline and a function.
     * The contents of the #ClutterAlpha structure are private and should
     * only be accessed using the provided API.
     */
    class Alpha extends GObject.InitiallyUnowned implements Scriptable {
        static $gtype: GObject.GType<Alpha>;

        // Properties

        /**
         * The alpha value as computed by the alpha function. The linear
         * interval is 0.0 to 1.0, but the Alpha allows overshooting by
         * one unit in each direction, so the valid interval is -1.0 to 2.0.
         */
        get alpha(): number;
        /**
         * The progress function logical id - either a value from the
         * #ClutterAnimationMode enumeration or a value returned by
         * clutter_alpha_register_func().
         *
         * If %CLUTTER_CUSTOM_MODE is used then the function set using
         * clutter_alpha_set_closure() or clutter_alpha_set_func()
         * will be used.
         */
        get mode(): number;
        set mode(val: number);
        /**
         * A #ClutterTimeline instance used to drive the alpha function.
         */
        get timeline(): Timeline;
        set timeline(val: Timeline);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Alpha.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Alpha.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Alpha;

        static new_full(timeline: Timeline, mode: number): Alpha;

        static new_with_func(timeline: Timeline, func: AlphaFunc): Alpha;

        // Signals

        connect<K extends keyof Alpha.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Alpha.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Alpha.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Alpha.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Alpha.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Alpha.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * #GClosure variant of clutter_alpha_register_func().
         *
         * Registers a global alpha function and returns its logical id
         * to be used by clutter_alpha_set_mode() or by #ClutterAnimation.
         *
         * The logical id is always greater than %CLUTTER_ANIMATION_LAST.
         * @param closure a #GClosure
         */
        static register_func(closure: GObject.Closure): number;

        // Methods

        /**
         * Query the current alpha value.
         * @returns The current alpha value for the alpha
         */
        get_alpha(): number;
        /**
         * Retrieves the #ClutterAnimationMode used by `alpha`.
         * @returns the animation mode
         */
        get_mode(): number;
        /**
         * Gets the #ClutterTimeline bound to `alpha`.
         * @returns a #ClutterTimeline instance
         */
        get_timeline(): Timeline;
        /**
         * Sets the #GClosure used to compute the alpha value at each
         * frame of the #ClutterTimeline bound to `alpha`.
         * @param closure A #GClosure
         */
        set_closure(closure: GObject.Closure): void;
        /**
         * Sets the #ClutterAlphaFunc function used to compute
         * the alpha value at each frame of the #ClutterTimeline
         * bound to `alpha`.
         *
         * This function will not register `func` as a global alpha function.
         * @param func A #ClutterAlphaFunc
         */
        set_func(func: AlphaFunc): void;
        /**
         * Sets the progress function of `alpha` using the symbolic value
         * of `mode,` as taken by the #ClutterAnimationMode enumeration or
         * using the value returned by clutter_alpha_register_func().
         * @param mode a #ClutterAnimationMode
         */
        set_mode(mode: number): void;
        /**
         * Binds `alpha` to `timeline`.
         * @param timeline A #ClutterTimeline
         */
        set_timeline(timeline: Timeline): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Animation {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            completed: () => void;
            started: () => void;
            'notify::alpha': (pspec: GObject.ParamSpec) => void;
            'notify::duration': (pspec: GObject.ParamSpec) => void;
            'notify::loop': (pspec: GObject.ParamSpec) => void;
            'notify::mode': (pspec: GObject.ParamSpec) => void;
            'notify::object': (pspec: GObject.ParamSpec) => void;
            'notify::timeline': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Scriptable.ConstructorProps {
            alpha: Alpha;
            duration: number;
            loop: boolean;
            mode: number;
            object: GObject.Object;
            timeline: Timeline;
        }
    }

    /**
     * The #ClutterAnimation structure contains only private data and should
     * be accessed using the provided functions.
     */
    class Animation extends GObject.Object implements Scriptable {
        static $gtype: GObject.GType<Animation>;

        // Properties

        /**
         * The #ClutterAlpha used by the animation.
         */
        get alpha(): Alpha;
        set alpha(val: Alpha);
        /**
         * The duration of the animation, expressed in milliseconds.
         */
        get duration(): number;
        set duration(val: number);
        /**
         * Whether the animation should loop.
         */
        get loop(): boolean;
        set loop(val: boolean);
        /**
         * The animation mode, either a value from #ClutterAnimationMode
         * or a value returned by clutter_alpha_register_func(). The
         * default value is %CLUTTER_LINEAR.
         */
        get mode(): number;
        set mode(val: number);
        /**
         * The #GObject to which the animation applies.
         */
        get object(): GObject.Object;
        set object(val: GObject.Object);
        /**
         * The #ClutterTimeline used by the animation.
         */
        get timeline(): Timeline;
        set timeline(val: Timeline);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Animation.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Animation.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Animation;

        // Signals

        connect<K extends keyof Animation.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Animation.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Animation.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Animation.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Animation.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Animation.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        /**
         * Emits the ::completed signal on `animation`
         *
         * When using this function with a #ClutterAnimation created
         * by the clutter_actor_animate() family of functions, `animation`
         * will be unreferenced and it will not be valid anymore,
         * unless g_object_ref() was called before calling this function
         * or unless a reference was taken inside a handler for the
         * #ClutterAnimation::completed signal
         */
        vfunc_completed(): void;
        vfunc_started(): void;

        // Methods

        /**
         * Adds a single property with name `property_name` to the
         * animation `animation`.  For more information about animations,
         * see clutter_actor_animate().
         *
         * This method returns the animation primarily to make chained
         * calls convenient in language bindings.
         * @param property_name the property to control
         * @param _final The final value of the property
         * @returns The animation itself.
         */
        bind(property_name: string, _final: GObject.Value | any): Animation;
        /**
         * Binds `interval` to the `property_name` of the #GObject
         * attached to `animation`. The #ClutterAnimation will take
         * ownership of the passed #ClutterInterval.  For more information
         * about animations, see clutter_actor_animate().
         *
         * If you need to update the interval instance use
         * clutter_animation_update_interval() instead.
         * @param property_name the property to control
         * @param interval a #ClutterInterval
         * @returns The animation itself.
         */
        bind_interval(property_name: string, interval: Interval): Animation;
        /**
         * Emits the ::completed signal on `animation`
         *
         * When using this function with a #ClutterAnimation created
         * by the clutter_actor_animate() family of functions, `animation`
         * will be unreferenced and it will not be valid anymore,
         * unless g_object_ref() was called before calling this function
         * or unless a reference was taken inside a handler for the
         * #ClutterAnimation::completed signal
         */
        completed(): void;
        /**
         * Retrieves the #ClutterAlpha used by `animation`.
         * @returns the alpha object used by the animation
         */
        get_alpha(): Alpha;
        /**
         * Retrieves the duration of `animation,` in milliseconds.
         * @returns the duration of the animation
         */
        get_duration(): number;
        /**
         * Retrieves the #ClutterInterval associated to `property_name`
         * inside `animation`.
         * @param property_name name of the property
         * @returns a #ClutterInterval or %NULL if no   property with the same name was found. The returned interval is   owned by the #ClutterAnimation and should not be unreferenced
         */
        get_interval(property_name: string): Interval;
        /**
         * Retrieves whether `animation` is looping.
         * @returns %TRUE if the animation is looping
         */
        get_loop(): boolean;
        /**
         * Retrieves the animation mode of `animation,` as set by
         * clutter_animation_set_mode().
         * @returns the mode for the animation
         */
        get_mode(): number;
        /**
         * Retrieves the #GObject attached to `animation`.
         * @returns a #GObject
         */
        get_object<T = GObject.Object>(): T;
        /**
         * Retrieves the #ClutterTimeline used by `animation`
         * @returns the timeline used by the animation
         */
        get_timeline(): Timeline;
        /**
         * Checks whether `animation` is controlling `property_name`.
         * @param property_name name of the property
         * @returns %TRUE if the property is animated by the   #ClutterAnimation, %FALSE otherwise
         */
        has_property(property_name: string): boolean;
        /**
         * Sets `alpha` as the #ClutterAlpha used by `animation`.
         *
         * If `alpha` is not %NULL, the #ClutterAnimation will take ownership
         * of the #ClutterAlpha instance.
         * @param alpha a #ClutterAlpha, or %NULL to unset the current #ClutterAlpha
         */
        set_alpha(alpha: Alpha): void;
        /**
         * Sets the duration of `animation` in milliseconds.
         *
         * This function will set #ClutterAnimation:alpha and
         * #ClutterAnimation:timeline if needed.
         * @param msecs the duration in milliseconds
         */
        set_duration(msecs: number): void;
        /**
         * Sets whether `animation` should loop over itself once finished.
         *
         * A looping #ClutterAnimation will not emit the #ClutterAnimation::completed
         * signal when finished.
         *
         * This function will set #ClutterAnimation:alpha and
         * #ClutterAnimation:timeline if needed.
         * @param loop %TRUE if the animation should loop
         */
        set_loop(loop: boolean): void;
        /**
         * Sets the animation `mode` of `animation`. The animation `mode` is
         * a logical id, either coming from the #ClutterAnimationMode enumeration
         * or the return value of clutter_alpha_register_func().
         *
         * This function will also set #ClutterAnimation:alpha if needed.
         * @param mode an animation mode logical id
         */
        set_mode(mode: number): void;
        /**
         * Attaches `animation` to `object`. The #ClutterAnimation will take a
         * reference on `object`.
         * @param object a #GObject
         */
        set_object(object: GObject.Object): void;
        /**
         * Sets the #ClutterTimeline used by `animation`.
         *
         * This function will take a reference on the passed `timeline`.
         * @param timeline a #ClutterTimeline, or %NULL to unset the   current #ClutterTimeline
         */
        set_timeline(timeline?: Timeline | null): void;
        /**
         * Removes `property_name` from the list of animated properties.
         * @param property_name name of the property
         */
        unbind_property(property_name: string): void;
        /**
         * Updates the `final` value of the interval for `property_name`
         * @param property_name name of the property
         * @param _final The final value of the property
         * @returns The animation itself.
         */
        update(property_name: string, _final: GObject.Value | any): Animation;
        /**
         * Changes the `interval` for `property_name`. The #ClutterAnimation
         * will take ownership of the passed #ClutterInterval.
         * @param property_name name of the property
         * @param interval a #ClutterInterval
         */
        update_interval(property_name: string, interval: Interval): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Animator {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::duration': (pspec: GObject.ParamSpec) => void;
            'notify::timeline': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Scriptable.ConstructorProps {
            duration: number;
            timeline: Timeline;
        }
    }

    /**
     * The #ClutterAnimator structure contains only private data and
     * should be accessed using the provided API
     */
    class Animator extends GObject.Object implements Scriptable {
        static $gtype: GObject.GType<Animator>;

        // Properties

        /**
         * The duration of the #ClutterTimeline used by the #ClutterAnimator
         * to drive the animation
         */
        get duration(): number;
        set duration(val: number);
        /**
         * The #ClutterTimeline used by the #ClutterAnimator to drive the
         * animation
         */
        get timeline(): Timeline;
        set timeline(val: Timeline);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Animator.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Animator.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Animator;

        // Signals

        connect<K extends keyof Animator.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Animator.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Animator.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Animator.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Animator.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Animator.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Compute the value for a managed property at a given progress.
         *
         * If the property is an ease-in property, the current value of the property
         * on the object will be used as the starting point for computation.
         * @param object a #GObject
         * @param property_name the name of the property on object to check
         * @param progress a value between 0.0 and 1.0
         * @param value an initialized value to store the computed result
         * @returns %TRUE if the computation yields has a value, otherwise (when   an error occurs or the progress is before any of the keys) %FALSE is   returned and the #GValue is left untouched
         */
        compute_value(
            object: GObject.Object,
            property_name: string,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Retrieves the current duration of an animator
         * @returns the duration of the animation, in milliseconds
         */
        get_duration(): number;
        /**
         * Returns a list of pointers to opaque structures with accessor functions
         * that describe the keys added to an animator.
         * @param object a #GObject to search for, or %NULL for all objects
         * @param property_name a specific property name to query for,   or %NULL for all properties
         * @param progress a specific progress to search for, or a negative value for all   progresses
         * @returns a   list of #ClutterAnimatorKey<!-- -->s; the contents of the list are owned   by the #ClutterAnimator, but you should free the returned list when done,   using g_list_free()
         */
        get_keys(object: GObject.Object | null, property_name: string | null, progress: number): AnimatorKey[];
        /**
         * Get the timeline hooked up for driving the #ClutterAnimator
         * @returns the #ClutterTimeline that drives the animator
         */
        get_timeline(): Timeline;
        /**
         * Checks if a property value is to be eased into the animation.
         * @param object a #GObject
         * @param property_name the name of a property on object
         * @returns %TRUE if the property is eased in
         */
        property_get_ease_in(object: GObject.Object, property_name: string): boolean;
        /**
         * Get the interpolation used by animator for a property on a particular
         * object.
         * @param object a #GObject
         * @param property_name the name of a property on object
         * @returns a ClutterInterpolation value.
         */
        property_get_interpolation(object: GObject.Object, property_name: string): Interpolation;
        /**
         * Sets whether a property value is to be eased into the animation.
         * @param object a #GObject
         * @param property_name the name of a property on object
         * @param ease_in we are going to be easing in this property
         */
        property_set_ease_in(object: GObject.Object, property_name: string, ease_in: boolean): void;
        /**
         * Set the interpolation method to use, %CLUTTER_INTERPOLATION_LINEAR causes
         * the values to linearly change between the values, and
         * %CLUTTER_INTERPOLATION_CUBIC causes the values to smoothly change between
         * the values.
         * @param object a #GObject
         * @param property_name the name of a property on object
         * @param interpolation the #ClutterInterpolation to use
         */
        property_set_interpolation(
            object: GObject.Object,
            property_name: string,
            interpolation: Interpolation | null,
        ): void;
        /**
         * Removes all keys matching the conditions specificed in the arguments.
         * @param object a #GObject to search for, or %NULL for all
         * @param property_name a specific property name to query for,   or %NULL for all
         * @param progress a specific progress to search for or a negative value   for all
         */
        remove_key(object: GObject.Object | null, property_name: string | null, progress: number): void;
        /**
         * Runs the timeline of the #ClutterAnimator with a duration in msecs
         * as specified.
         * @param duration milliseconds a run of the animator should last.
         */
        set_duration(duration: number): void;
        /**
         * Sets a single key in the #ClutterAnimator for the `property_name` of
         * `object` at `progress`.
         *
         * See also: clutter_animator_set()
         * @param object a #GObject
         * @param property_name the property to specify a key for
         * @param mode the id of the alpha function to use
         * @param progress the normalized range at which stage of the animation this   value applies
         * @param value the value property_name should have at progress.
         * @returns The animator instance
         */
        set_key(
            object: GObject.Object,
            property_name: string,
            mode: number,
            progress: number,
            value: GObject.Value | any,
        ): Animator;
        /**
         * Sets an external timeline that will be used for driving the animation
         * @param timeline a #ClutterTimeline
         */
        set_timeline(timeline: Timeline): void;
        /**
         * Start the ClutterAnimator, this is a thin wrapper that rewinds
         * and starts the animators current timeline.
         * @returns the #ClutterTimeline that drives   the animator. The returned timeline is owned by the #ClutterAnimator   and it should not be unreferenced
         */
        start(): Timeline;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Backend {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'font-changed': () => void;
            'resolution-changed': () => void;
            'settings-changed': () => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    /**
     * #ClutterBackend is an opaque structure whose
     * members cannot be directly accessed.
     */
    abstract class Backend extends GObject.Object {
        static $gtype: GObject.GType<Backend>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Backend.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Backend.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof Backend.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Backend.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Backend.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Backend.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Backend.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Backend.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the distance used to verify a double click event
         * @returns a distance, in pixels.
         */
        get_double_click_distance(): number;
        /**
         * Gets the maximum time between two button press events, as set
         * by clutter_backend_set_double_click_time().
         * @returns a time in milliseconds
         */
        get_double_click_time(): number;
        /**
         * Retrieves the default font name as set by
         * clutter_backend_set_font_name().
         * @returns the font name for the backend. The returned string is   owned by the #ClutterBackend and should never be modified or freed
         */
        get_font_name(): string;
        /**
         * Retrieves the font options for `backend`.
         * @returns the font options of the #ClutterBackend.   The returned #cairo_font_options_t is owned by the backend and should   not be modified or freed
         */
        get_font_options(): cairo.FontOptions;
        /**
         * Gets the resolution for font handling on the screen.
         *
         * The resolution is a scale factor between points specified in a
         * #PangoFontDescription and cairo units. The default value is 96.0,
         * meaning that a 10 point font will be 13 units
         * high (10 * 96. / 72. = 13.3).
         *
         * Clutter will set the resolution using the current backend when
         * initializing; the resolution is also stored in the
         * #ClutterSettings:font-dpi property.
         * @returns the current resolution, or -1 if no resolution   has been set.
         */
        get_resolution(): number;
        /**
         * Sets the maximum distance used to verify a double click event.
         * @param distance a distance, in pixels
         */
        set_double_click_distance(distance: number): void;
        /**
         * Sets the maximum time between two button press events, used to
         * verify whether it's a double click event or not.
         * @param msec milliseconds between two button press events
         */
        set_double_click_time(msec: number): void;
        /**
         * Sets the default font to be used by Clutter. The `font_name` string
         * must either be %NULL, which means that the font name from the
         * default #ClutterBackend will be used; or be something that can
         * be parsed by the pango_font_description_from_string() function.
         * @param font_name the name of the font
         */
        set_font_name(font_name: string): void;
        /**
         * Sets the new font options for `backend`. The #ClutterBackend will
         * copy the #cairo_font_options_t.
         *
         * If `options` is %NULL, the first following call to
         * clutter_backend_get_font_options() will return the default font
         * options for `backend`.
         *
         * This function is intended for actors creating a Pango layout
         * using the PangoCairo API.
         * @param options Cairo font options for the backend, or %NULL
         */
        set_font_options(options: cairo.FontOptions): void;
        /**
         * Sets the resolution for font handling on the screen. This is a
         * scale factor between points specified in a #PangoFontDescription
         * and cairo units. The default value is 96, meaning that a 10 point
         * font will be 13 units high. (10 * 96. / 72. = 13.3).
         *
         * Applications should never need to call this function.
         * @param dpi the resolution in "dots per inch" (Physical inches aren't   actually involved; the terminology is conventional).
         */
        set_resolution(dpi: number): void;
    }

    namespace Behaviour {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            applied: (arg0: Actor) => void;
            removed: (arg0: Actor) => void;
            'notify::alpha': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Scriptable.ConstructorProps {
            alpha: Alpha;
        }
    }

    /**
     * #ClutterBehaviour-struct contains only private data and should
     * be accessed with the functions below.
     */
    abstract class Behaviour extends GObject.Object implements Scriptable {
        static $gtype: GObject.GType<Behaviour>;

        // Properties

        /**
         * The #ClutterAlpha object used to drive this behaviour. A #ClutterAlpha
         * object binds a #ClutterTimeline and a function which computes a value
         * (the "alpha") depending on the time. Each time the alpha value changes
         * the alpha-notify virtual function is called.
         */
        get alpha(): Alpha;
        set alpha(val: Alpha);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Behaviour.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Behaviour.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof Behaviour.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Behaviour.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Behaviour.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Behaviour.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Behaviour.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Behaviour.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_alpha_notify(alpha_value: number): void;
        vfunc_applied(actor: Actor): void;
        vfunc_removed(actor: Actor): void;

        // Methods

        /**
         * Calls `func` for every actor driven by `behave`.
         * @param func a function called for each actor
         */
        actors_foreach(func: BehaviourForeachFunc): void;
        /**
         * Applies `behave` to `actor`.  This function adds a reference on
         * the actor.
         * @param actor a #ClutterActor
         */
        apply(actor: Actor): void;
        /**
         * Retrieves all the actors to which `behave` applies. It is not recommended
         * for derived classes to use this in there alpha notify method but use
         * #clutter_behaviour_actors_foreach as it avoids alot of needless allocations.
         * @returns a list of   actors. You should free the returned list with g_slist_free() when   finished using it.
         */
        get_actors(): Actor[];
        /**
         * Retrieves the #ClutterAlpha object bound to `behave`.
         * @returns a #ClutterAlpha object, or %NULL if no alpha   object has been bound to this behaviour.
         */
        get_alpha(): Alpha;
        /**
         * Gets the number of actors this behaviour is applied too.
         * @returns The number of applied actors
         */
        get_n_actors(): number;
        /**
         * Gets an actor the behaviour was applied to referenced by index num.
         * @param index_ the index of an actor this behaviour is applied too.
         * @returns A Clutter actor or NULL if @index_ is invalid.
         */
        get_nth_actor(index_: number): Actor;
        /**
         * Check if `behave` applied to  `actor`.
         * @param actor a #ClutterActor
         * @returns TRUE if actor has behaviour. FALSE otherwise.
         */
        is_applied(actor: Actor): boolean;
        /**
         * Removes `actor` from the list of #ClutterActor<!-- -->s to which
         * `behave` applies.  This function removes a reference on the actor.
         * @param actor a #ClutterActor
         */
        remove(actor: Actor): void;
        /**
         * Removes every actor from the list that `behave` holds.
         */
        remove_all(): void;
        /**
         * Binds `alpha` to a #ClutterBehaviour. The #ClutterAlpha object
         * is what makes a behaviour work: for each tick of the timeline
         * used by #ClutterAlpha a new value of the alpha parameter is
         * computed by the alpha function; the value should be used by
         * the #ClutterBehaviour to update one or more properties of the
         * actors to which the behaviour applies.
         *
         * If `alpha` is not %NULL, the #ClutterBehaviour will take ownership
         * of the #ClutterAlpha instance.
         * @param alpha a #ClutterAlpha or %NULL to unset a previously set alpha
         */
        set_alpha(alpha: Alpha): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace BehaviourDepth {
        // Signal signatures
        interface SignalSignatures extends Behaviour.SignalSignatures {
            'notify::depth-end': (pspec: GObject.ParamSpec) => void;
            'notify::depth-start': (pspec: GObject.ParamSpec) => void;
            'notify::alpha': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Behaviour.ConstructorProps, Scriptable.ConstructorProps {
            depth_end: number;
            depthEnd: number;
            depth_start: number;
            depthStart: number;
        }
    }

    /**
     * The #ClutterBehaviourDepth structure contains only private data
     * and should be accessed using the provided API
     */
    class BehaviourDepth extends Behaviour implements Scriptable {
        static $gtype: GObject.GType<BehaviourDepth>;

        // Properties

        /**
         * End depth level to apply to the actors.
         */
        get depth_end(): number;
        set depth_end(val: number);
        /**
         * End depth level to apply to the actors.
         */
        get depthEnd(): number;
        set depthEnd(val: number);
        /**
         * Start depth level to apply to the actors.
         */
        get depth_start(): number;
        set depth_start(val: number);
        /**
         * Start depth level to apply to the actors.
         */
        get depthStart(): number;
        set depthStart(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BehaviourDepth.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BehaviourDepth.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](alpha: Alpha | null, depth_start: number, depth_end: number): BehaviourDepth;

        // Signals

        connect<K extends keyof BehaviourDepth.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BehaviourDepth.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BehaviourDepth.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BehaviourDepth.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BehaviourDepth.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BehaviourDepth.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Gets the boundaries of the `behaviour`
         */
        get_bounds(): [number, number];
        /**
         * Sets the boundaries of the `behaviour`.
         * @param depth_start initial value of the depth
         * @param depth_end final value of the depth
         */
        set_bounds(depth_start: number, depth_end: number): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace BehaviourEllipse {
        // Signal signatures
        interface SignalSignatures extends Behaviour.SignalSignatures {
            'notify::angle-end': (pspec: GObject.ParamSpec) => void;
            'notify::angle-start': (pspec: GObject.ParamSpec) => void;
            'notify::angle-tilt-x': (pspec: GObject.ParamSpec) => void;
            'notify::angle-tilt-y': (pspec: GObject.ParamSpec) => void;
            'notify::angle-tilt-z': (pspec: GObject.ParamSpec) => void;
            'notify::center': (pspec: GObject.ParamSpec) => void;
            'notify::direction': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::alpha': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Behaviour.ConstructorProps, Scriptable.ConstructorProps {
            angle_end: number;
            angleEnd: number;
            angle_start: number;
            angleStart: number;
            angle_tilt_x: number;
            angleTiltX: number;
            angle_tilt_y: number;
            angleTiltY: number;
            angle_tilt_z: number;
            angleTiltZ: number;
            center: Knot;
            direction: RotateDirection;
            height: number;
            width: number;
        }
    }

    /**
     * The #ClutterBehaviourEllipse struct contains only private data
     * and should be accessed using the provided API
     */
    class BehaviourEllipse extends Behaviour implements Scriptable {
        static $gtype: GObject.GType<BehaviourEllipse>;

        // Properties

        /**
         * The final angle to where the rotation should end.
         */
        get angle_end(): number;
        set angle_end(val: number);
        /**
         * The final angle to where the rotation should end.
         */
        get angleEnd(): number;
        set angleEnd(val: number);
        /**
         * The initial angle from where the rotation should start.
         */
        get angle_start(): number;
        set angle_start(val: number);
        /**
         * The initial angle from where the rotation should start.
         */
        get angleStart(): number;
        set angleStart(val: number);
        /**
         * The tilt angle for the rotation around center in X axis
         */
        get angle_tilt_x(): number;
        set angle_tilt_x(val: number);
        /**
         * The tilt angle for the rotation around center in X axis
         */
        get angleTiltX(): number;
        set angleTiltX(val: number);
        /**
         * The tilt angle for the rotation around center in Y axis
         */
        get angle_tilt_y(): number;
        set angle_tilt_y(val: number);
        /**
         * The tilt angle for the rotation around center in Y axis
         */
        get angleTiltY(): number;
        set angleTiltY(val: number);
        /**
         * The tilt angle for the rotation on the Z axis
         */
        get angle_tilt_z(): number;
        set angle_tilt_z(val: number);
        /**
         * The tilt angle for the rotation on the Z axis
         */
        get angleTiltZ(): number;
        set angleTiltZ(val: number);
        /**
         * The center of the ellipse.
         */
        get center(): Knot;
        set center(val: Knot);
        /**
         * The direction of the rotation.
         */
        get direction(): RotateDirection;
        set direction(val: RotateDirection);
        /**
         * Height of the ellipse, in pixels
         */
        get height(): number;
        set height(val: number);
        /**
         * Width of the ellipse, in pixels
         */
        get width(): number;
        set width(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BehaviourEllipse.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BehaviourEllipse.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            alpha: Alpha | null,
            x: number,
            y: number,
            width: number,
            height: number,
            direction: RotateDirection,
            start: number,
            end: number,
        ): BehaviourEllipse;

        // Signals

        connect<K extends keyof BehaviourEllipse.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BehaviourEllipse.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BehaviourEllipse.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BehaviourEllipse.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BehaviourEllipse.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BehaviourEllipse.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Gets the at which movements ends.
         * @returns angle in degrees
         */
        get_angle_end(): number;
        /**
         * Gets the angle at which movements starts.
         * @returns angle in degrees
         */
        get_angle_start(): number;
        /**
         * Gets the tilt of the ellipse around the center in the given axis.
         * @param axis a #ClutterRotateAxis
         * @returns angle in degrees.
         */
        get_angle_tilt(axis: RotateAxis | null): number;
        /**
         * Gets the center of the elliptical path path.
         */
        get_center(): [number, number];
        /**
         * Retrieves the #ClutterRotateDirection used by the ellipse behaviour.
         * @returns the rotation direction
         */
        get_direction(): RotateDirection;
        /**
         * Gets the height of the elliptical path.
         * @returns the height of the path
         */
        get_height(): number;
        /**
         * Gets the tilt of the ellipse around the center in Y axis.
         */
        get_tilt(): [number, number, number];
        /**
         * Gets the width of the elliptical path.
         * @returns the width of the path
         */
        get_width(): number;
        /**
         * Sets the angle at which movement ends; angles >= 360 degress get clamped
         * to the canonical interval <0, 360).
         * @param angle_end angle at which movement ends in degrees, between 0 and 360.
         */
        set_angle_end(angle_end: number): void;
        /**
         * Sets the angle at which movement starts; angles >= 360 degress get clamped
         * to the canonical interval <0, 360).
         * @param angle_start angle at which movement starts in degrees, between 0 and 360.
         */
        set_angle_start(angle_start: number): void;
        /**
         * Sets the angle at which the ellipse should be tilted around it's center.
         * @param axis a #ClutterRotateAxis
         * @param angle_tilt tilt of the elipse around the center in the given axis in degrees.
         */
        set_angle_tilt(axis: RotateAxis | null, angle_tilt: number): void;
        /**
         * Sets the center of the elliptical path to the point represented by knot.
         * @param x x coordinace of centre
         * @param y y coordinace of centre
         */
        set_center(x: number, y: number): void;
        /**
         * Sets the rotation direction used by the ellipse behaviour.
         * @param direction the rotation direction
         */
        set_direction(direction: RotateDirection | null): void;
        /**
         * Sets the height of the elliptical path.
         * @param height height of the ellipse
         */
        set_height(height: number): void;
        /**
         * Sets the angles at which the ellipse should be tilted around it's center.
         * @param angle_tilt_x tilt of the elipse around the center in X axis in degrees.
         * @param angle_tilt_y tilt of the elipse around the center in Y axis in degrees.
         * @param angle_tilt_z tilt of the elipse around the center in Z axis in degrees.
         */
        set_tilt(angle_tilt_x: number, angle_tilt_y: number, angle_tilt_z: number): void;
        /**
         * Sets the width of the elliptical path.
         * @param width width of the ellipse
         */
        set_width(width: number): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace BehaviourOpacity {
        // Signal signatures
        interface SignalSignatures extends Behaviour.SignalSignatures {
            'notify::opacity-end': (pspec: GObject.ParamSpec) => void;
            'notify::opacity-start': (pspec: GObject.ParamSpec) => void;
            'notify::alpha': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Behaviour.ConstructorProps, Scriptable.ConstructorProps {
            opacity_end: number;
            opacityEnd: number;
            opacity_start: number;
            opacityStart: number;
        }
    }

    /**
     * The #ClutterBehaviourOpacity structure contains only private data and
     * should be accessed using the provided API
     */
    class BehaviourOpacity extends Behaviour implements Scriptable {
        static $gtype: GObject.GType<BehaviourOpacity>;

        // Properties

        /**
         * Final opacity level of the behaviour.
         */
        get opacity_end(): number;
        set opacity_end(val: number);
        /**
         * Final opacity level of the behaviour.
         */
        get opacityEnd(): number;
        set opacityEnd(val: number);
        /**
         * Initial opacity level of the behaviour.
         */
        get opacity_start(): number;
        set opacity_start(val: number);
        /**
         * Initial opacity level of the behaviour.
         */
        get opacityStart(): number;
        set opacityStart(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BehaviourOpacity.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BehaviourOpacity.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](alpha: Alpha | null, opacity_start: number, opacity_end: number): BehaviourOpacity;

        // Signals

        connect<K extends keyof BehaviourOpacity.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BehaviourOpacity.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BehaviourOpacity.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BehaviourOpacity.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BehaviourOpacity.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BehaviourOpacity.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Gets the initial and final levels of the opacity applied by `behaviour`
         * on each actor it controls.
         */
        get_bounds(): [number, number];
        /**
         * Sets the initial and final levels of the opacity applied by `behaviour`
         * on each actor it controls.
         * @param opacity_start minimum level of opacity
         * @param opacity_end maximum level of opacity
         */
        set_bounds(opacity_start: number, opacity_end: number): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace BehaviourPath {
        // Signal signatures
        interface SignalSignatures extends Behaviour.SignalSignatures {
            'knot-reached': (arg0: number) => void;
            'notify::path': (pspec: GObject.ParamSpec) => void;
            'notify::alpha': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Behaviour.ConstructorProps, Scriptable.ConstructorProps {
            path: Path;
        }
    }

    /**
     * The #ClutterBehaviourPath structure contains only private data
     * and should be accessed using the provided API
     */
    class BehaviourPath extends Behaviour implements Scriptable {
        static $gtype: GObject.GType<BehaviourPath>;

        // Properties

        get path(): Path;
        set path(val: Path);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BehaviourPath.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BehaviourPath.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](alpha: Alpha | null, path: Path): BehaviourPath;

        static new_with_description(alpha: Alpha | null, desc: string): BehaviourPath;

        static new_with_knots(alpha: Alpha | null, knots: Knot[]): BehaviourPath;

        // Signals

        connect<K extends keyof BehaviourPath.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BehaviourPath.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BehaviourPath.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BehaviourPath.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BehaviourPath.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BehaviourPath.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_knot_reached(knot_num: number): void;

        // Methods

        /**
         * Get the current path of the behaviour
         * @returns the path
         */
        get_path(): Path;
        /**
         * Change the path that the actors will follow. This will take the
         * floating reference on the #ClutterPath so you do not need to unref
         * it.
         * @param path the new path to follow
         */
        set_path(path: Path): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace BehaviourRotate {
        // Signal signatures
        interface SignalSignatures extends Behaviour.SignalSignatures {
            'notify::angle-end': (pspec: GObject.ParamSpec) => void;
            'notify::angle-start': (pspec: GObject.ParamSpec) => void;
            'notify::axis': (pspec: GObject.ParamSpec) => void;
            'notify::center-x': (pspec: GObject.ParamSpec) => void;
            'notify::center-y': (pspec: GObject.ParamSpec) => void;
            'notify::center-z': (pspec: GObject.ParamSpec) => void;
            'notify::direction': (pspec: GObject.ParamSpec) => void;
            'notify::alpha': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Behaviour.ConstructorProps, Scriptable.ConstructorProps {
            angle_end: number;
            angleEnd: number;
            angle_start: number;
            angleStart: number;
            axis: RotateAxis;
            center_x: number;
            centerX: number;
            center_y: number;
            centerY: number;
            center_z: number;
            centerZ: number;
            direction: RotateDirection;
        }
    }

    /**
     * The #ClutterBehaviourRotate struct contains only private data and
     * should be accessed using the provided API
     */
    class BehaviourRotate extends Behaviour implements Scriptable {
        static $gtype: GObject.GType<BehaviourRotate>;

        // Properties

        /**
         * The final angle to where the rotation should end.
         */
        get angle_end(): number;
        set angle_end(val: number);
        /**
         * The final angle to where the rotation should end.
         */
        get angleEnd(): number;
        set angleEnd(val: number);
        /**
         * The initial angle from whence the rotation should start.
         */
        get angle_start(): number;
        set angle_start(val: number);
        /**
         * The initial angle from whence the rotation should start.
         */
        get angleStart(): number;
        set angleStart(val: number);
        /**
         * The axis of rotation.
         */
        get axis(): RotateAxis;
        set axis(val: RotateAxis);
        /**
         * The x center of rotation.
         */
        get center_x(): number;
        set center_x(val: number);
        /**
         * The x center of rotation.
         */
        get centerX(): number;
        set centerX(val: number);
        /**
         * The y center of rotation.
         */
        get center_y(): number;
        set center_y(val: number);
        /**
         * The y center of rotation.
         */
        get centerY(): number;
        set centerY(val: number);
        /**
         * The z center of rotation.
         */
        get center_z(): number;
        set center_z(val: number);
        /**
         * The z center of rotation.
         */
        get centerZ(): number;
        set centerZ(val: number);
        /**
         * The direction of the rotation.
         */
        get direction(): RotateDirection;
        set direction(val: RotateDirection);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BehaviourRotate.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BehaviourRotate.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            alpha: Alpha | null,
            axis: RotateAxis,
            direction: RotateDirection,
            angle_start: number,
            angle_end: number,
        ): BehaviourRotate;

        // Signals

        connect<K extends keyof BehaviourRotate.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BehaviourRotate.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BehaviourRotate.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BehaviourRotate.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BehaviourRotate.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BehaviourRotate.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the #ClutterRotateAxis used by the rotate behaviour.
         * @returns the rotation axis
         */
        get_axis(): RotateAxis;
        /**
         * Retrieves the rotation boundaries of the rotate behaviour.
         */
        get_bounds(): [number, number];
        /**
         * Retrieves the center of rotation set using
         * clutter_behaviour_rotate_set_center().
         */
        get_center(): [number, number, number];
        /**
         * Retrieves the #ClutterRotateDirection used by the rotate behaviour.
         * @returns the rotation direction
         */
        get_direction(): RotateDirection;
        /**
         * Sets the axis used by the rotate behaviour.
         * @param axis a #ClutterRotateAxis
         */
        set_axis(axis: RotateAxis | null): void;
        /**
         * Sets the initial and final angles of a rotation behaviour; angles >= 360
         * degrees get clamped to the canonical interval <0, 360).
         * @param angle_start initial angle in degrees, between 0 and 360.
         * @param angle_end final angle in degrees, between 0 and 360.
         */
        set_bounds(angle_start: number, angle_end: number): void;
        /**
         * Sets the center of rotation. The coordinates are relative to the plane
         * normal to the rotation axis set with clutter_behaviour_rotate_set_axis().
         * @param x X axis center of rotation
         * @param y Y axis center of rotation
         * @param z Z axis center of rotation
         */
        set_center(x: number, y: number, z: number): void;
        /**
         * Sets the rotation direction used by the rotate behaviour.
         * @param direction the rotation direction
         */
        set_direction(direction: RotateDirection | null): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace BehaviourScale {
        // Signal signatures
        interface SignalSignatures extends Behaviour.SignalSignatures {
            'notify::x-scale-end': (pspec: GObject.ParamSpec) => void;
            'notify::x-scale-start': (pspec: GObject.ParamSpec) => void;
            'notify::y-scale-end': (pspec: GObject.ParamSpec) => void;
            'notify::y-scale-start': (pspec: GObject.ParamSpec) => void;
            'notify::alpha': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Behaviour.ConstructorProps, Scriptable.ConstructorProps {
            x_scale_end: number;
            xScaleEnd: number;
            x_scale_start: number;
            xScaleStart: number;
            y_scale_end: number;
            yScaleEnd: number;
            y_scale_start: number;
            yScaleStart: number;
        }
    }

    /**
     * The #ClutterBehaviourScale struct contains only private data and
     * should be accessed using the provided API
     */
    class BehaviourScale extends Behaviour implements Scriptable {
        static $gtype: GObject.GType<BehaviourScale>;

        // Properties

        /**
         * The final scaling factor on the X axis for the actors.
         */
        get x_scale_end(): number;
        set x_scale_end(val: number);
        /**
         * The final scaling factor on the X axis for the actors.
         */
        get xScaleEnd(): number;
        set xScaleEnd(val: number);
        /**
         * The initial scaling factor on the X axis for the actors.
         */
        get x_scale_start(): number;
        set x_scale_start(val: number);
        /**
         * The initial scaling factor on the X axis for the actors.
         */
        get xScaleStart(): number;
        set xScaleStart(val: number);
        /**
         * The final scaling factor on the Y axis for the actors.
         */
        get y_scale_end(): number;
        set y_scale_end(val: number);
        /**
         * The final scaling factor on the Y axis for the actors.
         */
        get yScaleEnd(): number;
        set yScaleEnd(val: number);
        /**
         * The initial scaling factor on the Y axis for the actors.
         */
        get y_scale_start(): number;
        set y_scale_start(val: number);
        /**
         * The initial scaling factor on the Y axis for the actors.
         */
        get yScaleStart(): number;
        set yScaleStart(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BehaviourScale.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BehaviourScale.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](
            alpha: Alpha | null,
            x_scale_start: number,
            y_scale_start: number,
            x_scale_end: number,
            y_scale_end: number,
        ): BehaviourScale;

        // Signals

        connect<K extends keyof BehaviourScale.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BehaviourScale.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BehaviourScale.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BehaviourScale.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BehaviourScale.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BehaviourScale.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the bounds used by scale behaviour.
         */
        get_bounds(): [number, number, number, number];
        /**
         * Sets the bounds used by scale behaviour.
         * @param x_scale_start initial scale factor on the X axis
         * @param y_scale_start initial scale factor on the Y axis
         * @param x_scale_end final scale factor on the X axis
         * @param y_scale_end final scale factor on the Y axis
         */
        set_bounds(x_scale_start: number, y_scale_start: number, x_scale_end: number, y_scale_end: number): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace BinLayout {
        // Signal signatures
        interface SignalSignatures extends LayoutManager.SignalSignatures {
            'notify::x-align': (pspec: GObject.ParamSpec) => void;
            'notify::y-align': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends LayoutManager.ConstructorProps {
            x_align: BinAlignment;
            xAlign: BinAlignment;
            y_align: BinAlignment;
            yAlign: BinAlignment;
        }
    }

    /**
     * The #ClutterBinLayout structure contains only private data
     * and should be accessed using the provided API
     */
    class BinLayout extends LayoutManager {
        static $gtype: GObject.GType<BinLayout>;

        // Properties

        /**
         * The default horizontal alignment policy for actors managed
         * by the #ClutterBinLayout
         */
        get x_align(): BinAlignment;
        set x_align(val: BinAlignment);
        /**
         * The default horizontal alignment policy for actors managed
         * by the #ClutterBinLayout
         */
        get xAlign(): BinAlignment;
        set xAlign(val: BinAlignment);
        /**
         * The default vertical alignment policy for actors managed
         * by the #ClutterBinLayout
         */
        get y_align(): BinAlignment;
        set y_align(val: BinAlignment);
        /**
         * The default vertical alignment policy for actors managed
         * by the #ClutterBinLayout
         */
        get yAlign(): BinAlignment;
        set yAlign(val: BinAlignment);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BinLayout.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BinLayout.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](x_align: BinAlignment, y_align: BinAlignment): BinLayout;

        // Signals

        connect<K extends keyof BinLayout.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BinLayout.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BinLayout.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BinLayout.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BinLayout.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BinLayout.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Adds a #ClutterActor to the container using `self` and
         * sets the alignment policies for it
         *
         * This function is equivalent to clutter_container_add_actor()
         * and clutter_layout_manager_child_set_property() but it does not
         * require a pointer to the #ClutterContainer associated to the
         * #ClutterBinLayout
         * @param child a #ClutterActor
         * @param x_align horizontal alignment policy for @child
         * @param y_align vertical alignment policy for @child
         */
        add(child: Actor, x_align: BinAlignment | null, y_align: BinAlignment | null): void;
        /**
         * Retrieves the horizontal and vertical alignment policies for
         * a child of `self`
         *
         * If `child` is %NULL the default alignment policies will be returned
         * instead
         * @param child a child of @container
         */
        get_alignment(child?: Actor | null): [BinAlignment | null, BinAlignment | null];
        /**
         * Sets the horizontal and vertical alignment policies to be applied
         * to a `child` of `self`
         *
         * If `child` is %NULL then the `x_align` and `y_align` values will
         * be set as the default alignment policies
         * @param child a child of @container
         * @param x_align the horizontal alignment policy to be used for the @child   inside @container
         * @param y_align the vertical aligment policy to be used on the @child   inside @container
         */
        set_alignment(child: Actor | null, x_align: BinAlignment | null, y_align: BinAlignment | null): void;
    }

    namespace BindConstraint {
        // Signal signatures
        interface SignalSignatures extends Constraint.SignalSignatures {
            'notify::coordinate': (pspec: GObject.ParamSpec) => void;
            'notify::offset': (pspec: GObject.ParamSpec) => void;
            'notify::source': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Constraint.ConstructorProps {
            coordinate: BindCoordinate;
            offset: number;
            source: Actor;
        }
    }

    /**
     * #ClutterBindConstraint is an opaque structure
     * whose members cannot be directly accessed
     */
    class BindConstraint extends Constraint {
        static $gtype: GObject.GType<BindConstraint>;

        // Properties

        /**
         * The coordinate to be bound
         */
        get coordinate(): BindCoordinate;
        set coordinate(val: BindCoordinate);
        /**
         * The offset, in pixels, to be applied to the binding
         */
        get offset(): number;
        set offset(val: number);
        /**
         * The #ClutterActor used as the source for the binding.
         *
         * The #ClutterActor must not be contained inside the actor associated
         * to the constraint.
         */
        get source(): Actor;
        set source(val: Actor);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BindConstraint.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BindConstraint.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](source: Actor | null, coordinate: BindCoordinate, offset: number): BindConstraint;

        // Signals

        connect<K extends keyof BindConstraint.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BindConstraint.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BindConstraint.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BindConstraint.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BindConstraint.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BindConstraint.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the bound coordinate of the constraint
         * @returns the bound coordinate
         */
        get_coordinate(): BindCoordinate;
        /**
         * Retrieves the offset set using clutter_bind_constraint_set_offset()
         * @returns the offset, in pixels
         */
        get_offset(): number;
        /**
         * Retrieves the #ClutterActor set using clutter_bind_constraint_set_source()
         * @returns a pointer to the source actor
         */
        get_source(): Actor;
        /**
         * Sets the coordinate to bind in the constraint
         * @param coordinate the coordinate to bind
         */
        set_coordinate(coordinate: BindCoordinate | null): void;
        /**
         * Sets the offset to be applied to the constraint
         * @param offset the offset to apply, in pixels
         */
        set_offset(offset: number): void;
        /**
         * Sets the source #ClutterActor for the constraint
         * @param source a #ClutterActor, or %NULL to unset the source
         */
        set_source(source?: Actor | null): void;
    }

    namespace BindingPool {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            name: string;
        }
    }

    /**
     * Container of key bindings. The #ClutterBindingPool struct is
     * private.
     */
    class BindingPool extends GObject.Object {
        static $gtype: GObject.GType<BindingPool>;

        // Properties

        /**
         * The unique name of the #ClutterBindingPool.
         */
        get name(): string;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BindingPool.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BindingPool.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](name: string): BindingPool;

        // Signals

        connect<K extends keyof BindingPool.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BindingPool.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BindingPool.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BindingPool.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BindingPool.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BindingPool.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Finds the #ClutterBindingPool with `name`.
         * @param name the name of the binding pool to find
         */
        static find(name: string): BindingPool;
        /**
         * Retrieves the #ClutterBindingPool for the given #GObject class
         * and, eventually, creates it. This function is a wrapper around
         * clutter_binding_pool_new() and uses the class type name as the
         * unique name for the binding pool.
         *
         * Calling this function multiple times will return the same
         * #ClutterBindingPool.
         *
         * A binding pool for a class can also be retrieved using
         * clutter_binding_pool_find() with the class type name:
         *
         *
         * ```
         *   pool = clutter_binding_pool_find (G_OBJECT_TYPE_NAME (instance));
         * ```
         *
         * @param klass a #GObjectClass pointer
         */
        static get_for_class(klass?: any | null): BindingPool;

        // Methods

        /**
         * Activates the callback associated to the action that is
         * bound to the `key_val` and `modifiers` pair.
         *
         * The callback has the following signature:
         *
         *
         * ```
         *   void (* callback) (GObject             *gobject,
         *                      const gchar         *action_name,
         *                      guint                key_val,
         *                      ClutterModifierType  modifiers,
         *                      gpointer             user_data);
         * ```
         *
         *
         * Where the #GObject instance is `gobject` and the user data
         * is the one passed when installing the action with
         * clutter_binding_pool_install_action().
         *
         * If the action bound to the `key_val,` `modifiers` pair has been
         * blocked using clutter_binding_pool_block_action(), the callback
         * will not be invoked, and this function will return %FALSE.
         * @param key_val the key symbol
         * @param modifiers bitmask for the modifiers
         * @param gobject a #GObject
         * @returns %TRUE if an action was found and was activated
         */
        activate(key_val: number, modifiers: ModifierType | null, gobject: GObject.Object): boolean;
        /**
         * Blocks all the actions with name `action_name` inside `pool`.
         * @param action_name an action name
         */
        block_action(action_name: string): void;
        /**
         * Retrieves the name of the action matching the given key symbol
         * and modifiers bitmask.
         * @param key_val a key symbol
         * @param modifiers a bitmask for the modifiers
         * @returns the name of the action, if found, or %NULL. The   returned string is owned by the binding pool and should never   be modified or freed
         */
        find_action(key_val: number, modifiers: ModifierType | null): string;
        /**
         * Installs a new action inside a #ClutterBindingPool. The action
         * is bound to `key_val` and `modifiers`.
         *
         * The same action name can be used for multiple `key_val,` `modifiers`
         * pairs.
         *
         * When an action has been activated using clutter_binding_pool_activate()
         * the passed `callback` will be invoked (with `data)`.
         *
         * Actions can be blocked with clutter_binding_pool_block_action()
         * and then unblocked using clutter_binding_pool_unblock_action().
         * @param action_name the name of the action
         * @param key_val key symbol
         * @param modifiers bitmask of modifiers
         * @param callback function to be called   when the action is activated
         */
        install_action(
            action_name: string,
            key_val: number,
            modifiers: ModifierType | null,
            callback: BindingActionFunc,
        ): void;
        /**
         * A #GClosure variant of clutter_binding_pool_install_action().
         *
         * Installs a new action inside a #ClutterBindingPool. The action
         * is bound to `key_val` and `modifiers`.
         *
         * The same action name can be used for multiple `key_val,` `modifiers`
         * pairs.
         *
         * When an action has been activated using clutter_binding_pool_activate()
         * the passed `closure` will be invoked.
         *
         * Actions can be blocked with clutter_binding_pool_block_action()
         * and then unblocked using clutter_binding_pool_unblock_action().
         * @param action_name the name of the action
         * @param key_val key symbol
         * @param modifiers bitmask of modifiers
         * @param closure a #GClosure
         */
        install_closure(
            action_name: string,
            key_val: number,
            modifiers: ModifierType | null,
            closure: GObject.Closure,
        ): void;
        /**
         * Allows overriding the action for `key_val` and `modifiers` inside a
         * #ClutterBindingPool. See clutter_binding_pool_install_action().
         *
         * When an action has been activated using clutter_binding_pool_activate()
         * the passed `callback` will be invoked (with `data)`.
         *
         * Actions can be blocked with clutter_binding_pool_block_action()
         * and then unblocked using clutter_binding_pool_unblock_action().
         * @param key_val key symbol
         * @param modifiers bitmask of modifiers
         * @param callback function to be called when the action is activated
         */
        override_action(key_val: number, modifiers: ModifierType | null, callback: BindingActionFunc): void;
        /**
         * A #GClosure variant of clutter_binding_pool_override_action().
         *
         * Allows overriding the action for `key_val` and `modifiers` inside a
         * #ClutterBindingPool. See clutter_binding_pool_install_closure().
         *
         * When an action has been activated using clutter_binding_pool_activate()
         * the passed `callback` will be invoked (with `data)`.
         *
         * Actions can be blocked with clutter_binding_pool_block_action()
         * and then unblocked using clutter_binding_pool_unblock_action().
         * @param key_val key symbol
         * @param modifiers bitmask of modifiers
         * @param closure a #GClosure
         */
        override_closure(key_val: number, modifiers: ModifierType | null, closure: GObject.Closure): void;
        /**
         * Removes the action matching the given `key_val,` `modifiers` pair,
         * if any exists.
         * @param key_val a key symbol
         * @param modifiers a bitmask for the modifiers
         */
        remove_action(key_val: number, modifiers: ModifierType | null): void;
        /**
         * Unblockes all the actions with name `action_name` inside `pool`.
         *
         * Unblocking an action does not cause the callback bound to it to
         * be invoked in case clutter_binding_pool_activate() was called on
         * an action previously blocked with clutter_binding_pool_block_action().
         * @param action_name an action name
         */
        unblock_action(action_name: string): void;
    }

    namespace BlurEffect {
        // Signal signatures
        interface SignalSignatures extends OffscreenEffect.SignalSignatures {
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends OffscreenEffect.ConstructorProps {}
    }

    /**
     * #ClutterBlurEffect is an opaque structure
     * whose members cannot be accessed directly
     */
    class BlurEffect extends OffscreenEffect {
        static $gtype: GObject.GType<BlurEffect>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BlurEffect.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BlurEffect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): BlurEffect;

        // Signals

        connect<K extends keyof BlurEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BlurEffect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BlurEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BlurEffect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BlurEffect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BlurEffect.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace Box {
        // Signal signatures
        interface SignalSignatures extends Actor.SignalSignatures {
            'notify::color': (pspec: GObject.ParamSpec) => void;
            'notify::color-set': (pspec: GObject.ParamSpec) => void;
            'notify::actions': (pspec: GObject.ParamSpec) => void;
            'notify::allocation': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-x': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-y': (pspec: GObject.ParamSpec) => void;
            'notify::background-color': (pspec: GObject.ParamSpec) => void;
            'notify::background-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::clip': (pspec: GObject.ParamSpec) => void;
            'notify::clip-rect': (pspec: GObject.ParamSpec) => void;
            'notify::clip-to-allocation': (pspec: GObject.ParamSpec) => void;
            'notify::constraints': (pspec: GObject.ParamSpec) => void;
            'notify::content': (pspec: GObject.ParamSpec) => void;
            'notify::content-box': (pspec: GObject.ParamSpec) => void;
            'notify::content-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::content-repeat': (pspec: GObject.ParamSpec) => void;
            'notify::depth': (pspec: GObject.ParamSpec) => void;
            'notify::effect': (pspec: GObject.ParamSpec) => void;
            'notify::first-child': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-position-set': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-x': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-y': (pspec: GObject.ParamSpec) => void;
            'notify::has-clip': (pspec: GObject.ParamSpec) => void;
            'notify::has-pointer': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::last-child': (pspec: GObject.ParamSpec) => void;
            'notify::layout-manager': (pspec: GObject.ParamSpec) => void;
            'notify::magnification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::mapped': (pspec: GObject.ParamSpec) => void;
            'notify::margin-bottom': (pspec: GObject.ParamSpec) => void;
            'notify::margin-left': (pspec: GObject.ParamSpec) => void;
            'notify::margin-right': (pspec: GObject.ParamSpec) => void;
            'notify::margin-top': (pspec: GObject.ParamSpec) => void;
            'notify::min-height': (pspec: GObject.ParamSpec) => void;
            'notify::min-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::min-width': (pspec: GObject.ParamSpec) => void;
            'notify::min-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::minification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::offscreen-redirect': (pspec: GObject.ParamSpec) => void;
            'notify::opacity': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point-z': (pspec: GObject.ParamSpec) => void;
            'notify::position': (pspec: GObject.ParamSpec) => void;
            'notify::reactive': (pspec: GObject.ParamSpec) => void;
            'notify::realized': (pspec: GObject.ParamSpec) => void;
            'notify::request-mode': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-zgravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-z': (pspec: GObject.ParamSpec) => void;
            'notify::show-on-set-parent': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::text-direction': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::translation-x': (pspec: GObject.ParamSpec) => void;
            'notify::translation-y': (pspec: GObject.ParamSpec) => void;
            'notify::translation-z': (pspec: GObject.ParamSpec) => void;
            'notify::visible': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::x-align': (pspec: GObject.ParamSpec) => void;
            'notify::x-expand': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::y-align': (pspec: GObject.ParamSpec) => void;
            'notify::y-expand': (pspec: GObject.ParamSpec) => void;
            'notify::z-position': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Actor.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Animatable.ConstructorProps,
                Container.ConstructorProps,
                Scriptable.ConstructorProps {
            color: Color;
            color_set: boolean;
            colorSet: boolean;
        }
    }

    /**
     * The #ClutterBox structure contains only private data and should
     * be accessed using the provided API
     */
    class Box extends Actor implements Atk.ImplementorIface, Animatable, Container, Scriptable {
        static $gtype: GObject.GType<Box>;

        // Properties

        /**
         * The color to be used to paint the background of the
         * #ClutterBox. Setting this property will set the
         * #ClutterBox:color-set property as a side effect
         *
         * This property sets the #ClutterActor:background-color property
         * internally.
         */
        get color(): Color;
        set color(val: Color);
        /**
         * Whether the #ClutterBox:color property has been set.
         *
         * This property reads the #ClutterActor:background-color-set property
         * internally.
         */
        get color_set(): boolean;
        set color_set(val: boolean);
        /**
         * Whether the #ClutterBox:color property has been set.
         *
         * This property reads the #ClutterActor:background-color-set property
         * internally.
         */
        get colorSet(): boolean;
        set colorSet(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Box.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Box.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](manager: LayoutManager): Box;
        // Conflicted with Clutter.Actor.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof Box.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Box.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Box.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Box.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Box.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Box.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the background color of `box`
         *
         * If the #ClutterBox:color-set property is set to %FALSE the
         * returned #ClutterColor is undefined
         */
        get_color(): Color;
        /**
         * Retrieves the #ClutterLayoutManager instance used by `box`
         * @returns a #ClutterLayoutManager. The returned   #ClutterLayoutManager is owned by the #ClutterBox and it should not   be unreferenced
         */
        get_layout_manager(): LayoutManager;
        /**
         * Vector-based variant of clutter_box_pack(), intended for language
         * bindings to use
         * @param actor a #ClutterActor
         * @param properties a vector   containing the property names to set
         * @param values a vector containing the property   values to set
         */
        packv(actor: Actor, properties: string[], values: (GObject.Value | any)[]): void;
        /**
         * Sets (or unsets) the background color for `box`
         * @param color the background color, or %NULL to unset
         */
        set_color(color?: Color | null): void;
        /**
         * Sets the #ClutterLayoutManager for `box`
         *
         * A #ClutterLayoutManager is a delegate object that controls the
         * layout of the children of `box`
         * @param manager a #ClutterLayoutManager
         */
        set_layout_manager(manager: LayoutManager): void;
        // Conflicted with Clutter.Actor.set_layout_manager
        set_layout_manager(...args: never[]): any;

        // Inherited methods
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         * @returns %TRUE if the value has been validated and can   be applied to the #ClutterAnimatable, and %FALSE otherwise
         */
        animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         * @returns The #GParamSpec for the given property   or %NULL
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         * @returns %TRUE if the interpolation was successful,   and %FALSE otherwise
         */
        interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         */
        vfunc_animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         */
        vfunc_find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        vfunc_get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         */
        vfunc_interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        vfunc_set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        add_actor(actor: Actor): void;
        /**
         * Gets a container specific property of a child of `container,` In general,
         * a copy is made of the property contents and the caller is responsible for
         * freeing the memory by calling g_value_unset().
         *
         * Note that clutter_container_child_set_property() is really intended for
         * language bindings, clutter_container_child_set() is much more convenient
         * for C programming.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_get_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Sets a container-specific property on a child of `container`.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_set_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        destroy_child_meta(actor: Actor): void;
        /**
         * Finds a child actor of a container by its name. Search recurses
         * into any child container.
         * @param child_name the name of the requested child.
         * @returns The child actor with the requested name,   or %NULL if no actor with that name was found.
         */
        find_child_by_name(child_name: string): Actor;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         * @returns the #ClutterChildMeta for the @actor child   of @container or %NULL if the specifiec actor does not exist or the   container is not configured to provide #ClutterChildMeta<!-- -->s
         */
        get_child_meta(actor: Actor): ChildMeta;
        /**
         * Retrieves all the children of `container`.
         * @returns a list   of #ClutterActor<!-- -->s. Use g_list_free() on the returned   list when done.
         */
        get_children(): Actor[];
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        lower_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        raise_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        remove_actor(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        sort_depth_order(): void;
        vfunc_actor_added(actor: Actor): void;
        vfunc_actor_removed(actor: Actor): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        vfunc_add(actor: Actor): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        vfunc_child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_destroy_child_meta(actor: Actor): void;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         */
        vfunc_get_child_meta(actor: Actor): ChildMeta;
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        vfunc_lower(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        vfunc_raise(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        vfunc_remove(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        vfunc_sort_depth_order(): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace BoxLayout {
        // Signal signatures
        interface SignalSignatures extends LayoutManager.SignalSignatures {
            'notify::easing-duration': (pspec: GObject.ParamSpec) => void;
            'notify::easing-mode': (pspec: GObject.ParamSpec) => void;
            'notify::homogeneous': (pspec: GObject.ParamSpec) => void;
            'notify::orientation': (pspec: GObject.ParamSpec) => void;
            'notify::pack-start': (pspec: GObject.ParamSpec) => void;
            'notify::spacing': (pspec: GObject.ParamSpec) => void;
            'notify::use-animations': (pspec: GObject.ParamSpec) => void;
            'notify::vertical': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends LayoutManager.ConstructorProps {
            easing_duration: number;
            easingDuration: number;
            easing_mode: number;
            easingMode: number;
            homogeneous: boolean;
            orientation: Orientation;
            pack_start: boolean;
            packStart: boolean;
            spacing: number;
            use_animations: boolean;
            useAnimations: boolean;
            vertical: boolean;
        }
    }

    /**
     * The #ClutterBoxLayout structure contains only private data
     * and should be accessed using the provided API
     */
    class BoxLayout extends LayoutManager {
        static $gtype: GObject.GType<BoxLayout>;

        // Properties

        /**
         * The duration of the animations, in case #ClutterBoxLayout:use-animations
         * is set to %TRUE.
         *
         * The duration is expressed in milliseconds.
         */
        get easing_duration(): number;
        set easing_duration(val: number);
        /**
         * The duration of the animations, in case #ClutterBoxLayout:use-animations
         * is set to %TRUE.
         *
         * The duration is expressed in milliseconds.
         */
        get easingDuration(): number;
        set easingDuration(val: number);
        /**
         * The easing mode for the animations, in case
         * #ClutterBoxLayout:use-animations is set to %TRUE.
         *
         * The easing mode has the same semantics of #ClutterAnimation:mode: it can
         * either be a value from the #ClutterAnimationMode enumeration, like
         * %CLUTTER_EASE_OUT_CUBIC, or a logical id as returned by
         * clutter_alpha_register_func().
         *
         * The default value is %CLUTTER_EASE_OUT_CUBIC.
         */
        get easing_mode(): number;
        set easing_mode(val: number);
        /**
         * The easing mode for the animations, in case
         * #ClutterBoxLayout:use-animations is set to %TRUE.
         *
         * The easing mode has the same semantics of #ClutterAnimation:mode: it can
         * either be a value from the #ClutterAnimationMode enumeration, like
         * %CLUTTER_EASE_OUT_CUBIC, or a logical id as returned by
         * clutter_alpha_register_func().
         *
         * The default value is %CLUTTER_EASE_OUT_CUBIC.
         */
        get easingMode(): number;
        set easingMode(val: number);
        /**
         * Whether the #ClutterBoxLayout should arrange its children
         * homogeneously, i.e. all children get the same size
         */
        get homogeneous(): boolean;
        set homogeneous(val: boolean);
        /**
         * The orientation of the #ClutterBoxLayout, either horizontal
         * or vertical
         */
        get orientation(): Orientation;
        set orientation(val: Orientation);
        /**
         * Whether the #ClutterBoxLayout should pack items at the start
         * or append them at the end
         */
        get pack_start(): boolean;
        set pack_start(val: boolean);
        /**
         * Whether the #ClutterBoxLayout should pack items at the start
         * or append them at the end
         */
        get packStart(): boolean;
        set packStart(val: boolean);
        /**
         * The spacing between children of the #ClutterBoxLayout, in pixels
         */
        get spacing(): number;
        set spacing(val: number);
        /**
         * Whether the #ClutterBoxLayout should animate changes in the
         * layout, overriding the easing state of the children.
         */
        get use_animations(): boolean;
        set use_animations(val: boolean);
        /**
         * Whether the #ClutterBoxLayout should animate changes in the
         * layout, overriding the easing state of the children.
         */
        get useAnimations(): boolean;
        set useAnimations(val: boolean);
        /**
         * Whether the #ClutterBoxLayout should arrange its children
         * alongside the Y axis, instead of alongside the X axis
         */
        get vertical(): boolean;
        set vertical(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BoxLayout.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BoxLayout.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): BoxLayout;

        // Signals

        connect<K extends keyof BoxLayout.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BoxLayout.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BoxLayout.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BoxLayout.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BoxLayout.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BoxLayout.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the horizontal and vertical alignment policies for `actor`
         * as set using clutter_box_layout_pack() or clutter_box_layout_set_alignment()
         * @param actor a #ClutterActor child of @layout
         */
        get_alignment(actor: Actor): [BoxAlignment, BoxAlignment];
        /**
         * Retrieves the duration set using clutter_box_layout_set_easing_duration()
         * @returns the duration of the animations, in milliseconds
         */
        get_easing_duration(): number;
        /**
         * Retrieves the easing mode set using clutter_box_layout_set_easing_mode()
         * @returns an easing mode
         */
        get_easing_mode(): number;
        /**
         * Retrieves whether `actor` should expand inside `layout`
         * @param actor a #ClutterActor child of @layout
         * @returns %TRUE if the #ClutterActor should expand, %FALSE otherwise
         */
        get_expand(actor: Actor): boolean;
        /**
         * Retrieves the horizontal and vertical fill policies for `actor`
         * as set using clutter_box_layout_pack() or clutter_box_layout_set_fill()
         * @param actor a #ClutterActor child of @layout
         */
        get_fill(actor: Actor): [boolean, boolean];
        /**
         * Retrieves if the children sizes are allocated homogeneously.
         * @returns %TRUE if the #ClutterBoxLayout is arranging its children   homogeneously, and %FALSE otherwise
         */
        get_homogeneous(): boolean;
        /**
         * Retrieves the orientation of the `layout`.
         * @returns the orientation of the layout
         */
        get_orientation(): Orientation;
        /**
         * Retrieves the value set using clutter_box_layout_set_pack_start()
         * @returns %TRUE if the #ClutterBoxLayout should pack children  at the beginning of the layout, and %FALSE otherwise
         */
        get_pack_start(): boolean;
        /**
         * Retrieves the spacing set using clutter_box_layout_set_spacing()
         * @returns the spacing between children of the #ClutterBoxLayout
         */
        get_spacing(): number;
        /**
         * Retrieves whether `layout` should animate changes in the layout properties.
         * @returns %TRUE if the animations should be used, %FALSE otherwise
         */
        get_use_animations(): boolean;
        /**
         * Retrieves the orientation of the `layout` as set using the
         * clutter_box_layout_set_vertical() function
         * @returns %TRUE if the #ClutterBoxLayout is arranging its children   vertically, and %FALSE otherwise
         */
        get_vertical(): boolean;
        /**
         * Packs `actor` inside the #ClutterContainer associated to `layout`
         * and sets the layout properties
         * @param actor a #ClutterActor
         * @param expand whether the @actor should expand
         * @param x_fill whether the @actor should fill horizontally
         * @param y_fill whether the @actor should fill vertically
         * @param x_align the horizontal alignment policy for @actor
         * @param y_align the vertical alignment policy for @actor
         */
        pack(
            actor: Actor,
            expand: boolean,
            x_fill: boolean,
            y_fill: boolean,
            x_align: BoxAlignment | null,
            y_align: BoxAlignment | null,
        ): void;
        /**
         * Sets the horizontal and vertical alignment policies for `actor`
         * inside `layout`
         * @param actor a #ClutterActor child of @layout
         * @param x_align Horizontal alignment policy for @actor
         * @param y_align Vertical alignment policy for @actor
         */
        set_alignment(actor: Actor, x_align: BoxAlignment | null, y_align: BoxAlignment | null): void;
        /**
         * Sets the duration of the animations used by `layout` when animating changes
         * in the layout properties.
         * @param msecs the duration of the animations, in milliseconds
         */
        set_easing_duration(msecs: number): void;
        /**
         * Sets the easing mode to be used by `layout` when animating changes in layout
         * properties.
         * @param mode an easing mode, either from #ClutterAnimationMode or a logical id   from clutter_alpha_register_func()
         */
        set_easing_mode(mode: number): void;
        /**
         * Sets whether `actor` should expand inside `layout`
         * @param actor a #ClutterActor child of @layout
         * @param expand whether @actor should expand
         */
        set_expand(actor: Actor, expand: boolean): void;
        /**
         * Sets the horizontal and vertical fill policies for `actor`
         * inside `layout`
         * @param actor a #ClutterActor child of @layout
         * @param x_fill whether @actor should fill horizontally the allocated space
         * @param y_fill whether @actor should fill vertically the allocated space
         */
        set_fill(actor: Actor, x_fill: boolean, y_fill: boolean): void;
        /**
         * Sets whether the size of `layout` children should be
         * homogeneous
         * @param homogeneous %TRUE if the layout should be homogeneous
         */
        set_homogeneous(homogeneous: boolean): void;
        /**
         * Sets the orientation of the #ClutterBoxLayout layout manager.
         * @param orientation the orientation of the #ClutterBoxLayout
         */
        set_orientation(orientation: Orientation | null): void;
        /**
         * Sets whether children of `layout` should be layed out by appending
         * them or by prepending them
         * @param pack_start %TRUE if the @layout should pack children at the   beginning of the layout
         */
        set_pack_start(pack_start: boolean): void;
        /**
         * Sets the spacing between children of `layout`
         * @param spacing the spacing between children of the layout, in pixels
         */
        set_spacing(spacing: number): void;
        /**
         * Sets whether `layout` should animate changes in the layout properties
         *
         * The duration of the animations is controlled by
         * clutter_box_layout_set_easing_duration(); the easing mode to be used
         * by the animations is controlled by clutter_box_layout_set_easing_mode().
         *
         * Enabling animations will override the easing state of each child
         * of the actor using `layout,` and will use the #ClutterBoxLayout:easing-mode
         * and #ClutterBoxLayout:easing-duration properties instead.
         * @param animate %TRUE if the @layout should use animations
         */
        set_use_animations(animate: boolean): void;
        /**
         * Sets whether `layout` should arrange its children vertically alongside
         * the Y axis, instead of horizontally alongside the X axis
         * @param vertical %TRUE if the layout should be vertical
         */
        set_vertical(vertical: boolean): void;
    }

    namespace BrightnessContrastEffect {
        // Signal signatures
        interface SignalSignatures extends OffscreenEffect.SignalSignatures {
            'notify::brightness': (pspec: GObject.ParamSpec) => void;
            'notify::contrast': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends OffscreenEffect.ConstructorProps {
            brightness: Color;
            contrast: Color;
        }
    }

    /**
     * #ClutterBrightnessContrastEffect is an opaque structure
     * whose members cannot be directly accessed
     */
    class BrightnessContrastEffect extends OffscreenEffect {
        static $gtype: GObject.GType<BrightnessContrastEffect>;

        // Properties

        /**
         * The brightness change to apply to the effect.
         *
         * This property uses a #ClutterColor to represent the changes to each
         * color channel. The range is [ 0, 255 ], with 127 as the value used
         * to indicate no change; values smaller than 127 indicate a decrease
         * in brightness, and values larger than 127 indicate an increase in
         * brightness.
         */
        get brightness(): Color;
        set brightness(val: Color);
        /**
         * The contrast change to apply to the effect.
         *
         * This property uses a #ClutterColor to represent the changes to each
         * color channel. The range is [ 0, 255 ], with 127 as the value used
         * to indicate no change; values smaller than 127 indicate a decrease
         * in contrast, and values larger than 127 indicate an increase in
         * contrast.
         */
        get contrast(): Color;
        set contrast(val: Color);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: BrightnessContrastEffect.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<BrightnessContrastEffect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): BrightnessContrastEffect;

        // Signals

        connect<K extends keyof BrightnessContrastEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BrightnessContrastEffect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof BrightnessContrastEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, BrightnessContrastEffect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof BrightnessContrastEffect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<BrightnessContrastEffect.SignalSignatures[K]> extends [any, ...infer Q]
                ? Q
                : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the change in brightness used by `effect`.
         */
        get_brightness(): [number, number, number];
        /**
         * Retrieves the contrast value used by `effect`.
         */
        get_contrast(): [number, number, number];
        /**
         * The range of `brightness` is [-1.0, 1.0], where 0.0 designates no change;
         * a value below 0.0 indicates a decrease in brightness; and a value
         * above 0.0 indicates an increase of brightness.
         * @param brightness the brightness change for all three components (r, g, b)
         */
        set_brightness(brightness: number): void;
        /**
         * The range for each component is [-1.0, 1.0] where 0.0 designates no change,
         * values below 0.0 mean a decrease in brightness, and values above indicate
         * an increase.
         * @param red red component of the change in brightness
         * @param green green component of the change in brightness
         * @param blue blue component of the change in brightness
         */
        set_brightness_full(red: number, green: number, blue: number): void;
        /**
         * The range for `contrast` is [-1.0, 1.0], where 0.0 designates no change;
         * a value below 0.0 indicates a decrease in contrast; and a value above
         * 0.0 indicates an increase.
         * @param contrast contrast change for all three channels
         */
        set_contrast(contrast: number): void;
        /**
         * The range for each component is [-1.0, 1.0] where 0.0 designates no change,
         * values below 0.0 mean a decrease in contrast, and values above indicate
         * an increase.
         * @param red red component of the change in contrast
         * @param green green component of the change in contrast
         * @param blue blue component of the change in contrast
         */
        set_contrast_full(red: number, green: number, blue: number): void;
    }

    namespace CairoTexture {
        // Signal signatures
        interface SignalSignatures extends Texture.SignalSignatures {
            'create-surface': (arg0: number, arg1: number) => cairo.Surface;
            draw: (arg0: cairo.Context) => boolean | void;
            'notify::auto-resize': (pspec: GObject.ParamSpec) => void;
            'notify::surface-height': (pspec: GObject.ParamSpec) => void;
            'notify::surface-width': (pspec: GObject.ParamSpec) => void;
            'notify::disable-slicing': (pspec: GObject.ParamSpec) => void;
            'notify::filename': (pspec: GObject.ParamSpec) => void;
            'notify::filter-quality': (pspec: GObject.ParamSpec) => void;
            'notify::keep-aspect-ratio': (pspec: GObject.ParamSpec) => void;
            'notify::load-async': (pspec: GObject.ParamSpec) => void;
            'notify::load-data-async': (pspec: GObject.ParamSpec) => void;
            'notify::pick-with-alpha': (pspec: GObject.ParamSpec) => void;
            'notify::pixel-format': (pspec: GObject.ParamSpec) => void;
            'notify::repeat-x': (pspec: GObject.ParamSpec) => void;
            'notify::repeat-y': (pspec: GObject.ParamSpec) => void;
            'notify::sync-size': (pspec: GObject.ParamSpec) => void;
            'notify::tile-waste': (pspec: GObject.ParamSpec) => void;
            'notify::actions': (pspec: GObject.ParamSpec) => void;
            'notify::allocation': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-x': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-y': (pspec: GObject.ParamSpec) => void;
            'notify::background-color': (pspec: GObject.ParamSpec) => void;
            'notify::background-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::clip': (pspec: GObject.ParamSpec) => void;
            'notify::clip-rect': (pspec: GObject.ParamSpec) => void;
            'notify::clip-to-allocation': (pspec: GObject.ParamSpec) => void;
            'notify::constraints': (pspec: GObject.ParamSpec) => void;
            'notify::content': (pspec: GObject.ParamSpec) => void;
            'notify::content-box': (pspec: GObject.ParamSpec) => void;
            'notify::content-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::content-repeat': (pspec: GObject.ParamSpec) => void;
            'notify::depth': (pspec: GObject.ParamSpec) => void;
            'notify::effect': (pspec: GObject.ParamSpec) => void;
            'notify::first-child': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-position-set': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-x': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-y': (pspec: GObject.ParamSpec) => void;
            'notify::has-clip': (pspec: GObject.ParamSpec) => void;
            'notify::has-pointer': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::last-child': (pspec: GObject.ParamSpec) => void;
            'notify::layout-manager': (pspec: GObject.ParamSpec) => void;
            'notify::magnification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::mapped': (pspec: GObject.ParamSpec) => void;
            'notify::margin-bottom': (pspec: GObject.ParamSpec) => void;
            'notify::margin-left': (pspec: GObject.ParamSpec) => void;
            'notify::margin-right': (pspec: GObject.ParamSpec) => void;
            'notify::margin-top': (pspec: GObject.ParamSpec) => void;
            'notify::min-height': (pspec: GObject.ParamSpec) => void;
            'notify::min-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::min-width': (pspec: GObject.ParamSpec) => void;
            'notify::min-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::minification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::offscreen-redirect': (pspec: GObject.ParamSpec) => void;
            'notify::opacity': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point-z': (pspec: GObject.ParamSpec) => void;
            'notify::position': (pspec: GObject.ParamSpec) => void;
            'notify::reactive': (pspec: GObject.ParamSpec) => void;
            'notify::realized': (pspec: GObject.ParamSpec) => void;
            'notify::request-mode': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-zgravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-z': (pspec: GObject.ParamSpec) => void;
            'notify::show-on-set-parent': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::text-direction': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::translation-x': (pspec: GObject.ParamSpec) => void;
            'notify::translation-y': (pspec: GObject.ParamSpec) => void;
            'notify::translation-z': (pspec: GObject.ParamSpec) => void;
            'notify::visible': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::x-align': (pspec: GObject.ParamSpec) => void;
            'notify::x-expand': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::y-align': (pspec: GObject.ParamSpec) => void;
            'notify::y-expand': (pspec: GObject.ParamSpec) => void;
            'notify::z-position': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Texture.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Animatable.ConstructorProps,
                Container.ConstructorProps,
                Scriptable.ConstructorProps {
            auto_resize: boolean;
            autoResize: boolean;
            surface_height: number;
            surfaceHeight: number;
            surface_width: number;
            surfaceWidth: number;
        }
    }

    /**
     * The #ClutterCairoTexture struct contains only private data.
     */
    class CairoTexture extends Texture implements Atk.ImplementorIface, Animatable, Container, Scriptable {
        static $gtype: GObject.GType<CairoTexture>;

        // Properties

        /**
         * Controls whether the #ClutterCairoTexture should automatically
         * resize the Cairo surface whenever the actor's allocation changes.
         * If :auto-resize is set to %TRUE the surface contents will also
         * be invalidated automatically.
         */
        get auto_resize(): boolean;
        set auto_resize(val: boolean);
        /**
         * Controls whether the #ClutterCairoTexture should automatically
         * resize the Cairo surface whenever the actor's allocation changes.
         * If :auto-resize is set to %TRUE the surface contents will also
         * be invalidated automatically.
         */
        get autoResize(): boolean;
        set autoResize(val: boolean);
        /**
         * The height of the Cairo surface used by the #ClutterCairoTexture
         * actor, in pixels.
         */
        get surface_height(): number;
        set surface_height(val: number);
        /**
         * The height of the Cairo surface used by the #ClutterCairoTexture
         * actor, in pixels.
         */
        get surfaceHeight(): number;
        set surfaceHeight(val: number);
        /**
         * The width of the Cairo surface used by the #ClutterCairoTexture
         * actor, in pixels.
         */
        get surface_width(): number;
        set surface_width(val: number);
        /**
         * The width of the Cairo surface used by the #ClutterCairoTexture
         * actor, in pixels.
         */
        get surfaceWidth(): number;
        set surfaceWidth(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: CairoTexture.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<CairoTexture.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](width: number, height: number): CairoTexture;
        // Conflicted with Clutter.Texture.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof CairoTexture.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CairoTexture.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof CairoTexture.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, CairoTexture.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof CairoTexture.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<CairoTexture.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_create_surface(width: number, height: number): cairo.Surface;
        vfunc_draw(cr: cairo.Context): boolean;

        // Methods

        /**
         * Clears `self'`s internal drawing surface, so that the next upload
         * will replace the previous contents of the #ClutterCairoTexture
         * rather than adding to it.
         *
         * Calling this function from within a #ClutterCairoTexture::draw
         * signal handler will clear the invalidated area.
         */
        clear(): void;
        /**
         * Creates a new Cairo context for the `cairo` texture. It is
         * similar to using clutter_cairo_texture_create_region() with `x_offset`
         * and `y_offset` of 0, `width` equal to the `cairo` texture surface width
         * and `height` equal to the `cairo` texture surface height.
         *
         * Do not call this function within the paint virtual
         * function or from a callback to the #ClutterActor::paint
         * signal.
         * @returns a newly created Cairo context. Use cairo_destroy()   to upload the contents of the context when done drawing
         */
        create(): cairo.Context;
        /**
         * Creates a new Cairo context that will updat the region defined
         * by `x_offset,` `y_offset,` `width` and `height`.
         *
         * Do not call this function within the paint virtual
         * function or from a callback to the #ClutterActor::paint
         * signal.
         * @param x_offset offset of the region on the X axis
         * @param y_offset offset of the region on the Y axis
         * @param width width of the region, or -1 for the full surface width
         * @param height height of the region, or -1 for the full surface height
         * @returns a newly created Cairo context. Use cairo_destroy()   to upload the contents of the context when done drawing
         */
        create_region(x_offset: number, y_offset: number, width: number, height: number): cairo.Context;
        /**
         * Retrieves the value set using clutter_cairo_texture_set_auto_resize().
         * @returns %TRUE if the #ClutterCairoTexture should track the   allocation, and %FALSE otherwise
         */
        get_auto_resize(): boolean;
        /**
         * Retrieves the surface width and height for `self`.
         */
        get_surface_size(): [number, number];
        /**
         * Invalidates the whole surface of a #ClutterCairoTexture.
         *
         * This function will cause the #ClutterCairoTexture::draw signal
         * to be emitted.
         *
         * See also: clutter_cairo_texture_invalidate_rectangle()
         */
        invalidate(): void;
        /**
         * Invalidates a rectangular region of a #ClutterCairoTexture.
         *
         * The invalidation will cause the #ClutterCairoTexture::draw signal
         * to be emitted.
         *
         * See also: clutter_cairo_texture_invalidate()
         * @param rect a rectangle with the area to invalida,   or %NULL to perform an unbounded invalidation
         */
        invalidate_rectangle(rect?: cairo.RectangleInt | null): void;
        /**
         * Sets whether the #ClutterCairoTexture should ensure that the
         * backing Cairo surface used matches the allocation assigned to
         * the actor. If the allocation changes, the contents of the
         * #ClutterCairoTexture will also be invalidated automatically.
         * @param value %TRUE if the #ClutterCairoTexture should bind the surface   size to the allocation
         */
        set_auto_resize(value: boolean): void;
        /**
         * Resizes the Cairo surface used by `self` to `width` and `height`.
         *
         * This function will not invalidate the contents of the Cairo
         * texture: you will have to explicitly call either
         * clutter_cairo_texture_invalidate_rectangle() or
         * clutter_cairo_texture_invalidate().
         * @param width the new width of the surface
         * @param height the new height of the surface
         */
        set_surface_size(width: number, height: number): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Canvas {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            draw: (arg0: cairo.Context, arg1: number, arg2: number) => boolean | void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::scale-factor': (pspec: GObject.ParamSpec) => void;
            'notify::scale-factor-set': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Content.ConstructorProps {
            height: number;
            scale_factor: number;
            scaleFactor: number;
            scale_factor_set: boolean;
            scaleFactorSet: boolean;
            width: number;
        }
    }

    /**
     * The #ClutterCanvas structure contains
     * private data and should only be accessed using the provided
     * API.
     */
    class Canvas extends GObject.Object implements Content {
        static $gtype: GObject.GType<Canvas>;

        // Properties

        /**
         * The height of the canvas.
         */
        get height(): number;
        set height(val: number);
        /**
         * The scaling factor to be applied to the Cairo surface used for
         * drawing.
         *
         * If #ClutterCanvas:scale-factor is set to a negative value, the
         * value of the #ClutterSettings:window-scaling-factor property is
         * used instead.
         *
         * Use #ClutterCanvas:scale-factor-set to check if the scale factor
         * is set.
         */
        get scale_factor(): number;
        set scale_factor(val: number);
        /**
         * The scaling factor to be applied to the Cairo surface used for
         * drawing.
         *
         * If #ClutterCanvas:scale-factor is set to a negative value, the
         * value of the #ClutterSettings:window-scaling-factor property is
         * used instead.
         *
         * Use #ClutterCanvas:scale-factor-set to check if the scale factor
         * is set.
         */
        get scaleFactor(): number;
        set scaleFactor(val: number);
        /**
         * Whether the #ClutterCanvas:scale-factor property is set.
         *
         * If the #ClutterCanvas:scale-factor-set property is %FALSE
         * then #ClutterCanvas will use the #ClutterSettings:window-scaling-factor
         * property.
         */
        get scale_factor_set(): boolean;
        /**
         * Whether the #ClutterCanvas:scale-factor property is set.
         *
         * If the #ClutterCanvas:scale-factor-set property is %FALSE
         * then #ClutterCanvas will use the #ClutterSettings:window-scaling-factor
         * property.
         */
        get scaleFactorSet(): boolean;
        /**
         * The width of the canvas.
         */
        get width(): number;
        set width(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Canvas.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Canvas.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof Canvas.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Canvas.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Canvas.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Canvas.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Canvas.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Canvas.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Creates a new instance of #ClutterCanvas.
         *
         * You should call clutter_canvas_set_size() to set the size of the canvas.
         *
         * You should call clutter_content_invalidate() every time you wish to
         * draw the contents of the canvas.
         */
        static ['new'](): Content;

        // Virtual methods

        vfunc_draw(cr: cairo.Context, width: number, height: number): boolean;

        // Methods

        /**
         * Retrieves the scaling factor of `canvas,` as set using
         * clutter_canvas_set_scale_factor().
         * @returns the scaling factor, or -1 if the @canvas   uses the default from #ClutterSettings
         */
        get_scale_factor(): number;
        /**
         * Sets the scaling factor for the Cairo surface used by `canvas`.
         *
         * This function should rarely be used.
         *
         * The default scaling factor of a #ClutterCanvas content uses the
         * #ClutterSettings:window-scaling-factor property, which is set by
         * the windowing system. By using this function it is possible to
         * override that setting.
         *
         * Changing the scale factor will invalidate the `canvas`.
         * @param scale the scale factor, or -1 for the default
         */
        set_scale_factor(scale: number): void;
        /**
         * Sets the size of the `canvas,` and invalidates the content.
         *
         * This function will cause the `canvas` to be invalidated only
         * if the size of the canvas surface has changed.
         *
         * If you want to invalidate the contents of the `canvas` when setting
         * the size, you can use the return value of the function to conditionally
         * call clutter_content_invalidate():
         *
         *
         * ```
         *   if (!clutter_canvas_set_size (canvas, width, height))
         *     clutter_content_invalidate (CLUTTER_CONTENT (canvas));
         * ```
         *
         * @param width the width of the canvas, in pixels
         * @param height the height of the canvas, in pixels
         * @returns this function returns %TRUE if the size change   caused a content invalidation, and %FALSE otherwise
         */
        set_size(width: number, height: number): boolean;

        // Inherited methods
        /**
         * Retrieves the natural size of the `content,` if any.
         *
         * The natural size of a #ClutterContent is defined as the size the content
         * would have regardless of the allocation of the actor that is painting it,
         * for instance the size of an image data.
         * @returns %TRUE if the content has a preferred size, and %FALSE   otherwise
         */
        get_preferred_size(): [boolean, number, number];
        /**
         * Invalidates a #ClutterContent.
         *
         * This function should be called by #ClutterContent implementations when
         * they change the way a the content should be painted regardless of the
         * actor state.
         */
        invalidate(): void;
        vfunc_attached(actor: Actor): void;
        vfunc_detached(actor: Actor): void;
        /**
         * Retrieves the natural size of the `content,` if any.
         *
         * The natural size of a #ClutterContent is defined as the size the content
         * would have regardless of the allocation of the actor that is painting it,
         * for instance the size of an image data.
         */
        vfunc_get_preferred_size(): [boolean, number, number];
        /**
         * Invalidates a #ClutterContent.
         *
         * This function should be called by #ClutterContent implementations when
         * they change the way a the content should be painted regardless of the
         * actor state.
         */
        vfunc_invalidate(): void;
        vfunc_paint_content(actor: Actor, node: PaintNode): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace ChildMeta {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::container': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            actor: Actor;
            container: Container;
        }
    }

    /**
     * Base interface for container specific state for child actors. A child
     * data is meant to be used when you need to keep track of information
     * about each individual child added to a container.
     *
     * In order to use it you should create your own subclass of
     * #ClutterChildMeta and set the #ClutterContainerIface child_meta_type
     * interface member to your subclass type, like:
     *
     *
     * ```
     * static void
     * my_container_iface_init (ClutterContainerIface *iface)
     * {
     *   // set the rest of the #ClutterContainer vtable
     *
     *   container_iface->child_meta_type  = MY_TYPE_CHILD_META;
     * }
     * ```
     *
     *
     * This will automatically create a #ClutterChildMeta of type
     * `MY_TYPE_CHILD_META` for every actor that is added to the container.
     *
     * The child data for an actor can be retrieved using the
     * clutter_container_get_child_meta() function.
     *
     * The properties of the data and your subclass can be manipulated with
     * clutter_container_child_set() and clutter_container_child_get() which
     * act like g_object_set() and g_object_get().
     *
     * You can provide hooks for your own storage as well as control the
     * instantiation by overriding the #ClutterContainerIface virtual functions
     * #ClutterContainerIface.create_child_meta(), #ClutterContainerIface.destroy_child_meta(),
     * and #ClutterContainerIface.get_child_meta().
     */
    abstract class ChildMeta extends GObject.Object {
        static $gtype: GObject.GType<ChildMeta>;

        // Properties

        /**
         * The #ClutterActor being wrapped by this #ClutterChildMeta
         */
        get actor(): Actor;
        /**
         * The #ClutterContainer that created this #ClutterChildMeta.
         */
        get container(): Container;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ChildMeta.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ChildMeta.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof ChildMeta.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ChildMeta.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ChildMeta.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ChildMeta.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ChildMeta.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ChildMeta.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the actor wrapped by `data`
         * @returns a #ClutterActor
         */
        get_actor(): Actor;
        /**
         * Retrieves the container using `data`
         * @returns a #ClutterContainer
         */
        get_container(): Container;
    }

    namespace ClickAction {
        // Signal signatures
        interface SignalSignatures extends Action.SignalSignatures {
            clicked: (arg0: Actor) => void;
            'long-press': (arg0: Actor, arg1: LongPressState) => boolean | void;
            'notify::held': (pspec: GObject.ParamSpec) => void;
            'notify::long-press-duration': (pspec: GObject.ParamSpec) => void;
            'notify::long-press-threshold': (pspec: GObject.ParamSpec) => void;
            'notify::pressed': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Action.ConstructorProps {
            held: boolean;
            long_press_duration: number;
            longPressDuration: number;
            long_press_threshold: number;
            longPressThreshold: number;
            pressed: boolean;
        }
    }

    /**
     * The #ClutterClickAction structure contains
     * only private data and should be accessed using the provided API
     */
    class ClickAction extends Action {
        static $gtype: GObject.GType<ClickAction>;

        // Properties

        /**
         * Whether the clickable actor has the pointer grabbed
         */
        get held(): boolean;
        /**
         * The minimum duration of a press for it to be recognized as a long
         * press gesture, in milliseconds.
         *
         * A value of -1 will make the #ClutterClickAction use the value of
         * the #ClutterSettings:long-press-duration property.
         */
        get long_press_duration(): number;
        set long_press_duration(val: number);
        /**
         * The minimum duration of a press for it to be recognized as a long
         * press gesture, in milliseconds.
         *
         * A value of -1 will make the #ClutterClickAction use the value of
         * the #ClutterSettings:long-press-duration property.
         */
        get longPressDuration(): number;
        set longPressDuration(val: number);
        /**
         * The maximum allowed distance that can be covered (on both axes) before
         * a long press gesture is cancelled, in pixels.
         *
         * A value of -1 will make the #ClutterClickAction use the value of
         * the #ClutterSettings:dnd-drag-threshold property.
         */
        get long_press_threshold(): number;
        set long_press_threshold(val: number);
        /**
         * The maximum allowed distance that can be covered (on both axes) before
         * a long press gesture is cancelled, in pixels.
         *
         * A value of -1 will make the #ClutterClickAction use the value of
         * the #ClutterSettings:dnd-drag-threshold property.
         */
        get longPressThreshold(): number;
        set longPressThreshold(val: number);
        /**
         * Whether the clickable actor should be in "pressed" state
         */
        get pressed(): boolean;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ClickAction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ClickAction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ClickAction;

        // Signals

        connect<K extends keyof ClickAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ClickAction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ClickAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ClickAction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ClickAction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ClickAction.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_clicked(actor: Actor): void;
        vfunc_long_press(actor: Actor, state: LongPressState): boolean;

        // Methods

        /**
         * Retrieves the button that was pressed.
         * @returns the button value
         */
        get_button(): number;
        /**
         * Retrieves the screen coordinates of the button press.
         */
        get_coords(): [number, number];
        /**
         * Retrieves the modifier state of the click action.
         * @returns the modifier state parameter, or 0
         */
        get_state(): ModifierType;
        /**
         * Emulates a release of the pointer button, which ungrabs the pointer
         * and unsets the #ClutterClickAction:pressed state.
         *
         * This function will also cancel the long press gesture if one was
         * initiated.
         *
         * This function is useful to break a grab, for instance after a certain
         * amount of time has passed.
         */
        release(): void;
    }

    namespace ClipNode {
        // Signal signatures
        interface SignalSignatures extends PaintNode.SignalSignatures {}
    }

    /**
     * The #ClutterTextNode structure is an opaque
     * type whose members cannot be directly accessed.
     */
    class ClipNode extends PaintNode {
        static $gtype: GObject.GType<ClipNode>;

        // Constructors

        _init(...args: any[]): void;

        static ['new'](): ClipNode;

        // Signals

        connect<K extends keyof ClipNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ClipNode.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ClipNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ClipNode.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ClipNode.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ClipNode.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace Clone {
        // Signal signatures
        interface SignalSignatures extends Actor.SignalSignatures {
            'notify::source': (pspec: GObject.ParamSpec) => void;
            'notify::actions': (pspec: GObject.ParamSpec) => void;
            'notify::allocation': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-x': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-y': (pspec: GObject.ParamSpec) => void;
            'notify::background-color': (pspec: GObject.ParamSpec) => void;
            'notify::background-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::clip': (pspec: GObject.ParamSpec) => void;
            'notify::clip-rect': (pspec: GObject.ParamSpec) => void;
            'notify::clip-to-allocation': (pspec: GObject.ParamSpec) => void;
            'notify::constraints': (pspec: GObject.ParamSpec) => void;
            'notify::content': (pspec: GObject.ParamSpec) => void;
            'notify::content-box': (pspec: GObject.ParamSpec) => void;
            'notify::content-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::content-repeat': (pspec: GObject.ParamSpec) => void;
            'notify::depth': (pspec: GObject.ParamSpec) => void;
            'notify::effect': (pspec: GObject.ParamSpec) => void;
            'notify::first-child': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-position-set': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-x': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-y': (pspec: GObject.ParamSpec) => void;
            'notify::has-clip': (pspec: GObject.ParamSpec) => void;
            'notify::has-pointer': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::last-child': (pspec: GObject.ParamSpec) => void;
            'notify::layout-manager': (pspec: GObject.ParamSpec) => void;
            'notify::magnification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::mapped': (pspec: GObject.ParamSpec) => void;
            'notify::margin-bottom': (pspec: GObject.ParamSpec) => void;
            'notify::margin-left': (pspec: GObject.ParamSpec) => void;
            'notify::margin-right': (pspec: GObject.ParamSpec) => void;
            'notify::margin-top': (pspec: GObject.ParamSpec) => void;
            'notify::min-height': (pspec: GObject.ParamSpec) => void;
            'notify::min-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::min-width': (pspec: GObject.ParamSpec) => void;
            'notify::min-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::minification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::offscreen-redirect': (pspec: GObject.ParamSpec) => void;
            'notify::opacity': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point-z': (pspec: GObject.ParamSpec) => void;
            'notify::position': (pspec: GObject.ParamSpec) => void;
            'notify::reactive': (pspec: GObject.ParamSpec) => void;
            'notify::realized': (pspec: GObject.ParamSpec) => void;
            'notify::request-mode': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-zgravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-z': (pspec: GObject.ParamSpec) => void;
            'notify::show-on-set-parent': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::text-direction': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::translation-x': (pspec: GObject.ParamSpec) => void;
            'notify::translation-y': (pspec: GObject.ParamSpec) => void;
            'notify::translation-z': (pspec: GObject.ParamSpec) => void;
            'notify::visible': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::x-align': (pspec: GObject.ParamSpec) => void;
            'notify::x-expand': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::y-align': (pspec: GObject.ParamSpec) => void;
            'notify::y-expand': (pspec: GObject.ParamSpec) => void;
            'notify::z-position': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Actor.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Animatable.ConstructorProps,
                Container.ConstructorProps,
                Scriptable.ConstructorProps {
            source: Actor;
        }
    }

    /**
     * The #ClutterClone structure contains only private data
     * and should be accessed using the provided API
     */
    class Clone extends Actor implements Atk.ImplementorIface, Animatable, Container, Scriptable {
        static $gtype: GObject.GType<Clone>;

        // Properties

        /**
         * This property specifies the source actor being cloned.
         */
        get source(): Actor;
        set source(val: Actor);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Clone.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Clone.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](source: Actor): Clone;
        // Conflicted with Clutter.Actor.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof Clone.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Clone.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Clone.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Clone.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Clone.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Clone.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the source #ClutterActor being cloned by `self`.
         * @returns the actor source for the clone
         */
        get_source(): Actor;
        /**
         * Sets `source` as the source actor to be cloned by `self`.
         * @param source a #ClutterActor, or %NULL
         */
        set_source(source?: Actor | null): void;

        // Inherited methods
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         * @returns %TRUE if the value has been validated and can   be applied to the #ClutterAnimatable, and %FALSE otherwise
         */
        animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         * @returns The #GParamSpec for the given property   or %NULL
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         * @returns %TRUE if the interpolation was successful,   and %FALSE otherwise
         */
        interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         */
        vfunc_animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         */
        vfunc_find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        vfunc_get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         */
        vfunc_interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        vfunc_set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        add_actor(actor: Actor): void;
        /**
         * Gets a container specific property of a child of `container,` In general,
         * a copy is made of the property contents and the caller is responsible for
         * freeing the memory by calling g_value_unset().
         *
         * Note that clutter_container_child_set_property() is really intended for
         * language bindings, clutter_container_child_set() is much more convenient
         * for C programming.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_get_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Sets a container-specific property on a child of `container`.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_set_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        destroy_child_meta(actor: Actor): void;
        /**
         * Finds a child actor of a container by its name. Search recurses
         * into any child container.
         * @param child_name the name of the requested child.
         * @returns The child actor with the requested name,   or %NULL if no actor with that name was found.
         */
        find_child_by_name(child_name: string): Actor;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         * @returns the #ClutterChildMeta for the @actor child   of @container or %NULL if the specifiec actor does not exist or the   container is not configured to provide #ClutterChildMeta<!-- -->s
         */
        get_child_meta(actor: Actor): ChildMeta;
        /**
         * Retrieves all the children of `container`.
         * @returns a list   of #ClutterActor<!-- -->s. Use g_list_free() on the returned   list when done.
         */
        get_children(): Actor[];
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        lower_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        raise_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        remove_actor(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        sort_depth_order(): void;
        vfunc_actor_added(actor: Actor): void;
        vfunc_actor_removed(actor: Actor): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        vfunc_add(actor: Actor): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        vfunc_child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_destroy_child_meta(actor: Actor): void;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         */
        vfunc_get_child_meta(actor: Actor): ChildMeta;
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        vfunc_lower(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        vfunc_raise(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        vfunc_remove(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        vfunc_sort_depth_order(): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace ColorNode {
        // Signal signatures
        interface SignalSignatures extends PipelineNode.SignalSignatures {}
    }

    /**
     * The #ClutterTextNode structure is an opaque
     * type whose members cannot be directly accessed.
     */
    class ColorNode extends PipelineNode {
        static $gtype: GObject.GType<ColorNode>;

        // Constructors

        _init(...args: any[]): void;

        static ['new'](color?: Color | null): ColorNode;

        // Signals

        connect<K extends keyof ColorNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ColorNode.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ColorNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ColorNode.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ColorNode.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ColorNode.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace ColorizeEffect {
        // Signal signatures
        interface SignalSignatures extends OffscreenEffect.SignalSignatures {
            'notify::tint': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends OffscreenEffect.ConstructorProps {
            tint: Color;
        }
    }

    /**
     * #ClutterColorizeEffect is an opaque structure
     * whose members cannot be directly accessed
     */
    class ColorizeEffect extends OffscreenEffect {
        static $gtype: GObject.GType<ColorizeEffect>;

        // Properties

        /**
         * The tint to apply to the actor
         */
        get tint(): Color;
        set tint(val: Color);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ColorizeEffect.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ColorizeEffect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](tint: Color): ColorizeEffect;

        // Signals

        connect<K extends keyof ColorizeEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ColorizeEffect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ColorizeEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ColorizeEffect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ColorizeEffect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ColorizeEffect.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the tint used by `effect`
         */
        get_tint(): Color;
        /**
         * Sets the tint to be used when colorizing
         * @param tint the color to be used
         */
        set_tint(tint: Color): void;
    }

    namespace Constraint {
        // Signal signatures
        interface SignalSignatures extends ActorMeta.SignalSignatures {
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends ActorMeta.ConstructorProps {}
    }

    /**
     * The #ClutterConstraint structure contains only
     * private data and should be accessed using the provided API
     */
    abstract class Constraint extends ActorMeta {
        static $gtype: GObject.GType<Constraint>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Constraint.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Constraint.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof Constraint.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Constraint.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Constraint.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Constraint.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Constraint.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Constraint.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_update_allocation(actor: Actor, allocation: ActorBox): void;
        vfunc_update_preferred_size(
            actor: Actor,
            direction: Orientation,
            for_size: number,
            minimum_size: number,
            natural_size: number,
        ): void;
    }

    namespace DeformEffect {
        // Signal signatures
        interface SignalSignatures extends OffscreenEffect.SignalSignatures {
            'notify::x-tiles': (pspec: GObject.ParamSpec) => void;
            'notify::y-tiles': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends OffscreenEffect.ConstructorProps {
            x_tiles: number;
            xTiles: number;
            y_tiles: number;
            yTiles: number;
        }
    }

    /**
     * The #ClutterDeformEffect structure contains
     * only private data and should be accessed using the provided API
     */
    abstract class DeformEffect extends OffscreenEffect {
        static $gtype: GObject.GType<DeformEffect>;

        // Properties

        /**
         * The number of horizontal tiles. The bigger the number, the
         * smaller the tiles
         */
        get x_tiles(): number;
        set x_tiles(val: number);
        /**
         * The number of horizontal tiles. The bigger the number, the
         * smaller the tiles
         */
        get xTiles(): number;
        set xTiles(val: number);
        /**
         * The number of vertical tiles. The bigger the number, the
         * smaller the tiles
         */
        get y_tiles(): number;
        set y_tiles(val: number);
        /**
         * The number of vertical tiles. The bigger the number, the
         * smaller the tiles
         */
        get yTiles(): number;
        set yTiles(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DeformEffect.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DeformEffect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof DeformEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DeformEffect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DeformEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DeformEffect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DeformEffect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DeformEffect.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_deform_vertex(width: number, height: number, vertex: Cogl.TextureVertex): void;

        // Methods

        /**
         * Retrieves the handle to the back face material used by `effect`
         * @returns a handle for the material, or %NULL.   The returned material is owned by the #ClutterDeformEffect and it   should not be freed directly
         */
        get_back_material(): Cogl.Handle;
        /**
         * Retrieves the number of horizontal and vertical tiles used to sub-divide
         * the actor's geometry during the effect
         */
        get_n_tiles(): [number, number];
        /**
         * Invalidates the `effect<`!-- -->'s vertices and, if it is associated
         * to an actor, it will queue a redraw
         */
        invalidate(): void;
        /**
         * Sets the material that should be used when drawing the back face
         * of the actor during a deformation
         *
         * The #ClutterDeformEffect will take a reference on the material's
         * handle
         * @param material a handle to a Cogl material
         */
        set_back_material(material?: Cogl.Handle | null): void;
        /**
         * Sets the number of horizontal and vertical tiles to be used
         * when applying the effect
         *
         * More tiles allow a finer grained deformation at the expenses
         * of computation
         * @param x_tiles number of horizontal tiles
         * @param y_tiles number of vertical tiles
         */
        set_n_tiles(x_tiles: number, y_tiles: number): void;
    }

    namespace DesaturateEffect {
        // Signal signatures
        interface SignalSignatures extends OffscreenEffect.SignalSignatures {
            'notify::factor': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends OffscreenEffect.ConstructorProps {
            factor: number;
        }
    }

    /**
     * #ClutterDesaturateEffect is an opaque structure
     * whose members cannot be directly accessed
     */
    class DesaturateEffect extends OffscreenEffect {
        static $gtype: GObject.GType<DesaturateEffect>;

        // Properties

        /**
         * The desaturation factor, between 0.0 (no desaturation) and 1.0 (full
         * desaturation).
         */
        get factor(): number;
        set factor(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DesaturateEffect.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DesaturateEffect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](factor: number): DesaturateEffect;

        // Signals

        connect<K extends keyof DesaturateEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DesaturateEffect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DesaturateEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DesaturateEffect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DesaturateEffect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DesaturateEffect.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the desaturation factor of `effect`
         * @returns the desaturation factor
         */
        get_factor(): number;
        /**
         * Sets the desaturation factor for `effect,` with 0.0 being "do not desaturate"
         * and 1.0 being "fully desaturate"
         * @param factor the desaturation factor, between 0.0 and 1.0
         */
        set_factor(factor: number): void;
    }

    namespace DeviceManager {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'device-added': (arg0: InputDevice) => void;
            'device-removed': (arg0: InputDevice) => void;
            'notify::backend': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            backend: Backend;
        }
    }

    /**
     * The #ClutterDeviceManager structure contains only private data
     */
    abstract class DeviceManager extends GObject.Object {
        static $gtype: GObject.GType<DeviceManager>;

        // Properties

        get backend(): Backend;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DeviceManager.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DeviceManager.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof DeviceManager.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DeviceManager.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DeviceManager.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DeviceManager.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DeviceManager.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DeviceManager.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Retrieves the device manager singleton
         */
        static get_default(): DeviceManager;

        // Virtual methods

        vfunc_add_device(device: InputDevice): void;
        /**
         * Retrieves the core #ClutterInputDevice of type `device_type`
         *
         * Core devices are devices created automatically by the default
         * Clutter backend
         * @param device_type the type of the core device
         */
        vfunc_get_core_device(device_type: InputDeviceType): InputDevice;
        /**
         * Retrieves the #ClutterInputDevice with the given `device_id`
         * @param device_id the integer id of a device
         */
        vfunc_get_device(device_id: number): InputDevice;
        vfunc_remove_device(device: InputDevice): void;
        vfunc_select_stage_events(stage: Stage): void;

        // Methods

        /**
         * Retrieves the core #ClutterInputDevice of type `device_type`
         *
         * Core devices are devices created automatically by the default
         * Clutter backend
         * @param device_type the type of the core device
         * @returns a #ClutterInputDevice or %NULL. The   returned device is owned by the #ClutterDeviceManager and should   not be modified or freed
         */
        get_core_device(device_type: InputDeviceType | null): InputDevice;
        /**
         * Retrieves the #ClutterInputDevice with the given `device_id`
         * @param device_id the integer id of a device
         * @returns a #ClutterInputDevice or %NULL. The   returned device is owned by the #ClutterDeviceManager and should   never be modified or freed
         */
        get_device(device_id: number): InputDevice;
        /**
         * Lists all currently registered input devices
         * @returns a newly allocated list of #ClutterInputDevice objects. Use   g_slist_free() to deallocate it when done
         */
        list_devices(): InputDevice[];
        /**
         * Lists all currently registered input devices
         * @returns a pointer to the internal list of #ClutterInputDevice objects. The   returned list is owned by the #ClutterDeviceManager and should never   be modified or freed
         */
        peek_devices(): InputDevice[];
    }

    namespace DragAction {
        // Signal signatures
        interface SignalSignatures extends Action.SignalSignatures {
            'drag-begin': (arg0: Actor, arg1: number, arg2: number, arg3: ModifierType) => void;
            'drag-end': (arg0: Actor, arg1: number, arg2: number, arg3: ModifierType) => void;
            'drag-motion': (arg0: Actor, arg1: number, arg2: number) => void;
            'drag-progress': (arg0: Actor, arg1: number, arg2: number) => boolean | void;
            'notify::drag-area': (pspec: GObject.ParamSpec) => void;
            'notify::drag-area-set': (pspec: GObject.ParamSpec) => void;
            'notify::drag-axis': (pspec: GObject.ParamSpec) => void;
            'notify::drag-handle': (pspec: GObject.ParamSpec) => void;
            'notify::x-drag-threshold': (pspec: GObject.ParamSpec) => void;
            'notify::y-drag-threshold': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Action.ConstructorProps {
            drag_area: Rect;
            dragArea: Rect;
            drag_area_set: boolean;
            dragAreaSet: boolean;
            drag_axis: DragAxis;
            dragAxis: DragAxis;
            drag_handle: Actor;
            dragHandle: Actor;
            x_drag_threshold: number;
            xDragThreshold: number;
            y_drag_threshold: number;
            yDragThreshold: number;
        }
    }

    /**
     * The #ClutterDragAction structure contains only
     * private data and should be accessed using the provided API
     */
    class DragAction extends Action {
        static $gtype: GObject.GType<DragAction>;

        // Properties

        /**
         * Constains the dragging action (or in particular, the resulting
         * actor position) to the specified #ClutterRect, in parent's
         * coordinates.
         */
        get drag_area(): Rect;
        set drag_area(val: Rect);
        /**
         * Constains the dragging action (or in particular, the resulting
         * actor position) to the specified #ClutterRect, in parent's
         * coordinates.
         */
        get dragArea(): Rect;
        set dragArea(val: Rect);
        /**
         * Whether the #ClutterDragAction:drag-area property has been set.
         */
        get drag_area_set(): boolean;
        /**
         * Whether the #ClutterDragAction:drag-area property has been set.
         */
        get dragAreaSet(): boolean;
        /**
         * Constraints the dragging action to the specified axis
         */
        get drag_axis(): DragAxis;
        set drag_axis(val: DragAxis);
        /**
         * Constraints the dragging action to the specified axis
         */
        get dragAxis(): DragAxis;
        set dragAxis(val: DragAxis);
        /**
         * The #ClutterActor that is effectively being dragged
         *
         * A #ClutterDragAction will, be default, use the #ClutterActor that
         * has been attached to the action; it is possible to create a
         * separate #ClutterActor and use it instead.
         *
         * Setting this property has no effect on the #ClutterActor argument
         * passed to the #ClutterDragAction signals
         */
        get drag_handle(): Actor;
        set drag_handle(val: Actor);
        /**
         * The #ClutterActor that is effectively being dragged
         *
         * A #ClutterDragAction will, be default, use the #ClutterActor that
         * has been attached to the action; it is possible to create a
         * separate #ClutterActor and use it instead.
         *
         * Setting this property has no effect on the #ClutterActor argument
         * passed to the #ClutterDragAction signals
         */
        get dragHandle(): Actor;
        set dragHandle(val: Actor);
        /**
         * The horizontal threshold, in pixels, that the cursor must travel
         * in order to begin a drag action.
         *
         * When set to a positive value, #ClutterDragAction will only emit
         * #ClutterDragAction::drag-begin if the pointer has moved
         * horizontally at least of the given amount of pixels since
         * the button press event.
         *
         * When set to -1, #ClutterDragAction will use the default threshold
         * stored in the #ClutterSettings:dnd-drag-threshold property of
         * #ClutterSettings.
         *
         * When read, this property will always return a valid drag
         * threshold, either as set or the default one.
         */
        get x_drag_threshold(): number;
        set x_drag_threshold(val: number);
        /**
         * The horizontal threshold, in pixels, that the cursor must travel
         * in order to begin a drag action.
         *
         * When set to a positive value, #ClutterDragAction will only emit
         * #ClutterDragAction::drag-begin if the pointer has moved
         * horizontally at least of the given amount of pixels since
         * the button press event.
         *
         * When set to -1, #ClutterDragAction will use the default threshold
         * stored in the #ClutterSettings:dnd-drag-threshold property of
         * #ClutterSettings.
         *
         * When read, this property will always return a valid drag
         * threshold, either as set or the default one.
         */
        get xDragThreshold(): number;
        set xDragThreshold(val: number);
        /**
         * The vertical threshold, in pixels, that the cursor must travel
         * in order to begin a drag action.
         *
         * When set to a positive value, #ClutterDragAction will only emit
         * #ClutterDragAction::drag-begin if the pointer has moved
         * vertically at least of the given amount of pixels since
         * the button press event.
         *
         * When set to -1, #ClutterDragAction will use the value stored
         * in the #ClutterSettings:dnd-drag-threshold property of
         * #ClutterSettings.
         *
         * When read, this property will always return a valid drag
         * threshold, either as set or the default one.
         */
        get y_drag_threshold(): number;
        set y_drag_threshold(val: number);
        /**
         * The vertical threshold, in pixels, that the cursor must travel
         * in order to begin a drag action.
         *
         * When set to a positive value, #ClutterDragAction will only emit
         * #ClutterDragAction::drag-begin if the pointer has moved
         * vertically at least of the given amount of pixels since
         * the button press event.
         *
         * When set to -1, #ClutterDragAction will use the value stored
         * in the #ClutterSettings:dnd-drag-threshold property of
         * #ClutterSettings.
         *
         * When read, this property will always return a valid drag
         * threshold, either as set or the default one.
         */
        get yDragThreshold(): number;
        set yDragThreshold(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DragAction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DragAction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DragAction;

        // Signals

        connect<K extends keyof DragAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DragAction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DragAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DragAction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DragAction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DragAction.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_drag_begin(actor: Actor, event_x: number, event_y: number, modifiers: ModifierType): void;
        vfunc_drag_end(actor: Actor, event_x: number, event_y: number, modifiers: ModifierType): void;
        vfunc_drag_motion(actor: Actor, delta_x: number, delta_y: number): void;
        vfunc_drag_progress(actor: Actor, delta_x: number, delta_y: number): boolean;

        // Methods

        /**
         * Retrieves the "drag area" associated with `action,` that
         * is a #ClutterRect that constrains the actor movements,
         * in parents coordinates.
         * @returns %TRUE if the actor is actually constrained (and thus          @drag_area is valid), %FALSE otherwise
         */
        get_drag_area(): [boolean, Rect];
        /**
         * Retrieves the axis constraint set by clutter_drag_action_set_drag_axis()
         * @returns the axis constraint
         */
        get_drag_axis(): DragAxis;
        /**
         * Retrieves the drag handle set by clutter_drag_action_set_drag_handle()
         * @returns a #ClutterActor, used as the drag   handle, or %NULL if none was set
         */
        get_drag_handle(): Actor;
        /**
         * Retrieves the values set by clutter_drag_action_set_drag_threshold().
         *
         * If the #ClutterDragAction:x-drag-threshold property or the
         * #ClutterDragAction:y-drag-threshold property have been set to -1 then
         * this function will return the default drag threshold value as stored
         * by the #ClutterSettings:dnd-drag-threshold property of #ClutterSettings.
         */
        get_drag_threshold(): [number, number];
        /**
         * Retrieves the coordinates, in stage space, of the latest motion
         * event during the dragging
         */
        get_motion_coords(): [number, number];
        /**
         * Retrieves the coordinates, in stage space, of the press event
         * that started the dragging
         */
        get_press_coords(): [number, number];
        /**
         * Sets `drag_area` to constrain the dragging of the actor associated
         * with `action,` so that it position is always within `drag_area,` expressed
         * in parent's coordinates.
         * If `drag_area` is %NULL, the actor is not constrained.
         * @param drag_area a #ClutterRect
         */
        set_drag_area(drag_area?: Rect | null): void;
        /**
         * Restricts the dragging action to a specific axis
         * @param axis the axis to constraint the dragging to
         */
        set_drag_axis(axis: DragAxis | null): void;
        /**
         * Sets the actor to be used as the drag handle.
         * @param handle a #ClutterActor, or %NULL to unset
         */
        set_drag_handle(handle?: Actor | null): void;
        /**
         * Sets the horizontal and vertical drag thresholds that must be
         * cleared by the pointer before `action` can begin the dragging.
         *
         * If `x_threshold` or `y_threshold` are set to -1 then the default
         * drag threshold stored in the #ClutterSettings:dnd-drag-threshold
         * property of #ClutterSettings will be used.
         * @param x_threshold a distance on the horizontal axis, in pixels, or   -1 to use the default drag threshold from #ClutterSettings
         * @param y_threshold a distance on the vertical axis, in pixels, or   -1 to use the default drag threshold from #ClutterSettings
         */
        set_drag_threshold(x_threshold: number, y_threshold: number): void;
    }

    namespace DropAction {
        // Signal signatures
        interface SignalSignatures extends Action.SignalSignatures {
            'can-drop': (arg0: Actor, arg1: number, arg2: number) => boolean | void;
            drop: (arg0: Actor, arg1: number, arg2: number) => void;
            'drop-cancel': (arg0: Actor, arg1: number, arg2: number) => void;
            'over-in': (arg0: Actor) => void;
            'over-out': (arg0: Actor) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Action.ConstructorProps {}
    }

    /**
     * The #ClutterDropAction structure contains only
     * private data and should be accessed using the provided API.
     */
    class DropAction extends Action {
        static $gtype: GObject.GType<DropAction>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: DropAction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<DropAction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): DropAction;

        // Signals

        connect<K extends keyof DropAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DropAction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof DropAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, DropAction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof DropAction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<DropAction.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_can_drop(actor: Actor, event_x: number, event_y: number): boolean;
        vfunc_drop(actor: Actor, event_x: number, event_y: number): void;
        vfunc_over_in(actor: Actor): void;
        vfunc_over_out(actor: Actor): void;
    }

    namespace Effect {
        // Signal signatures
        interface SignalSignatures extends ActorMeta.SignalSignatures {
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends ActorMeta.ConstructorProps {}
    }

    /**
     * The #ClutterEffect structure contains only private data and should
     * be accessed using the provided API
     */
    abstract class Effect extends ActorMeta {
        static $gtype: GObject.GType<Effect>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Effect.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Effect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof Effect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Effect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Effect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Effect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Effect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Effect.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_get_paint_volume(volume: PaintVolume): boolean;
        vfunc_paint(flags: EffectPaintFlags): void;
        vfunc_pick(flags: EffectPaintFlags): void;
        vfunc_post_paint(): void;
        vfunc_pre_paint(): boolean;

        // Methods

        /**
         * Queues a repaint of the effect. The effect can detect when the paint
         * method is called as a result of this function because it will not
         * have the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag set. In that case the
         * effect is free to assume that the actor has not changed its
         * appearance since the last time it was painted so it doesn't need to
         * call clutter_actor_continue_paint() if it can draw a cached
         * image. This is mostly intended for effects that are using a
         * %CoglOffscreen to redirect the actor (such as
         * %ClutterOffscreenEffect). In that case the effect can save a bit of
         * rendering time by painting the cached texture without causing the
         * entire actor to be painted.
         *
         * This function can be used by effects that have their own animatable
         * parameters. For example, an effect which adds a varying degree of a
         * red tint to an actor by redirecting it through a CoglOffscreen
         * might have a property to specify the level of tint. When this value
         * changes, the underlying actor doesn't need to be redrawn so the
         * effect can call clutter_effect_queue_repaint() to make sure the
         * effect is repainted.
         *
         * Note however that modifying the position of the parent of an actor
         * may change the appearance of the actor because its transformation
         * matrix would change. In this case a redraw wouldn't be queued on
         * the actor itself so the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY would still
         * not be set. The effect can detect this case by keeping track of the
         * last modelview matrix that was used to render the actor and
         * veryifying that it remains the same in the next paint.
         *
         * Any other effects that are layered on top of the passed in effect
         * will still be passed the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY flag. If
         * anything queues a redraw on the actor without specifying an effect
         * or with an effect that is lower in the chain of effects than this
         * one then that will override this call. In that case this effect
         * will instead be called with the %CLUTTER_EFFECT_PAINT_ACTOR_DIRTY
         * flag set.
         */
        queue_repaint(): void;
    }

    namespace FixedLayout {
        // Signal signatures
        interface SignalSignatures extends LayoutManager.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends LayoutManager.ConstructorProps {}
    }

    /**
     * The #ClutterFixedLayout structure contains only private data and
     * it should be accessed using the provided API
     */
    class FixedLayout extends LayoutManager {
        static $gtype: GObject.GType<FixedLayout>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: FixedLayout.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<FixedLayout.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): FixedLayout;

        // Signals

        connect<K extends keyof FixedLayout.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, FixedLayout.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof FixedLayout.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, FixedLayout.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof FixedLayout.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<FixedLayout.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace FlowLayout {
        // Signal signatures
        interface SignalSignatures extends LayoutManager.SignalSignatures {
            'notify::column-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::homogeneous': (pspec: GObject.ParamSpec) => void;
            'notify::max-column-width': (pspec: GObject.ParamSpec) => void;
            'notify::max-row-height': (pspec: GObject.ParamSpec) => void;
            'notify::min-column-width': (pspec: GObject.ParamSpec) => void;
            'notify::min-row-height': (pspec: GObject.ParamSpec) => void;
            'notify::orientation': (pspec: GObject.ParamSpec) => void;
            'notify::row-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::snap-to-grid': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends LayoutManager.ConstructorProps {
            column_spacing: number;
            columnSpacing: number;
            homogeneous: boolean;
            max_column_width: number;
            maxColumnWidth: number;
            max_row_height: number;
            maxRowHeight: number;
            min_column_width: number;
            minColumnWidth: number;
            min_row_height: number;
            minRowHeight: number;
            orientation: FlowOrientation;
            row_spacing: number;
            rowSpacing: number;
            snap_to_grid: boolean;
            snapToGrid: boolean;
        }
    }

    /**
     * The #ClutterFlowLayout structure contains only private data
     * and should be accessed using the provided API
     */
    class FlowLayout extends LayoutManager {
        static $gtype: GObject.GType<FlowLayout>;

        // Properties

        /**
         * The spacing between columns, in pixels; the value of this
         * property is honoured by horizontal non-overflowing layouts
         * and by vertical overflowing layouts
         */
        get column_spacing(): number;
        set column_spacing(val: number);
        /**
         * The spacing between columns, in pixels; the value of this
         * property is honoured by horizontal non-overflowing layouts
         * and by vertical overflowing layouts
         */
        get columnSpacing(): number;
        set columnSpacing(val: number);
        /**
         * Whether each child inside the #ClutterFlowLayout should receive
         * the same allocation
         */
        get homogeneous(): boolean;
        set homogeneous(val: boolean);
        /**
         * Maximum width for each column in the layout, in pixels. If
         * set to -1 the width will be the maximum child width
         */
        get max_column_width(): number;
        set max_column_width(val: number);
        /**
         * Maximum width for each column in the layout, in pixels. If
         * set to -1 the width will be the maximum child width
         */
        get maxColumnWidth(): number;
        set maxColumnWidth(val: number);
        /**
         * Maximum height for each row in the layout, in pixels. If
         * set to -1 the width will be the maximum child height
         */
        get max_row_height(): number;
        set max_row_height(val: number);
        /**
         * Maximum height for each row in the layout, in pixels. If
         * set to -1 the width will be the maximum child height
         */
        get maxRowHeight(): number;
        set maxRowHeight(val: number);
        /**
         * Minimum width for each column in the layout, in pixels
         */
        get min_column_width(): number;
        set min_column_width(val: number);
        /**
         * Minimum width for each column in the layout, in pixels
         */
        get minColumnWidth(): number;
        set minColumnWidth(val: number);
        /**
         * Minimum height for each row in the layout, in pixels
         */
        get min_row_height(): number;
        set min_row_height(val: number);
        /**
         * Minimum height for each row in the layout, in pixels
         */
        get minRowHeight(): number;
        set minRowHeight(val: number);
        /**
         * The orientation of the #ClutterFlowLayout. The children
         * of the layout will be layed out following the orientation.
         *
         * This property also controls the overflowing directions
         */
        get orientation(): FlowOrientation;
        set orientation(val: FlowOrientation);
        /**
         * The spacing between rows, in pixels; the value of this
         * property is honoured by vertical non-overflowing layouts and
         * by horizontal overflowing layouts
         */
        get row_spacing(): number;
        set row_spacing(val: number);
        /**
         * The spacing between rows, in pixels; the value of this
         * property is honoured by vertical non-overflowing layouts and
         * by horizontal overflowing layouts
         */
        get rowSpacing(): number;
        set rowSpacing(val: number);
        /**
         * Whether the #ClutterFlowLayout should arrange its children
         * on a grid
         */
        get snap_to_grid(): boolean;
        set snap_to_grid(val: boolean);
        /**
         * Whether the #ClutterFlowLayout should arrange its children
         * on a grid
         */
        get snapToGrid(): boolean;
        set snapToGrid(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: FlowLayout.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<FlowLayout.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](orientation: FlowOrientation): FlowLayout;

        // Signals

        connect<K extends keyof FlowLayout.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, FlowLayout.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof FlowLayout.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, FlowLayout.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof FlowLayout.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<FlowLayout.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the spacing between columns
         * @returns the spacing between columns of the #ClutterFlowLayout,   in pixels
         */
        get_column_spacing(): number;
        /**
         * Retrieves the minimum and maximum column widths
         */
        get_column_width(): [number, number];
        /**
         * Retrieves whether the `layout` is homogeneous
         * @returns %TRUE if the #ClutterFlowLayout is homogeneous
         */
        get_homogeneous(): boolean;
        /**
         * Retrieves the orientation of the `layout`
         * @returns the orientation of the #ClutterFlowLayout
         */
        get_orientation(): FlowOrientation;
        /**
         * Retrieves the minimum and maximum row heights
         */
        get_row_height(): [number, number];
        /**
         * Retrieves the spacing between rows
         * @returns the spacing between rows of the #ClutterFlowLayout,   in pixels
         */
        get_row_spacing(): number;
        /**
         * Retrieves the value of #ClutterFlowLayout:snap-to-grid property
         * @returns %TRUE if the @layout is placing its children on a grid
         */
        get_snap_to_grid(): boolean;
        /**
         * Sets the space between columns, in pixels
         * @param spacing the space between columns
         */
        set_column_spacing(spacing: number): void;
        /**
         * Sets the minimum and maximum widths that a column can have
         * @param min_width minimum width of a column
         * @param max_width maximum width of a column
         */
        set_column_width(min_width: number, max_width: number): void;
        /**
         * Sets whether the `layout` should allocate the same space for
         * each child
         * @param homogeneous whether the layout should be homogeneous or not
         */
        set_homogeneous(homogeneous: boolean): void;
        /**
         * Sets the orientation of the flow layout
         *
         * The orientation controls the direction used to allocate
         * the children: either horizontally or vertically. The
         * orientation also controls the direction of the overflowing
         * @param orientation the orientation of the layout
         */
        set_orientation(orientation: FlowOrientation | null): void;
        /**
         * Sets the minimum and maximum heights that a row can have
         * @param min_height the minimum height of a row
         * @param max_height the maximum height of a row
         */
        set_row_height(min_height: number, max_height: number): void;
        /**
         * Sets the spacing between rows, in pixels
         * @param spacing the space between rows
         */
        set_row_spacing(spacing: number): void;
        /**
         * Whether the `layout` should place its children on a grid.
         * @param snap_to_grid %TRUE if @layout should place its children on a grid
         */
        set_snap_to_grid(snap_to_grid: boolean): void;
    }

    namespace GestureAction {
        // Signal signatures
        interface SignalSignatures extends Action.SignalSignatures {
            'gesture-begin': (arg0: Actor) => boolean | void;
            'gesture-cancel': (arg0: Actor) => void;
            'gesture-end': (arg0: Actor) => void;
            'gesture-progress': (arg0: Actor) => boolean | void;
            'notify::n-touch-points': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-distance-x': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-distance-y': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-edge': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Action.ConstructorProps {
            n_touch_points: number;
            nTouchPoints: number;
            threshold_trigger_distance_x: number;
            thresholdTriggerDistanceX: number;
            threshold_trigger_distance_y: number;
            thresholdTriggerDistanceY: number;
            threshold_trigger_edge: GestureTriggerEdge;
            thresholdTriggerEdge: GestureTriggerEdge;
        }
    }

    /**
     * The #ClutterGestureAction structure contains
     * only private data and should be accessed using the provided API
     */
    class GestureAction extends Action {
        static $gtype: GObject.GType<GestureAction>;

        // Properties

        /**
         * Number of touch points to trigger a gesture action.
         */
        get n_touch_points(): number;
        set n_touch_points(val: number);
        /**
         * Number of touch points to trigger a gesture action.
         */
        get nTouchPoints(): number;
        set nTouchPoints(val: number);
        /**
         * The horizontal trigger distance to be used by the action to either
         * emit the #ClutterGestureAction::gesture-begin signal or to emit
         * the #ClutterGestureAction::gesture-cancel signal.
         *
         * A negative value will be interpreted as the default drag threshold.
         */
        get threshold_trigger_distance_x(): number;
        /**
         * The horizontal trigger distance to be used by the action to either
         * emit the #ClutterGestureAction::gesture-begin signal or to emit
         * the #ClutterGestureAction::gesture-cancel signal.
         *
         * A negative value will be interpreted as the default drag threshold.
         */
        get thresholdTriggerDistanceX(): number;
        /**
         * The vertical trigger distance to be used by the action to either
         * emit the #ClutterGestureAction::gesture-begin signal or to emit
         * the #ClutterGestureAction::gesture-cancel signal.
         *
         * A negative value will be interpreted as the default drag threshold.
         */
        get threshold_trigger_distance_y(): number;
        /**
         * The vertical trigger distance to be used by the action to either
         * emit the #ClutterGestureAction::gesture-begin signal or to emit
         * the #ClutterGestureAction::gesture-cancel signal.
         *
         * A negative value will be interpreted as the default drag threshold.
         */
        get thresholdTriggerDistanceY(): number;
        /**
         * The trigger edge to be used by the action to either emit the
         * #ClutterGestureAction::gesture-begin signal or to emit the
         * #ClutterGestureAction::gesture-cancel signal.
         */
        get threshold_trigger_edge(): GestureTriggerEdge;
        /**
         * The trigger edge to be used by the action to either emit the
         * #ClutterGestureAction::gesture-begin signal or to emit the
         * #ClutterGestureAction::gesture-cancel signal.
         */
        get thresholdTriggerEdge(): GestureTriggerEdge;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: GestureAction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<GestureAction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): GestureAction;

        // Signals

        connect<K extends keyof GestureAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, GestureAction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof GestureAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, GestureAction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof GestureAction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<GestureAction.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_gesture_begin(actor: Actor): boolean;
        vfunc_gesture_cancel(actor: Actor): void;
        vfunc_gesture_end(actor: Actor): void;
        vfunc_gesture_prepare(actor: Actor): boolean;
        vfunc_gesture_progress(actor: Actor): boolean;

        // Methods

        /**
         * Cancel a #ClutterGestureAction before it begins
         */
        cancel(): void;
        /**
         * Retrieves the #ClutterInputDevice of a touch point.
         * @param point the touch point index, with 0 being the first touch   point received by the action
         * @returns the #ClutterInputDevice of a touch point.
         */
        get_device(point: number): InputDevice;
        /**
         * Retrieves a reference to the last #ClutterEvent for a touch point. Call
         * clutter_event_copy() if you need to store the reference somewhere.
         * @param point index of a point currently active
         * @returns the last #ClutterEvent for a touch point.
         */
        get_last_event(point: number): Event;
        /**
         * Retrieves the coordinates, in stage space, of the latest motion
         * event during the dragging.
         * @param point the touch point index, with 0 being the first touch   point received by the action
         */
        get_motion_coords(point: number): [number, number];
        /**
         * Retrieves the incremental delta since the last motion event
         * during the dragging.
         * @param point the touch point index, with 0 being the first touch   point received by the action
         * @returns the distance since last motion event
         */
        get_motion_delta(point: number): [number, number, number];
        /**
         * Retrieves the number of points currently active.
         * @returns the number of points currently active.
         */
        get_n_current_points(): number;
        /**
         * Retrieves the number of requested points to trigger the gesture.
         * @returns the number of points to trigger the gesture.
         */
        get_n_touch_points(): number;
        /**
         * Retrieves the coordinates, in stage space, of the press event
         * that started the dragging for a specific touch point.
         * @param point the touch point index, with 0 being the first touch   point received by the action
         */
        get_press_coords(point: number): [number, number];
        /**
         * Retrieves the coordinates, in stage space, where the touch point was
         * last released.
         * @param point the touch point index, with 0 being the first touch   point received by the action
         */
        get_release_coords(point: number): [number, number];
        /**
         * Retrieves the #ClutterEventSequence of a touch point.
         * @param point index of a point currently active
         * @returns the #ClutterEventSequence of a touch point.
         */
        get_sequence(point: number): EventSequence;
        /**
         * Retrieves the threshold trigger distance of the gesture `action,`
         * as set using clutter_gesture_action_set_threshold_trigger_distance().
         */
        get_threshold_trigger_distance(): [number, number];
        /**
         * Retrieves the edge trigger of the gesture `action,` as set using
         * clutter_gesture_action_set_threshold_trigger_edge().
         * @returns the edge trigger
         */
        get_threshold_trigger_edge(): GestureTriggerEdge;
        /**
         * Retrieves the edge trigger of the gesture `action,` as set using
         * clutter_gesture_action_set_threshold_trigger_edge().
         * @returns the edge trigger
         */
        get_threshold_trigger_egde(): GestureTriggerEdge;
        /**
         * Retrieves the velocity, in stage pixels per millisecond, of the
         * latest motion event during the dragging.
         * @param point the touch point index, with 0 being the first touch   point received by the action
         */
        get_velocity(point: number): [number, number, number];
        /**
         * Sets the number of points needed to trigger the gesture.
         * @param nb_points a number of points
         */
        set_n_touch_points(nb_points: number): void;
        /**
         * Sets the threshold trigger distance for the gesture drag threshold, if any.
         *
         * This function should only be called by sub-classes of
         * #ClutterGestureAction during their construction phase.
         * @param x the distance on the horizontal axis
         * @param y the distance on the vertical axis
         */
        set_threshold_trigger_distance(x: number, y: number): void;
        /**
         * Sets the edge trigger for the gesture drag threshold, if any.
         *
         * This function should only be called by sub-classes of
         * #ClutterGestureAction during their construction phase.
         * @param edge the %ClutterGestureTriggerEdge
         */
        set_threshold_trigger_edge(edge: GestureTriggerEdge | null): void;
    }

    namespace GridLayout {
        // Signal signatures
        interface SignalSignatures extends LayoutManager.SignalSignatures {
            'notify::column-homogeneous': (pspec: GObject.ParamSpec) => void;
            'notify::column-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::orientation': (pspec: GObject.ParamSpec) => void;
            'notify::row-homogeneous': (pspec: GObject.ParamSpec) => void;
            'notify::row-spacing': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends LayoutManager.ConstructorProps {
            column_homogeneous: boolean;
            columnHomogeneous: boolean;
            column_spacing: number;
            columnSpacing: number;
            orientation: Orientation;
            row_homogeneous: boolean;
            rowHomogeneous: boolean;
            row_spacing: number;
            rowSpacing: number;
        }
    }

    /**
     * The #ClutterGridLayout structure contains only private data
     * and should be accessed using the provided API
     */
    class GridLayout extends LayoutManager {
        static $gtype: GObject.GType<GridLayout>;

        // Properties

        /**
         * Whether all columns of the layout should have the same width
         */
        get column_homogeneous(): boolean;
        set column_homogeneous(val: boolean);
        /**
         * Whether all columns of the layout should have the same width
         */
        get columnHomogeneous(): boolean;
        set columnHomogeneous(val: boolean);
        /**
         * The amount of space in pixels between two consecutive columns
         */
        get column_spacing(): number;
        set column_spacing(val: number);
        /**
         * The amount of space in pixels between two consecutive columns
         */
        get columnSpacing(): number;
        set columnSpacing(val: number);
        /**
         * The orientation of the layout, either horizontal or vertical
         */
        get orientation(): Orientation;
        set orientation(val: Orientation);
        /**
         * Whether all rows of the layout should have the same height
         */
        get row_homogeneous(): boolean;
        set row_homogeneous(val: boolean);
        /**
         * Whether all rows of the layout should have the same height
         */
        get rowHomogeneous(): boolean;
        set rowHomogeneous(val: boolean);
        /**
         * The amount of space in pixels between two consecutive rows
         */
        get row_spacing(): number;
        set row_spacing(val: number);
        /**
         * The amount of space in pixels between two consecutive rows
         */
        get rowSpacing(): number;
        set rowSpacing(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: GridLayout.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<GridLayout.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): GridLayout;

        // Signals

        connect<K extends keyof GridLayout.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, GridLayout.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof GridLayout.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, GridLayout.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof GridLayout.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<GridLayout.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Adds a widget to the grid.
         *
         * The position of `child` is determined by `left` and `top`. The
         * number of 'cells' that `child` will occupy is determined by
         * `width` and `height`.
         * @param child the #ClutterActor to add
         * @param left the column number to attach the left side of @child to
         * @param top the row number to attach the top side of @child to
         * @param width the number of columns that @child will span
         * @param height the number of rows that @child will span
         */
        attach(child: Actor, left: number, top: number, width: number, height: number): void;
        /**
         * Adds a actor to the grid.
         *
         * The actor is placed next to `sibling,` on the side determined by
         * `side`. When `sibling` is %NULL, the actor is placed in row (for
         * left or right placement) or column 0 (for top or bottom placement),
         * at the end indicated by `side`.
         *
         * Attaching widgets labeled [1], [2], [3] with `sibling` == %NULL and
         * `side` == %CLUTTER_GRID_POSITION_LEFT yields a layout of [3][2][1].
         * @param child the actor to add
         * @param sibling the child of @layout that @child will be placed     next to, or %NULL to place @child at the beginning or end
         * @param side the side of @sibling that @child is positioned next to
         * @param width the number of columns that @child will span
         * @param height the number of rows that @child will span
         */
        attach_next_to(
            child: Actor,
            sibling: Actor | null,
            side: GridPosition | null,
            width: number,
            height: number,
        ): void;
        /**
         * Gets the child of `layout` whose area covers the grid
         * cell whose upper left corner is at `left,` `top`.
         * @param left the left edge of the cell
         * @param top the top edge of the cell
         * @returns the child at the given position, or %NULL
         */
        get_child_at(left: number, top: number): Actor;
        /**
         * Returns whether all columns of `layout` have the same width.
         * @returns whether all columns of @layout have the same width.
         */
        get_column_homogeneous(): boolean;
        /**
         * Retrieves the spacing set using clutter_grid_layout_set_column_spacing()
         * @returns the spacing between coluns of @layout
         */
        get_column_spacing(): number;
        /**
         * Retrieves the orientation of the `layout`.
         * @returns the orientation of the layout
         */
        get_orientation(): Orientation;
        /**
         * Returns whether all rows of `layout` have the same height.
         * @returns whether all rows of @layout have the same height.
         */
        get_row_homogeneous(): boolean;
        /**
         * Retrieves the spacing set using clutter_grid_layout_set_row_spacing()
         * @returns the spacing between rows of @layout
         */
        get_row_spacing(): number;
        /**
         * Inserts a column at the specified position.
         *
         * Children which are attached at or to the right of this position
         * are moved one column to the right. Children which span across this
         * position are grown to span the new column.
         * @param position the position to insert the column at
         */
        insert_column(position: number): void;
        /**
         * Inserts a row or column at the specified position.
         *
         * The new row or column is placed next to `sibling,` on the side
         * determined by `side`. If `side` is %CLUTTER_GRID_POSITION_LEFT or
         * %CLUTTER_GRID_POSITION_BOTTOM, a row is inserted. If `side` is
         * %CLUTTER_GRID_POSITION_LEFT of %CLUTTER_GRID_POSITION_RIGHT,
         * a column is inserted.
         * @param sibling the child of @layout that the new row or column will be     placed next to
         * @param side the side of @sibling that @child is positioned next to
         */
        insert_next_to(sibling: Actor, side: GridPosition | null): void;
        /**
         * Inserts a row at the specified position.
         *
         * Children which are attached at or below this position
         * are moved one row down. Children which span across this
         * position are grown to span the new row.
         * @param position the position to insert the row at
         */
        insert_row(position: number): void;
        /**
         * Sets whether all columns of `layout` will have the same width.
         * @param homogeneous %TRUE to make columns homogeneous
         */
        set_column_homogeneous(homogeneous: boolean): void;
        /**
         * Sets the spacing between columns of `layout`
         * @param spacing the spacing between columns of the layout, in pixels
         */
        set_column_spacing(spacing: number): void;
        /**
         * Sets the orientation of the `layout`.
         *
         * #ClutterGridLayout uses the orientation as a hint when adding
         * children to the #ClutterActor using it as a layout manager via
         * clutter_actor_add_child(); changing this value will not have
         * any effect on children that are already part of the layout.
         * @param orientation the orientation of the #ClutterGridLayout
         */
        set_orientation(orientation: Orientation | null): void;
        /**
         * Sets whether all rows of `layout` will have the same height.
         * @param homogeneous %TRUE to make rows homogeneous
         */
        set_row_homogeneous(homogeneous: boolean): void;
        /**
         * Sets the spacing between rows of `layout`
         * @param spacing the spacing between rows of the layout, in pixels
         */
        set_row_spacing(spacing: number): void;
    }

    namespace Group {
        // Signal signatures
        interface SignalSignatures extends Actor.SignalSignatures {
            'notify::actions': (pspec: GObject.ParamSpec) => void;
            'notify::allocation': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-x': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-y': (pspec: GObject.ParamSpec) => void;
            'notify::background-color': (pspec: GObject.ParamSpec) => void;
            'notify::background-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::clip': (pspec: GObject.ParamSpec) => void;
            'notify::clip-rect': (pspec: GObject.ParamSpec) => void;
            'notify::clip-to-allocation': (pspec: GObject.ParamSpec) => void;
            'notify::constraints': (pspec: GObject.ParamSpec) => void;
            'notify::content': (pspec: GObject.ParamSpec) => void;
            'notify::content-box': (pspec: GObject.ParamSpec) => void;
            'notify::content-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::content-repeat': (pspec: GObject.ParamSpec) => void;
            'notify::depth': (pspec: GObject.ParamSpec) => void;
            'notify::effect': (pspec: GObject.ParamSpec) => void;
            'notify::first-child': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-position-set': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-x': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-y': (pspec: GObject.ParamSpec) => void;
            'notify::has-clip': (pspec: GObject.ParamSpec) => void;
            'notify::has-pointer': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::last-child': (pspec: GObject.ParamSpec) => void;
            'notify::layout-manager': (pspec: GObject.ParamSpec) => void;
            'notify::magnification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::mapped': (pspec: GObject.ParamSpec) => void;
            'notify::margin-bottom': (pspec: GObject.ParamSpec) => void;
            'notify::margin-left': (pspec: GObject.ParamSpec) => void;
            'notify::margin-right': (pspec: GObject.ParamSpec) => void;
            'notify::margin-top': (pspec: GObject.ParamSpec) => void;
            'notify::min-height': (pspec: GObject.ParamSpec) => void;
            'notify::min-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::min-width': (pspec: GObject.ParamSpec) => void;
            'notify::min-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::minification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::offscreen-redirect': (pspec: GObject.ParamSpec) => void;
            'notify::opacity': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point-z': (pspec: GObject.ParamSpec) => void;
            'notify::position': (pspec: GObject.ParamSpec) => void;
            'notify::reactive': (pspec: GObject.ParamSpec) => void;
            'notify::realized': (pspec: GObject.ParamSpec) => void;
            'notify::request-mode': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-zgravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-z': (pspec: GObject.ParamSpec) => void;
            'notify::show-on-set-parent': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::text-direction': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::translation-x': (pspec: GObject.ParamSpec) => void;
            'notify::translation-y': (pspec: GObject.ParamSpec) => void;
            'notify::translation-z': (pspec: GObject.ParamSpec) => void;
            'notify::visible': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::x-align': (pspec: GObject.ParamSpec) => void;
            'notify::x-expand': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::y-align': (pspec: GObject.ParamSpec) => void;
            'notify::y-expand': (pspec: GObject.ParamSpec) => void;
            'notify::z-position': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Actor.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Animatable.ConstructorProps,
                Container.ConstructorProps,
                Scriptable.ConstructorProps {}
    }

    /**
     * The #ClutterGroup structure contains only private data
     * and should be accessed using the provided API
     */
    class Group extends Actor implements Atk.ImplementorIface, Animatable, Container, Scriptable {
        static $gtype: GObject.GType<Group>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Group.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Group.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Group;

        // Signals

        connect<K extends keyof Group.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Group.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Group.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Group.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Group.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Group.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Gets the number of actors held in the group.
         * @returns The number of child actors held in the group.
         */
        get_n_children(): number;
        /**
         * Gets a groups child held at `index_` in stack.
         * @param index_ the position of the requested actor.
         * @returns A Clutter actor, or %NULL if   @index_ is invalid.
         */
        get_nth_child(index_: number): Actor;
        /**
         * Removes all children actors from the #ClutterGroup.
         */
        remove_all(): void;

        // Inherited methods
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         * @returns %TRUE if the value has been validated and can   be applied to the #ClutterAnimatable, and %FALSE otherwise
         */
        animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         * @returns The #GParamSpec for the given property   or %NULL
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         * @returns %TRUE if the interpolation was successful,   and %FALSE otherwise
         */
        interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         */
        vfunc_animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         */
        vfunc_find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        vfunc_get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         */
        vfunc_interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        vfunc_set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        add_actor(actor: Actor): void;
        /**
         * Gets a container specific property of a child of `container,` In general,
         * a copy is made of the property contents and the caller is responsible for
         * freeing the memory by calling g_value_unset().
         *
         * Note that clutter_container_child_set_property() is really intended for
         * language bindings, clutter_container_child_set() is much more convenient
         * for C programming.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_get_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Sets a container-specific property on a child of `container`.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_set_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        destroy_child_meta(actor: Actor): void;
        /**
         * Finds a child actor of a container by its name. Search recurses
         * into any child container.
         * @param child_name the name of the requested child.
         * @returns The child actor with the requested name,   or %NULL if no actor with that name was found.
         */
        find_child_by_name(child_name: string): Actor;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         * @returns the #ClutterChildMeta for the @actor child   of @container or %NULL if the specifiec actor does not exist or the   container is not configured to provide #ClutterChildMeta<!-- -->s
         */
        get_child_meta(actor: Actor): ChildMeta;
        /**
         * Retrieves all the children of `container`.
         * @returns a list   of #ClutterActor<!-- -->s. Use g_list_free() on the returned   list when done.
         */
        get_children(): Actor[];
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        lower_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        raise_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        remove_actor(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        sort_depth_order(): void;
        vfunc_actor_added(actor: Actor): void;
        vfunc_actor_removed(actor: Actor): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        vfunc_add(actor: Actor): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        vfunc_child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_destroy_child_meta(actor: Actor): void;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         */
        vfunc_get_child_meta(actor: Actor): ChildMeta;
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        vfunc_lower(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        vfunc_raise(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        vfunc_remove(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        vfunc_sort_depth_order(): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Image {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Content.ConstructorProps {}
    }

    /**
     * The #ClutterImage structure contains
     * private data and should only be accessed using the provided
     * API.
     */
    class Image extends GObject.Object implements Content {
        static $gtype: GObject.GType<Image>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Image.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Image.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof Image.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Image.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Image.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Image.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Image.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Image.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Creates a new #ClutterImage instance.
         */
        static ['new'](): Content;

        // Methods

        /**
         * Sets the image data to be display by `image,` using `rect` to indicate
         * the position and size of the image data to be set.
         *
         * If the `image` does not have any image data set when this function is
         * called, a new texture will be created with the size of the width and
         * height of the rectangle, i.e. calling this function on a newly created
         * #ClutterImage will be the equivalent of calling clutter_image_set_data().
         *
         * If the image data was successfully loaded, the `image` will be invalidated.
         *
         * In case of error, the `error` value will be set, and this function will
         * return %FALSE.
         *
         * The image data is copied in texture memory.
         * @param data the image data, as an array of bytes
         * @param pixel_format the Cogl pixel format of the image data
         * @param rect a rectangle indicating the area that should be set
         * @param row_stride the length of each row inside @data
         * @returns %TRUE if the image data was successfully loaded,   and %FALSE otherwise.
         */
        set_area(
            data: Uint8Array | string,
            pixel_format: Cogl.PixelFormat | null,
            rect: cairo.RectangleInt,
            row_stride: number,
        ): boolean;
        /**
         * Sets the image data stored inside a #GBytes to be displayed by `image`.
         *
         * If the image data was successfully loaded, the `image` will be invalidated.
         *
         * In case of error, the `error` value will be set, and this function will
         * return %FALSE.
         *
         * The image data contained inside the #GBytes is copied in texture memory,
         * and no additional reference is acquired on the `data`.
         * @param data the image data, as a #GBytes
         * @param pixel_format the Cogl pixel format of the image data
         * @param width the width of the image data
         * @param height the height of the image data
         * @param row_stride the length of each row inside @data
         * @returns %TRUE if the image data was successfully loaded,   and %FALSE otherwise.
         */
        set_bytes(
            data: GLib.Bytes | Uint8Array,
            pixel_format: Cogl.PixelFormat | null,
            width: number,
            height: number,
            row_stride: number,
        ): boolean;
        /**
         * Sets the image data to be displayed by `image`.
         *
         * If the image data was successfully loaded, the `image` will be invalidated.
         *
         * In case of error, the `error` value will be set, and this function will
         * return %FALSE.
         *
         * The image data is copied in texture memory.
         *
         * The image data is expected to be a linear array of RGBA or RGB pixel data;
         * how to retrieve that data is left to platform specific image loaders. For
         * instance, if you use the GdkPixbuf library:
         *
         *
         * ```c
         *   ClutterContent *image = clutter_image_new ();
         *
         *   GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file (filename, NULL);
         *
         *   clutter_image_set_data (CLUTTER_IMAGE (image),
         *                           gdk_pixbuf_get_pixels (pixbuf),
         *                           gdk_pixbuf_get_has_alpha (pixbuf)
         *                             ? COGL_PIXEL_FORMAT_RGBA_8888
         *                             : COGL_PIXEL_FORMAT_RGB_888,
         *                           gdk_pixbuf_get_width (pixbuf),
         *                           gdk_pixbuf_get_height (pixbuf),
         *                           gdk_pixbuf_get_rowstride (pixbuf),
         *                           &error);
         *
         *   g_object_unref (pixbuf);
         * ```
         *
         * @param data the image data, as an array of bytes
         * @param pixel_format the Cogl pixel format of the image data
         * @param width the width of the image data
         * @param height the height of the image data
         * @param row_stride the length of each row inside @data
         * @returns %TRUE if the image data was successfully loaded,   and %FALSE otherwise.
         */
        set_data(
            data: Uint8Array | string,
            pixel_format: Cogl.PixelFormat | null,
            width: number,
            height: number,
            row_stride: number,
        ): boolean;
        // Conflicted with GObject.Object.set_data
        set_data(...args: never[]): any;

        // Inherited methods
        /**
         * Retrieves the natural size of the `content,` if any.
         *
         * The natural size of a #ClutterContent is defined as the size the content
         * would have regardless of the allocation of the actor that is painting it,
         * for instance the size of an image data.
         * @returns %TRUE if the content has a preferred size, and %FALSE   otherwise
         */
        get_preferred_size(): [boolean, number, number];
        /**
         * Invalidates a #ClutterContent.
         *
         * This function should be called by #ClutterContent implementations when
         * they change the way a the content should be painted regardless of the
         * actor state.
         */
        invalidate(): void;
        vfunc_attached(actor: Actor): void;
        vfunc_detached(actor: Actor): void;
        /**
         * Retrieves the natural size of the `content,` if any.
         *
         * The natural size of a #ClutterContent is defined as the size the content
         * would have regardless of the allocation of the actor that is painting it,
         * for instance the size of an image data.
         */
        vfunc_get_preferred_size(): [boolean, number, number];
        /**
         * Invalidates a #ClutterContent.
         *
         * This function should be called by #ClutterContent implementations when
         * they change the way a the content should be painted regardless of the
         * actor state.
         */
        vfunc_invalidate(): void;
        vfunc_paint_content(actor: Actor, node: PaintNode): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace InputDevice {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::backend': (pspec: GObject.ParamSpec) => void;
            'notify::device-manager': (pspec: GObject.ParamSpec) => void;
            'notify::device-mode': (pspec: GObject.ParamSpec) => void;
            'notify::device-type': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::has-cursor': (pspec: GObject.ParamSpec) => void;
            'notify::id': (pspec: GObject.ParamSpec) => void;
            'notify::n-axes': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::product-id': (pspec: GObject.ParamSpec) => void;
            'notify::vendor-id': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            backend: Backend;
            device_manager: DeviceManager;
            deviceManager: DeviceManager;
            device_mode: InputMode;
            deviceMode: InputMode;
            device_type: InputDeviceType;
            deviceType: InputDeviceType;
            enabled: boolean;
            has_cursor: boolean;
            hasCursor: boolean;
            id: number;
            n_axes: number;
            nAxes: number;
            name: string;
            product_id: string;
            productId: string;
            vendor_id: string;
            vendorId: string;
        }
    }

    /**
     * Generic representation of an input device. The actual contents of this
     * structure depend on the backend used.
     */
    class InputDevice extends GObject.Object {
        static $gtype: GObject.GType<InputDevice>;

        // Properties

        /**
         * The #ClutterBackend that created the device.
         */
        get backend(): Backend;
        /**
         * The #ClutterDeviceManager instance which owns the device
         */
        get device_manager(): DeviceManager;
        /**
         * The #ClutterDeviceManager instance which owns the device
         */
        get deviceManager(): DeviceManager;
        get device_mode(): InputMode;
        get deviceMode(): InputMode;
        /**
         * The type of the device
         */
        get device_type(): InputDeviceType;
        /**
         * The type of the device
         */
        get deviceType(): InputDeviceType;
        /**
         * Whether the device is enabled.
         *
         * A device with the #ClutterInputDevice:device-mode property set
         * to %CLUTTER_INPUT_MODE_MASTER cannot be disabled.
         *
         * A device must be enabled in order to receive events from it.
         */
        get enabled(): boolean;
        set enabled(val: boolean);
        /**
         * Whether the device has an on screen cursor following its movement.
         */
        get has_cursor(): boolean;
        /**
         * Whether the device has an on screen cursor following its movement.
         */
        get hasCursor(): boolean;
        /**
         * The unique identifier of the device
         */
        get id(): number;
        /**
         * The number of axes of the device.
         */
        get n_axes(): number;
        /**
         * The number of axes of the device.
         */
        get nAxes(): number;
        /**
         * The name of the device
         */
        get name(): string;
        /**
         * Product ID of this device.
         */
        get product_id(): string;
        /**
         * Product ID of this device.
         */
        get productId(): string;
        /**
         * Vendor ID of this device.
         */
        get vendor_id(): string;
        /**
         * Vendor ID of this device.
         */
        get vendorId(): string;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: InputDevice.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<InputDevice.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof InputDevice.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, InputDevice.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof InputDevice.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, InputDevice.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof InputDevice.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<InputDevice.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves a pointer to the #ClutterInputDevice that has been
         * associated to `device`.
         *
         * If the #ClutterInputDevice:device-mode property of `device` is
         * set to %CLUTTER_INPUT_MODE_MASTER, this function will return
         * %NULL.
         * @returns a #ClutterInputDevice, or %NULL
         */
        get_associated_device(): InputDevice;
        /**
         * Retrieves the type of axis on `device` at the given index.
         * @param index_ the index of the axis
         * @returns the axis type
         */
        get_axis(index_: number): InputAxis;
        /**
         * Extracts the value of the given `axis` of a #ClutterInputDevice from
         * an array of axis values.
         *
         * An example of typical usage for this function is:
         *
         *
         * ```
         *   ClutterInputDevice *device = clutter_event_get_device (event);
         *   gdouble *axes = clutter_event_get_axes (event, NULL);
         *   gdouble pressure_value = 0;
         *
         *   clutter_input_device_get_axis_value (device, axes,
         *                                        CLUTTER_INPUT_AXIS_PRESSURE,
         *                                        &pressure_value);
         * ```
         *
         * @param axes an array of axes values, typically   coming from clutter_event_get_axes()
         * @param axis the axis to extract
         * @returns %TRUE if the value was set, and %FALSE otherwise
         */
        get_axis_value(axes: number[], axis: InputAxis | null): [boolean, number];
        /**
         * Retrieves the latest coordinates of a pointer or touch point of
         * `device`.
         * @param sequence a #ClutterEventSequence, or %NULL if   the device is not touch-based
         * @returns %FALSE if the device's sequence hasn't been found,   and %TRUE otherwise.
         */
        get_coords(sequence: EventSequence | null): [boolean, Point];
        /**
         * Retrieves the latest coordinates of the pointer of `device`
         */
        get_device_coords(): [number, number];
        /**
         * Retrieves the unique identifier of `device`
         * @returns the identifier of the device
         */
        get_device_id(): number;
        /**
         * Retrieves the #ClutterInputMode of `device`.
         * @returns the device mode
         */
        get_device_mode(): InputMode;
        /**
         * Retrieves the name of the `device`
         * @returns the name of the device, or %NULL. The returned string   is owned by the #ClutterInputDevice and should never be modified   or freed
         */
        get_device_name(): string;
        /**
         * Retrieves the type of `device`
         * @returns the type of the device
         */
        get_device_type(): InputDeviceType;
        /**
         * Retrieves whether `device` is enabled.
         * @returns %TRUE if the device is enabled
         */
        get_enabled(): boolean;
        /**
         * Retrieves a pointer to the #ClutterActor currently grabbing all
         * the events coming from `device`.
         * @returns a #ClutterActor, or %NULL
         */
        get_grabbed_actor(): Actor;
        /**
         * Retrieves whether `device` has a pointer that follows the
         * device motion.
         * @returns %TRUE if the device has a cursor
         */
        get_has_cursor(): boolean;
        /**
         * Retrieves the key set using clutter_input_device_set_key()
         * @param index_ the index of the key
         * @returns %TRUE if a key was set at the given index
         */
        get_key(index_: number): [boolean, number, ModifierType];
        /**
         * Retrieves the current modifiers state of the device, as seen
         * by the last event Clutter processed.
         * @returns the last known modifier state
         */
        get_modifier_state(): ModifierType;
        /**
         * Retrieves the number of axes available on `device`.
         * @returns the number of axes on the device
         */
        get_n_axes(): number;
        /**
         * Retrieves the number of keys registered for `device`.
         * @returns the number of registered keys
         */
        get_n_keys(): number;
        /**
         * Retrieves the #ClutterActor underneath the pointer of `device`
         * @returns a pointer to the #ClutterActor or %NULL
         */
        get_pointer_actor(): Actor;
        /**
         * Retrieves the #ClutterStage underneath the pointer of `device`
         * @returns a pointer to the #ClutterStage or %NULL
         */
        get_pointer_stage(): Stage;
        /**
         * Gets the product ID of this device.
         * @returns the product ID
         */
        get_product_id(): string;
        /**
         * Retrieves the slave devices attached to `device`.
         * @returns a   list of #ClutterInputDevice, or %NULL. The contents of the list are   owned by the device. Use g_list_free() when done
         */
        get_slave_devices(): InputDevice[];
        /**
         * Gets the vendor ID of this device.
         * @returns the vendor ID
         */
        get_vendor_id(): string;
        /**
         * Acquires a grab on `actor` for the given `device`.
         *
         * Any event coming from `device` will be delivered to `actor,` bypassing
         * the usual event delivery mechanism, until the grab is released by
         * calling clutter_input_device_ungrab().
         *
         * The grab is client-side: even if the windowing system used by the Clutter
         * backend has the concept of "device grabs", Clutter will not use them.
         *
         * Only #ClutterInputDevice of types %CLUTTER_POINTER_DEVICE and
         * %CLUTTER_KEYBOARD_DEVICE can hold a grab.
         * @param actor a #ClutterActor
         */
        grab(actor: Actor): void;
        /**
         * Translates a hardware keycode from a #ClutterKeyEvent to the
         * equivalent evdev keycode. Note that depending on the input backend
         * used by Clutter this function can fail if there is no obvious
         * mapping between the key codes. The hardware keycode can be taken
         * from the #ClutterKeyEvent.hardware_keycode member of #ClutterKeyEvent.
         * @param hardware_keycode The hardware keycode from a #ClutterKeyEvent
         * @param evdev_keycode The return location for the evdev keycode
         * @returns %TRUE if the conversion succeeded, %FALSE otherwise.
         */
        keycode_to_evdev(hardware_keycode: number, evdev_keycode: number): boolean;
        /**
         * Retrieves a pointer to the #ClutterActor currently grabbing the
         * touch events coming from `device` given the `sequence`.
         * @param sequence a #ClutterEventSequence
         * @returns a #ClutterActor, or %NULL
         */
        sequence_get_grabbed_actor(sequence: EventSequence): Actor;
        /**
         * Acquires a grab on `actor` for the given `device` and the given touch
         * `sequence`.
         *
         * Any touch event coming from `device` and from `sequence` will be
         * delivered to `actor,` bypassing the usual event delivery mechanism,
         * until the grab is released by calling
         * clutter_input_device_sequence_ungrab().
         *
         * The grab is client-side: even if the windowing system used by the Clutter
         * backend has the concept of "device grabs", Clutter will not use them.
         * @param sequence a #ClutterEventSequence
         * @param actor a #ClutterActor
         */
        sequence_grab(sequence: EventSequence, actor: Actor): void;
        /**
         * Releases the grab on the `device` for the given `sequence,` if one is
         * in place.
         * @param sequence a #ClutterEventSequence
         */
        sequence_ungrab(sequence: EventSequence): void;
        /**
         * Enables or disables a #ClutterInputDevice.
         *
         * Only devices with a #ClutterInputDevice:device-mode property set
         * to %CLUTTER_INPUT_MODE_SLAVE or %CLUTTER_INPUT_MODE_FLOATING can
         * be disabled.
         * @param enabled %TRUE to enable the @device
         */
        set_enabled(enabled: boolean): void;
        /**
         * Sets the keyval and modifiers at the given `index_` for `device`.
         *
         * Clutter will use the keyval and modifiers set when filling out
         * an event coming from the same input device.
         * @param index_ the index of the key
         * @param keyval the keyval
         * @param modifiers a bitmask of modifiers
         */
        set_key(index_: number, keyval: number, modifiers: ModifierType | null): void;
        /**
         * Releases the grab on the `device,` if one is in place.
         */
        ungrab(): void;
        /**
         * Forcibly updates the state of the `device` using a #ClutterEvent
         *
         * This function should never be used by applications: it is meant
         * for integration with embedding toolkits, like clutter-gtk
         *
         * Embedding toolkits that disable the event collection inside Clutter
         * need to use this function to update the state of input devices depending
         * on a #ClutterEvent that they are going to submit to the event handling code
         * in Clutter though clutter_do_event(). Since the input devices hold the state
         * that is going to be used to fill in fields like the #ClutterButtonEvent
         * click count, or to emit synthesized events like %CLUTTER_ENTER and
         * %CLUTTER_LEAVE, it is necessary for embedding toolkits to also be
         * responsible of updating the input device state.
         *
         * For instance, this might be the code to translate an embedding toolkit
         * native motion notification into a Clutter #ClutterMotionEvent and ask
         * Clutter to process it:
         *
         *
         * ```
         *   ClutterEvent c_event;
         *
         *   translate_native_event_to_clutter (native_event, &c_event);
         *
         *   clutter_do_event (&c_event);
         * ```
         *
         *
         * Before letting clutter_do_event() process the event, it is necessary to call
         * clutter_input_device_update_from_event():
         *
         *
         * ```
         *   ClutterEvent c_event;
         *   ClutterDeviceManager *manager;
         *   ClutterInputDevice *device;
         *
         *   translate_native_event_to_clutter (native_event, &c_event);
         *
         *   // get the device manager
         *   manager = clutter_device_manager_get_default ();
         *
         *   // use the default Core Pointer that Clutter backends register by default
         *   device = clutter_device_manager_get_core_device (manager, %CLUTTER_POINTER_DEVICE);
         *
         *   // update the state of the input device
         *   clutter_input_device_update_from_event (device, &c_event, FALSE);
         *
         *   clutter_do_event (&c_event);
         * ```
         *
         *
         * The `update_stage` boolean argument should be used when the input device
         * enters and leaves a #ClutterStage; it will use the #ClutterStage field
         * of the passed `event` to update the stage associated to the input device.
         * @param event a #ClutterEvent
         * @param update_stage whether to update the #ClutterStage of the @device   using the stage of the event
         */
        update_from_event(event: Event, update_stage: boolean): void;
    }

    namespace Interval {
        // Signal signatures
        interface SignalSignatures extends GObject.InitiallyUnowned.SignalSignatures {
            'notify::final': (pspec: GObject.ParamSpec) => void;
            'notify::initial': (pspec: GObject.ParamSpec) => void;
            'notify::value-type': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.InitiallyUnowned.ConstructorProps, Scriptable.ConstructorProps {
            final: GObject.Value;
            initial: GObject.Value;
            value_type: GObject.GType;
            valueType: GObject.GType;
        }
    }

    /**
     * The #ClutterInterval structure contains only private data and should
     * be accessed using the provided functions.
     */
    class Interval extends GObject.InitiallyUnowned implements Scriptable {
        static $gtype: GObject.GType<Interval>;

        // Properties

        /**
         * The final value of the interval.
         */
        get final(): GObject.Value;
        set final(val: GObject.Value);
        /**
         * The initial value of the interval.
         */
        get initial(): GObject.Value;
        set initial(val: GObject.Value);
        /**
         * The type of the values in the interval.
         */
        get value_type(): GObject.GType;
        /**
         * The type of the values in the interval.
         */
        get valueType(): GObject.GType;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Interval.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Interval.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static new_with_values(
            gtype: GObject.GType,
            initial?: GObject.Value | null,
            _final?: GObject.Value | null,
        ): Interval;

        // Signals

        connect<K extends keyof Interval.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Interval.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Interval.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Interval.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Interval.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Interval.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        /**
         * Computes the value between the `interval` boundaries given the
         * progress `factor` and copies it into `value`.
         * @param factor the progress factor, between 0 and 1
         */
        vfunc_compute_value(factor: number): [boolean, unknown];
        /**
         * Validates the initial and final values of `interval` against
         * a #GParamSpec.
         * @param pspec a #GParamSpec
         */
        vfunc_validate(pspec: GObject.ParamSpec): boolean;

        // Methods

        /**
         * Creates a copy of `interval`.
         * @returns the newly created #ClutterInterval
         */
        clone(): Interval;
        /**
         * Computes the value between the `interval` boundaries given the
         * progress `factor`
         *
         * Unlike clutter_interval_compute_value(), this function will
         * return a const pointer to the computed value
         *
         * You should use this function if you immediately pass the computed
         * value to another function that makes a copy of it, like
         * g_object_set_property()
         * @param factor the progress factor, between 0 and 1
         * @returns a pointer to the computed value,   or %NULL if the computation was not successfull
         */
        compute(factor: number): unknown;
        /**
         * Computes the value between the `interval` boundaries given the
         * progress `factor` and copies it into `value`.
         * @param factor the progress factor, between 0 and 1
         * @returns %TRUE if the operation was successful
         */
        compute_value(factor: number): [boolean, unknown];
        /**
         * Retrieves the final value of `interval` and copies
         * it into `value`.
         *
         * The passed #GValue must be initialized to the value held by
         * the #ClutterInterval.
         */
        get_final_value(): unknown;
        /**
         * Retrieves the initial value of `interval` and copies
         * it into `value`.
         *
         * The passed #GValue must be initialized to the value held by
         * the #ClutterInterval.
         */
        get_initial_value(): unknown;
        /**
         * Retrieves the #GType of the values inside `interval`.
         * @returns the type of the value, or G_TYPE_INVALID
         */
        get_value_type(): GObject.GType;
        /**
         * Checks if the `interval` has a valid initial and final values.
         * @returns %TRUE if the #ClutterInterval has an initial and   final values, and %FALSE otherwise
         */
        is_valid(): boolean;
        /**
         * Gets the pointer to the final value of `interval`
         * @returns the final value of the interval.   The value is owned by the #ClutterInterval and it should not be   modified or freed
         */
        peek_final_value(): unknown;
        /**
         * Gets the pointer to the initial value of `interval`
         * @returns the initial value of the interval.   The value is owned by the #ClutterInterval and it should not be   modified or freed
         */
        peek_initial_value(): unknown;
        /**
         * Sets the final value of `interval` to `value`. The value is
         * copied inside the #ClutterInterval.
         * @param value a #GValue
         */
        set_final(value: GObject.Value | any): void;
        /**
         * Sets the initial value of `interval` to `value`. The value is copied
         * inside the #ClutterInterval.
         * @param value a #GValue
         */
        set_initial(value: GObject.Value | any): void;
        /**
         * Validates the initial and final values of `interval` against
         * a #GParamSpec.
         * @param pspec a #GParamSpec
         * @returns %TRUE if the #ClutterInterval is valid, %FALSE otherwise
         */
        validate(pspec: GObject.ParamSpec): boolean;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace KeyframeTransition {
        // Signal signatures
        interface SignalSignatures extends PropertyTransition.SignalSignatures {
            'notify::property-name': (pspec: GObject.ParamSpec) => void;
            'notify::animatable': (pspec: GObject.ParamSpec) => void;
            'notify::interval': (pspec: GObject.ParamSpec) => void;
            'notify::remove-on-complete': (pspec: GObject.ParamSpec) => void;
            'notify::auto-reverse': (pspec: GObject.ParamSpec) => void;
            'notify::delay': (pspec: GObject.ParamSpec) => void;
            'notify::direction': (pspec: GObject.ParamSpec) => void;
            'notify::duration': (pspec: GObject.ParamSpec) => void;
            'notify::loop': (pspec: GObject.ParamSpec) => void;
            'notify::progress-mode': (pspec: GObject.ParamSpec) => void;
            'notify::repeat-count': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends PropertyTransition.ConstructorProps, Scriptable.ConstructorProps {}
    }

    /**
     * The `ClutterKeyframeTransition` structure contains only private
     * data and should be accessed using the provided API.
     */
    class KeyframeTransition extends PropertyTransition implements Scriptable {
        static $gtype: GObject.GType<KeyframeTransition>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: KeyframeTransition.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<KeyframeTransition.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](property_name: string): KeyframeTransition;
        // Conflicted with Clutter.PropertyTransition.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof KeyframeTransition.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, KeyframeTransition.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof KeyframeTransition.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, KeyframeTransition.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof KeyframeTransition.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<KeyframeTransition.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Removes all key frames from `transition`.
         */
        clear(): void;
        /**
         * Retrieves the details of the key frame at `index_` inside `transition`.
         *
         * The `transition` must already have key frames set, and `index_` must be
         * smaller than the number of key frames.
         * @param index_ the index of the key frame
         */
        get_key_frame(index_: number): [number, AnimationMode | null, unknown];
        /**
         * Retrieves the number of key frames inside `transition`.
         * @returns the number of key frames
         */
        get_n_key_frames(): number;
        /**
         * Sets the details of the key frame at `index_` inside `transition`.
         *
         * The `transition` must already have a key frame at `index_,` and `index_`
         * must be smaller than the number of key frames inside `transition`.
         * @param index_ the index of the key frame
         * @param key the key of the key frame
         * @param mode the easing mode of the key frame
         * @param value a #GValue containing the value of the key frame
         */
        set_key_frame(index_: number, key: number, mode: AnimationMode | null, value: GObject.Value | any): void;
        /**
         * Sets the keys for each key frame inside `transition`.
         *
         * If `transition` does not hold any key frame, `n_key_frames` key frames
         * will be created; if `transition` already has key frames, `key_frames` must
         * have at least as many elements as the number of key frames.
         * @param key_frames an array of keys between 0.0   and 1.0, one for each key frame
         */
        set_key_frames(key_frames: number[]): void;
        /**
         * Sets the easing modes for each key frame inside `transition`.
         *
         * If `transition` does not hold any key frame, `n_modes` key frames will
         * be created; if `transition` already has key frames, `modes` must have
         * at least as many elements as the number of key frames.
         * @param modes an array of easing modes, one for   each key frame
         */
        set_modes(modes: AnimationMode[] | null): void;
        /**
         * Sets the values for each key frame inside `transition`.
         *
         * If `transition` does not hold any key frame, `n_values` key frames will
         * be created; if `transition` already has key frames, `values` must have
         * at least as many elements as the number of key frames.
         * @param values an array of values, one for each   key frame
         */
        set_values(values: (GObject.Value | any)[]): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace LayoutManager {
        // Signal signatures
        interface SignalSignatures extends GObject.InitiallyUnowned.SignalSignatures {
            'layout-changed': () => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.InitiallyUnowned.ConstructorProps {}
    }

    /**
     * The #ClutterLayoutManager structure contains only private data
     * and should be accessed using the provided API
     */
    abstract class LayoutManager extends GObject.InitiallyUnowned {
        static $gtype: GObject.GType<LayoutManager>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: LayoutManager.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<LayoutManager.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof LayoutManager.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, LayoutManager.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof LayoutManager.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, LayoutManager.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof LayoutManager.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<LayoutManager.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        /**
         * Allocates the children of `container` given an area
         *
         * See also clutter_actor_allocate()
         * @param container the #ClutterContainer using @manager
         * @param allocation the #ClutterActorBox containing the allocated area   of @container
         * @param flags the allocation flags
         */
        vfunc_allocate(container: Container, allocation: ActorBox, flags: AllocationFlags): void;
        /**
         * Begins an animation of `duration` milliseconds, using the provided
         * easing `mode`
         *
         * The easing mode can be specified either as a #ClutterAnimationMode
         * or as a logical id returned by clutter_alpha_register_func()
         *
         * The result of this function depends on the `manager` implementation
         * @param duration the duration of the animation, in milliseconds
         * @param mode the easing mode of the animation
         */
        vfunc_begin_animation(duration: number, mode: number): Alpha;
        /**
         * Ends an animation started by clutter_layout_manager_begin_animation()
         *
         * The result of this call depends on the `manager` implementation
         */
        vfunc_end_animation(): void;
        /**
         * Retrieves the progress of the animation, if one has been started by
         * clutter_layout_manager_begin_animation()
         *
         * The returned value has the same semantics of the #ClutterAlpha:alpha
         * value
         */
        vfunc_get_animation_progress(): number;
        vfunc_get_child_meta_type(): GObject.GType;
        /**
         * Computes the minimum and natural heights of the `container` according
         * to `manager`.
         *
         * See also clutter_actor_get_preferred_height()
         * @param container the #ClutterContainer using @manager
         * @param for_width the width for which the height should be computed, or -1
         */
        vfunc_get_preferred_height(container: Container, for_width: number): [number, number];
        /**
         * Computes the minimum and natural widths of the `container` according
         * to `manager`.
         *
         * See also clutter_actor_get_preferred_width()
         * @param container the #ClutterContainer using @manager
         * @param for_height the height for which the width should be computed, or -1
         */
        vfunc_get_preferred_width(container: Container, for_height: number): [number, number];
        /**
         * Emits the #ClutterLayoutManager::layout-changed signal on `manager`
         *
         * This function should only be called by implementations of the
         * #ClutterLayoutManager class
         */
        vfunc_layout_changed(): void;
        /**
         * If the #ClutterLayoutManager sub-class allows it, allow
         * adding a weak reference of the `container` using `manager`
         * from within the layout manager
         *
         * The layout manager should not increase the reference
         * count of the `container`
         * @param container a #ClutterContainer using @manager
         */
        vfunc_set_container(container?: Container | null): void;

        // Methods

        /**
         * Allocates the children of `container` given an area
         *
         * See also clutter_actor_allocate()
         * @param container the #ClutterContainer using @manager
         * @param allocation the #ClutterActorBox containing the allocated area   of @container
         * @param flags the allocation flags
         */
        allocate(container: Container, allocation: ActorBox, flags: AllocationFlags | null): void;
        /**
         * Begins an animation of `duration` milliseconds, using the provided
         * easing `mode`
         *
         * The easing mode can be specified either as a #ClutterAnimationMode
         * or as a logical id returned by clutter_alpha_register_func()
         *
         * The result of this function depends on the `manager` implementation
         * @param duration the duration of the animation, in milliseconds
         * @param mode the easing mode of the animation
         * @returns The #ClutterAlpha created by the   layout manager; the returned instance is owned by the layout   manager and should not be unreferenced
         */
        begin_animation(duration: number, mode: number): Alpha;
        /**
         * Gets a property on the #ClutterLayoutMeta created by `manager` and
         * attached to a child of `container`
         *
         * The #GValue must already be initialized to the type of the property
         * and has to be unset with g_value_unset() after extracting the real
         * value out of it
         * @param container a #ClutterContainer using @manager
         * @param actor a #ClutterActor child of @container
         * @param property_name the name of the property to get
         * @param value a #GValue with the value of the property to get
         */
        child_get_property(container: Container, actor: Actor, property_name: string, value: GObject.Value | any): void;
        /**
         * Sets a property on the #ClutterLayoutMeta created by `manager` and
         * attached to a child of `container`
         * @param container a #ClutterContainer using @manager
         * @param actor a #ClutterActor child of @container
         * @param property_name the name of the property to set
         * @param value a #GValue with the value of the property to set
         */
        child_set_property(container: Container, actor: Actor, property_name: string, value: GObject.Value | any): void;
        /**
         * Ends an animation started by clutter_layout_manager_begin_animation()
         *
         * The result of this call depends on the `manager` implementation
         */
        end_animation(): void;
        /**
         * Retrieves the #GParamSpec for the layout property `name` inside
         * the #ClutterLayoutMeta sub-class used by `manager`
         * @param name the name of the property
         * @returns a #GParamSpec describing the property,   or %NULL if no property with that name exists. The returned   #GParamSpec is owned by the layout manager and should not be   modified or freed
         */
        find_child_property(name: string): GObject.ParamSpec;
        /**
         * Retrieves the progress of the animation, if one has been started by
         * clutter_layout_manager_begin_animation()
         *
         * The returned value has the same semantics of the #ClutterAlpha:alpha
         * value
         * @returns the progress of the animation
         */
        get_animation_progress(): number;
        /**
         * Retrieves the #ClutterLayoutMeta that the layout `manager` associated
         * to the `actor` child of `container,` eventually by creating one if the
         * #ClutterLayoutManager supports layout properties
         * @param container a #ClutterContainer using @manager
         * @param actor a #ClutterActor child of @container
         * @returns a #ClutterLayoutMeta, or %NULL if the   #ClutterLayoutManager does not have layout properties. The returned   layout meta instance is owned by the #ClutterLayoutManager and it   should not be unreferenced
         */
        get_child_meta(container: Container, actor: Actor): LayoutMeta;
        /**
         * Computes the minimum and natural heights of the `container` according
         * to `manager`.
         *
         * See also clutter_actor_get_preferred_height()
         * @param container the #ClutterContainer using @manager
         * @param for_width the width for which the height should be computed, or -1
         */
        get_preferred_height(container: Container, for_width: number): [number, number];
        /**
         * Computes the minimum and natural widths of the `container` according
         * to `manager`.
         *
         * See also clutter_actor_get_preferred_width()
         * @param container the #ClutterContainer using @manager
         * @param for_height the height for which the width should be computed, or -1
         */
        get_preferred_width(container: Container, for_height: number): [number, number];
        /**
         * Emits the #ClutterLayoutManager::layout-changed signal on `manager`
         *
         * This function should only be called by implementations of the
         * #ClutterLayoutManager class
         */
        layout_changed(): void;
        /**
         * Retrieves all the #GParamSpec<!-- -->s for the layout properties
         * stored inside the #ClutterLayoutMeta sub-class used by `manager`
         * @returns the newly-allocated,   %NULL-terminated array of #GParamSpec<!-- -->s. Use g_free() to free the   resources allocated for the array
         */
        list_child_properties(): GObject.ParamSpec[];
        /**
         * If the #ClutterLayoutManager sub-class allows it, allow
         * adding a weak reference of the `container` using `manager`
         * from within the layout manager
         *
         * The layout manager should not increase the reference
         * count of the `container`
         * @param container a #ClutterContainer using @manager
         */
        set_container(container?: Container | null): void;
    }

    namespace LayoutMeta {
        // Signal signatures
        interface SignalSignatures extends ChildMeta.SignalSignatures {
            'notify::manager': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::container': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends ChildMeta.ConstructorProps {
            manager: LayoutManager;
        }
    }

    /**
     * Sub-class of #ClutterChildMeta specific for layout managers
     *
     * A #ClutterLayoutManager sub-class should create a #ClutterLayoutMeta
     * instance by overriding the #ClutterLayoutManager::create_child_meta()
     * virtual function
     */
    abstract class LayoutMeta extends ChildMeta {
        static $gtype: GObject.GType<LayoutMeta>;

        // Properties

        /**
         * The #ClutterLayoutManager that created this #ClutterLayoutMeta.
         */
        get manager(): LayoutManager;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: LayoutMeta.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<LayoutMeta.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof LayoutMeta.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, LayoutMeta.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof LayoutMeta.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, LayoutMeta.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof LayoutMeta.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<LayoutMeta.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the actor wrapped by `data`
         * @returns a #ClutterLayoutManager
         */
        get_manager(): LayoutManager;
    }

    namespace ListModel {
        // Signal signatures
        interface SignalSignatures extends Model.SignalSignatures {
            'notify::filter-set': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Model.ConstructorProps, Scriptable.ConstructorProps {}
    }

    /**
     * The #ClutterListModel struct contains only private data.
     */
    class ListModel extends Model implements Scriptable {
        static $gtype: GObject.GType<ListModel>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ListModel.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ListModel.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static newv(types: GObject.GType[], names: string[]): ListModel;
        // Conflicted with GObject.Object.newv

        static newv(...args: never[]): any;

        // Signals

        connect<K extends keyof ListModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ListModel.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ListModel.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ListModel.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ListModel.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ListModel.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Model {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'filter-changed': () => void;
            'row-added': (arg0: ModelIter) => void;
            'row-changed': (arg0: ModelIter) => void;
            'row-removed': (arg0: ModelIter) => void;
            'sort-changed': () => void;
            'notify::filter-set': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Scriptable.ConstructorProps {
            filter_set: boolean;
            filterSet: boolean;
        }
    }

    /**
     * Base class for list models. The #ClutterModel structure contains
     * only private data and should be manipulated using the provided
     * API.
     */
    abstract class Model extends GObject.Object implements Scriptable {
        static $gtype: GObject.GType<Model>;

        // Properties

        /**
         * Whether the #ClutterModel has a filter set
         *
         * This property is set to %TRUE if a filter function has been
         * set using clutter_model_set_filter()
         */
        get filter_set(): boolean;
        /**
         * Whether the #ClutterModel has a filter set
         *
         * This property is set to %TRUE if a filter function has been
         * set using clutter_model_set_filter()
         */
        get filterSet(): boolean;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Model.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Model.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof Model.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Model.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Model.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Model.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Model.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Model.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_filter_changed(): void;
        /**
         * Retrieves the name of the `column`
         * @param column the column number
         */
        vfunc_get_column_name(column: number): string;
        /**
         * Retrieves the type of the `column`.
         * @param column the column number
         */
        vfunc_get_column_type(column: number): GObject.GType;
        /**
         * Retrieves a #ClutterModelIter representing the row at the given index.
         *
         * If a filter function has been set using clutter_model_set_filter()
         * then the `model` implementation will return the first non filtered
         * row.
         * @param row position of the row to retrieve
         */
        vfunc_get_iter_at_row(row: number): ModelIter;
        /**
         * Retrieves the number of columns inside `model`.
         */
        vfunc_get_n_columns(): number;
        /**
         * Retrieves the number of rows inside `model,` eventually taking
         * into account any filtering function set using clutter_model_set_filter().
         */
        vfunc_get_n_rows(): number;
        vfunc_remove_row(row: number): void;
        vfunc_row_added(iter: ModelIter): void;
        vfunc_row_changed(iter: ModelIter): void;
        vfunc_row_removed(iter: ModelIter): void;
        vfunc_sort_changed(): void;

        // Methods

        /**
         * Creates and appends a new row to the #ClutterModel, setting the row
         * values for the given `columns` upon creation.
         * @param columns a vector with the columns to set
         * @param values a vector with the values
         */
        appendv(columns: number[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether the row pointer by `iter` should be filtered or not using
         * the filtering function set on `model`.
         *
         * This function should be used only by subclasses of #ClutterModel.
         * @param iter the row to filter
         * @returns %TRUE if the row should be displayed,   %FALSE otherwise
         */
        filter_iter(iter: ModelIter): boolean;
        /**
         * Checks whether `row` should be filtered or not using the
         * filtering function set on `model`.
         *
         * This function should be used only by subclasses of #ClutterModel.
         * @param row the row to filter
         * @returns %TRUE if the row should be displayed,   %FALSE otherwise
         */
        filter_row(row: number): boolean;
        /**
         * Calls `func` for each row in the model.
         * @param func a #ClutterModelForeachFunc
         */
        foreach(func: ModelForeachFunc): void;
        /**
         * Retrieves the name of the `column`
         * @param column the column number
         * @returns the name of the column. The model holds the returned   string, and it should not be modified or freed
         */
        get_column_name(column: number): string;
        /**
         * Retrieves the type of the `column`.
         * @param column the column number
         * @returns the type of the column.
         */
        get_column_type(column: number): GObject.GType;
        /**
         * Returns whether the `model` has a filter in place, set
         * using clutter_model_set_filter()
         * @returns %TRUE if a filter is set
         */
        get_filter_set(): boolean;
        /**
         * Retrieves a #ClutterModelIter representing the first non-filtered
         * row in `model`.
         * @returns A new #ClutterModelIter.   Call g_object_unref() when done using it
         */
        get_first_iter(): ModelIter;
        /**
         * Retrieves a #ClutterModelIter representing the row at the given index.
         *
         * If a filter function has been set using clutter_model_set_filter()
         * then the `model` implementation will return the first non filtered
         * row.
         * @param row position of the row to retrieve
         * @returns A new #ClutterModelIter, or %NULL if @row was   out of bounds. When done using the iterator object, call g_object_unref()   to deallocate its resources
         */
        get_iter_at_row(row: number): ModelIter;
        /**
         * Retrieves a #ClutterModelIter representing the last non-filtered
         * row in `model`.
         * @returns A new #ClutterModelIter.   Call g_object_unref() when done using it
         */
        get_last_iter(): ModelIter;
        /**
         * Retrieves the number of columns inside `model`.
         * @returns the number of columns
         */
        get_n_columns(): number;
        /**
         * Retrieves the number of rows inside `model,` eventually taking
         * into account any filtering function set using clutter_model_set_filter().
         * @returns The length of the @model. If there is a filter set, then   the length of the filtered @model is returned.
         */
        get_n_rows(): number;
        /**
         * Retrieves the number of column used for sorting the `model`.
         * @returns a column number, or -1 if the model is not sorted
         */
        get_sorting_column(): number;
        /**
         * Sets the data in the cell specified by `iter` and `column`. The type of
         * `value` must be convertable to the type of the column. If the row does
         * not exist then it is created.
         * @param row position of the row to modify
         * @param column column to modify
         * @param value new value for the cell
         */
        insert_value(row: number, column: number, value: GObject.Value | any): void;
        /**
         * Inserts data at `row` into the #ClutterModel, setting the row
         * values for the given `columns` upon creation.
         * @param row row index
         * @param columns a vector containing the columns to set
         * @param values a vector containing the values for the cells
         */
        insertv(row: number, columns: number[], values: (GObject.Value | any)[]): void;
        /**
         * Creates and prepends a new row to the #ClutterModel, setting the row
         * values for the given `columns` upon creation.
         * @param columns a vector containing the columns to set
         * @param values a vector containing the values for the cells
         */
        prependv(columns: number[], values: (GObject.Value | any)[]): void;
        /**
         * Removes the row at the given position from the model.
         * @param row position of row to remove
         */
        remove(row: number): void;
        /**
         * Force a resort on the `model`. This function should only be
         * used by subclasses of #ClutterModel.
         */
        resort(): void;
        /**
         * Filters the `model` using the given filtering function.
         * @param func a #ClutterModelFilterFunc, or #NULL
         */
        set_filter(func?: ModelFilterFunc | null): void;
        /**
         * Assigns a name to the columns of a #ClutterModel.
         *
         * This function is meant primarily for #GObjects that inherit from
         * #ClutterModel, and should only be used when contructing a #ClutterModel.
         * It will not work after the initial creation of the #ClutterModel.
         * @param names an array of strings
         */
        set_names(names: string[]): void;
        /**
         * Sorts `model` using the given sorting function.
         * @param column the column to sort on
         * @param func a #ClutterModelSortFunc, or #NULL
         */
        set_sort(column: number, func?: ModelSortFunc | null): void;
        /**
         * Sets the model to sort by `column`. If `column` is a negative value
         * the sorting column will be unset.
         * @param column the column of the @model to sort, or -1
         */
        set_sorting_column(column: number): void;
        /**
         * Sets the types of the columns inside a #ClutterModel.
         *
         * This function is meant primarily for #GObjects that inherit from
         * #ClutterModel, and should only be used when contructing a #ClutterModel.
         * It will not work after the initial creation of the #ClutterModel.
         * @param types an array of #GType types
         */
        set_types(types: GObject.GType[]): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace ModelIter {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::model': (pspec: GObject.ParamSpec) => void;
            'notify::row': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            model: Model;
            row: number;
        }
    }

    /**
     * Base class for list models iters. The #ClutterModelIter structure
     * contains only private data and should be manipulated using the
     * provided API.
     */
    abstract class ModelIter extends GObject.Object {
        static $gtype: GObject.GType<ModelIter>;

        // Properties

        /**
         * A reference to the #ClutterModel that this iter belongs to.
         */
        get model(): Model;
        set model(val: Model);
        /**
         * The row number to which this iter points to.
         */
        get row(): number;
        set row(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ModelIter.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ModelIter.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof ModelIter.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ModelIter.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ModelIter.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ModelIter.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ModelIter.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ModelIter.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        /**
         * Copies the passed iterator.
         */
        vfunc_copy(): ModelIter;
        /**
         * Retrieves a pointer to the #ClutterModel that this iter is part of.
         */
        vfunc_get_model(): Model;
        /**
         * Retrieves the position of the row that the `iter` points to.
         */
        vfunc_get_row(): number;
        /**
         * Sets an initializes `value` to that at `column`. When done with `value,`
         * g_value_unset() needs to be called to free any allocated memory.
         * @param column column number to retrieve the value from
         */
        vfunc_get_value(column: number): unknown;
        /**
         * Gets whether the current iterator is at the beginning of the model
         * to which it belongs.
         */
        vfunc_is_first(): boolean;
        /**
         * Gets whether the iterator is at the end of the model to which it
         * belongs.
         */
        vfunc_is_last(): boolean;
        /**
         * Updates the `iter` to point at the next position in the model.
         * The model implementation should take into account the presence of
         * a filter function.
         */
        vfunc_next(): ModelIter;
        /**
         * Sets the `iter` to point at the previous position in the model.
         * The model implementation should take into account the presence of
         * a filter function.
         */
        vfunc_prev(): ModelIter;
        /**
         * Sets the data in the cell specified by `iter` and `column`. The type of
         * `value` must be convertable to the type of the column.
         * @param column column number to retrieve the value from
         * @param value new value for the cell
         */
        vfunc_set_value(column: number, value: GObject.Value | any): void;

        // Methods

        /**
         * Copies the passed iterator.
         * @returns a copy of the iterator, or %NULL
         */
        copy(): ModelIter;
        /**
         * Retrieves a pointer to the #ClutterModel that this iter is part of.
         * @returns a pointer to a #ClutterModel.
         */
        get_model(): Model;
        /**
         * Retrieves the position of the row that the `iter` points to.
         * @returns the position of the @iter in the model
         */
        get_row(): number;
        /**
         * Sets an initializes `value` to that at `column`. When done with `value,`
         * g_value_unset() needs to be called to free any allocated memory.
         * @param column column number to retrieve the value from
         */
        get_value(column: number): unknown;
        /**
         * Gets whether the current iterator is at the beginning of the model
         * to which it belongs.
         * @returns #TRUE if @iter is the first iter in the filtered model
         */
        is_first(): boolean;
        /**
         * Gets whether the iterator is at the end of the model to which it
         * belongs.
         * @returns #TRUE if @iter is the last iter in the filtered model.
         */
        is_last(): boolean;
        /**
         * Updates the `iter` to point at the next position in the model.
         * The model implementation should take into account the presence of
         * a filter function.
         * @returns The passed iterator, updated to point at the next   row in the model.
         */
        next(): ModelIter;
        /**
         * Sets the `iter` to point at the previous position in the model.
         * The model implementation should take into account the presence of
         * a filter function.
         * @returns The passed iterator, updated to point at the previous   row in the model.
         */
        prev(): ModelIter;
        /**
         * Sets the data in the cell specified by `iter` and `column`. The type of
         * `value` must be convertable to the type of the column.
         * @param column column number to retrieve the value from
         * @param value new value for the cell
         */
        set_value(column: number, value: GObject.Value | any): void;
    }

    namespace OffscreenEffect {
        // Signal signatures
        interface SignalSignatures extends Effect.SignalSignatures {
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Effect.ConstructorProps {}
    }

    /**
     * The #ClutterOffscreenEffect structure contains only private data
     * and should be accessed using the provided API
     */
    abstract class OffscreenEffect extends Effect {
        static $gtype: GObject.GType<OffscreenEffect>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: OffscreenEffect.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<OffscreenEffect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof OffscreenEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, OffscreenEffect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof OffscreenEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, OffscreenEffect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof OffscreenEffect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<OffscreenEffect.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        /**
         * Calls the create_texture() virtual function of the `effect`
         * @param width the minimum width of the target texture
         * @param height the minimum height of the target texture
         */
        vfunc_create_texture(width: number, height: number): Cogl.Handle;
        /**
         * Calls the paint_target() virtual function of the `effect`
         */
        vfunc_paint_target(): void;

        // Methods

        /**
         * Calls the create_texture() virtual function of the `effect`
         * @param width the minimum width of the target texture
         * @param height the minimum height of the target texture
         * @returns a handle to a Cogl texture, or   %COGL_INVALID_HANDLE. The returned handle has its reference   count increased.
         */
        create_texture(width: number, height: number): Cogl.Handle;
        /**
         * Retrieves the material used as a render target for the offscreen
         * buffer created by `effect`
         *
         * You should only use the returned #CoglMaterial when painting. The
         * returned material might change between different frames.
         * @returns a #CoglMaterial or %NULL. The   returned material is owned by Clutter and it should not be   modified or freed
         */
        get_target(): Cogl.Material;
        /**
         * Retrieves the origin and size of the offscreen buffer used by `effect` to
         * paint the actor to which it has been applied.
         *
         * This function should only be called by #ClutterOffscreenEffect
         * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
         * virtual function.
         * @returns %TRUE if the offscreen buffer has a valid rectangle,   and %FALSE otherwise
         */
        get_target_rect(): [boolean, Rect];
        /**
         * Retrieves the size of the offscreen buffer used by `effect` to
         * paint the actor to which it has been applied.
         *
         * This function should only be called by #ClutterOffscreenEffect
         * implementations, from within the #ClutterOffscreenEffectClass.paint_target()
         * virtual function.
         * @returns %TRUE if the offscreen buffer has a valid size,   and %FALSE otherwise
         */
        get_target_size(): [boolean, number, number];
        /**
         * Retrieves the texture used as a render target for the offscreen
         * buffer created by `effect`
         *
         * You should only use the returned texture when painting. The texture
         * may change after ClutterEffect::pre_paint is called so the effect
         * implementation should update any references to the texture after
         * chaining-up to the parent's pre_paint implementation. This can be
         * used instead of clutter_offscreen_effect_get_target() when the
         * effect subclass wants to paint using its own material.
         * @returns a #CoglHandle or %COGL_INVALID_HANDLE. The   returned texture is owned by Clutter and it should not be   modified or freed
         */
        get_texture(): Cogl.Handle;
        /**
         * Calls the paint_target() virtual function of the `effect`
         */
        paint_target(): void;
    }

    namespace PageTurnEffect {
        // Signal signatures
        interface SignalSignatures extends DeformEffect.SignalSignatures {
            'notify::angle': (pspec: GObject.ParamSpec) => void;
            'notify::period': (pspec: GObject.ParamSpec) => void;
            'notify::radius': (pspec: GObject.ParamSpec) => void;
            'notify::x-tiles': (pspec: GObject.ParamSpec) => void;
            'notify::y-tiles': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends DeformEffect.ConstructorProps {
            angle: number;
            period: number;
            radius: number;
        }
    }

    /**
     * #ClutterPageTurnEffect is an opaque structure
     * whose members can only be accessed using the provided API
     */
    class PageTurnEffect extends DeformEffect {
        static $gtype: GObject.GType<PageTurnEffect>;

        // Properties

        /**
         * The angle of the page rotation, in degrees, between 0.0 and 360.0
         */
        get angle(): number;
        set angle(val: number);
        /**
         * The period of the page turn, between 0.0 (no curling) and
         * 1.0 (fully curled)
         */
        get period(): number;
        set period(val: number);
        /**
         * The radius of the page curl, in pixels
         */
        get radius(): number;
        set radius(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: PageTurnEffect.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<PageTurnEffect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](period: number, angle: number, radius: number): PageTurnEffect;

        // Signals

        connect<K extends keyof PageTurnEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PageTurnEffect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof PageTurnEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PageTurnEffect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof PageTurnEffect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<PageTurnEffect.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the value set using clutter_page_turn_effect_get_angle()
         * @returns the angle of the page curling
         */
        get_angle(): number;
        /**
         * Retrieves the value set using clutter_page_turn_effect_get_period()
         * @returns the period of the page curling
         */
        get_period(): number;
        /**
         * Retrieves the value set using clutter_page_turn_effect_set_radius()
         * @returns the radius of the page curling
         */
        get_radius(): number;
        /**
         * Sets the angle of the page curling, in degrees
         * @param angle the angle of the page curl, in degrees
         */
        set_angle(angle: number): void;
        /**
         * Sets the period of the page curling, between 0.0 (no curling)
         * and 1.0 (fully curled)
         * @param period the period of the page curl, between 0.0 and 1.0
         */
        set_period(period: number): void;
        /**
         * Sets the radius of the page curling
         * @param radius the radius of the page curling, in pixels
         */
        set_radius(radius: number): void;
    }

    namespace PaintNode {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}
    }

    /**
     * The `ClutterPaintNode` structure contains only private data
     * and it should be accessed using the provided API.
     */
    abstract class PaintNode {
        static $gtype: GObject.GType<PaintNode>;

        // Constructors

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof PaintNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PaintNode.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof PaintNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PaintNode.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof PaintNode.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<PaintNode.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Adds `child` to the list of children of `node`.
         *
         * This function will acquire a reference on `child`.
         * @param child the child #ClutterPaintNode to add
         */
        add_child(child: PaintNode): void;
        /**
         * Adds a rectangle region to the `node,` as described by the
         * passed `rect`.
         * @param rect a #ClutterActorBox
         */
        add_rectangle(rect: ActorBox): void;
        /**
         * Adds a rectangle region to the `node,` with texture coordinates.
         * @param rect a #ClutterActorBox
         * @param x_1 the left X coordinate of the texture
         * @param y_1 the top Y coordinate of the texture
         * @param x_2 the right X coordinate of the texture
         * @param y_2 the bottom Y coordinate of the texture
         */
        add_texture_rectangle(rect: ActorBox, x_1: number, y_1: number, x_2: number, y_2: number): void;
        /**
         * Acquires a reference on `node`.
         * @returns the #ClutterPaintNode
         */
        ref(): PaintNode;
        /**
         * Sets a user-readable `name` for `node`.
         *
         * The `name` will be used for debugging purposes.
         *
         * The `node` will copy the passed string.
         * @param name a string annotating the @node
         */
        set_name(name: string): void;
        /**
         * Releases a reference on `node`.
         */
        unref(): void;
    }

    namespace PanAction {
        // Signal signatures
        interface SignalSignatures extends GestureAction.SignalSignatures {
            pan: (arg0: Actor, arg1: boolean) => boolean | void;
            'pan-stopped': (arg0: Actor) => void;
            'notify::acceleration-factor': (pspec: GObject.ParamSpec) => void;
            'notify::deceleration': (pspec: GObject.ParamSpec) => void;
            'notify::interpolate': (pspec: GObject.ParamSpec) => void;
            'notify::pan-axis': (pspec: GObject.ParamSpec) => void;
            'notify::n-touch-points': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-distance-x': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-distance-y': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-edge': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GestureAction.ConstructorProps {
            acceleration_factor: number;
            accelerationFactor: number;
            deceleration: number;
            interpolate: boolean;
            pan_axis: PanAxis;
            panAxis: PanAxis;
        }
    }

    /**
     * The #ClutterPanAction structure contains
     * only private data and should be accessed using the provided API
     */
    class PanAction extends GestureAction {
        static $gtype: GObject.GType<PanAction>;

        // Properties

        /**
         * The initial acceleration factor
         *
         * The kinetic momentum measured at the time of releasing the pointer will
         * be multiplied by the factor specified by this property before being used
         * to generate interpolated ::pan events.
         */
        get acceleration_factor(): number;
        set acceleration_factor(val: number);
        /**
         * The initial acceleration factor
         *
         * The kinetic momentum measured at the time of releasing the pointer will
         * be multiplied by the factor specified by this property before being used
         * to generate interpolated ::pan events.
         */
        get accelerationFactor(): number;
        set accelerationFactor(val: number);
        /**
         * The rate at which the interpolated panning will decelerate in
         *
         * #ClutterPanAction will emit interpolated ::pan events with decreasing
         * scroll deltas, using the rate specified by this property.
         */
        get deceleration(): number;
        set deceleration(val: number);
        /**
         * Whether interpolated events emission is enabled.
         */
        get interpolate(): boolean;
        set interpolate(val: boolean);
        /**
         * Constraints the panning action to the specified axis
         */
        get pan_axis(): PanAxis;
        set pan_axis(val: PanAxis);
        /**
         * Constraints the panning action to the specified axis
         */
        get panAxis(): PanAxis;
        set panAxis(val: PanAxis);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: PanAction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<PanAction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): PanAction;

        // Signals

        connect<K extends keyof PanAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PanAction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof PanAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PanAction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof PanAction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<PanAction.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_pan(actor: Actor, is_interpolated: boolean): boolean;
        vfunc_pan_stopped(actor: Actor): void;

        // Methods

        /**
         * Retrieves the initial acceleration factor for interpolated ::pan events.
         * @returns The initial acceleration factor for interpolated events.
         */
        get_acceleration_factor(): number;
        /**
         * Retrieves the delta, in stage space, dependent on the current state
         * of the #ClutterPanAction, and respecting the constraint specified by the
         * #ClutterPanAction:pan-axis property.
         * @param point the touch point index, with 0 being the first touch   point received by the action
         * @returns the distance since last motion event
         */
        get_constrained_motion_delta(point: number): [number, number, number];
        /**
         * Retrieves the deceleration rate of interpolated ::pan events.
         * @returns The deceleration rate of the interpolated events.
         */
        get_deceleration(): number;
        /**
         * Checks if the action should emit ::pan events even after releasing
         * the pointer during a panning gesture, to emulate some kind of
         * kinetic inertia.
         * @returns %TRUE if interpolated events emission is active.
         */
        get_interpolate(): boolean;
        /**
         * Retrieves the coordinates, in stage space, of the latest interpolated
         * event, analogous to clutter_gesture_action_get_motion_coords().
         */
        get_interpolated_coords(): [number, number];
        /**
         * Retrieves the delta, in stage space, since the latest interpolated
         * event, analogous to clutter_gesture_action_get_motion_delta().
         * @returns the distance since the latest interpolated event
         */
        get_interpolated_delta(): [number, number, number];
        /**
         * Retrieves the coordinates, in stage space, dependent on the current state
         * of the #ClutterPanAction. If it is inactive, both fields will be
         * set to 0. If it is panning by user action, the values will be equivalent
         * to those returned by clutter_gesture_action_get_motion_coords().
         * If it is interpolating with some form of kinetic scrolling, the values
         * will be equivalent to those returned by
         * clutter_pan_action_get_interpolated_coords(). This is a convenience
         * method designed to be used in replacement "pan" signal handlers.
         * @param point the touch point index, with 0 being the first touch   point received by the action
         */
        get_motion_coords(point: number): [number, number];
        /**
         * Retrieves the delta, in stage space, dependent on the current state
         * of the #ClutterPanAction. If it is inactive, both fields will be
         * set to 0. If it is panning by user action, the values will be equivalent
         * to those returned by clutter_gesture_action_get_motion_delta().
         * If it is interpolating with some form of kinetic scrolling, the values
         * will be equivalent to those returned by
         * clutter_pan_action_get_interpolated_delta(). This is a convenience
         * method designed to be used in replacement "pan" signal handlers.
         * @param point the touch point index, with 0 being the first touch   point received by the action
         */
        get_motion_delta(point: number): [number, number, number];
        /**
         * Retrieves the axis constraint set by clutter_pan_action_set_pan_axis()
         * @returns the axis constraint
         */
        get_pan_axis(): PanAxis;
        /**
         * Factor applied to the momentum velocity at the time of releasing the
         * pointer when generating interpolated ::pan events.
         * @param factor The acceleration factor
         */
        set_acceleration_factor(factor: number): void;
        /**
         * Sets the deceleration rate of the interpolated ::pan events generated
         * after a pan gesture. This is approximately the value that the momentum
         * at the time of releasing the pointer is divided by every 60th of a second.
         * @param rate The deceleration rate
         */
        set_deceleration(rate: number): void;
        /**
         * Sets whether the action should emit interpolated ::pan events
         * after the drag has ended, to emulate the gesture kinetic inertia.
         * @param should_interpolate whether to enable interpolated pan events
         */
        set_interpolate(should_interpolate: boolean): void;
        /**
         * Restricts the panning action to a specific axis
         * @param axis the axis to constraint the panning to
         */
        set_pan_axis(axis: PanAxis | null): void;
    }

    namespace Path {
        // Signal signatures
        interface SignalSignatures extends GObject.InitiallyUnowned.SignalSignatures {
            'notify::description': (pspec: GObject.ParamSpec) => void;
            'notify::length': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.InitiallyUnowned.ConstructorProps {
            description: string;
            length: number;
        }
    }

    /**
     * The #ClutterPath struct contains only private data and should
     * be accessed with the functions below.
     */
    class Path extends GObject.InitiallyUnowned {
        static $gtype: GObject.GType<Path>;

        // Properties

        get description(): string;
        set description(val: string);
        get length(): number;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Path.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Path.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Path;

        static new_with_description(desc: string): Path;

        // Signals

        connect<K extends keyof Path.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Path.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Path.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Path.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Path.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Path.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Add the nodes of the Cairo path to the end of `path`.
         * @param cpath a Cairo path
         */
        add_cairo_path(cpath: cairo.Path): void;
        /**
         * Adds a %CLUTTER_PATH_CLOSE type node to the path. This creates a
         * straight line from the last node to the last %CLUTTER_PATH_MOVE_TO
         * type node.
         */
        add_close(): void;
        /**
         * Adds a %CLUTTER_PATH_CURVE_TO type node to the path. This causes
         * the actor to follow a bezier from the last node to (`x_3`, `y_3`) using
         * (`x_1`, `y_1`) and (`x_2`,`y_2`) as control points.
         * @param x_1 the x coordinate of the first control point
         * @param y_1 the y coordinate of the first control point
         * @param x_2 the x coordinate of the second control point
         * @param y_2 the y coordinate of the second control point
         * @param x_3 the x coordinate of the third control point
         * @param y_3 the y coordinate of the third control point
         */
        add_curve_to(x_1: number, y_1: number, x_2: number, y_2: number, x_3: number, y_3: number): void;
        /**
         * Adds a %CLUTTER_PATH_LINE_TO type node to the path. This causes the
         * actor to move to the new coordinates in a straight line.
         * @param x the x coordinate
         * @param y the y coordinate
         */
        add_line_to(x: number, y: number): void;
        /**
         * Adds a %CLUTTER_PATH_MOVE_TO type node to the path. This is usually
         * used as the first node in a path. It can also be used in the middle
         * of the path to cause the actor to jump to the new coordinate.
         * @param x the x coordinate
         * @param y the y coordinate
         */
        add_move_to(x: number, y: number): void;
        /**
         * Adds `node` to the end of the path.
         * @param node a #ClutterPathNode
         */
        add_node(node: PathNode): void;
        /**
         * Same as clutter_path_add_curve_to() except the coordinates are
         * relative to the previous node.
         * @param x_1 the x coordinate of the first control point
         * @param y_1 the y coordinate of the first control point
         * @param x_2 the x coordinate of the second control point
         * @param y_2 the y coordinate of the second control point
         * @param x_3 the x coordinate of the third control point
         * @param y_3 the y coordinate of the third control point
         */
        add_rel_curve_to(x_1: number, y_1: number, x_2: number, y_2: number, x_3: number, y_3: number): void;
        /**
         * Same as clutter_path_add_line_to() except the coordinates are
         * relative to the previous node.
         * @param x the x coordinate
         * @param y the y coordinate
         */
        add_rel_line_to(x: number, y: number): void;
        /**
         * Same as clutter_path_add_move_to() except the coordinates are
         * relative to the previous node.
         * @param x the x coordinate
         * @param y the y coordinate
         */
        add_rel_move_to(x: number, y: number): void;
        /**
         * Adds new nodes to the end of the path as described in `str`. The
         * format is a subset of the SVG path format. Each node is represented
         * by a letter and is followed by zero, one or three pairs of
         * coordinates. The coordinates can be separated by spaces or a
         * comma. The types are:
         *
         *  - `M`: Adds a %CLUTTER_PATH_MOVE_TO node. Takes one pair of coordinates.
         *  - `L`: Adds a %CLUTTER_PATH_LINE_TO node. Takes one pair of coordinates.
         *  - `C`: Adds a %CLUTTER_PATH_CURVE_TO node. Takes three pairs of coordinates.
         *  - `z`: Adds a %CLUTTER_PATH_CLOSE node. No coordinates are needed.
         *
         * The M, L and C commands can also be specified in lower case which
         * means the coordinates are relative to the previous node.
         *
         * For example, to move an actor in a 100 by 100 pixel square centered
         * on the point 300,300 you could use the following path:
         *
         *
         * ```
         *   M 250,350 l 0 -100 L 350,250 l 0 100 z
         * ```
         *
         *
         * If the path description isn't valid %FALSE will be returned and no
         * nodes will be added.
         * @param str a string describing the new nodes
         * @returns %TRUE is the path description was valid or %FALSE otherwise.
         */
        add_string(str: string): boolean;
        /**
         * Removes all nodes from the path.
         */
        clear(): void;
        /**
         * Calls a function for each node of the path.
         * @param callback the function to call with each node
         */
        foreach(callback: PathCallback): void;
        /**
         * Returns a newly allocated string describing the path in the same
         * format as used by clutter_path_add_string().
         * @returns a string description of the path. Free with g_free().
         */
        get_description(): string;
        /**
         * Retrieves an approximation of the total length of the path.
         * @returns the length of the path.
         */
        get_length(): number;
        /**
         * Retrieves the number of nodes in the path.
         * @returns the number of nodes.
         */
        get_n_nodes(): number;
        /**
         * Retrieves the node of the path indexed by `index`.
         * @param index_ the node number to retrieve
         */
        get_node(index_: number): PathNode;
        /**
         * Returns a #GSList of #ClutterPathNode<!-- -->s. The list should be
         * freed with g_slist_free(). The nodes are owned by the path and
         * should not be freed. Altering the path may cause the nodes in the
         * list to become invalid so you should copy them if you want to keep
         * the list.
         * @returns a   list of nodes in the path.
         */
        get_nodes(): PathNode[];
        /**
         * The value in `progress` represents a position along the path where
         * 0.0 is the beginning and 1.0 is the end of the path. An
         * interpolated position is then stored in `position`.
         * @param progress a position along the path as a fraction of its length
         * @returns index of the node used to calculate the position.
         */
        get_position(progress: number): [number, Knot];
        /**
         * Inserts `node` into the path before the node at the given offset. If
         * `index_` is negative it will append the node to the end of the path.
         * @param index_ offset of where to insert the node
         * @param node the node to insert
         */
        insert_node(index_: number, node: PathNode): void;
        /**
         * Removes the node at the given offset from the path.
         * @param index_ index of the node to remove
         */
        remove_node(index_: number): void;
        /**
         * Replaces the node at offset `index_` with `node`.
         * @param index_ index to the existing node
         * @param node the replacement node
         */
        replace_node(index_: number, node: PathNode): void;
        /**
         * Replaces all of the nodes in the path with nodes described by
         * `str`. See clutter_path_add_string() for details of the format.
         *
         * If the string is invalid then %FALSE is returned and the path is
         * unaltered.
         * @param str a string describing the path
         * @returns %TRUE is the path was valid, %FALSE otherwise.
         */
        set_description(str: string): boolean;
        /**
         * Add the nodes of the ClutterPath to the path in the Cairo context.
         * @param cr a Cairo context
         */
        to_cairo_path(cr: cairo.Context): void;
    }

    namespace PathConstraint {
        // Signal signatures
        interface SignalSignatures extends Constraint.SignalSignatures {
            'node-reached': (arg0: Actor, arg1: number) => void;
            'notify::offset': (pspec: GObject.ParamSpec) => void;
            'notify::path': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Constraint.ConstructorProps {
            offset: number;
            path: Path;
        }
    }

    /**
     * #ClutterPathConstraint is an opaque structure
     * whose members cannot be directly accessed
     */
    class PathConstraint extends Constraint {
        static $gtype: GObject.GType<PathConstraint>;

        // Properties

        /**
         * The offset along the #ClutterPathConstraint:path, between -1.0 and 2.0.
         */
        get offset(): number;
        set offset(val: number);
        /**
         * The #ClutterPath used to constrain the position of an actor.
         */
        get path(): Path;
        set path(val: Path);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: PathConstraint.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<PathConstraint.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](path: Path | null, offset: number): PathConstraint;

        // Signals

        connect<K extends keyof PathConstraint.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PathConstraint.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof PathConstraint.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PathConstraint.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof PathConstraint.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<PathConstraint.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the offset along the #ClutterPath used by `constraint`.
         * @returns the offset
         */
        get_offset(): number;
        /**
         * Retrieves a pointer to the #ClutterPath used by `constraint`.
         * @returns the #ClutterPath used by the   #ClutterPathConstraint, or %NULL. The returned #ClutterPath is owned   by the constraint and it should not be unreferenced
         */
        get_path(): Path;
        /**
         * Sets the offset along the #ClutterPath used by `constraint`.
         * @param offset the offset along the path
         */
        set_offset(offset: number): void;
        /**
         * Sets the `path` to be followed by the #ClutterPathConstraint.
         *
         * The `constraint` will take ownership of the #ClutterPath passed to this
         * function.
         * @param path a #ClutterPath
         */
        set_path(path?: Path | null): void;
    }

    namespace PipelineNode {
        // Signal signatures
        interface SignalSignatures extends PaintNode.SignalSignatures {}
    }

    /**
     * The #ClutterTextNode structure is an opaque
     * type whose members cannot be directly accessed.
     */
    class PipelineNode extends PaintNode {
        static $gtype: GObject.GType<PipelineNode>;

        // Constructors

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof PipelineNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PipelineNode.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof PipelineNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PipelineNode.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof PipelineNode.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<PipelineNode.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace PropertyTransition {
        // Signal signatures
        interface SignalSignatures extends Transition.SignalSignatures {
            'notify::property-name': (pspec: GObject.ParamSpec) => void;
            'notify::animatable': (pspec: GObject.ParamSpec) => void;
            'notify::interval': (pspec: GObject.ParamSpec) => void;
            'notify::remove-on-complete': (pspec: GObject.ParamSpec) => void;
            'notify::auto-reverse': (pspec: GObject.ParamSpec) => void;
            'notify::delay': (pspec: GObject.ParamSpec) => void;
            'notify::direction': (pspec: GObject.ParamSpec) => void;
            'notify::duration': (pspec: GObject.ParamSpec) => void;
            'notify::loop': (pspec: GObject.ParamSpec) => void;
            'notify::progress-mode': (pspec: GObject.ParamSpec) => void;
            'notify::repeat-count': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Transition.ConstructorProps, Scriptable.ConstructorProps {
            property_name: string;
            propertyName: string;
        }
    }

    /**
     * The #ClutterPropertyTransition structure contains
     * private data and should only be accessed using the provided API.
     */
    class PropertyTransition extends Transition implements Scriptable {
        static $gtype: GObject.GType<PropertyTransition>;

        // Properties

        /**
         * The name of the property of a #ClutterAnimatable to animate.
         */
        get property_name(): string;
        set property_name(val: string);
        /**
         * The name of the property of a #ClutterAnimatable to animate.
         */
        get propertyName(): string;
        set propertyName(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: PropertyTransition.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<PropertyTransition.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](property_name?: string | null): PropertyTransition;
        // Conflicted with Clutter.Timeline.new

        static ['new'](...args: never[]): any;

        // Signals

        connect<K extends keyof PropertyTransition.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PropertyTransition.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof PropertyTransition.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, PropertyTransition.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof PropertyTransition.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<PropertyTransition.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the value of the #ClutterPropertyTransition:property-name
         * property.
         * @returns the name of the property being animated, or %NULL if   none is set. The returned string is owned by the @transition and   it should not be freed.
         */
        get_property_name(): string;
        /**
         * Sets the #ClutterPropertyTransition:property-name property of `transition`.
         * @param property_name a property name
         */
        set_property_name(property_name?: string | null): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Rectangle {
        // Signal signatures
        interface SignalSignatures extends Actor.SignalSignatures {
            'notify::border-color': (pspec: GObject.ParamSpec) => void;
            'notify::border-width': (pspec: GObject.ParamSpec) => void;
            'notify::color': (pspec: GObject.ParamSpec) => void;
            'notify::has-border': (pspec: GObject.ParamSpec) => void;
            'notify::actions': (pspec: GObject.ParamSpec) => void;
            'notify::allocation': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-x': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-y': (pspec: GObject.ParamSpec) => void;
            'notify::background-color': (pspec: GObject.ParamSpec) => void;
            'notify::background-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::clip': (pspec: GObject.ParamSpec) => void;
            'notify::clip-rect': (pspec: GObject.ParamSpec) => void;
            'notify::clip-to-allocation': (pspec: GObject.ParamSpec) => void;
            'notify::constraints': (pspec: GObject.ParamSpec) => void;
            'notify::content': (pspec: GObject.ParamSpec) => void;
            'notify::content-box': (pspec: GObject.ParamSpec) => void;
            'notify::content-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::content-repeat': (pspec: GObject.ParamSpec) => void;
            'notify::depth': (pspec: GObject.ParamSpec) => void;
            'notify::effect': (pspec: GObject.ParamSpec) => void;
            'notify::first-child': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-position-set': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-x': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-y': (pspec: GObject.ParamSpec) => void;
            'notify::has-clip': (pspec: GObject.ParamSpec) => void;
            'notify::has-pointer': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::last-child': (pspec: GObject.ParamSpec) => void;
            'notify::layout-manager': (pspec: GObject.ParamSpec) => void;
            'notify::magnification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::mapped': (pspec: GObject.ParamSpec) => void;
            'notify::margin-bottom': (pspec: GObject.ParamSpec) => void;
            'notify::margin-left': (pspec: GObject.ParamSpec) => void;
            'notify::margin-right': (pspec: GObject.ParamSpec) => void;
            'notify::margin-top': (pspec: GObject.ParamSpec) => void;
            'notify::min-height': (pspec: GObject.ParamSpec) => void;
            'notify::min-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::min-width': (pspec: GObject.ParamSpec) => void;
            'notify::min-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::minification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::offscreen-redirect': (pspec: GObject.ParamSpec) => void;
            'notify::opacity': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point-z': (pspec: GObject.ParamSpec) => void;
            'notify::position': (pspec: GObject.ParamSpec) => void;
            'notify::reactive': (pspec: GObject.ParamSpec) => void;
            'notify::realized': (pspec: GObject.ParamSpec) => void;
            'notify::request-mode': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-zgravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-z': (pspec: GObject.ParamSpec) => void;
            'notify::show-on-set-parent': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::text-direction': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::translation-x': (pspec: GObject.ParamSpec) => void;
            'notify::translation-y': (pspec: GObject.ParamSpec) => void;
            'notify::translation-z': (pspec: GObject.ParamSpec) => void;
            'notify::visible': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::x-align': (pspec: GObject.ParamSpec) => void;
            'notify::x-expand': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::y-align': (pspec: GObject.ParamSpec) => void;
            'notify::y-expand': (pspec: GObject.ParamSpec) => void;
            'notify::z-position': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Actor.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Animatable.ConstructorProps,
                Container.ConstructorProps,
                Scriptable.ConstructorProps {
            border_color: Color;
            borderColor: Color;
            border_width: number;
            borderWidth: number;
            color: Color;
            has_border: boolean;
            hasBorder: boolean;
        }
    }

    /**
     * The #ClutterRectangle structure contains only private data
     * and should be accessed using the provided API
     */
    class Rectangle extends Actor implements Atk.ImplementorIface, Animatable, Container, Scriptable {
        static $gtype: GObject.GType<Rectangle>;

        // Properties

        /**
         * The color of the border of the rectangle.
         */
        get border_color(): Color;
        set border_color(val: Color);
        /**
         * The color of the border of the rectangle.
         */
        get borderColor(): Color;
        set borderColor(val: Color);
        /**
         * The width of the border of the rectangle, in pixels.
         */
        get border_width(): number;
        set border_width(val: number);
        /**
         * The width of the border of the rectangle, in pixels.
         */
        get borderWidth(): number;
        set borderWidth(val: number);
        /**
         * The color of the rectangle.
         */
        get color(): Color;
        set color(val: Color);
        /**
         * Whether the #ClutterRectangle should be displayed with a border.
         */
        get has_border(): boolean;
        set has_border(val: boolean);
        /**
         * Whether the #ClutterRectangle should be displayed with a border.
         */
        get hasBorder(): boolean;
        set hasBorder(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Rectangle.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Rectangle.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Rectangle;

        static new_with_color(color: Color): Rectangle;

        // Signals

        connect<K extends keyof Rectangle.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Rectangle.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Rectangle.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Rectangle.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Rectangle.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Rectangle.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Gets the color of the border used by `rectangle` and places
         * it into `color`.
         */
        get_border_color(): Color;
        /**
         * Gets the width (in pixels) of the border used by `rectangle`
         * @returns the border's width
         */
        get_border_width(): number;
        /**
         * Retrieves the color of `rectangle`.
         */
        get_color(): Color;
        /**
         * Sets the color of the border used by `rectangle` using `color`
         * @param color the color of the border
         */
        set_border_color(color: Color): void;
        /**
         * Sets the width (in pixel) of the border used by `rectangle`.
         * A `width` of 0 will unset the border.
         * @param width the width of the border
         */
        set_border_width(width: number): void;
        /**
         * Sets the color of `rectangle`.
         * @param color a #ClutterColor
         */
        set_color(color: Color): void;

        // Inherited methods
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         * @returns %TRUE if the value has been validated and can   be applied to the #ClutterAnimatable, and %FALSE otherwise
         */
        animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         * @returns The #GParamSpec for the given property   or %NULL
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         * @returns %TRUE if the interpolation was successful,   and %FALSE otherwise
         */
        interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         */
        vfunc_animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         */
        vfunc_find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        vfunc_get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         */
        vfunc_interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        vfunc_set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        add_actor(actor: Actor): void;
        /**
         * Gets a container specific property of a child of `container,` In general,
         * a copy is made of the property contents and the caller is responsible for
         * freeing the memory by calling g_value_unset().
         *
         * Note that clutter_container_child_set_property() is really intended for
         * language bindings, clutter_container_child_set() is much more convenient
         * for C programming.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_get_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Sets a container-specific property on a child of `container`.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_set_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        destroy_child_meta(actor: Actor): void;
        /**
         * Finds a child actor of a container by its name. Search recurses
         * into any child container.
         * @param child_name the name of the requested child.
         * @returns The child actor with the requested name,   or %NULL if no actor with that name was found.
         */
        find_child_by_name(child_name: string): Actor;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         * @returns the #ClutterChildMeta for the @actor child   of @container or %NULL if the specifiec actor does not exist or the   container is not configured to provide #ClutterChildMeta<!-- -->s
         */
        get_child_meta(actor: Actor): ChildMeta;
        /**
         * Retrieves all the children of `container`.
         * @returns a list   of #ClutterActor<!-- -->s. Use g_list_free() on the returned   list when done.
         */
        get_children(): Actor[];
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        lower_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        raise_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        remove_actor(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        sort_depth_order(): void;
        vfunc_actor_added(actor: Actor): void;
        vfunc_actor_removed(actor: Actor): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        vfunc_add(actor: Actor): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        vfunc_child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_destroy_child_meta(actor: Actor): void;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         */
        vfunc_get_child_meta(actor: Actor): ChildMeta;
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        vfunc_lower(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        vfunc_raise(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        vfunc_remove(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        vfunc_sort_depth_order(): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace RotateAction {
        // Signal signatures
        interface SignalSignatures extends GestureAction.SignalSignatures {
            rotate: (arg0: Actor, arg1: number) => boolean | void;
            'notify::n-touch-points': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-distance-x': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-distance-y': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-edge': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GestureAction.ConstructorProps {}
    }

    /**
     * The #ClutterRotateAction structure contains
     * only private data and should be accessed using the provided API
     */
    class RotateAction extends GestureAction {
        static $gtype: GObject.GType<RotateAction>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: RotateAction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<RotateAction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): RotateAction;

        // Signals

        connect<K extends keyof RotateAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, RotateAction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof RotateAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, RotateAction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof RotateAction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<RotateAction.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_rotate(actor: Actor, angle: number): boolean;
    }

    namespace Score {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            completed: () => void;
            paused: () => void;
            started: () => void;
            'timeline-completed': (arg0: Timeline) => void;
            'timeline-started': (arg0: Timeline) => void;
            'notify::loop': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            loop: boolean;
        }
    }

    /**
     * The #ClutterScore structure contains only private data
     * and should be accessed using the provided API
     */
    class Score extends GObject.Object {
        static $gtype: GObject.GType<Score>;

        // Properties

        /**
         * Whether the #ClutterScore should restart once finished.
         */
        get loop(): boolean;
        set loop(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Score.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Score.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Score;

        // Signals

        connect<K extends keyof Score.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Score.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Score.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Score.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Score.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Score.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_completed(): void;
        vfunc_paused(): void;
        vfunc_started(): void;
        vfunc_timeline_completed(timeline: Timeline): void;
        vfunc_timeline_started(timeline: Timeline): void;

        // Methods

        /**
         * Appends a timeline to another one existing in the score; the newly
         * appended timeline will be started when `parent` is complete.
         *
         * If `parent` is %NULL, the new #ClutterTimeline will be started when
         * clutter_score_start() is called.
         *
         * #ClutterScore will take a reference on `timeline`.
         * @param parent a #ClutterTimeline in the score, or %NULL
         * @param timeline a #ClutterTimeline
         * @returns the id of the #ClutterTimeline inside the score, or   0 on failure. The returned id can be used with clutter_score_remove()   or clutter_score_get_timeline().
         */
        append(parent: Timeline | null, timeline: Timeline): number;
        /**
         * Appends `timeline` at the given `marker_name` on the `parent`
         * #ClutterTimeline.
         *
         * If you want to append `timeline` at the end of `parent,` use
         * clutter_score_append().
         *
         * The #ClutterScore will take a reference on `timeline`.
         * @param parent the parent #ClutterTimeline
         * @param marker_name the name of the marker to use
         * @param timeline the #ClutterTimeline to append
         * @returns the id of the #ClutterTimeline inside the score, or   0 on failure. The returned id can be used with clutter_score_remove()   or clutter_score_get_timeline().
         */
        append_at_marker(parent: Timeline, marker_name: string, timeline: Timeline): number;
        /**
         * Gets whether `score` is looping
         * @returns %TRUE if the score is looping
         */
        get_loop(): boolean;
        /**
         * Retrieves the #ClutterTimeline for `id_` inside `score`.
         * @param id_ the id of the timeline
         * @returns the requested timeline, or %NULL. This   function does not increase the reference count on the returned   #ClutterTimeline
         */
        get_timeline(id_: number): Timeline;
        /**
         * Query state of a #ClutterScore instance.
         * @returns %TRUE if score is currently playing
         */
        is_playing(): boolean;
        /**
         * Retrieves a list of all the #ClutterTimelines managed by `score`.
         * @returns a   #GSList containing all the timelines in the score. This function does   not increase the reference count of the returned timelines. Use   g_slist_free() on the returned list to deallocate its resources.
         */
        list_timelines(): Timeline[];
        /**
         * Pauses a playing score `score`.
         */
        pause(): void;
        /**
         * Removes the #ClutterTimeline with the given id inside `score`. If
         * the timeline has other timelines attached to it, those are removed
         * as well.
         * @param id_ the id of the timeline to remove
         */
        remove(id_: number): void;
        /**
         * Removes all the timelines inside `score`.
         */
        remove_all(): void;
        /**
         * Rewinds a #ClutterScore to its initial state.
         */
        rewind(): void;
        /**
         * Sets whether `score` should loop. A looping #ClutterScore will start
         * from its initial state after the ::complete signal has been fired.
         * @param loop %TRUE for enable looping
         */
        set_loop(loop: boolean): void;
        /**
         * Starts the score.
         */
        start(): void;
        /**
         * Stops and rewinds a playing #ClutterScore instance.
         */
        stop(): void;
    }

    namespace Script {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::filename': (pspec: GObject.ParamSpec) => void;
            'notify::filename-set': (pspec: GObject.ParamSpec) => void;
            'notify::translation-domain': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            filename: string;
            filename_set: boolean;
            filenameSet: boolean;
            translation_domain: string;
            translationDomain: string;
        }
    }

    /**
     * The #ClutterScript structure contains only private data
     * and should be accessed using the provided API
     */
    class Script extends GObject.Object {
        static $gtype: GObject.GType<Script>;

        // Properties

        /**
         * The path of the currently parsed file. If #ClutterScript:filename-set
         * is %FALSE then the value of this property is undefined.
         */
        get filename(): string;
        /**
         * Whether the #ClutterScript:filename property is set. If this property
         * is %TRUE then the currently parsed data comes from a file, and the
         * file name is stored inside the #ClutterScript:filename property.
         */
        get filename_set(): boolean;
        /**
         * Whether the #ClutterScript:filename property is set. If this property
         * is %TRUE then the currently parsed data comes from a file, and the
         * file name is stored inside the #ClutterScript:filename property.
         */
        get filenameSet(): boolean;
        /**
         * The translation domain, used to localize strings marked as translatable
         * inside a UI definition.
         *
         * If #ClutterScript:translation-domain is set to %NULL, #ClutterScript
         * will use gettext(), otherwise g_dgettext() will be used.
         */
        get translation_domain(): string;
        set translation_domain(val: string);
        /**
         * The translation domain, used to localize strings marked as translatable
         * inside a UI definition.
         *
         * If #ClutterScript:translation-domain is set to %NULL, #ClutterScript
         * will use gettext(), otherwise g_dgettext() will be used.
         */
        get translationDomain(): string;
        set translationDomain(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Script.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Script.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Script;

        // Signals

        connect<K extends keyof Script.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Script.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Script.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Script.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Script.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Script.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        /**
         * Looks up a type by name, using the virtual function that
         * #ClutterScript has for that purpose. This function should
         * rarely be used.
         * @param type_name name of the type to look up
         */
        vfunc_get_type_from_name(type_name: string): GObject.GType;

        // Methods

        /**
         * Adds `paths` to the list of search paths held by `script`.
         *
         * The search paths are used by clutter_script_lookup_filename(), which
         * can be used to define search paths for the textures source file name
         * or other custom, file-based properties.
         * @param paths an array of strings containing   different search paths
         */
        add_search_paths(paths: string[]): void;
        /**
         * Associates a #ClutterState to the #ClutterScript instance using the given
         * name.
         *
         * The #ClutterScript instance will use `state` to resolve target states when
         * connecting signal handlers.
         *
         * The #ClutterScript instance will take a reference on the #ClutterState
         * passed to this function.
         * @param name a name for the @state, or %NULL to   set the default #ClutterState
         * @param state a #ClutterState
         */
        add_states(name: string | null, state: State): void;
        /**
         * Connects all the signals defined into a UI definition file to their
         * handlers.
         *
         * This method invokes clutter_script_connect_signals_full() internally
         * and uses  #GModule's introspective features (by opening the current
         * module's scope) to look at the application's symbol table.
         *
         * Note that this function will not work if #GModule is not supported by
         * the platform Clutter is running on.
         * @param user_data data to be passed to the signal handlers, or %NULL
         */
        connect_signals(user_data?: any | null): void;
        /**
         * Connects all the signals defined into a UI definition file to their
         * handlers.
         *
         * This function allows to control how the signal handlers are
         * going to be connected to their respective signals. It is meant
         * primarily for language bindings to allow resolving the function
         * names using the native API, but it can also be used on platforms
         * that do not support GModule.
         *
         * Applications should use clutter_script_connect_signals().
         * @param func signal connection function
         */
        connect_signals_full(func: ScriptConnectFunc): void;
        /**
         * Ensure that every object defined inside `script` is correctly
         * constructed. You should rarely need to use this function.
         */
        ensure_objects(): void;
        /**
         * Retrieves the object bound to `name`. This function does not increment
         * the reference count of the returned object.
         * @param name the name of the object to retrieve
         * @returns the named object, or %NULL if no object   with the given name was available
         */
        get_object<T = GObject.Object>(name: string): T;
        /**
         * Retrieves the #ClutterState for the given `state_name`.
         *
         * If `name` is %NULL, this function will return the default
         * #ClutterState instance.
         * @param name the name of the #ClutterState, or %NULL
         * @returns a pointer to the #ClutterState for the   given name. The #ClutterState is owned by the #ClutterScript instance   and it should not be unreferenced
         */
        get_states(name?: string | null): State;
        /**
         * Retrieves the translation domain set using
         * clutter_script_set_translation_domain().
         * @returns the translation domain, if any is set,   or %NULL
         */
        get_translation_domain(): string;
        /**
         * Looks up a type by name, using the virtual function that
         * #ClutterScript has for that purpose. This function should
         * rarely be used.
         * @param type_name name of the type to look up
         * @returns the type for the requested type name, or   %G_TYPE_INVALID if not corresponding type was found.
         */
        get_type_from_name(type_name: string): GObject.GType;
        /**
         * Retrieves all the objects created by `script`.
         *
         * Note: this function does not increment the reference count of the
         * objects it returns.
         * @returns a list   of #GObject<!-- -->s, or %NULL. The objects are owned by the   #ClutterScript instance. Use g_list_free() on the returned list when   done.
         */
        list_objects(): GObject.Object[];
        /**
         * Loads the definitions from `data` into `script` and merges with
         * the currently loaded ones, if any.
         * @param data a buffer containing the definitions
         * @param length the length of the buffer, or -1 if @data is a NUL-terminated   buffer
         * @returns on error, zero is returned and @error is set   accordingly. On success, the merge id for the UI definitions is   returned. You can use the merge id with clutter_script_unmerge_objects().
         */
        load_from_data(data: string, length: number): number;
        /**
         * Loads the definitions from `filename` into `script` and merges with
         * the currently loaded ones, if any.
         * @param filename the full path to the definition file
         * @returns on error, zero is returned and @error is set   accordingly. On success, the merge id for the UI definitions is   returned. You can use the merge id with clutter_script_unmerge_objects().
         */
        load_from_file(filename: string): number;
        /**
         * Loads the definitions from a resource file into `script` and merges with
         * the currently loaded ones, if any.
         * @param resource_path the resource path of the file to parse
         * @returns on error, zero is returned and @error is set   accordingly. On success, the merge id for the UI definitions is   returned. You can use the merge id with clutter_script_unmerge_objects().
         */
        load_from_resource(resource_path: string): number;
        /**
         * Looks up `filename` inside the search paths of `script`. If `filename`
         * is found, its full path will be returned .
         * @param filename the name of the file to lookup
         * @returns the full path of @filename or %NULL if no path was   found.
         */
        lookup_filename(filename: string): string;
        /**
         * Sets the translation domain for `script`.
         * @param domain the translation domain, or %NULL
         */
        set_translation_domain(domain?: string | null): void;
        /**
         * Unmerges the objects identified by `merge_id`.
         * @param merge_id merge id returned when loading a UI definition
         */
        unmerge_objects(merge_id: number): void;
    }

    namespace ScrollActor {
        // Signal signatures
        interface SignalSignatures extends Actor.SignalSignatures {
            'notify::scroll-mode': (pspec: GObject.ParamSpec) => void;
            'notify::actions': (pspec: GObject.ParamSpec) => void;
            'notify::allocation': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-x': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-y': (pspec: GObject.ParamSpec) => void;
            'notify::background-color': (pspec: GObject.ParamSpec) => void;
            'notify::background-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::clip': (pspec: GObject.ParamSpec) => void;
            'notify::clip-rect': (pspec: GObject.ParamSpec) => void;
            'notify::clip-to-allocation': (pspec: GObject.ParamSpec) => void;
            'notify::constraints': (pspec: GObject.ParamSpec) => void;
            'notify::content': (pspec: GObject.ParamSpec) => void;
            'notify::content-box': (pspec: GObject.ParamSpec) => void;
            'notify::content-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::content-repeat': (pspec: GObject.ParamSpec) => void;
            'notify::depth': (pspec: GObject.ParamSpec) => void;
            'notify::effect': (pspec: GObject.ParamSpec) => void;
            'notify::first-child': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-position-set': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-x': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-y': (pspec: GObject.ParamSpec) => void;
            'notify::has-clip': (pspec: GObject.ParamSpec) => void;
            'notify::has-pointer': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::last-child': (pspec: GObject.ParamSpec) => void;
            'notify::layout-manager': (pspec: GObject.ParamSpec) => void;
            'notify::magnification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::mapped': (pspec: GObject.ParamSpec) => void;
            'notify::margin-bottom': (pspec: GObject.ParamSpec) => void;
            'notify::margin-left': (pspec: GObject.ParamSpec) => void;
            'notify::margin-right': (pspec: GObject.ParamSpec) => void;
            'notify::margin-top': (pspec: GObject.ParamSpec) => void;
            'notify::min-height': (pspec: GObject.ParamSpec) => void;
            'notify::min-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::min-width': (pspec: GObject.ParamSpec) => void;
            'notify::min-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::minification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::offscreen-redirect': (pspec: GObject.ParamSpec) => void;
            'notify::opacity': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point-z': (pspec: GObject.ParamSpec) => void;
            'notify::position': (pspec: GObject.ParamSpec) => void;
            'notify::reactive': (pspec: GObject.ParamSpec) => void;
            'notify::realized': (pspec: GObject.ParamSpec) => void;
            'notify::request-mode': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-zgravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-z': (pspec: GObject.ParamSpec) => void;
            'notify::show-on-set-parent': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::text-direction': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::translation-x': (pspec: GObject.ParamSpec) => void;
            'notify::translation-y': (pspec: GObject.ParamSpec) => void;
            'notify::translation-z': (pspec: GObject.ParamSpec) => void;
            'notify::visible': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::x-align': (pspec: GObject.ParamSpec) => void;
            'notify::x-expand': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::y-align': (pspec: GObject.ParamSpec) => void;
            'notify::y-expand': (pspec: GObject.ParamSpec) => void;
            'notify::z-position': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Actor.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Animatable.ConstructorProps,
                Container.ConstructorProps,
                Scriptable.ConstructorProps {
            scroll_mode: ScrollMode;
            scrollMode: ScrollMode;
        }
    }

    /**
     * The #ClutterScrollActor structure contains only
     * private data, and should be accessed using the provided API.
     */
    class ScrollActor extends Actor implements Atk.ImplementorIface, Animatable, Container, Scriptable {
        static $gtype: GObject.GType<ScrollActor>;

        // Properties

        /**
         * The scrollin direction.
         */
        get scroll_mode(): ScrollMode;
        set scroll_mode(val: ScrollMode);
        /**
         * The scrollin direction.
         */
        get scrollMode(): ScrollMode;
        set scrollMode(val: ScrollMode);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ScrollActor.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ScrollActor.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ScrollActor;

        // Signals

        connect<K extends keyof ScrollActor.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ScrollActor.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ScrollActor.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ScrollActor.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ScrollActor.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ScrollActor.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the #ClutterScrollActor:scroll-mode property
         * @returns the scrolling mode
         */
        get_scroll_mode(): ScrollMode;
        /**
         * Scrolls the contents of `actor` so that `point` is the new origin
         * of the visible area.
         *
         * The coordinates of `point` must be relative to the `actor`.
         *
         * This function will use the currently set easing state of the `actor`
         * to transition from the current scroll origin to the new one.
         * @param point a #ClutterPoint
         */
        scroll_to_point(point: Point): void;
        /**
         * Scrolls `actor` so that `rect` is in the visible portion.
         * @param rect a #ClutterRect
         */
        scroll_to_rect(rect: Rect): void;
        /**
         * Sets the #ClutterScrollActor:scroll-mode property.
         * @param mode a #ClutterScrollMode
         */
        set_scroll_mode(mode: ScrollMode | null): void;

        // Inherited methods
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         * @returns %TRUE if the value has been validated and can   be applied to the #ClutterAnimatable, and %FALSE otherwise
         */
        animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         * @returns The #GParamSpec for the given property   or %NULL
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         * @returns %TRUE if the interpolation was successful,   and %FALSE otherwise
         */
        interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         */
        vfunc_animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         */
        vfunc_find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        vfunc_get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         */
        vfunc_interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        vfunc_set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        add_actor(actor: Actor): void;
        /**
         * Gets a container specific property of a child of `container,` In general,
         * a copy is made of the property contents and the caller is responsible for
         * freeing the memory by calling g_value_unset().
         *
         * Note that clutter_container_child_set_property() is really intended for
         * language bindings, clutter_container_child_set() is much more convenient
         * for C programming.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_get_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Sets a container-specific property on a child of `container`.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_set_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        destroy_child_meta(actor: Actor): void;
        /**
         * Finds a child actor of a container by its name. Search recurses
         * into any child container.
         * @param child_name the name of the requested child.
         * @returns The child actor with the requested name,   or %NULL if no actor with that name was found.
         */
        find_child_by_name(child_name: string): Actor;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         * @returns the #ClutterChildMeta for the @actor child   of @container or %NULL if the specifiec actor does not exist or the   container is not configured to provide #ClutterChildMeta<!-- -->s
         */
        get_child_meta(actor: Actor): ChildMeta;
        /**
         * Retrieves all the children of `container`.
         * @returns a list   of #ClutterActor<!-- -->s. Use g_list_free() on the returned   list when done.
         */
        get_children(): Actor[];
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        lower_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        raise_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        remove_actor(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        sort_depth_order(): void;
        vfunc_actor_added(actor: Actor): void;
        vfunc_actor_removed(actor: Actor): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        vfunc_add(actor: Actor): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        vfunc_child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_destroy_child_meta(actor: Actor): void;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         */
        vfunc_get_child_meta(actor: Actor): ChildMeta;
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        vfunc_lower(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        vfunc_raise(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        vfunc_remove(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        vfunc_sort_depth_order(): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Settings {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::backend': (pspec: GObject.ParamSpec) => void;
            'notify::dnd-drag-threshold': (pspec: GObject.ParamSpec) => void;
            'notify::double-click-distance': (pspec: GObject.ParamSpec) => void;
            'notify::double-click-time': (pspec: GObject.ParamSpec) => void;
            'notify::font-antialias': (pspec: GObject.ParamSpec) => void;
            'notify::font-dpi': (pspec: GObject.ParamSpec) => void;
            'notify::font-hint-style': (pspec: GObject.ParamSpec) => void;
            'notify::font-hinting': (pspec: GObject.ParamSpec) => void;
            'notify::font-name': (pspec: GObject.ParamSpec) => void;
            'notify::font-subpixel-order': (pspec: GObject.ParamSpec) => void;
            'notify::fontconfig-timestamp': (pspec: GObject.ParamSpec) => void;
            'notify::long-press-duration': (pspec: GObject.ParamSpec) => void;
            'notify::password-hint-time': (pspec: GObject.ParamSpec) => void;
            'notify::unscaled-font-dpi': (pspec: GObject.ParamSpec) => void;
            'notify::window-scaling-factor': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            backend: Backend;
            dnd_drag_threshold: number;
            dndDragThreshold: number;
            double_click_distance: number;
            doubleClickDistance: number;
            double_click_time: number;
            doubleClickTime: number;
            font_antialias: number;
            fontAntialias: number;
            font_dpi: number;
            fontDpi: number;
            font_hint_style: string;
            fontHintStyle: string;
            font_hinting: number;
            fontHinting: number;
            font_name: string;
            fontName: string;
            font_subpixel_order: string;
            fontSubpixelOrder: string;
            fontconfig_timestamp: number;
            fontconfigTimestamp: number;
            long_press_duration: number;
            longPressDuration: number;
            password_hint_time: number;
            passwordHintTime: number;
            unscaled_font_dpi: number;
            unscaledFontDpi: number;
            window_scaling_factor: number;
            windowScalingFactor: number;
        }
    }

    /**
     * `ClutterSettings` is an opaque structure whose
     * members cannot be directly accessed.
     */
    class Settings extends GObject.Object {
        static $gtype: GObject.GType<Settings>;

        // Properties

        /**
         * A back pointer to the #ClutterBackend
         */
        set backend(val: Backend);
        /**
         * The default distance that the cursor of a pointer device
         * should travel before a drag operation should start.
         */
        get dnd_drag_threshold(): number;
        set dnd_drag_threshold(val: number);
        /**
         * The default distance that the cursor of a pointer device
         * should travel before a drag operation should start.
         */
        get dndDragThreshold(): number;
        set dndDragThreshold(val: number);
        /**
         * The maximum distance, in pixels, between button-press events that
         * determines whether or not to increase the click count by 1.
         */
        get double_click_distance(): number;
        set double_click_distance(val: number);
        /**
         * The maximum distance, in pixels, between button-press events that
         * determines whether or not to increase the click count by 1.
         */
        get doubleClickDistance(): number;
        set doubleClickDistance(val: number);
        /**
         * The time, in milliseconds, that should elapse between button-press
         * events in order to increase the click count by 1.
         */
        get double_click_time(): number;
        set double_click_time(val: number);
        /**
         * The time, in milliseconds, that should elapse between button-press
         * events in order to increase the click count by 1.
         */
        get doubleClickTime(): number;
        set doubleClickTime(val: number);
        /**
         * Whether or not to use antialiasing when rendering text; a value
         * of 1 enables it unconditionally; a value of 0 disables it
         * unconditionally; and -1 will use the system's default.
         */
        get font_antialias(): number;
        set font_antialias(val: number);
        /**
         * Whether or not to use antialiasing when rendering text; a value
         * of 1 enables it unconditionally; a value of 0 disables it
         * unconditionally; and -1 will use the system's default.
         */
        get fontAntialias(): number;
        set fontAntialias(val: number);
        /**
         * The DPI used when rendering text, as a value of 1024 * dots/inch.
         *
         * If set to -1, the system's default will be used instead
         */
        get font_dpi(): number;
        set font_dpi(val: number);
        /**
         * The DPI used when rendering text, as a value of 1024 * dots/inch.
         *
         * If set to -1, the system's default will be used instead
         */
        get fontDpi(): number;
        set fontDpi(val: number);
        /**
         * The style of the hinting used when rendering text. Valid values
         * are:
         *
         *   - hintnone
         *   - hintslight
         *   - hintmedium
         *   - hintfull
         */
        get font_hint_style(): string;
        set font_hint_style(val: string);
        /**
         * The style of the hinting used when rendering text. Valid values
         * are:
         *
         *   - hintnone
         *   - hintslight
         *   - hintmedium
         *   - hintfull
         */
        get fontHintStyle(): string;
        set fontHintStyle(val: string);
        /**
         * Whether or not to use hinting when rendering text; a value of 1
         * unconditionally enables it; a value of 0 unconditionally disables
         * it; and a value of -1 will use the system's default.
         */
        get font_hinting(): number;
        set font_hinting(val: number);
        /**
         * Whether or not to use hinting when rendering text; a value of 1
         * unconditionally enables it; a value of 0 unconditionally disables
         * it; and a value of -1 will use the system's default.
         */
        get fontHinting(): number;
        set fontHinting(val: number);
        /**
         * The default font name that should be used by text actors, as
         * a string that can be passed to pango_font_description_from_string().
         */
        get font_name(): string;
        set font_name(val: string);
        /**
         * The default font name that should be used by text actors, as
         * a string that can be passed to pango_font_description_from_string().
         */
        get fontName(): string;
        set fontName(val: string);
        /**
         * The type of sub-pixel antialiasing used when rendering text. Valid
         * values are:
         *
         *   - none
         *   - rgb
         *   - bgr
         *   - vrgb
         *   - vbgr
         */
        get font_subpixel_order(): string;
        set font_subpixel_order(val: string);
        /**
         * The type of sub-pixel antialiasing used when rendering text. Valid
         * values are:
         *
         *   - none
         *   - rgb
         *   - bgr
         *   - vrgb
         *   - vbgr
         */
        get fontSubpixelOrder(): string;
        set fontSubpixelOrder(val: string);
        set fontconfig_timestamp(val: number);
        set fontconfigTimestamp(val: number);
        /**
         * Sets the minimum duration for a press to be recognized as a long press
         * gesture. The duration is expressed in milliseconds.
         *
         * See also #ClutterClickAction:long-press-duration.
         */
        get long_press_duration(): number;
        set long_press_duration(val: number);
        /**
         * Sets the minimum duration for a press to be recognized as a long press
         * gesture. The duration is expressed in milliseconds.
         *
         * See also #ClutterClickAction:long-press-duration.
         */
        get longPressDuration(): number;
        set longPressDuration(val: number);
        get password_hint_time(): number;
        set password_hint_time(val: number);
        get passwordHintTime(): number;
        set passwordHintTime(val: number);
        set unscaled_font_dpi(val: number);
        set unscaledFontDpi(val: number);
        get window_scaling_factor(): number;
        set window_scaling_factor(val: number);
        get windowScalingFactor(): number;
        set windowScalingFactor(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Settings.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Settings.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof Settings.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Settings.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Settings.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Settings.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Settings.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Settings.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Retrieves the singleton instance of #ClutterSettings
         */
        static get_default(): Settings;
    }

    namespace Shader {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'notify::compiled': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::fragment-source': (pspec: GObject.ParamSpec) => void;
            'notify::vertex-source': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            compiled: boolean;
            enabled: boolean;
            fragment_source: string;
            fragmentSource: string;
            vertex_source: string;
            vertexSource: string;
        }
    }

    /**
     * The #ClutterShader structure contains only private data
     * and should be accessed using the provided API
     */
    class Shader extends GObject.Object {
        static $gtype: GObject.GType<Shader>;

        // Properties

        /**
         * Whether the shader is compiled and linked, ready for use
         * in the GL context.
         */
        get compiled(): boolean;
        /**
         * Whether the shader is currently used in the GL rendering pipeline.
         */
        get enabled(): boolean;
        set enabled(val: boolean);
        /**
         * GLSL source code for the fragment shader part of the shader program.
         */
        get fragment_source(): string;
        set fragment_source(val: string);
        /**
         * GLSL source code for the fragment shader part of the shader program.
         */
        get fragmentSource(): string;
        set fragmentSource(val: string);
        /**
         * GLSL source code for the vertex shader part of the shader
         * program, if any
         */
        get vertex_source(): string;
        set vertex_source(val: string);
        /**
         * GLSL source code for the vertex shader part of the shader
         * program, if any
         */
        get vertexSource(): string;
        set vertexSource(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Shader.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Shader.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Shader;

        // Signals

        connect<K extends keyof Shader.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Shader.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Shader.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Shader.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Shader.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Shader.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Compiles and links GLSL sources set for vertex and fragment shaders for
         * a #ClutterShader. If the compilation fails and a #GError return location is
         * provided the error will contain the errors from the compiler, if any.
         * @returns returns TRUE if the shader was succesfully compiled.
         */
        compile(): boolean;
        /**
         * Retrieves the underlying #CoglHandle for the fragment shader.
         * @returns A #CoglHandle for the fragment   shader, or %NULL. The handle is owned by the #ClutterShader   and it should not be unreferenced
         */
        get_cogl_fragment_shader(): Cogl.Handle;
        /**
         * Retrieves the underlying #CoglHandle for the shader program.
         * @returns A #CoglHandle for the shader program,   or %NULL. The handle is owned by the #ClutterShader and it should   not be unreferenced
         */
        get_cogl_program(): Cogl.Handle;
        /**
         * Retrieves the underlying #CoglHandle for the vertex shader.
         * @returns A #CoglHandle for the vertex   shader, or %NULL. The handle is owned by the #ClutterShader   and it should not be unreferenced
         */
        get_cogl_vertex_shader(): Cogl.Handle;
        /**
         * Query the current GLSL fragment source set on `shader`.
         * @returns the source of the fragment shader for this ClutterShader object or %NULL. The returned string is owned by the shader object and should never be modified or freed
         */
        get_fragment_source(): string;
        /**
         * Checks whether `shader` is enabled.
         * @returns %TRUE if the shader is enabled.
         */
        get_is_enabled(): boolean;
        /**
         * Query the current GLSL vertex source set on `shader`.
         * @returns the source of the vertex shader for this ClutterShader object or %NULL. The returned string is owned by the shader object and should never be modified or freed
         */
        get_vertex_source(): string;
        /**
         * Checks whether `shader` is is currently compiled, linked and bound
         * to the GL context.
         * @returns %TRUE if the shader is compiled, linked and ready for use.
         */
        is_compiled(): boolean;
        /**
         * Frees up any GL context resources held by the shader.
         */
        release(): void;
        /**
         * Sets the GLSL source code to be used by a #ClutterShader for the fragment
         * program.
         * @param data GLSL source code.
         * @param length length of source buffer (currently ignored)
         */
        set_fragment_source(data: string, length: number): void;
        /**
         * Enables a shader. This function will attempt to compile and link
         * the shader, if it isn't already.
         *
         * When `enabled` is %FALSE the default state of the GL pipeline will be
         * used instead.
         * @param enabled The new state of the shader.
         */
        set_is_enabled(enabled: boolean): void;
        /**
         * Sets a user configurable variable in the GLSL shader programs attached to
         * a #ClutterShader.
         * @param name name of uniform in GLSL shader program to set.
         * @param value a #ClutterShaderFloat, #ClutterShaderInt or #ClutterShaderMatrix         #GValue.
         */
        set_uniform(name: string, value: GObject.Value | any): void;
        /**
         * Sets the GLSL source code to be used by a #ClutterShader for the vertex
         * program.
         * @param data GLSL source code.
         * @param length length of source buffer (currently ignored)
         */
        set_vertex_source(data: string, length: number): void;
    }

    namespace ShaderEffect {
        // Signal signatures
        interface SignalSignatures extends OffscreenEffect.SignalSignatures {
            'notify::shader-type': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends OffscreenEffect.ConstructorProps {
            shader_type: ShaderType;
            shaderType: ShaderType;
        }
    }

    /**
     * The #ClutterShaderEffect structure contains
     * only private data and should be accessed using the provided API
     */
    class ShaderEffect extends OffscreenEffect {
        static $gtype: GObject.GType<ShaderEffect>;

        // Properties

        /**
         * The type of shader that is used by the effect. This property
         * should be set by the constructor of #ClutterShaderEffect
         * sub-classes.
         */
        set shader_type(val: ShaderType);
        /**
         * The type of shader that is used by the effect. This property
         * should be set by the constructor of #ClutterShaderEffect
         * sub-classes.
         */
        set shaderType(val: ShaderType);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ShaderEffect.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ShaderEffect.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](shader_type: ShaderType): ShaderEffect;

        // Signals

        connect<K extends keyof ShaderEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ShaderEffect.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ShaderEffect.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ShaderEffect.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ShaderEffect.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ShaderEffect.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_get_static_shader_source(): string;

        // Methods

        /**
         * Retrieves a pointer to the program's handle
         * @returns a pointer to the program's handle,   or %COGL_INVALID_HANDLE
         */
        get_program(): Cogl.Handle;
        /**
         * Retrieves a pointer to the shader's handle
         * @returns a pointer to the shader's handle,   or %COGL_INVALID_HANDLE
         */
        get_shader(): Cogl.Handle;
        /**
         * Sets the source of the GLSL shader used by `effect`
         *
         * This function should only be called by implementations of
         * the #ClutterShaderEffect class, and not by application code.
         *
         * This function can only be called once; subsequent calls will
         * yield no result.
         * @param source the source of a GLSL shader
         * @returns %TRUE if the source was set
         */
        set_shader_source(source: string): boolean;
        /**
         * Sets `value` as the payload for the uniform `name` inside the shader
         * effect
         *
         * The #GType of the `value` must be one of: %G_TYPE_INT, for a single
         * integer value; %G_TYPE_FLOAT, for a single floating point value;
         * %CLUTTER_TYPE_SHADER_INT, for an array of integer values;
         * %CLUTTER_TYPE_SHADER_FLOAT, for an array of floating point values;
         * and %CLUTTER_TYPE_SHADER_MATRIX, for a matrix of floating point
         * values. It also accepts %G_TYPE_DOUBLE for compatibility with other
         * languages than C.
         * @param name the name of the uniform to set
         * @param value a #GValue with the value of the uniform to set
         */
        set_uniform_value(name: string, value: GObject.Value | any): void;
    }

    namespace ShaderFloat {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}
    }

    class ShaderFloat {
        static $gtype: GObject.GType<ShaderFloat>;

        // Constructors

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof ShaderFloat.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ShaderFloat.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ShaderFloat.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ShaderFloat.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ShaderFloat.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ShaderFloat.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace ShaderInt {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}
    }

    class ShaderInt {
        static $gtype: GObject.GType<ShaderInt>;

        // Constructors

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof ShaderInt.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ShaderInt.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ShaderInt.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ShaderInt.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ShaderInt.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ShaderInt.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace ShaderMatrix {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {}
    }

    class ShaderMatrix {
        static $gtype: GObject.GType<ShaderMatrix>;

        // Constructors

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof ShaderMatrix.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ShaderMatrix.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ShaderMatrix.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ShaderMatrix.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ShaderMatrix.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ShaderMatrix.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace SnapConstraint {
        // Signal signatures
        interface SignalSignatures extends Constraint.SignalSignatures {
            'notify::from-edge': (pspec: GObject.ParamSpec) => void;
            'notify::offset': (pspec: GObject.ParamSpec) => void;
            'notify::source': (pspec: GObject.ParamSpec) => void;
            'notify::to-edge': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Constraint.ConstructorProps {
            from_edge: SnapEdge;
            fromEdge: SnapEdge;
            offset: number;
            source: Actor;
            to_edge: SnapEdge;
            toEdge: SnapEdge;
        }
    }

    /**
     * #ClutterSnapConstraint is an opaque structure
     * whose members cannot be directly accesses
     */
    class SnapConstraint extends Constraint {
        static $gtype: GObject.GType<SnapConstraint>;

        // Properties

        /**
         * The edge of the #ClutterActor that should be snapped
         */
        get from_edge(): SnapEdge;
        set from_edge(val: SnapEdge);
        /**
         * The edge of the #ClutterActor that should be snapped
         */
        get fromEdge(): SnapEdge;
        set fromEdge(val: SnapEdge);
        /**
         * The offset, in pixels, between #ClutterSnapConstraint:from-edge
         * and #ClutterSnapConstraint:to-edge
         */
        get offset(): number;
        set offset(val: number);
        /**
         * The #ClutterActor used as the source for the constraint
         */
        get source(): Actor;
        set source(val: Actor);
        /**
         * The edge of the #ClutterSnapConstraint:source that should be snapped
         */
        get to_edge(): SnapEdge;
        set to_edge(val: SnapEdge);
        /**
         * The edge of the #ClutterSnapConstraint:source that should be snapped
         */
        get toEdge(): SnapEdge;
        set toEdge(val: SnapEdge);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: SnapConstraint.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<SnapConstraint.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](source: Actor | null, from_edge: SnapEdge, to_edge: SnapEdge, offset: number): SnapConstraint;

        // Signals

        connect<K extends keyof SnapConstraint.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, SnapConstraint.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof SnapConstraint.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, SnapConstraint.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof SnapConstraint.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<SnapConstraint.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the edges used by the `constraint`
         */
        get_edges(): [SnapEdge, SnapEdge];
        /**
         * Retrieves the offset set using clutter_snap_constraint_set_offset()
         * @returns the offset, in pixels
         */
        get_offset(): number;
        /**
         * Retrieves the #ClutterActor set using clutter_snap_constraint_set_source()
         * @returns a pointer to the source actor
         */
        get_source(): Actor;
        /**
         * Sets the edges to be used by the `constraint`
         *
         * The `from_edge` is the edge on the #ClutterActor to which `constraint`
         * has been added. The `to_edge` is the edge of the #ClutterActor inside
         * the #ClutterSnapConstraint:source property.
         * @param from_edge the edge on the actor
         * @param to_edge the edge on the source
         */
        set_edges(from_edge: SnapEdge | null, to_edge: SnapEdge | null): void;
        /**
         * Sets the offset to be applied to the constraint
         * @param offset the offset to apply, in pixels
         */
        set_offset(offset: number): void;
        /**
         * Sets the source #ClutterActor for the constraint
         * @param source a #ClutterActor, or %NULL to unset the source
         */
        set_source(source?: Actor | null): void;
    }

    namespace Stage {
        // Signal signatures
        interface SignalSignatures extends Group.SignalSignatures {
            activate: () => void;
            'after-paint': () => void;
            deactivate: () => void;
            'delete-event': (arg0: Event) => boolean | void;
            fullscreen: () => void;
            unfullscreen: () => void;
            'notify::accept-focus': (pspec: GObject.ParamSpec) => void;
            'notify::color': (pspec: GObject.ParamSpec) => void;
            'notify::cursor-visible': (pspec: GObject.ParamSpec) => void;
            'notify::fog': (pspec: GObject.ParamSpec) => void;
            'notify::fullscreen-set': (pspec: GObject.ParamSpec) => void;
            'notify::key-focus': (pspec: GObject.ParamSpec) => void;
            'notify::no-clear-hint': (pspec: GObject.ParamSpec) => void;
            'notify::offscreen': (pspec: GObject.ParamSpec) => void;
            'notify::perspective': (pspec: GObject.ParamSpec) => void;
            'notify::title': (pspec: GObject.ParamSpec) => void;
            'notify::use-alpha': (pspec: GObject.ParamSpec) => void;
            'notify::use-fog': (pspec: GObject.ParamSpec) => void;
            'notify::user-resizable': (pspec: GObject.ParamSpec) => void;
            'notify::actions': (pspec: GObject.ParamSpec) => void;
            'notify::allocation': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-x': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-y': (pspec: GObject.ParamSpec) => void;
            'notify::background-color': (pspec: GObject.ParamSpec) => void;
            'notify::background-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::clip': (pspec: GObject.ParamSpec) => void;
            'notify::clip-rect': (pspec: GObject.ParamSpec) => void;
            'notify::clip-to-allocation': (pspec: GObject.ParamSpec) => void;
            'notify::constraints': (pspec: GObject.ParamSpec) => void;
            'notify::content': (pspec: GObject.ParamSpec) => void;
            'notify::content-box': (pspec: GObject.ParamSpec) => void;
            'notify::content-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::content-repeat': (pspec: GObject.ParamSpec) => void;
            'notify::depth': (pspec: GObject.ParamSpec) => void;
            'notify::effect': (pspec: GObject.ParamSpec) => void;
            'notify::first-child': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-position-set': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-x': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-y': (pspec: GObject.ParamSpec) => void;
            'notify::has-clip': (pspec: GObject.ParamSpec) => void;
            'notify::has-pointer': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::last-child': (pspec: GObject.ParamSpec) => void;
            'notify::layout-manager': (pspec: GObject.ParamSpec) => void;
            'notify::magnification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::mapped': (pspec: GObject.ParamSpec) => void;
            'notify::margin-bottom': (pspec: GObject.ParamSpec) => void;
            'notify::margin-left': (pspec: GObject.ParamSpec) => void;
            'notify::margin-right': (pspec: GObject.ParamSpec) => void;
            'notify::margin-top': (pspec: GObject.ParamSpec) => void;
            'notify::min-height': (pspec: GObject.ParamSpec) => void;
            'notify::min-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::min-width': (pspec: GObject.ParamSpec) => void;
            'notify::min-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::minification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::offscreen-redirect': (pspec: GObject.ParamSpec) => void;
            'notify::opacity': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point-z': (pspec: GObject.ParamSpec) => void;
            'notify::position': (pspec: GObject.ParamSpec) => void;
            'notify::reactive': (pspec: GObject.ParamSpec) => void;
            'notify::realized': (pspec: GObject.ParamSpec) => void;
            'notify::request-mode': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-zgravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-z': (pspec: GObject.ParamSpec) => void;
            'notify::show-on-set-parent': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::text-direction': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::translation-x': (pspec: GObject.ParamSpec) => void;
            'notify::translation-y': (pspec: GObject.ParamSpec) => void;
            'notify::translation-z': (pspec: GObject.ParamSpec) => void;
            'notify::visible': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::x-align': (pspec: GObject.ParamSpec) => void;
            'notify::x-expand': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::y-align': (pspec: GObject.ParamSpec) => void;
            'notify::y-expand': (pspec: GObject.ParamSpec) => void;
            'notify::z-position': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Group.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Animatable.ConstructorProps,
                Container.ConstructorProps,
                Scriptable.ConstructorProps {
            accept_focus: boolean;
            acceptFocus: boolean;
            color: Color;
            cursor_visible: boolean;
            cursorVisible: boolean;
            fog: Fog;
            fullscreen_set: boolean;
            fullscreenSet: boolean;
            key_focus: Actor;
            keyFocus: Actor;
            no_clear_hint: boolean;
            noClearHint: boolean;
            offscreen: boolean;
            perspective: Perspective;
            title: string;
            use_alpha: boolean;
            useAlpha: boolean;
            use_fog: boolean;
            useFog: boolean;
            user_resizable: boolean;
            userResizable: boolean;
        }
    }

    /**
     * The #ClutterStage structure contains only private data
     * and should be accessed using the provided API
     */
    class Stage extends Group implements Atk.ImplementorIface, Animatable, Container, Scriptable {
        static $gtype: GObject.GType<Stage>;

        // Properties

        /**
         * Whether the #ClutterStage should accept key focus when shown.
         */
        get accept_focus(): boolean;
        set accept_focus(val: boolean);
        /**
         * Whether the #ClutterStage should accept key focus when shown.
         */
        get acceptFocus(): boolean;
        set acceptFocus(val: boolean);
        /**
         * The background color of the main stage.
         */
        get color(): Color;
        set color(val: Color);
        /**
         * Whether the mouse pointer should be visible
         */
        get cursor_visible(): boolean;
        set cursor_visible(val: boolean);
        /**
         * Whether the mouse pointer should be visible
         */
        get cursorVisible(): boolean;
        set cursorVisible(val: boolean);
        /**
         * The settings for the GL "fog", used only if #ClutterStage:use-fog
         * is set to %TRUE
         */
        get fog(): Fog;
        set fog(val: Fog);
        get fullscreen_set(): boolean;
        get fullscreenSet(): boolean;
        /**
         * The #ClutterActor that will receive key events from the underlying
         * windowing system.
         *
         * If %NULL, the #ClutterStage will receive the events.
         */
        get key_focus(): Actor;
        set key_focus(val: Actor);
        /**
         * The #ClutterActor that will receive key events from the underlying
         * windowing system.
         *
         * If %NULL, the #ClutterStage will receive the events.
         */
        get keyFocus(): Actor;
        set keyFocus(val: Actor);
        /**
         * Whether or not the #ClutterStage should clear its contents
         * before each paint cycle.
         *
         * See clutter_stage_set_no_clear_hint() for further information.
         */
        get no_clear_hint(): boolean;
        set no_clear_hint(val: boolean);
        /**
         * Whether or not the #ClutterStage should clear its contents
         * before each paint cycle.
         *
         * See clutter_stage_set_no_clear_hint() for further information.
         */
        get noClearHint(): boolean;
        set noClearHint(val: boolean);
        /**
         * Whether the stage should be rendered in an offscreen buffer.
         */
        get offscreen(): boolean;
        set offscreen(val: boolean);
        /**
         * The parameters used for the perspective projection from 3D
         * coordinates to 2D
         */
        get perspective(): Perspective;
        set perspective(val: Perspective);
        /**
         * The stage's title - usually displayed in stage windows title decorations.
         */
        get title(): string;
        set title(val: string);
        /**
         * Whether the #ClutterStage should honour the alpha component of the
         * #ClutterStage:color property when painting. If Clutter is run under
         * a compositing manager this will result in the stage being blended
         * with the underlying window(s)
         */
        get use_alpha(): boolean;
        set use_alpha(val: boolean);
        /**
         * Whether the #ClutterStage should honour the alpha component of the
         * #ClutterStage:color property when painting. If Clutter is run under
         * a compositing manager this will result in the stage being blended
         * with the underlying window(s)
         */
        get useAlpha(): boolean;
        set useAlpha(val: boolean);
        /**
         * Whether the stage should use a linear GL "fog" in creating the
         * depth-cueing effect, to enhance the perception of depth by fading
         * actors farther from the viewpoint.
         */
        get use_fog(): boolean;
        set use_fog(val: boolean);
        /**
         * Whether the stage should use a linear GL "fog" in creating the
         * depth-cueing effect, to enhance the perception of depth by fading
         * actors farther from the viewpoint.
         */
        get useFog(): boolean;
        set useFog(val: boolean);
        /**
         * Whether the stage is resizable via user interaction.
         */
        get user_resizable(): boolean;
        set user_resizable(val: boolean);
        /**
         * Whether the stage is resizable via user interaction.
         */
        get userResizable(): boolean;
        set userResizable(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Stage.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Stage.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Stage;

        // Signals

        connect<K extends keyof Stage.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Stage.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Stage.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Stage.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Stage.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Stage.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Retrieves a #ClutterStage singleton.
         *
         * This function is not as useful as it sounds, and will most likely
         * by deprecated in the future. Application code should only create
         * a #ClutterStage instance using clutter_stage_new(), and manage the
         * lifetime of the stage manually.
         *
         * The default stage singleton has a platform-specific behaviour: on
         * platforms without the %CLUTTER_FEATURE_STAGE_MULTIPLE feature flag
         * set, the first #ClutterStage instance will also be set to be the
         * default stage instance, and this function will always return a
         * pointer to it.
         *
         * On platforms with the %CLUTTER_FEATURE_STAGE_MULTIPLE feature flag
         * set, the default stage will be created by the first call to this
         * function, and every following call will return the same pointer to
         * it.
         */
        static get_default(): Stage;

        // Virtual methods

        vfunc_activate(): void;
        vfunc_deactivate(): void;
        vfunc_delete_event(event: Event): boolean;
        vfunc_fullscreen(): void;
        vfunc_unfullscreen(): void;

        // Methods

        /**
         * This function essentially makes sure the right GL context is
         * current for the passed stage. It is not intended to
         * be used by applications.
         */
        ensure_current(): void;
        /**
         * Ensures that `stage` is redrawn
         *
         * This function should not be called by applications: it is
         * used when embedding a #ClutterStage into a toolkit with
         * another windowing system, like GTK+.
         */
        ensure_redraw(): void;
        /**
         * Ensures that the GL viewport is updated with the current
         * stage window size.
         *
         * This function will queue a redraw of `stage`.
         *
         * This function should not be called by applications; it is used
         * when embedding a #ClutterStage into a toolkit with another
         * windowing system, like GTK+.
         */
        ensure_viewport(): void;
        /**
         * This function is used to emit an event on the main stage.
         *
         * You should rarely need to use this function, except for
         * synthetised events.
         * @param event a #ClutterEvent
         * @returns the return value from the signal emission
         */
        event(event: Event): boolean;
        /**
         * Retrieves the value set with clutter_stage_set_accept_focus().
         * @returns %TRUE if the #ClutterStage should accept focus, and %FALSE   otherwise
         */
        get_accept_focus(): boolean;
        /**
         * Checks the scene at the coordinates `x` and `y` and returns a pointer
         * to the #ClutterActor at those coordinates.
         *
         * By using `pick_mode` it is possible to control which actors will be
         * painted and thus available.
         * @param pick_mode how the scene graph should be painted
         * @param x X coordinate to check
         * @param y Y coordinate to check
         * @returns the actor at the specified coordinates,   if any
         */
        get_actor_at_pos(pick_mode: PickMode | null, x: number, y: number): Actor;
        /**
         * Retrieves the stage color.
         */
        get_color(): Color;
        /**
         * Retrieves the current depth cueing settings from the stage.
         */
        get_fog(): Fog;
        /**
         * Retrieves whether the stage is full screen or not
         * @returns %TRUE if the stage is full screen
         */
        get_fullscreen(): boolean;
        /**
         * Retrieves the actor that is currently under key focus.
         * @returns the actor with key focus, or the stage
         */
        get_key_focus(): Actor;
        /**
         * Retrieves the minimum size for a stage window as set using
         * clutter_stage_set_minimum_size().
         *
         * The returned size may not correspond to the actual minimum size and
         * it is specific to the #ClutterStage implementation inside the
         * Clutter backend
         */
        get_minimum_size(): [number, number];
        /**
         * Retrieves the value set using clutter_stage_set_motion_events_enabled().
         * @returns %TRUE if the per-actor motion event delivery is enabled   and %FALSE otherwise
         */
        get_motion_events_enabled(): boolean;
        /**
         * Retrieves the hint set with clutter_stage_set_no_clear_hint()
         * @returns %TRUE if the stage should not clear itself on every paint   cycle, and %FALSE otherwise
         */
        get_no_clear_hint(): boolean;
        /**
         * Retrieves the stage perspective.
         */
        get_perspective(): Perspective | null;
        /**
         * Gets the bounds of the current redraw for `stage` in stage pixel
         * coordinates. E.g., if only a single actor has queued a redraw then
         * Clutter may redraw the stage with a clip so that it doesn't have to
         * paint every pixel in the stage. This function would then return the
         * bounds of that clip. An application can use this information to
         * avoid some extra work if it knows that some regions of the stage
         * aren't going to be painted. This should only be called while the
         * stage is being painted. If there is no current redraw clip then
         * this function will set `clip` to the full extents of the stage.
         */
        get_redraw_clip_bounds(): cairo.RectangleInt;
        /**
         * Retrieves the value set with clutter_stage_set_throttle_motion_events()
         * @returns %TRUE if the motion events are being throttled,   and %FALSE otherwise
         */
        get_throttle_motion_events(): boolean;
        /**
         * Gets the stage title.
         * @returns pointer to the title string for the stage. The returned string is owned by the actor and should not be modified or freed.
         */
        get_title(): string;
        /**
         * Retrieves the value set using clutter_stage_set_use_alpha()
         * @returns %TRUE if the stage should honour the opacity and the   alpha channel of the stage color
         */
        get_use_alpha(): boolean;
        /**
         * Gets whether the depth cueing effect is enabled on `stage`.
         * @returns %TRUE if the depth cueing effect is enabled
         */
        get_use_fog(): boolean;
        /**
         * Retrieves the value set with clutter_stage_set_user_resizable().
         * @returns %TRUE if the stage is resizable by the user.
         */
        get_user_resizable(): boolean;
        /**
         * Makes the cursor invisible on the stage window
         */
        hide_cursor(): void;
        /**
         * Checks if `stage` is the default stage, or an instance created using
         * clutter_stage_new() but internally using the same implementation.
         * @returns %TRUE if the passed stage is the default one
         */
        is_default(): boolean;
        /**
         * Queues a redraw for the passed stage.
         *
         * Applications should call clutter_actor_queue_redraw() and not
         * this function.
         */
        queue_redraw(): void;
        /**
         * Makes a screenshot of the stage in RGBA 8bit data, returns a
         * linear buffer with `width` * 4 as rowstride.
         *
         * The alpha data contained in the returned buffer is driver-dependent,
         * and not guaranteed to hold any sensible value.
         * @param x x coordinate of the first pixel that is read from stage
         * @param y y coordinate of the first pixel that is read from stage
         * @param width Width dimention of pixels to be read, or -1 for the   entire stage width
         * @param height Height dimention of pixels to be read, or -1 for the   entire stage height
         * @returns a pointer to newly allocated memory with the buffer   or %NULL if the read failed. Use g_free() on the returned data   to release the resources it has allocated.
         */
        read_pixels(x: number, y: number, width: number, height: number): Uint8Array;
        /**
         * Sets whether the `stage` should accept the key focus when shown.
         *
         * This function should be called before showing `stage` using
         * clutter_actor_show().
         * @param accept_focus %TRUE to accept focus on show
         */
        set_accept_focus(accept_focus: boolean): void;
        /**
         * Sets the stage color.
         * @param color A #ClutterColor
         */
        set_color(color: Color): void;
        /**
         * Sets the fog (also known as "depth cueing") settings for the `stage`.
         *
         * A #ClutterStage will only use a linear fog progression, which
         * depends solely on the distance from the viewer. The cogl_set_fog()
         * function in COGL exposes more of the underlying implementation,
         * and allows changing the for progression function. It can be directly
         * used by disabling the #ClutterStage:use-fog property and connecting
         * a signal handler to the #ClutterActor::paint signal on the `stage,`
         * like:
         *
         *
         * ```
         *   clutter_stage_set_use_fog (stage, FALSE);
         *   g_signal_connect (stage, "paint", G_CALLBACK (on_stage_paint), NULL);
         * ```
         *
         *
         * The paint signal handler will call cogl_set_fog() with the
         * desired settings:
         *
         *
         * ```
         *   static void
         *   on_stage_paint (ClutterActor *actor)
         *   {
         *     ClutterColor stage_color = { 0, };
         *     CoglColor fog_color = { 0, };
         *
         *     // set the fog color to the stage background color
         *     clutter_stage_get_color (CLUTTER_STAGE (actor), &stage_color);
         *     cogl_color_init_from_4ub (&fog_color,
         *                               stage_color.red,
         *                               stage_color.green,
         *                               stage_color.blue,
         *                               stage_color.alpha);
         *
         *     // enable fog //
         *     cogl_set_fog (&fog_color,
         *                   COGL_FOG_MODE_EXPONENTIAL, // mode
         *                   0.5,                       // density
         *                   5.0, 30.0);                // z_near and z_far
         *   }
         * ```
         *
         *
         * The fogging functions only work correctly when the visible actors use
         * unmultiplied alpha colors. By default Cogl will premultiply textures and
         * cogl_set_source_color() will premultiply colors, so unless you explicitly
         * load your textures requesting an unmultiplied internal format and use
         * cogl_material_set_color() you can only use fogging with fully opaque actors.
         * Support for premultiplied colors will improve in the future when we can
         * depend on fragment shaders.
         * @param fog a #ClutterFog structure
         */
        set_fog(fog: Fog): void;
        /**
         * Asks to place the stage window in the fullscreen or unfullscreen
         * states.
         *
         *  ( Note that you shouldn't assume the window is definitely full screen
         * afterward, because other entities (e.g. the user or window manager)
         * could unfullscreen it again, and not all window managers honor
         * requests to fullscreen windows.
         *
         * If you want to receive notification of the fullscreen state you
         * should either use the #ClutterStage::fullscreen and
         * #ClutterStage::unfullscreen signals, or use the notify signal
         * for the #ClutterStage:fullscreen-set property
         * @param fullscreen %TRUE to to set the stage fullscreen
         */
        set_fullscreen(fullscreen: boolean): void;
        /**
         * Sets the key focus on `actor`. An actor with key focus will receive
         * all the key events. If `actor` is %NULL, the stage will receive
         * focus.
         * @param actor the actor to set key focus to, or %NULL
         */
        set_key_focus(actor?: Actor | null): void;
        /**
         * Sets the minimum size for a stage window, if the default backend
         * uses #ClutterStage inside a window
         *
         * This is a convenience function, and it is equivalent to setting the
         * #ClutterActor:min-width and #ClutterActor:min-height on `stage`
         *
         * If the current size of `stage` is smaller than the minimum size, the
         * `stage` will be resized to the new `width` and `height`
         *
         * This function has no effect if `stage` is fullscreen
         * @param width width, in pixels
         * @param height height, in pixels
         */
        set_minimum_size(width: number, height: number): void;
        /**
         * Sets whether per-actor motion events (and relative crossing
         * events) should be disabled or not.
         *
         * The default is %TRUE.
         *
         * If `enable` is %FALSE the following signals will not be emitted
         * by the actors children of `stage:`
         *
         *  - #ClutterActor::motion-event
         *  - #ClutterActor::enter-event
         *  - #ClutterActor::leave-event
         *
         * The events will still be delivered to the #ClutterStage.
         *
         * The main side effect of this function is that disabling the motion
         * events will disable picking to detect the #ClutterActor underneath
         * the pointer for each motion event. This is useful, for instance,
         * when dragging a #ClutterActor across the `stage:` the actor underneath
         * the pointer is not going to change, so it's meaningless to perform
         * a pick.
         * @param enabled %TRUE to enable the motion events delivery, and %FALSE   otherwise
         */
        set_motion_events_enabled(enabled: boolean): void;
        /**
         * Sets whether the `stage` should clear itself at the beginning
         * of each paint cycle or not.
         *
         * Clearing the #ClutterStage can be a costly operation, especially
         * if the stage is always covered - for instance, in a full-screen
         * video player or in a game with a background texture.
         *
         * This setting is a hint; Clutter might discard this hint
         * depending on its internal state.
         *
         * If parts of the stage are visible and you disable clearing you
         * might end up with visual artifacts while painting the contents of
         * the stage.
         * @param no_clear %TRUE if the @stage should not clear itself on every   repaint cycle
         */
        set_no_clear_hint(no_clear: boolean): void;
        /**
         * Sets the stage perspective. Using this function is not recommended
         * because it will disable Clutter's attempts to generate an
         * appropriate perspective based on the size of the stage.
         * @param perspective A #ClutterPerspective
         */
        set_perspective(perspective: Perspective): void;
        /**
         * Sets whether motion events received between redraws should
         * be throttled or not. If motion events are throttled, those
         * events received by the windowing system between redraws will
         * be compressed so that only the last event will be propagated
         * to the `stage` and its actors.
         *
         * This function should only be used if you want to have all
         * the motion events delivered to your application code.
         * @param throttle %TRUE to throttle motion events
         */
        set_throttle_motion_events(throttle: boolean): void;
        /**
         * Sets the stage title.
         * @param title A utf8 string for the stage windows title.
         */
        set_title(title: string): void;
        /**
         * Sets whether the `stage` should honour the #ClutterActor:opacity and
         * the alpha channel of the #ClutterStage:color
         * @param use_alpha whether the stage should honour the opacity or the   alpha channel of the stage color
         */
        set_use_alpha(use_alpha: boolean): void;
        /**
         * Sets whether the depth cueing effect on the stage should be enabled
         * or not.
         *
         * Depth cueing is a 3D effect that makes actors farther away from the
         * viewing point less opaque, by fading them with the stage color.
         *
         * The parameters of the GL fog used can be changed using the
         * clutter_stage_set_fog() function.
         * @param fog %TRUE for enabling the depth cueing effect
         */
        set_use_fog(fog: boolean): void;
        /**
         * Sets if the stage is resizable by user interaction (e.g. via
         * window manager controls)
         * @param resizable whether the stage should be user resizable.
         */
        set_user_resizable(resizable: boolean): void;
        /**
         * Shows the cursor on the stage window
         */
        show_cursor(): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace StageManager {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'stage-added': (arg0: Stage) => void;
            'stage-removed': (arg0: Stage) => void;
            'notify::default-stage': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            default_stage: Stage;
            defaultStage: Stage;
        }
    }

    /**
     * The #ClutterStageManager structure is private.
     */
    class StageManager extends GObject.Object {
        static $gtype: GObject.GType<StageManager>;

        // Properties

        /**
         * The default stage used by Clutter.
         */
        get default_stage(): Stage;
        /**
         * The default stage used by Clutter.
         */
        get defaultStage(): Stage;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: StageManager.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<StageManager.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof StageManager.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, StageManager.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof StageManager.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, StageManager.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof StageManager.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<StageManager.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Static methods

        /**
         * Returns the default #ClutterStageManager.
         */
        static get_default(): StageManager;

        // Virtual methods

        vfunc_stage_added(stage: Stage): void;
        vfunc_stage_removed(stage: Stage): void;

        // Methods

        /**
         * Returns the default #ClutterStage.
         * @returns the default stage. The returned object   is owned by Clutter and you should never reference or unreference it
         */
        get_default_stage(): Stage;
        /**
         * Lists all currently used stages.
         * @returns a newly   allocated list of #ClutterStage objects. Use g_slist_free() to   deallocate it when done.
         */
        list_stages(): Stage[];
        /**
         * Lists all currently used stages.
         * @returns a pointer   to the internal list of #ClutterStage objects. The returned list   is owned by the #ClutterStageManager and should never be modified   or freed
         */
        peek_stages(): Stage[];
        /**
         * Sets `stage` as the default stage.
         * @param stage a #ClutterStage
         */
        set_default_stage(stage: Stage): void;
    }

    namespace State {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            completed: () => void;
            'notify::duration': (pspec: GObject.ParamSpec) => void;
            'notify::state': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Scriptable.ConstructorProps {
            duration: number;
            state: string;
        }
    }

    /**
     * The #ClutterState structure contains only
     * private data and should be accessed using the provided API
     */
    class State extends GObject.Object implements Scriptable {
        static $gtype: GObject.GType<State>;

        // Properties

        /**
         * Default duration used if an duration has not been specified for a specific
         * source/target state pair. The values is in milliseconds.
         */
        get duration(): number;
        set duration(val: number);
        /**
         * The currently set target state, setting it causes the
         * state machine to transition to the new state, use
         * clutter_state_warp_to_state() to change state without
         * a transition.
         */
        get state(): string;
        set state(val: string);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: State.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<State.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): State;

        // Signals

        connect<K extends keyof State.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, State.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof State.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, State.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof State.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<State.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_completed(): void;

        // Methods

        /**
         * Retrieves the #ClutterAnimator that is being used for transitioning
         * between the two states, if any has been set
         * @param source_state_name the name of a source state
         * @param target_state_name the name of a target state
         * @returns a #ClutterAnimator instance, or %NULL
         */
        get_animator(source_state_name: string, target_state_name: string): Animator;
        /**
         * Queries the duration used for transitions between a source and
         * target state pair
         *
         * The semantics for the query are the same as the semantics used for
         * setting the duration with clutter_state_set_duration()
         * @param source_state_name the name of the source state to   get the duration of, or %NULL
         * @param target_state_name the name of the source state to   get the duration of, or %NULL
         * @returns the duration, in milliseconds
         */
        get_duration(source_state_name?: string | null, target_state_name?: string | null): number;
        /**
         * Returns a list of pointers to opaque structures with accessor functions
         * that describe the keys added to an animator.
         * @param source_state_name the source transition name to query,   or %NULL for all source states
         * @param target_state_name the target transition name to query,   or %NULL for all target states
         * @param object the specific object instance to list keys for,   or %NULL for all managed objects
         * @param property_name the property name to search for, or %NULL   for all properties.
         * @returns a   newly allocated #GList of #ClutterStateKey<!-- -->s. The contents of   the returned list are owned by the #ClutterState and should not be   modified or freed. Use g_list_free() to free the resources allocated   by the returned list when done using it
         */
        get_keys(
            source_state_name?: string | null,
            target_state_name?: string | null,
            object?: GObject.Object | null,
            property_name?: string | null,
        ): StateKey[];
        /**
         * Queries the currently set target state.
         *
         * During a transition this function will return the target of the transition.
         *
         * This function is useful when called from handlers of the
         * #ClutterState::completed signal.
         * @returns a string containing the target state. The returned string   is owned by the #ClutterState and should not be modified or freed
         */
        get_state(): string;
        /**
         * Gets a list of all the state names managed by this #ClutterState.
         * @returns a newly allocated   #GList of state names. The contents of the returned #GList are owned   by the #ClutterState and should not be modified or freed. Use   g_list_free() to free the resources allocated by the returned list when   done using it
         */
        get_states(): string[];
        /**
         * Gets the timeline driving the #ClutterState
         * @returns the #ClutterTimeline that drives   the state change animations. The returned timeline is owned   by the #ClutterState and it should not be unreferenced directly
         */
        get_timeline(): Timeline;
        /**
         * Removes all keys matching the search criteria passed in arguments.
         * @param source_state_name the source state name to query,   or %NULL for all source states
         * @param target_state_name the target state name to query,   or %NULL for all target states
         * @param object the specific object instance to list keys for,   or %NULL for all managed objects
         * @param property_name the property name to search for,   or %NULL for all properties.
         */
        remove_key(
            source_state_name?: string | null,
            target_state_name?: string | null,
            object?: GObject.Object | null,
            property_name?: string | null,
        ): void;
        /**
         * Specifies a #ClutterAnimator to be used when transitioning between
         * the two named states.
         *
         * The `animator` allows specifying a transition between the state that is
         * more elaborate than the basic transitions allowed by the tweening of
         * properties defined in the #ClutterState keys.
         *
         * If `animator` is %NULL it will unset an existing animator.
         *
         * #ClutterState will take a reference on the passed `animator,` if any
         * @param source_state_name the name of a source state
         * @param target_state_name the name of a target state
         * @param animator a #ClutterAnimator instance, or %NULL to   unset an existing #ClutterAnimator
         */
        set_animator(source_state_name: string, target_state_name: string, animator?: Animator | null): void;
        /**
         * Sets the duration of a transition.
         *
         * If both state names are %NULL the default duration for `state` is set.
         *
         * If only `target_state_name` is specified, the passed `duration` becomes
         * the default duration for transitions to the target state.
         *
         * If both states names are specified, the passed `duration` only applies
         * to the specified transition.
         * @param source_state_name the name of the source state, or %NULL
         * @param target_state_name the name of the target state, or %NULL
         * @param duration the duration of the transition, in milliseconds
         */
        set_duration(source_state_name: string | null, target_state_name: string | null, duration: number): void;
        /**
         * Sets one specific end key for a state name, `object,` `property_name`
         * combination.
         * @param source_state_name the source transition to specify   transition for, or %NULL to specify the default fallback when a   more specific source state doesn't exist.
         * @param target_state_name the name of the transition to set a key value for.
         * @param object the #GObject to set a key for
         * @param property_name the property to set a key for
         * @param mode the id of the alpha function to use
         * @param value the value for property_name of object in state_name
         * @param pre_delay relative time of the transition to be idle in the beginning   of the transition
         * @param post_delay relative time of the transition to be idle in the end of   the transition
         * @returns the #ClutterState instance, allowing   chaining of multiple calls
         */
        set_key(
            source_state_name: string | null,
            target_state_name: string,
            object: GObject.Object,
            property_name: string,
            mode: number,
            value: GObject.Value | any,
            pre_delay: number,
            post_delay: number,
        ): State;
        /**
         * Change the current state of #ClutterState to `target_state_name`.
         *
         * The state will animate during its transition, see
         * #clutter_state_warp_to_state for animation-free state switching.
         *
         * Setting a %NULL state will stop the current animation and unset
         * the current state, but keys will be left intact.
         * @param target_state_name the state to transition to
         * @returns the #ClutterTimeline that drives the   state transition. The returned timeline is owned by the #ClutterState   and it should not be unreferenced
         */
        set_state(target_state_name: string): Timeline;
        /**
         * Change to the specified target state immediately with no animation.
         *
         * See clutter_state_set_state().
         * @param target_state_name the state to transition to
         * @returns the #ClutterTimeline that drives the   state transition. The returned timeline is owned by the #ClutterState   and it should not be unreferenced
         */
        warp_to_state(target_state_name: string): Timeline;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace SwipeAction {
        // Signal signatures
        interface SignalSignatures extends GestureAction.SignalSignatures {
            swept: (arg0: Actor, arg1: SwipeDirection) => void;
            swipe: (arg0: Actor, arg1: SwipeDirection) => boolean | void;
            'notify::n-touch-points': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-distance-x': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-distance-y': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-edge': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GestureAction.ConstructorProps {}
    }

    /**
     * The #ClutterSwipeAction structure contains
     * only private data and should be accessed using the provided API
     */
    class SwipeAction extends GestureAction {
        static $gtype: GObject.GType<SwipeAction>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: SwipeAction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<SwipeAction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): SwipeAction;

        // Signals

        connect<K extends keyof SwipeAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, SwipeAction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof SwipeAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, SwipeAction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof SwipeAction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<SwipeAction.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_swept(actor: Actor, direction: SwipeDirection): void;
        vfunc_swipe(actor: Actor, direction: SwipeDirection): boolean;
    }

    namespace TableLayout {
        // Signal signatures
        interface SignalSignatures extends LayoutManager.SignalSignatures {
            'notify::column-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::easing-duration': (pspec: GObject.ParamSpec) => void;
            'notify::easing-mode': (pspec: GObject.ParamSpec) => void;
            'notify::row-spacing': (pspec: GObject.ParamSpec) => void;
            'notify::use-animations': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends LayoutManager.ConstructorProps {
            column_spacing: number;
            columnSpacing: number;
            easing_duration: number;
            easingDuration: number;
            easing_mode: number;
            easingMode: number;
            row_spacing: number;
            rowSpacing: number;
            use_animations: boolean;
            useAnimations: boolean;
        }
    }

    /**
     * The #ClutterTableLayout structure contains only private data
     * and should be accessed using the provided API
     */
    class TableLayout extends LayoutManager {
        static $gtype: GObject.GType<TableLayout>;

        // Properties

        /**
         * The spacing between columns of the #ClutterTableLayout, in pixels
         */
        get column_spacing(): number;
        set column_spacing(val: number);
        /**
         * The spacing between columns of the #ClutterTableLayout, in pixels
         */
        get columnSpacing(): number;
        set columnSpacing(val: number);
        /**
         * The duration of the animations, in case #ClutterTableLayout:use-animations
         * is set to %TRUE.
         *
         * The duration is expressed in milliseconds.
         */
        get easing_duration(): number;
        set easing_duration(val: number);
        /**
         * The duration of the animations, in case #ClutterTableLayout:use-animations
         * is set to %TRUE.
         *
         * The duration is expressed in milliseconds.
         */
        get easingDuration(): number;
        set easingDuration(val: number);
        /**
         * The easing mode for the animations, in case
         * #ClutterTableLayout:use-animations is set to %TRUE.
         *
         * The easing mode has the same semantics of #ClutterAnimation:mode: it can
         * either be a value from the #ClutterAnimationMode enumeration, like
         * %CLUTTER_EASE_OUT_CUBIC, or a logical id as returned by
         * clutter_alpha_register_func().
         *
         * The default value is %CLUTTER_EASE_OUT_CUBIC.
         */
        get easing_mode(): number;
        set easing_mode(val: number);
        /**
         * The easing mode for the animations, in case
         * #ClutterTableLayout:use-animations is set to %TRUE.
         *
         * The easing mode has the same semantics of #ClutterAnimation:mode: it can
         * either be a value from the #ClutterAnimationMode enumeration, like
         * %CLUTTER_EASE_OUT_CUBIC, or a logical id as returned by
         * clutter_alpha_register_func().
         *
         * The default value is %CLUTTER_EASE_OUT_CUBIC.
         */
        get easingMode(): number;
        set easingMode(val: number);
        /**
         * The spacing between rows of the #ClutterTableLayout, in pixels
         */
        get row_spacing(): number;
        set row_spacing(val: number);
        /**
         * The spacing between rows of the #ClutterTableLayout, in pixels
         */
        get rowSpacing(): number;
        set rowSpacing(val: number);
        /**
         * Whether the #ClutterTableLayout should animate changes in the
         * layout properties.
         *
         * By default, #ClutterTableLayout will honour the easing state of
         * the children when allocating them. Setting this property to
         * %TRUE will override the easing state with the layout manager's
         * #ClutterTableLayout:easing-mode and #ClutterTableLayout:easing-duration
         * properties.
         */
        get use_animations(): boolean;
        set use_animations(val: boolean);
        /**
         * Whether the #ClutterTableLayout should animate changes in the
         * layout properties.
         *
         * By default, #ClutterTableLayout will honour the easing state of
         * the children when allocating them. Setting this property to
         * %TRUE will override the easing state with the layout manager's
         * #ClutterTableLayout:easing-mode and #ClutterTableLayout:easing-duration
         * properties.
         */
        get useAnimations(): boolean;
        set useAnimations(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TableLayout.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TableLayout.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): TableLayout;

        // Signals

        connect<K extends keyof TableLayout.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TableLayout.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TableLayout.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TableLayout.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TableLayout.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TableLayout.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Retrieves the horizontal and vertical alignment policies for `actor`
         * as set using clutter_table_layout_pack() or
         * clutter_table_layout_set_alignment().
         * @param actor a #ClutterActor child of @layout
         */
        get_alignment(actor: Actor): [TableAlignment, TableAlignment];
        /**
         * Retrieve the current number of columns in `layout`
         * @returns the number of columns
         */
        get_column_count(): number;
        /**
         * Retrieves the spacing set using clutter_table_layout_set_column_spacing()
         * @returns the spacing between columns of the #ClutterTableLayout
         */
        get_column_spacing(): number;
        /**
         * Retrieves the duration set using clutter_table_layout_set_easing_duration()
         * @returns the duration of the animations, in milliseconds
         */
        get_easing_duration(): number;
        /**
         * Retrieves the easing mode set using clutter_table_layout_set_easing_mode()
         * @returns an easing mode
         */
        get_easing_mode(): number;
        /**
         * Retrieves the horizontal and vertical expand policies for `actor`
         * as set using clutter_table_layout_pack() or clutter_table_layout_set_expand()
         * @param actor a #ClutterActor child of @layout
         */
        get_expand(actor: Actor): [boolean, boolean];
        /**
         * Retrieves the horizontal and vertical fill policies for `actor`
         * as set using clutter_table_layout_pack() or clutter_table_layout_set_fill()
         * @param actor a #ClutterActor child of @layout
         */
        get_fill(actor: Actor): [boolean, boolean];
        /**
         * Retrieve the current number rows in the `layout`
         * @returns the number of rows
         */
        get_row_count(): number;
        /**
         * Retrieves the spacing set using clutter_table_layout_set_row_spacing()
         * @returns the spacing between rows of the #ClutterTableLayout
         */
        get_row_spacing(): number;
        /**
         * Retrieves the row and column span for `actor` as set using
         * clutter_table_layout_pack() or clutter_table_layout_set_span()
         * @param actor a #ClutterActor child of @layout
         */
        get_span(actor: Actor): [number, number];
        /**
         * Retrieves whether `layout` should animate changes in the layout properties
         *
         * Since clutter_table_layout_set_use_animations()
         * @returns %TRUE if the animations should be used, %FALSE otherwise
         */
        get_use_animations(): boolean;
        /**
         * Packs `actor` inside the #ClutterContainer associated to `layout`
         * at the given row and column.
         * @param actor a #ClutterActor
         * @param column the column the @actor should be put, or -1 to append
         * @param row the row the @actor should be put, or -1 to append
         */
        pack(actor: Actor, column: number, row: number): void;
        /**
         * Sets the horizontal and vertical alignment policies for `actor`
         * inside `layout`
         * @param actor a #ClutterActor child of @layout
         * @param x_align Horizontal alignment policy for @actor
         * @param y_align Vertical alignment policy for @actor
         */
        set_alignment(actor: Actor, x_align: TableAlignment | null, y_align: TableAlignment | null): void;
        /**
         * Sets the spacing between columns of `layout`
         * @param spacing the spacing between columns of the layout, in pixels
         */
        set_column_spacing(spacing: number): void;
        /**
         * Sets the duration of the animations used by `layout` when animating changes
         * in the layout properties
         *
         * Use clutter_table_layout_set_use_animations() to enable and disable the
         * animations
         * @param msecs the duration of the animations, in milliseconds
         */
        set_easing_duration(msecs: number): void;
        /**
         * Sets the easing mode to be used by `layout` when animating changes in layout
         * properties
         *
         * Use clutter_table_layout_set_use_animations() to enable and disable the
         * animations
         * @param mode an easing mode, either from #ClutterAnimationMode or a logical id   from clutter_alpha_register_func()
         */
        set_easing_mode(mode: number): void;
        /**
         * Sets the horizontal and vertical expand policies for `actor`
         * inside `layout`
         * @param actor a #ClutterActor child of @layout
         * @param x_expand whether @actor should allocate extra space horizontally
         * @param y_expand whether @actor should allocate extra space vertically
         */
        set_expand(actor: Actor, x_expand: boolean, y_expand: boolean): void;
        /**
         * Sets the horizontal and vertical fill policies for `actor`
         * inside `layout`
         * @param actor a #ClutterActor child of @layout
         * @param x_fill whether @actor should fill horizontally the allocated space
         * @param y_fill whether @actor should fill vertically the allocated space
         */
        set_fill(actor: Actor, x_fill: boolean, y_fill: boolean): void;
        /**
         * Sets the spacing between rows of `layout`
         * @param spacing the spacing between rows of the layout, in pixels
         */
        set_row_spacing(spacing: number): void;
        /**
         * Sets the row and column span for `actor`
         * inside `layout`
         * @param actor a #ClutterActor child of @layout
         * @param column_span Column span for @actor
         * @param row_span Row span for @actor
         */
        set_span(actor: Actor, column_span: number, row_span: number): void;
        /**
         * Sets whether `layout` should animate changes in the layout properties
         *
         * The duration of the animations is controlled by
         * clutter_table_layout_set_easing_duration(); the easing mode to be used
         * by the animations is controlled by clutter_table_layout_set_easing_mode()
         * @param animate %TRUE if the @layout should use animations
         */
        set_use_animations(animate: boolean): void;
    }

    namespace TapAction {
        // Signal signatures
        interface SignalSignatures extends GestureAction.SignalSignatures {
            tap: (arg0: Actor) => void;
            'notify::n-touch-points': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-distance-x': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-distance-y': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-edge': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GestureAction.ConstructorProps {}
    }

    /**
     * The #ClutterTapAction structure contains
     * only private data and should be accessed using the provided API
     */
    class TapAction extends GestureAction {
        static $gtype: GObject.GType<TapAction>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TapAction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TapAction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): TapAction;

        // Signals

        connect<K extends keyof TapAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TapAction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TapAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TapAction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TapAction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TapAction.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_tap(actor: Actor): boolean;
    }

    namespace Text {
        // Signal signatures
        interface SignalSignatures extends Actor.SignalSignatures {
            activate: () => void;
            'cursor-changed': () => void;
            'cursor-event': (arg0: Geometry) => void;
            'delete-text': (arg0: number, arg1: number) => void;
            'insert-text': (arg0: string, arg1: number, arg2: any | null) => void;
            'text-changed': () => void;
            'notify::activatable': (pspec: GObject.ParamSpec) => void;
            'notify::attributes': (pspec: GObject.ParamSpec) => void;
            'notify::buffer': (pspec: GObject.ParamSpec) => void;
            'notify::color': (pspec: GObject.ParamSpec) => void;
            'notify::cursor-color': (pspec: GObject.ParamSpec) => void;
            'notify::cursor-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::cursor-position': (pspec: GObject.ParamSpec) => void;
            'notify::cursor-size': (pspec: GObject.ParamSpec) => void;
            'notify::cursor-visible': (pspec: GObject.ParamSpec) => void;
            'notify::editable': (pspec: GObject.ParamSpec) => void;
            'notify::ellipsize': (pspec: GObject.ParamSpec) => void;
            'notify::font-description': (pspec: GObject.ParamSpec) => void;
            'notify::font-name': (pspec: GObject.ParamSpec) => void;
            'notify::justify': (pspec: GObject.ParamSpec) => void;
            'notify::line-alignment': (pspec: GObject.ParamSpec) => void;
            'notify::line-wrap': (pspec: GObject.ParamSpec) => void;
            'notify::line-wrap-mode': (pspec: GObject.ParamSpec) => void;
            'notify::max-length': (pspec: GObject.ParamSpec) => void;
            'notify::password-char': (pspec: GObject.ParamSpec) => void;
            'notify::position': (pspec: GObject.ParamSpec) => void;
            'notify::selectable': (pspec: GObject.ParamSpec) => void;
            'notify::selected-text-color': (pspec: GObject.ParamSpec) => void;
            'notify::selected-text-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::selection-bound': (pspec: GObject.ParamSpec) => void;
            'notify::selection-color': (pspec: GObject.ParamSpec) => void;
            'notify::selection-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::single-line-mode': (pspec: GObject.ParamSpec) => void;
            'notify::text': (pspec: GObject.ParamSpec) => void;
            'notify::use-markup': (pspec: GObject.ParamSpec) => void;
            'notify::actions': (pspec: GObject.ParamSpec) => void;
            'notify::allocation': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-x': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-y': (pspec: GObject.ParamSpec) => void;
            'notify::background-color': (pspec: GObject.ParamSpec) => void;
            'notify::background-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::clip': (pspec: GObject.ParamSpec) => void;
            'notify::clip-rect': (pspec: GObject.ParamSpec) => void;
            'notify::clip-to-allocation': (pspec: GObject.ParamSpec) => void;
            'notify::constraints': (pspec: GObject.ParamSpec) => void;
            'notify::content': (pspec: GObject.ParamSpec) => void;
            'notify::content-box': (pspec: GObject.ParamSpec) => void;
            'notify::content-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::content-repeat': (pspec: GObject.ParamSpec) => void;
            'notify::depth': (pspec: GObject.ParamSpec) => void;
            'notify::effect': (pspec: GObject.ParamSpec) => void;
            'notify::first-child': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-position-set': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-x': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-y': (pspec: GObject.ParamSpec) => void;
            'notify::has-clip': (pspec: GObject.ParamSpec) => void;
            'notify::has-pointer': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::last-child': (pspec: GObject.ParamSpec) => void;
            'notify::layout-manager': (pspec: GObject.ParamSpec) => void;
            'notify::magnification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::mapped': (pspec: GObject.ParamSpec) => void;
            'notify::margin-bottom': (pspec: GObject.ParamSpec) => void;
            'notify::margin-left': (pspec: GObject.ParamSpec) => void;
            'notify::margin-right': (pspec: GObject.ParamSpec) => void;
            'notify::margin-top': (pspec: GObject.ParamSpec) => void;
            'notify::min-height': (pspec: GObject.ParamSpec) => void;
            'notify::min-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::min-width': (pspec: GObject.ParamSpec) => void;
            'notify::min-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::minification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::offscreen-redirect': (pspec: GObject.ParamSpec) => void;
            'notify::opacity': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point-z': (pspec: GObject.ParamSpec) => void;
            'notify::reactive': (pspec: GObject.ParamSpec) => void;
            'notify::realized': (pspec: GObject.ParamSpec) => void;
            'notify::request-mode': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-zgravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-z': (pspec: GObject.ParamSpec) => void;
            'notify::show-on-set-parent': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::text-direction': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::translation-x': (pspec: GObject.ParamSpec) => void;
            'notify::translation-y': (pspec: GObject.ParamSpec) => void;
            'notify::translation-z': (pspec: GObject.ParamSpec) => void;
            'notify::visible': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::x-align': (pspec: GObject.ParamSpec) => void;
            'notify::x-expand': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::y-align': (pspec: GObject.ParamSpec) => void;
            'notify::y-expand': (pspec: GObject.ParamSpec) => void;
            'notify::z-position': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Actor.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Animatable.ConstructorProps,
                Container.ConstructorProps,
                Scriptable.ConstructorProps {
            activatable: boolean;
            attributes: Pango.AttrList;
            buffer: TextBuffer;
            color: Color;
            cursor_color: Color;
            cursorColor: Color;
            cursor_color_set: boolean;
            cursorColorSet: boolean;
            cursor_position: number;
            cursorPosition: number;
            cursor_size: number;
            cursorSize: number;
            cursor_visible: boolean;
            cursorVisible: boolean;
            editable: boolean;
            ellipsize: Pango.EllipsizeMode;
            font_description: Pango.FontDescription;
            fontDescription: Pango.FontDescription;
            font_name: string;
            fontName: string;
            justify: boolean;
            line_alignment: Pango.Alignment;
            lineAlignment: Pango.Alignment;
            line_wrap: boolean;
            lineWrap: boolean;
            line_wrap_mode: Pango.WrapMode;
            lineWrapMode: Pango.WrapMode;
            max_length: number;
            maxLength: number;
            password_char: number;
            passwordChar: number;
            position: number | any;
            selectable: boolean;
            selected_text_color: Color;
            selectedTextColor: Color;
            selected_text_color_set: boolean;
            selectedTextColorSet: boolean;
            selection_bound: number;
            selectionBound: number;
            selection_color: Color;
            selectionColor: Color;
            selection_color_set: boolean;
            selectionColorSet: boolean;
            single_line_mode: boolean;
            singleLineMode: boolean;
            text: string;
            use_markup: boolean;
            useMarkup: boolean;
        }
    }

    /**
     * The #ClutterText struct contains only private data.
     */
    class Text extends Actor implements Atk.ImplementorIface, Animatable, Container, Scriptable {
        static $gtype: GObject.GType<Text>;

        // Properties

        /**
         * Toggles whether return invokes the activate signal or not.
         */
        get activatable(): boolean;
        set activatable(val: boolean);
        /**
         * A list of #PangoStyleAttribute<!-- -->s to be applied to the
         * contents of the #ClutterText actor.
         */
        get attributes(): Pango.AttrList;
        set attributes(val: Pango.AttrList);
        /**
         * The buffer which stores the text for this #ClutterText.
         *
         * If set to %NULL, a default buffer will be created.
         */
        get buffer(): TextBuffer;
        set buffer(val: TextBuffer);
        /**
         * The color used to render the text.
         */
        get color(): Color;
        set color(val: Color);
        /**
         * The color of the cursor.
         */
        get cursor_color(): Color;
        set cursor_color(val: Color);
        /**
         * The color of the cursor.
         */
        get cursorColor(): Color;
        set cursorColor(val: Color);
        /**
         * Will be set to %TRUE if #ClutterText:cursor-color has been set.
         */
        get cursor_color_set(): boolean;
        /**
         * Will be set to %TRUE if #ClutterText:cursor-color has been set.
         */
        get cursorColorSet(): boolean;
        /**
         * The current input cursor position. -1 is taken to be the end of the text
         */
        get cursor_position(): number;
        set cursor_position(val: number);
        /**
         * The current input cursor position. -1 is taken to be the end of the text
         */
        get cursorPosition(): number;
        set cursorPosition(val: number);
        /**
         * The size of the cursor, in pixels. If set to -1 the size used will
         * be the default cursor size of 2 pixels.
         */
        get cursor_size(): number;
        set cursor_size(val: number);
        /**
         * The size of the cursor, in pixels. If set to -1 the size used will
         * be the default cursor size of 2 pixels.
         */
        get cursorSize(): number;
        set cursorSize(val: number);
        /**
         * Whether the input cursor is visible or not.
         *
         * The cursor will only be visible if this property and either
         * the #ClutterText:editable or the #ClutterText:selectable properties
         * are set to %TRUE.
         */
        get cursor_visible(): boolean;
        set cursor_visible(val: boolean);
        /**
         * Whether the input cursor is visible or not.
         *
         * The cursor will only be visible if this property and either
         * the #ClutterText:editable or the #ClutterText:selectable properties
         * are set to %TRUE.
         */
        get cursorVisible(): boolean;
        set cursorVisible(val: boolean);
        /**
         * Whether key events delivered to the actor causes editing.
         */
        get editable(): boolean;
        set editable(val: boolean);
        /**
         * The preferred place to ellipsize the contents of the #ClutterText actor
         */
        get ellipsize(): Pango.EllipsizeMode;
        set ellipsize(val: Pango.EllipsizeMode);
        /**
         * The #PangoFontDescription that should be used by the #ClutterText
         *
         * If you have a string describing the font then you should look at
         * #ClutterText:font-name instead
         */
        get font_description(): Pango.FontDescription;
        set font_description(val: Pango.FontDescription);
        /**
         * The #PangoFontDescription that should be used by the #ClutterText
         *
         * If you have a string describing the font then you should look at
         * #ClutterText:font-name instead
         */
        get fontDescription(): Pango.FontDescription;
        set fontDescription(val: Pango.FontDescription);
        /**
         * The font to be used by the #ClutterText, as a string
         * that can be parsed by pango_font_description_from_string().
         *
         * If set to %NULL, the default system font will be used instead.
         */
        get font_name(): string;
        set font_name(val: string);
        /**
         * The font to be used by the #ClutterText, as a string
         * that can be parsed by pango_font_description_from_string().
         *
         * If set to %NULL, the default system font will be used instead.
         */
        get fontName(): string;
        set fontName(val: string);
        /**
         * Whether the contents of the #ClutterText should be justified
         * on both margins.
         */
        get justify(): boolean;
        set justify(val: boolean);
        /**
         * The preferred alignment for the text. This property controls
         * the alignment of multi-line paragraphs.
         */
        get line_alignment(): Pango.Alignment;
        set line_alignment(val: Pango.Alignment);
        /**
         * The preferred alignment for the text. This property controls
         * the alignment of multi-line paragraphs.
         */
        get lineAlignment(): Pango.Alignment;
        set lineAlignment(val: Pango.Alignment);
        /**
         * Whether to wrap the lines of #ClutterText:text if the contents
         * exceed the available allocation. The wrapping strategy is
         * controlled by the #ClutterText:line-wrap-mode property.
         */
        get line_wrap(): boolean;
        set line_wrap(val: boolean);
        /**
         * Whether to wrap the lines of #ClutterText:text if the contents
         * exceed the available allocation. The wrapping strategy is
         * controlled by the #ClutterText:line-wrap-mode property.
         */
        get lineWrap(): boolean;
        set lineWrap(val: boolean);
        /**
         * If #ClutterText:line-wrap is set to %TRUE, this property will
         * control how the text is wrapped.
         */
        get line_wrap_mode(): Pango.WrapMode;
        set line_wrap_mode(val: Pango.WrapMode);
        /**
         * If #ClutterText:line-wrap is set to %TRUE, this property will
         * control how the text is wrapped.
         */
        get lineWrapMode(): Pango.WrapMode;
        set lineWrapMode(val: Pango.WrapMode);
        /**
         * The maximum length of the contents of the #ClutterText actor.
         */
        get max_length(): number;
        set max_length(val: number);
        /**
         * The maximum length of the contents of the #ClutterText actor.
         */
        get maxLength(): number;
        set maxLength(val: number);
        /**
         * If non-zero, the character that should be used in place of
         * the actual text in a password text actor.
         */
        get password_char(): number;
        set password_char(val: number);
        /**
         * If non-zero, the character that should be used in place of
         * the actual text in a password text actor.
         */
        get passwordChar(): number;
        set passwordChar(val: number);
        /**
         * The current input cursor position. -1 is taken to be the end of the text
         */
        // This accessor conflicts with another accessor's type in a parent class or interface.
        get position(): number | any;
        // This accessor conflicts with another accessor's type in a parent class or interface.
        set position(val: number | any);
        /**
         * Whether it is possible to select text, either using the pointer
         * or the keyboard.
         *
         * This property depends on the #ClutterActor:reactive property being
         * set to %TRUE.
         */
        get selectable(): boolean;
        set selectable(val: boolean);
        /**
         * The color of selected text.
         */
        get selected_text_color(): Color;
        set selected_text_color(val: Color);
        /**
         * The color of selected text.
         */
        get selectedTextColor(): Color;
        set selectedTextColor(val: Color);
        /**
         * Will be set to %TRUE if #ClutterText:selected-text-color has been set.
         */
        get selected_text_color_set(): boolean;
        /**
         * Will be set to %TRUE if #ClutterText:selected-text-color has been set.
         */
        get selectedTextColorSet(): boolean;
        /**
         * The current input cursor position. -1 is taken to be the end of the text
         */
        get selection_bound(): number;
        set selection_bound(val: number);
        /**
         * The current input cursor position. -1 is taken to be the end of the text
         */
        get selectionBound(): number;
        set selectionBound(val: number);
        /**
         * The color of the selection.
         */
        get selection_color(): Color;
        set selection_color(val: Color);
        /**
         * The color of the selection.
         */
        get selectionColor(): Color;
        set selectionColor(val: Color);
        /**
         * Will be set to %TRUE if #ClutterText:selection-color has been set.
         */
        get selection_color_set(): boolean;
        /**
         * Will be set to %TRUE if #ClutterText:selection-color has been set.
         */
        get selectionColorSet(): boolean;
        /**
         * Whether the #ClutterText actor should be in single line mode
         * or not. A single line #ClutterText actor will only contain a
         * single line of text, scrolling it in case its length is bigger
         * than the allocated size.
         *
         * Setting this property will also set the #ClutterText:activatable
         * property as a side-effect.
         *
         * The #ClutterText:single-line-mode property is used only if the
         * #ClutterText:editable property is set to %TRUE.
         */
        get single_line_mode(): boolean;
        set single_line_mode(val: boolean);
        /**
         * Whether the #ClutterText actor should be in single line mode
         * or not. A single line #ClutterText actor will only contain a
         * single line of text, scrolling it in case its length is bigger
         * than the allocated size.
         *
         * Setting this property will also set the #ClutterText:activatable
         * property as a side-effect.
         *
         * The #ClutterText:single-line-mode property is used only if the
         * #ClutterText:editable property is set to %TRUE.
         */
        get singleLineMode(): boolean;
        set singleLineMode(val: boolean);
        /**
         * The text to render inside the actor.
         */
        get text(): string;
        set text(val: string);
        /**
         * Whether the text includes Pango markup.
         *
         * For more informations about the Pango markup format, see
         * pango_layout_set_markup() in the Pango documentation.
         *
         * It is not possible to round-trip this property between
         * %TRUE and %FALSE. Once a string with markup has been set on
         * a #ClutterText actor with :use-markup set to %TRUE, the markup
         * is stripped from the string.
         */
        get use_markup(): boolean;
        set use_markup(val: boolean);
        /**
         * Whether the text includes Pango markup.
         *
         * For more informations about the Pango markup format, see
         * pango_layout_set_markup() in the Pango documentation.
         *
         * It is not possible to round-trip this property between
         * %TRUE and %FALSE. Once a string with markup has been set on
         * a #ClutterText actor with :use-markup set to %TRUE, the markup
         * is stripped from the string.
         */
        get useMarkup(): boolean;
        set useMarkup(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Text.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Text.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Text;

        static new_full(font_name: string, text: string, color: Color): Text;

        static new_with_buffer(buffer: TextBuffer): Text;

        static new_with_text(font_name: string | null, text: string): Text;

        // Signals

        connect<K extends keyof Text.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Text.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Text.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Text.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Text.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Text.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_activate(): void;
        vfunc_cursor_changed(): void;
        vfunc_cursor_event(geometry: Geometry): void;
        vfunc_text_changed(): void;

        // Methods

        /**
         * Emits the #ClutterText::activate signal, if `self` has been set
         * as activatable using clutter_text_set_activatable().
         *
         * This function can be used to emit the ::activate signal inside
         * a #ClutterActor::captured-event or #ClutterActor::key-press-event
         * signal handlers before the default signal handler for the
         * #ClutterText is invoked.
         * @returns %TRUE if the ::activate signal has been emitted,   and %FALSE otherwise
         */
        activate(): boolean;
        /**
         * Retrieves the position of the character at the given coordinates.
         * @param x the X coordinate, relative to the actor
         * @param y the Y coordinate, relative to the actor
         * @returns the position of the character
         */
        coords_to_position(x: number, y: number): number;
        /**
         * Deletes `n_chars` inside a #ClutterText actor, starting from the
         * current cursor position.
         *
         * Somewhat awkwardly, the cursor position is decremented by the same
         * number of characters you've deleted.
         * @param n_chars the number of characters to delete
         */
        delete_chars(n_chars: number): void;
        /**
         * Deletes the currently selected text
         *
         * This function is only useful in subclasses of #ClutterText
         * @returns %TRUE if text was deleted or if the text actor   is empty, and %FALSE otherwise
         */
        delete_selection(): boolean;
        /**
         * Deletes the text inside a #ClutterText actor between `start_pos`
         * and `end_pos`.
         *
         * The starting and ending positions are expressed in characters,
         * not in bytes.
         * @param start_pos starting position
         * @param end_pos ending position
         */
        delete_text(start_pos: number, end_pos: number): void;
        /**
         * Retrieves whether a #ClutterText is activatable or not.
         * @returns %TRUE if the actor is activatable
         */
        get_activatable(): boolean;
        /**
         * Gets the attribute list that was set on the #ClutterText actor
         * clutter_text_set_attributes(), if any.
         * @returns the attribute list, or %NULL if none was set. The  returned value is owned by the #ClutterText and should not be unreferenced.
         */
        get_attributes(): Pango.AttrList;
        /**
         * Get the #ClutterTextBuffer object which holds the text for
         * this widget.
         * @returns A #GtkEntryBuffer object.
         */
        get_buffer(): TextBuffer;
        /**
         * Retrieves the contents of the #ClutterText actor between
         * `start_pos` and `end_pos,` but not including `end_pos`.
         *
         * The positions are specified in characters, not in bytes.
         * @param start_pos start of text, in characters
         * @param end_pos end of text, in characters
         * @returns a newly allocated string with the contents of   the text actor between the specified positions. Use g_free()   to free the resources when done
         */
        get_chars(start_pos: number, end_pos: number): string;
        /**
         * Retrieves the text color as set by clutter_text_set_color().
         */
        get_color(): Color;
        /**
         * Retrieves the color of the cursor of a #ClutterText actor.
         */
        get_cursor_color(): Color;
        /**
         * Retrieves the cursor position.
         * @returns the cursor position, in characters
         */
        get_cursor_position(): number;
        /**
         * Retrieves the rectangle that contains the cursor.
         *
         * The coordinates of the rectangle's origin are in actor-relative
         * coordinates.
         */
        get_cursor_rect(): Rect;
        /**
         * Retrieves the size of the cursor of a #ClutterText actor.
         * @returns the size of the cursor, in pixels
         */
        get_cursor_size(): number;
        /**
         * Retrieves whether the cursor of a #ClutterText actor is visible.
         * @returns %TRUE if the cursor is visible
         */
        get_cursor_visible(): boolean;
        /**
         * Retrieves whether a #ClutterText is editable or not.
         * @returns %TRUE if the actor is editable
         */
        get_editable(): boolean;
        /**
         * Returns the ellipsizing position of a #ClutterText actor, as
         * set by clutter_text_set_ellipsize().
         * @returns #PangoEllipsizeMode
         */
        get_ellipsize(): Pango.EllipsizeMode;
        /**
         * Retrieves the #PangoFontDescription used by `self`
         * @returns a #PangoFontDescription. The returned value is owned   by the #ClutterText actor and it should not be modified or freed
         */
        get_font_description(): Pango.FontDescription;
        /**
         * Retrieves the font name as set by clutter_text_set_font_name().
         * @returns a string containing the font name. The returned   string is owned by the #ClutterText actor and should not be   modified or freed
         */
        get_font_name(): string;
        /**
         * Retrieves whether the #ClutterText actor should justify its contents
         * on both margins.
         * @returns %TRUE if the text should be justified
         */
        get_justify(): boolean;
        /**
         * Retrieves the current #PangoLayout used by a #ClutterText actor.
         * @returns a #PangoLayout. The returned object is owned by   the #ClutterText actor and should not be modified or freed
         */
        get_layout(): Pango.Layout;
        /**
         * Obtains the coordinates where the #ClutterText will draw the #PangoLayout
         * representing the text.
         */
        get_layout_offsets(): [number, number];
        /**
         * Retrieves the alignment of a #ClutterText, as set by
         * clutter_text_set_line_alignment().
         * @returns a #PangoAlignment
         */
        get_line_alignment(): Pango.Alignment;
        /**
         * Retrieves the value set using clutter_text_set_line_wrap().
         * @returns %TRUE if the #ClutterText actor should wrap   its contents
         */
        get_line_wrap(): boolean;
        /**
         * Retrieves the line wrap mode used by the #ClutterText actor.
         *
         * See clutter_text_set_line_wrap_mode ().
         * @returns the wrap mode used by the #ClutterText
         */
        get_line_wrap_mode(): Pango.WrapMode;
        /**
         * Gets the maximum length of text that can be set into a text actor.
         *
         * See clutter_text_set_max_length().
         * @returns the maximum number of characters.
         */
        get_max_length(): number;
        /**
         * Retrieves the character to use in place of the actual text
         * as set by clutter_text_set_password_char().
         * @returns a Unicode character or 0 if the password   character is not set
         */
        get_password_char(): string;
        /**
         * Retrieves whether a #ClutterText is selectable or not.
         * @returns %TRUE if the actor is selectable
         */
        get_selectable(): boolean;
        /**
         * Retrieves the color of selected text of a #ClutterText actor.
         */
        get_selected_text_color(): Color;
        /**
         * Retrieves the currently selected text.
         * @returns a newly allocated string containing the currently   selected text, or %NULL. Use g_free() to free the returned   string.
         */
        get_selection(): string;
        /**
         * Retrieves the other end of the selection of a #ClutterText actor,
         * in characters from the current cursor position.
         * @returns the position of the other end of the selection
         */
        get_selection_bound(): number;
        /**
         * Retrieves the color of the selection of a #ClutterText actor.
         */
        get_selection_color(): Color;
        /**
         * Retrieves whether the #ClutterText actor is in single line mode.
         * @returns %TRUE if the #ClutterText actor is in single line mode
         */
        get_single_line_mode(): boolean;
        /**
         * Retrieves a pointer to the current contents of a #ClutterText
         * actor.
         *
         * If you need a copy of the contents for manipulating, either
         * use g_strdup() on the returned string, or use:
         *
         *
         * ```
         *    copy = clutter_text_get_chars (text, 0, -1);
         * ```
         *
         *
         * Which will return a newly allocated string.
         *
         * If the #ClutterText actor is empty, this function will return
         * an empty string, and not %NULL.
         * @returns the contents of the actor. The returned   string is owned by the #ClutterText actor and should never be modified   or freed
         */
        get_text(): string;
        /**
         * Retrieves whether the contents of the #ClutterText actor should be
         * parsed for the Pango text markup.
         * @returns %TRUE if the contents will be parsed for markup
         */
        get_use_markup(): boolean;
        /**
         * Inserts `text` into a #ClutterActor at the given position.
         *
         * If `position` is a negative number, the text will be appended
         * at the end of the current contents of the #ClutterText.
         *
         * The position is expressed in characters, not in bytes.
         * @param text the text to be inserted
         * @param position the position of the insertion, or -1
         */
        insert_text(text: string, position: number): void;
        /**
         * Inserts `wc` at the current cursor position of a
         * #ClutterText actor.
         * @param wc a Unicode character
         */
        insert_unichar(wc: string): void;
        /**
         * Retrieves the coordinates of the given `position`.
         * @param position position in characters
         * @returns %TRUE if the conversion was successful
         */
        position_to_coords(position: number): [boolean, number, number, number];
        /**
         * Sets whether a #ClutterText actor should be activatable.
         *
         * An activatable #ClutterText actor will emit the #ClutterText::activate
         * signal whenever the 'Enter' (or 'Return') key is pressed; if it is not
         * activatable, a new line will be appended to the current content.
         *
         * An activatable #ClutterText must also be set as editable using
         * clutter_text_set_editable().
         * @param activatable whether the #ClutterText actor should be activatable
         */
        set_activatable(activatable: boolean): void;
        /**
         * Sets the attributes list that are going to be applied to the
         * #ClutterText contents.
         *
         * The #ClutterText actor will take a reference on the #PangoAttrList
         * passed to this function.
         * @param attrs a #PangoAttrList or %NULL to unset the attributes
         */
        set_attributes(attrs?: Pango.AttrList | null): void;
        /**
         * Set the #ClutterTextBuffer object which holds the text for
         * this widget.
         * @param buffer a #ClutterTextBuffer
         */
        set_buffer(buffer: TextBuffer): void;
        /**
         * Sets the color of the contents of a #ClutterText actor.
         *
         * The overall opacity of the #ClutterText actor will be the
         * result of the alpha value of `color` and the composited
         * opacity of the actor itself on the scenegraph, as returned
         * by clutter_actor_get_paint_opacity().
         * @param color a #ClutterColor
         */
        set_color(color: Color): void;
        /**
         * Sets the color of the cursor of a #ClutterText actor.
         *
         * If `color` is %NULL, the cursor color will be the same as the
         * text color.
         * @param color the color of the cursor, or %NULL to unset it
         */
        set_cursor_color(color?: Color | null): void;
        /**
         * Sets the cursor of a #ClutterText actor at `position`.
         *
         * The position is expressed in characters, not in bytes.
         * @param position the new cursor position, in characters
         */
        set_cursor_position(position: number): void;
        /**
         * Sets the size of the cursor of a #ClutterText. The cursor
         * will only be visible if the #ClutterText:cursor-visible property
         * is set to %TRUE.
         * @param size the size of the cursor, in pixels, or -1 to use the   default value
         */
        set_cursor_size(size: number): void;
        /**
         * Sets whether the cursor of a #ClutterText actor should be
         * visible or not.
         *
         * The color of the cursor will be the same as the text color
         * unless clutter_text_set_cursor_color() has been called.
         *
         * The size of the cursor can be set using clutter_text_set_cursor_size().
         *
         * The position of the cursor can be changed programmatically using
         * clutter_text_set_cursor_position().
         * @param cursor_visible whether the cursor should be visible
         */
        set_cursor_visible(cursor_visible: boolean): void;
        /**
         * Sets whether the #ClutterText actor should be editable.
         *
         * An editable #ClutterText with key focus set using
         * clutter_actor_grab_key_focus() or clutter_stage_set_key_focus()
         * will receive key events and will update its contents accordingly.
         * @param editable whether the #ClutterText should be editable
         */
        set_editable(editable: boolean): void;
        /**
         * Sets the mode used to ellipsize (add an ellipsis: "...") to the
         * text if there is not enough space to render the entire contents
         * of a #ClutterText actor
         * @param mode a #PangoEllipsizeMode
         */
        set_ellipsize(mode: Pango.EllipsizeMode | null): void;
        /**
         * Sets `font_desc` as the font description for a #ClutterText
         *
         * The #PangoFontDescription is copied by the #ClutterText actor
         * so you can safely call pango_font_description_free() on it after
         * calling this function.
         * @param font_desc a #PangoFontDescription
         */
        set_font_description(font_desc: Pango.FontDescription): void;
        /**
         * Sets the font used by a #ClutterText. The `font_name` string
         * must either be %NULL, which means that the font name from the
         * default #ClutterBackend will be used; or be something that can
         * be parsed by the pango_font_description_from_string() function,
         * like:
         *
         *
         * ```
         *   // Set the font to the system's Sans, 10 points
         *   clutter_text_set_font_name (text, "Sans 10");
         *
         *   // Set the font to the system's Serif, 16 pixels
         *   clutter_text_set_font_name (text, "Serif 16px");
         *
         *   // Set the font to Helvetica, 10 points
         *   clutter_text_set_font_name (text, "Helvetica 10");
         * ```
         *
         * @param font_name a font name, or %NULL to set the default font name
         */
        set_font_name(font_name?: string | null): void;
        /**
         * Sets whether the text of the #ClutterText actor should be justified
         * on both margins. This setting is ignored if Clutter is compiled
         * against Pango &lt; 1.18.
         * @param justify whether the text should be justified
         */
        set_justify(justify: boolean): void;
        /**
         * Sets the way that the lines of a wrapped label are aligned with
         * respect to each other. This does not affect the overall alignment
         * of the label within its allocated or specified width.
         *
         * To align a #ClutterText actor you should add it to a container
         * that supports alignment, or use the anchor point.
         * @param alignment A #PangoAlignment
         */
        set_line_alignment(alignment: Pango.Alignment | null): void;
        /**
         * Sets whether the contents of a #ClutterText actor should wrap,
         * if they don't fit the size assigned to the actor.
         * @param line_wrap whether the contents should wrap
         */
        set_line_wrap(line_wrap: boolean): void;
        /**
         * If line wrapping is enabled (see clutter_text_set_line_wrap()) this
         * function controls how the line wrapping is performed. The default is
         * %PANGO_WRAP_WORD which means wrap on word boundaries.
         * @param wrap_mode the line wrapping mode
         */
        set_line_wrap_mode(wrap_mode: Pango.WrapMode | null): void;
        /**
         * Sets `markup` as the contents of a #ClutterText.
         *
         * This is a convenience function for setting a string containing
         * Pango markup, and it is logically equivalent to:
         *
         *
         * ```
         *   /&ast; the order is important &ast;/
         *   clutter_text_set_text (CLUTTER_TEXT (actor), markup);
         *   clutter_text_set_use_markup (CLUTTER_TEXT (actor), TRUE);
         * ```
         *
         * @param markup a string containing Pango markup.   Passing %NULL is the same as passing "" (the empty string)
         */
        set_markup(markup?: string | null): void;
        /**
         * Sets the maximum allowed length of the contents of the actor. If the
         * current contents are longer than the given length, then they will be
         * truncated to fit.
         * @param max the maximum number of characters allowed in the text actor; 0   to disable or -1 to set the length of the current string
         */
        set_max_length(max: number): void;
        /**
         * Sets the character to use in place of the actual text in a
         * password text actor.
         *
         * If `wc` is 0 the text will be displayed as it is entered in the
         * #ClutterText actor.
         * @param wc a Unicode character, or 0 to unset the password character
         */
        set_password_char(wc: string): void;
        /**
         * Sets, or unsets, the pre-edit string. This function is useful
         * for input methods to display a string (with eventual specific
         * Pango attributes) before it is entered inside the #ClutterText
         * buffer.
         *
         * The preedit string and attributes are ignored if the #ClutterText
         * actor is not editable.
         *
         * This function should not be used by applications
         * @param preedit_str the pre-edit string, or %NULL to unset it
         * @param preedit_attrs the pre-edit string attributes
         * @param cursor_pos the cursor position for the pre-edit string
         */
        set_preedit_string(preedit_str: string | null, preedit_attrs: Pango.AttrList | null, cursor_pos: number): void;
        /**
         * Sets whether a #ClutterText actor should be selectable.
         *
         * A selectable #ClutterText will allow selecting its contents using
         * the pointer or the keyboard.
         * @param selectable whether the #ClutterText actor should be selectable
         */
        set_selectable(selectable: boolean): void;
        /**
         * Sets the selected text color of a #ClutterText actor.
         *
         * If `color` is %NULL, the selected text color will be the same as the
         * selection color, which then falls back to cursor, and then text color.
         * @param color the selected text color, or %NULL to unset it
         */
        set_selected_text_color(color?: Color | null): void;
        /**
         * Selects the region of text between `start_pos` and `end_pos`.
         *
         * This function changes the position of the cursor to match
         * `start_pos` and the selection bound to match `end_pos`.
         * @param start_pos start of the selection, in characters
         * @param end_pos end of the selection, in characters
         */
        set_selection(start_pos: number, end_pos: number): void;
        /**
         * Sets the other end of the selection, starting from the current
         * cursor position.
         *
         * If `selection_bound` is -1, the selection unset.
         * @param selection_bound the position of the end of the selection, in characters
         */
        set_selection_bound(selection_bound: number): void;
        /**
         * Sets the color of the selection of a #ClutterText actor.
         *
         * If `color` is %NULL, the selection color will be the same as the
         * cursor color, or if no cursor color is set either then it will be
         * the same as the text color.
         * @param color the color of the selection, or %NULL to unset it
         */
        set_selection_color(color?: Color | null): void;
        /**
         * Sets whether a #ClutterText actor should be in single line mode
         * or not. Only editable #ClutterText<!-- -->s can be in single line
         * mode.
         *
         * A text actor in single line mode will not wrap text and will clip
         * the visible area to the predefined size. The contents of the
         * text actor will scroll to display the end of the text if its length
         * is bigger than the allocated width.
         *
         * When setting the single line mode the #ClutterText:activatable
         * property is also set as a side effect. Instead of entering a new
         * line character, the text actor will emit the #ClutterText::activate
         * signal.
         * @param single_line whether to enable single line mode
         */
        set_single_line_mode(single_line: boolean): void;
        /**
         * Sets the contents of a #ClutterText actor.
         *
         * If the #ClutterText:use-markup property was set to %TRUE it
         * will be reset to %FALSE as a side effect. If you want to
         * maintain the #ClutterText:use-markup you should use the
         * clutter_text_set_markup() function instead
         * @param text the text to set. Passing %NULL is the same   as passing "" (the empty string)
         */
        set_text(text?: string | null): void;
        /**
         * Sets whether the contents of the #ClutterText actor contains markup
         * in <link linkend="PangoMarkupFormat">Pango's text markup language</link>.
         *
         * Setting #ClutterText:use-markup on an editable #ClutterText will
         * not have any effect except hiding the markup.
         *
         * See also #ClutterText:use-markup.
         * @param setting %TRUE if the text should be parsed for markup.
         */
        set_use_markup(setting: boolean): void;

        // Inherited methods
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         * @returns %TRUE if the value has been validated and can   be applied to the #ClutterAnimatable, and %FALSE otherwise
         */
        animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         * @returns The #GParamSpec for the given property   or %NULL
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         * @returns %TRUE if the interpolation was successful,   and %FALSE otherwise
         */
        interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         */
        vfunc_animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         */
        vfunc_find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        vfunc_get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         */
        vfunc_interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        vfunc_set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        add_actor(actor: Actor): void;
        /**
         * Gets a container specific property of a child of `container,` In general,
         * a copy is made of the property contents and the caller is responsible for
         * freeing the memory by calling g_value_unset().
         *
         * Note that clutter_container_child_set_property() is really intended for
         * language bindings, clutter_container_child_set() is much more convenient
         * for C programming.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_get_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Sets a container-specific property on a child of `container`.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_set_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        destroy_child_meta(actor: Actor): void;
        /**
         * Finds a child actor of a container by its name. Search recurses
         * into any child container.
         * @param child_name the name of the requested child.
         * @returns The child actor with the requested name,   or %NULL if no actor with that name was found.
         */
        find_child_by_name(child_name: string): Actor;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         * @returns the #ClutterChildMeta for the @actor child   of @container or %NULL if the specifiec actor does not exist or the   container is not configured to provide #ClutterChildMeta<!-- -->s
         */
        get_child_meta(actor: Actor): ChildMeta;
        /**
         * Retrieves all the children of `container`.
         * @returns a list   of #ClutterActor<!-- -->s. Use g_list_free() on the returned   list when done.
         */
        get_children(): Actor[];
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        lower_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        raise_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        remove_actor(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        sort_depth_order(): void;
        vfunc_actor_added(actor: Actor): void;
        vfunc_actor_removed(actor: Actor): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        vfunc_add(actor: Actor): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        vfunc_child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_destroy_child_meta(actor: Actor): void;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         */
        vfunc_get_child_meta(actor: Actor): ChildMeta;
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        vfunc_lower(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        vfunc_raise(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        vfunc_remove(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        vfunc_sort_depth_order(): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace TextBuffer {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            'deleted-text': (arg0: number, arg1: number) => void;
            'inserted-text': (arg0: number, arg1: string, arg2: number) => void;
            'notify::length': (pspec: GObject.ParamSpec) => void;
            'notify::max-length': (pspec: GObject.ParamSpec) => void;
            'notify::text': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            length: number;
            max_length: number;
            maxLength: number;
            text: string;
        }
    }

    /**
     * The #ClutterTextBuffer structure contains private
     * data and it should only be accessed using the provided API.
     */
    class TextBuffer extends GObject.Object {
        static $gtype: GObject.GType<TextBuffer>;

        // Properties

        /**
         * The length (in characters) of the text in buffer.
         */
        get length(): number;
        /**
         * The maximum length (in characters) of the text in the buffer.
         */
        get max_length(): number;
        set max_length(val: number);
        /**
         * The maximum length (in characters) of the text in the buffer.
         */
        get maxLength(): number;
        set maxLength(val: number);
        /**
         * The contents of the buffer.
         */
        get text(): string;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TextBuffer.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TextBuffer.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): TextBuffer;

        static new_with_text(text: string | null, text_len: number): TextBuffer;

        // Signals

        connect<K extends keyof TextBuffer.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TextBuffer.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TextBuffer.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TextBuffer.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TextBuffer.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TextBuffer.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        /**
         * Deletes a sequence of characters from the buffer. `n_chars` characters are
         * deleted starting at `position`. If `n_chars` is negative, then all characters
         * until the end of the text are deleted.
         *
         * If `position` or `n_chars` are out of bounds, then they are coerced to sane
         * values.
         *
         * Note that the positions are specified in characters, not bytes.
         * @param position position at which to delete text
         * @param n_chars number of characters to delete
         */
        vfunc_delete_text(position: number, n_chars: number): number;
        vfunc_deleted_text(position: number, n_chars: number): void;
        /**
         * Retrieves the length in characters of the buffer.
         */
        vfunc_get_length(): number;
        vfunc_get_text(n_bytes: number): string;
        /**
         * Inserts `n_chars` characters of `chars` into the contents of the
         * buffer, at position `position`.
         *
         * If `n_chars` is negative, then characters from chars will be inserted
         * until a null-terminator is found. If `position` or `n_chars` are out of
         * bounds, or the maximum buffer text length is exceeded, then they are
         * coerced to sane values.
         *
         * Note that the position and length are in characters, not in bytes.
         * @param position the position at which to insert text.
         * @param chars the text to insert into the buffer.
         * @param n_chars the length of the text in characters, or -1
         */
        vfunc_insert_text(position: number, chars: string, n_chars: number): number;
        vfunc_inserted_text(position: number, chars: string, n_chars: number): void;

        // Methods

        /**
         * Deletes a sequence of characters from the buffer. `n_chars` characters are
         * deleted starting at `position`. If `n_chars` is negative, then all characters
         * until the end of the text are deleted.
         *
         * If `position` or `n_chars` are out of bounds, then they are coerced to sane
         * values.
         *
         * Note that the positions are specified in characters, not bytes.
         * @param position position at which to delete text
         * @param n_chars number of characters to delete
         * @returns The number of characters deleted.
         */
        delete_text(position: number, n_chars: number): number;
        /**
         * Emits the #ClutterTextBuffer::deleted-text signal on `buffer`.
         *
         * Used when subclassing #ClutterTextBuffer
         * @param position position at which text was deleted
         * @param n_chars number of characters deleted
         */
        emit_deleted_text(position: number, n_chars: number): void;
        /**
         * Emits the #ClutterTextBuffer::inserted-text signal on `buffer`.
         *
         * Used when subclassing #ClutterTextBuffer
         * @param position position at which text was inserted
         * @param chars text that was inserted
         * @param n_chars number of characters inserted
         */
        emit_inserted_text(position: number, chars: string, n_chars: number): void;
        /**
         * Retrieves the length in bytes of the buffer.
         * See clutter_text_buffer_get_length().
         * @returns The byte length of the buffer.
         */
        get_bytes(): number;
        /**
         * Retrieves the length in characters of the buffer.
         * @returns The number of characters in the buffer.
         */
        get_length(): number;
        /**
         * Retrieves the maximum allowed length of the text in
         * `buffer`. See clutter_text_buffer_set_max_length().
         * @returns the maximum allowed number of characters               in #ClutterTextBuffer, or 0 if there is no maximum.
         */
        get_max_length(): number;
        /**
         * Retrieves the contents of the buffer.
         *
         * The memory pointer returned by this call will not change
         * unless this object emits a signal, or is finalized.
         * @returns a pointer to the contents of the widget as a      string. This string points to internally allocated      storage in the buffer and must not be freed, modified or      stored.
         */
        get_text(): string;
        /**
         * Inserts `n_chars` characters of `chars` into the contents of the
         * buffer, at position `position`.
         *
         * If `n_chars` is negative, then characters from chars will be inserted
         * until a null-terminator is found. If `position` or `n_chars` are out of
         * bounds, or the maximum buffer text length is exceeded, then they are
         * coerced to sane values.
         *
         * Note that the position and length are in characters, not in bytes.
         * @param position the position at which to insert text.
         * @param chars the text to insert into the buffer.
         * @param n_chars the length of the text in characters, or -1
         * @returns The number of characters actually inserted.
         */
        insert_text(position: number, chars: string, n_chars: number): number;
        /**
         * Sets the maximum allowed length of the contents of the buffer. If
         * the current contents are longer than the given length, then they
         * will be truncated to fit.
         * @param max_length the maximum length of the entry buffer, or 0 for no maximum.   (other than the maximum length of entries.) The value passed in will   be clamped to the range [ 0, %CLUTTER_TEXT_BUFFER_MAX_SIZE ].
         */
        set_max_length(max_length: number): void;
        /**
         * Sets the text in the buffer.
         *
         * This is roughly equivalent to calling clutter_text_buffer_delete_text()
         * and clutter_text_buffer_insert_text().
         *
         * Note that `n_chars` is in characters, not in bytes.
         * @param chars the new text
         * @param n_chars the number of characters in @text, or -1
         */
        set_text(chars: string, n_chars: number): void;
    }

    namespace TextNode {
        // Signal signatures
        interface SignalSignatures extends PaintNode.SignalSignatures {}
    }

    /**
     * The #ClutterTextNode structure is an opaque
     * type whose members cannot be directly accessed.
     */
    class TextNode extends PaintNode {
        static $gtype: GObject.GType<TextNode>;

        // Constructors

        _init(...args: any[]): void;

        static ['new'](layout?: Pango.Layout | null, color?: Color | null): TextNode;

        // Signals

        connect<K extends keyof TextNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TextNode.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TextNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TextNode.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TextNode.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TextNode.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace Texture {
        // Signal signatures
        interface SignalSignatures extends Actor.SignalSignatures {
            'load-finished': (arg0: GLib.Error) => void;
            'pixbuf-change': () => void;
            'size-change': (arg0: number, arg1: number) => void;
            'notify::disable-slicing': (pspec: GObject.ParamSpec) => void;
            'notify::filename': (pspec: GObject.ParamSpec) => void;
            'notify::filter-quality': (pspec: GObject.ParamSpec) => void;
            'notify::keep-aspect-ratio': (pspec: GObject.ParamSpec) => void;
            'notify::load-async': (pspec: GObject.ParamSpec) => void;
            'notify::load-data-async': (pspec: GObject.ParamSpec) => void;
            'notify::pick-with-alpha': (pspec: GObject.ParamSpec) => void;
            'notify::pixel-format': (pspec: GObject.ParamSpec) => void;
            'notify::repeat-x': (pspec: GObject.ParamSpec) => void;
            'notify::repeat-y': (pspec: GObject.ParamSpec) => void;
            'notify::sync-size': (pspec: GObject.ParamSpec) => void;
            'notify::tile-waste': (pspec: GObject.ParamSpec) => void;
            'notify::actions': (pspec: GObject.ParamSpec) => void;
            'notify::allocation': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-x': (pspec: GObject.ParamSpec) => void;
            'notify::anchor-y': (pspec: GObject.ParamSpec) => void;
            'notify::background-color': (pspec: GObject.ParamSpec) => void;
            'notify::background-color-set': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform': (pspec: GObject.ParamSpec) => void;
            'notify::child-transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::clip': (pspec: GObject.ParamSpec) => void;
            'notify::clip-rect': (pspec: GObject.ParamSpec) => void;
            'notify::clip-to-allocation': (pspec: GObject.ParamSpec) => void;
            'notify::constraints': (pspec: GObject.ParamSpec) => void;
            'notify::content': (pspec: GObject.ParamSpec) => void;
            'notify::content-box': (pspec: GObject.ParamSpec) => void;
            'notify::content-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::content-repeat': (pspec: GObject.ParamSpec) => void;
            'notify::depth': (pspec: GObject.ParamSpec) => void;
            'notify::effect': (pspec: GObject.ParamSpec) => void;
            'notify::first-child': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-position-set': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-x': (pspec: GObject.ParamSpec) => void;
            'notify::fixed-y': (pspec: GObject.ParamSpec) => void;
            'notify::has-clip': (pspec: GObject.ParamSpec) => void;
            'notify::has-pointer': (pspec: GObject.ParamSpec) => void;
            'notify::height': (pspec: GObject.ParamSpec) => void;
            'notify::last-child': (pspec: GObject.ParamSpec) => void;
            'notify::layout-manager': (pspec: GObject.ParamSpec) => void;
            'notify::magnification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::mapped': (pspec: GObject.ParamSpec) => void;
            'notify::margin-bottom': (pspec: GObject.ParamSpec) => void;
            'notify::margin-left': (pspec: GObject.ParamSpec) => void;
            'notify::margin-right': (pspec: GObject.ParamSpec) => void;
            'notify::margin-top': (pspec: GObject.ParamSpec) => void;
            'notify::min-height': (pspec: GObject.ParamSpec) => void;
            'notify::min-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::min-width': (pspec: GObject.ParamSpec) => void;
            'notify::min-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::minification-filter': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height': (pspec: GObject.ParamSpec) => void;
            'notify::natural-height-set': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width': (pspec: GObject.ParamSpec) => void;
            'notify::natural-width-set': (pspec: GObject.ParamSpec) => void;
            'notify::offscreen-redirect': (pspec: GObject.ParamSpec) => void;
            'notify::opacity': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point': (pspec: GObject.ParamSpec) => void;
            'notify::pivot-point-z': (pspec: GObject.ParamSpec) => void;
            'notify::position': (pspec: GObject.ParamSpec) => void;
            'notify::reactive': (pspec: GObject.ParamSpec) => void;
            'notify::realized': (pspec: GObject.ParamSpec) => void;
            'notify::request-mode': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-angle-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-z-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::rotation-center-zgravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-center-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-gravity': (pspec: GObject.ParamSpec) => void;
            'notify::scale-x': (pspec: GObject.ParamSpec) => void;
            'notify::scale-y': (pspec: GObject.ParamSpec) => void;
            'notify::scale-z': (pspec: GObject.ParamSpec) => void;
            'notify::show-on-set-parent': (pspec: GObject.ParamSpec) => void;
            'notify::size': (pspec: GObject.ParamSpec) => void;
            'notify::text-direction': (pspec: GObject.ParamSpec) => void;
            'notify::transform': (pspec: GObject.ParamSpec) => void;
            'notify::transform-set': (pspec: GObject.ParamSpec) => void;
            'notify::translation-x': (pspec: GObject.ParamSpec) => void;
            'notify::translation-y': (pspec: GObject.ParamSpec) => void;
            'notify::translation-z': (pspec: GObject.ParamSpec) => void;
            'notify::visible': (pspec: GObject.ParamSpec) => void;
            'notify::width': (pspec: GObject.ParamSpec) => void;
            'notify::x': (pspec: GObject.ParamSpec) => void;
            'notify::x-align': (pspec: GObject.ParamSpec) => void;
            'notify::x-expand': (pspec: GObject.ParamSpec) => void;
            'notify::y': (pspec: GObject.ParamSpec) => void;
            'notify::y-align': (pspec: GObject.ParamSpec) => void;
            'notify::y-expand': (pspec: GObject.ParamSpec) => void;
            'notify::z-position': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps
            extends Actor.ConstructorProps,
                Atk.ImplementorIface.ConstructorProps,
                Animatable.ConstructorProps,
                Container.ConstructorProps,
                Scriptable.ConstructorProps {
            disable_slicing: boolean;
            disableSlicing: boolean;
            filename: string;
            filter_quality: TextureQuality;
            filterQuality: TextureQuality;
            keep_aspect_ratio: boolean;
            keepAspectRatio: boolean;
            load_async: boolean;
            loadAsync: boolean;
            load_data_async: boolean;
            loadDataAsync: boolean;
            pick_with_alpha: boolean;
            pickWithAlpha: boolean;
            pixel_format: Cogl.PixelFormat;
            pixelFormat: Cogl.PixelFormat;
            repeat_x: boolean;
            repeatX: boolean;
            repeat_y: boolean;
            repeatY: boolean;
            sync_size: boolean;
            syncSize: boolean;
            tile_waste: number;
            tileWaste: number;
        }
    }

    /**
     * The #ClutterTexture structure contains only private data
     * and should be accessed using the provided API
     */
    class Texture extends Actor implements Atk.ImplementorIface, Animatable, Container, Scriptable {
        static $gtype: GObject.GType<Texture>;

        // Properties

        get disable_slicing(): boolean;
        get disableSlicing(): boolean;
        /**
         * The path of the file containing the image data to be displayed by
         * the texture.
         *
         * This property is unset when using the clutter_texture_set_from_*_data()
         * family of functions.
         */
        get filename(): string;
        set filename(val: string);
        get filter_quality(): TextureQuality;
        set filter_quality(val: TextureQuality);
        get filterQuality(): TextureQuality;
        set filterQuality(val: TextureQuality);
        get keep_aspect_ratio(): boolean;
        set keep_aspect_ratio(val: boolean);
        get keepAspectRatio(): boolean;
        set keepAspectRatio(val: boolean);
        /**
         * Tries to load a texture from a filename by using a local thread to perform
         * the read operations. The initially created texture has dimensions 0x0 when
         * the true size becomes available the #ClutterTexture::size-change signal is
         * emitted and when the image has completed loading the
         * #ClutterTexture::load-finished signal is emitted.
         *
         * Threading is only enabled if g_thread_init() has been called prior to
         * clutter_init(), otherwise #ClutterTexture will use the main loop to load
         * the image.
         *
         * The upload of the texture data on the GL pipeline is not asynchronous, as
         * it must be performed from within the same thread that called
         * clutter_main().
         */
        set load_async(val: boolean);
        /**
         * Tries to load a texture from a filename by using a local thread to perform
         * the read operations. The initially created texture has dimensions 0x0 when
         * the true size becomes available the #ClutterTexture::size-change signal is
         * emitted and when the image has completed loading the
         * #ClutterTexture::load-finished signal is emitted.
         *
         * Threading is only enabled if g_thread_init() has been called prior to
         * clutter_init(), otherwise #ClutterTexture will use the main loop to load
         * the image.
         *
         * The upload of the texture data on the GL pipeline is not asynchronous, as
         * it must be performed from within the same thread that called
         * clutter_main().
         */
        set loadAsync(val: boolean);
        /**
         * Like #ClutterTexture:load-async but loads the width and height
         * synchronously causing some blocking.
         */
        set load_data_async(val: boolean);
        /**
         * Like #ClutterTexture:load-async but loads the width and height
         * synchronously causing some blocking.
         */
        set loadDataAsync(val: boolean);
        get pick_with_alpha(): boolean;
        set pick_with_alpha(val: boolean);
        get pickWithAlpha(): boolean;
        set pickWithAlpha(val: boolean);
        get pixel_format(): Cogl.PixelFormat;
        get pixelFormat(): Cogl.PixelFormat;
        get repeat_x(): boolean;
        set repeat_x(val: boolean);
        get repeatX(): boolean;
        set repeatX(val: boolean);
        get repeat_y(): boolean;
        set repeat_y(val: boolean);
        get repeatY(): boolean;
        set repeatY(val: boolean);
        get sync_size(): boolean;
        set sync_size(val: boolean);
        get syncSize(): boolean;
        set syncSize(val: boolean);
        get tile_waste(): number;
        get tileWaste(): number;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Texture.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Texture.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): Texture;

        static new_from_actor(actor: Actor): Texture;

        static new_from_file(filename: string): Texture;

        // Signals

        connect<K extends keyof Texture.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Texture.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Texture.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Texture.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Texture.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Texture.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_load_finished(error: GLib.Error): void;
        vfunc_pixbuf_change(): void;
        vfunc_size_change(width: number, height: number): void;

        // Methods

        /**
         * Gets the size in pixels of the untransformed underlying image
         */
        get_base_size(): [number, number];
        /**
         * Returns a handle to the underlying COGL material used for drawing
         * the actor.
         * @returns a handle for a #CoglMaterial. The   material is owned by the #ClutterTexture and it should not be   unreferenced
         */
        get_cogl_material(): Cogl.Handle;
        /**
         * Retrieves the handle to the underlying COGL texture used for drawing
         * the actor. No extra reference is taken so if you need to keep the
         * handle then you should call cogl_handle_ref() on it.
         *
         * The texture handle returned is the first layer of the material
         * handle used by the #ClutterTexture. If you need to access the other
         * layers you should use clutter_texture_get_cogl_material() instead
         * and use the #CoglMaterial API.
         * @returns a #CoglHandle for the texture. The returned   handle is owned by the #ClutterTexture and it should not be unreferenced
         */
        get_cogl_texture(): Cogl.Handle;
        /**
         * Gets the filter quality used when scaling a texture.
         * @returns The filter quality value.
         */
        get_filter_quality(): TextureQuality;
        /**
         * Retrieves the value set using clutter_texture_set_keep_aspect_ratio()
         * @returns %TRUE if the #ClutterTexture should maintain the   aspect ratio of the underlying image
         */
        get_keep_aspect_ratio(): boolean;
        /**
         * Retrieves the value set using clutter_texture_set_load_async()
         * @returns %TRUE if the #ClutterTexture should load the data from   disk asynchronously
         */
        get_load_async(): boolean;
        /**
         * Retrieves the value set by clutter_texture_set_load_data_async()
         * @returns %TRUE if the #ClutterTexture should load the image   data from a file asynchronously
         */
        get_load_data_async(): boolean;
        /**
         * Gets the maximum waste that will be used when creating a texture or
         * -1 if slicing is disabled.
         * @returns The maximum waste or -1 if the texture waste is   unlimited.
         */
        get_max_tile_waste(): number;
        /**
         * Retrieves the value set by clutter_texture_set_load_data_async()
         * @returns %TRUE if the #ClutterTexture should define its shape using the alpha channel when picking.
         */
        get_pick_with_alpha(): boolean;
        /**
         * Retrieves the pixel format used by `texture`. This is
         * equivalent to:
         *
         *
         * ```
         *   handle = clutter_texture_get_pixel_format (texture);
         *
         *   if (handle != COGL_INVALID_HANDLE)
         *     format = cogl_texture_get_format (handle);
         * ```
         *
         * @returns a #CoglPixelFormat value
         */
        get_pixel_format(): Cogl.PixelFormat;
        /**
         * Retrieves the horizontal and vertical repeat values set
         * using clutter_texture_set_repeat()
         */
        get_repeat(): [boolean, boolean];
        /**
         * Retrieves the value set with clutter_texture_set_sync_size()
         * @returns %TRUE if the #ClutterTexture should have the same   preferred size of the underlying image data
         */
        get_sync_size(): boolean;
        /**
         * Updates a sub-region of the pixel data in a #ClutterTexture.
         * @param data Image data in RGB type colorspace.
         * @param has_alpha Set to TRUE if image data has an alpha channel.
         * @param x X coordinate of upper left corner of region to update.
         * @param y Y coordinate of upper left corner of region to update.
         * @param width Width in pixels of region to update.
         * @param height Height in pixels of region to update.
         * @param rowstride Distance in bytes between row starts on source buffer.
         * @param bpp bytes per pixel (Currently only 3 and 4 supported,                        depending on @has_alpha)
         * @param flags #ClutterTextureFlags
         * @returns %TRUE on success, %FALSE on failure.
         */
        set_area_from_rgb_data(
            data: Uint8Array | string,
            has_alpha: boolean,
            x: number,
            y: number,
            width: number,
            height: number,
            rowstride: number,
            bpp: number,
            flags: TextureFlags | null,
        ): boolean;
        /**
         * Replaces the underlying Cogl material drawn by this actor with
         * `cogl_material`. A reference to the material is taken so if the
         * handle is no longer needed it should be deref'd with
         * cogl_handle_unref. Texture data is attached to the material so
         * calling this function also replaces the Cogl
         * texture. #ClutterTexture requires that the material have a texture
         * layer so you should set one on the material before calling this
         * function.
         * @param cogl_material A CoglHandle for a material
         */
        set_cogl_material(cogl_material: Cogl.Handle): void;
        /**
         * Replaces the underlying COGL texture drawn by this actor with
         * `cogl_tex`. A reference to the texture is taken so if the handle is
         * no longer needed it should be deref'd with cogl_handle_unref.
         * @param cogl_tex A CoglHandle for a texture
         */
        set_cogl_texture(cogl_tex: Cogl.Handle): void;
        /**
         * Sets the filter quality when scaling a texture. The quality is an
         * enumeration currently the following values are supported:
         * %CLUTTER_TEXTURE_QUALITY_LOW which is fast but only uses nearest neighbour
         * interpolation. %CLUTTER_TEXTURE_QUALITY_MEDIUM which is computationally a
         * bit more expensive (bilinear interpolation), and
         * %CLUTTER_TEXTURE_QUALITY_HIGH which uses extra texture memory resources to
         * improve scaled down rendering as well (by using mipmaps). The default value
         * is %CLUTTER_TEXTURE_QUALITY_MEDIUM.
         * @param filter_quality new filter quality value
         */
        set_filter_quality(filter_quality: TextureQuality | null): void;
        /**
         * Sets the #ClutterTexture image data from an image file. In case of
         * failure, %FALSE is returned and `error` is set.
         *
         * If #ClutterTexture:load-async is set to %TRUE, this function
         * will return as soon as possible, and the actual image loading
         * from disk will be performed asynchronously. #ClutterTexture::size-change
         * will be emitten when the size of the texture is available and
         * #ClutterTexture::load-finished will be emitted when the image has been
         * loaded or if an error occurred.
         * @param filename The filename of the image in GLib file name encoding
         * @returns %TRUE if the image was successfully loaded and set
         */
        set_from_file(filename: string): boolean;
        /**
         * Sets #ClutterTexture image data.
         * @param data image data in RGBA type colorspace.
         * @param has_alpha set to %TRUE if image data has an alpha channel.
         * @param width width in pixels of image data.
         * @param height height in pixels of image data
         * @param rowstride distance in bytes between row starts.
         * @param bpp bytes per pixel (currently only 3 and 4 supported, depending   on the value of @has_alpha)
         * @param flags #ClutterTextureFlags
         * @returns %TRUE on success, %FALSE on failure.
         */
        set_from_rgb_data(
            data: Uint8Array | string,
            has_alpha: boolean,
            width: number,
            height: number,
            rowstride: number,
            bpp: number,
            flags: TextureFlags | null,
        ): boolean;
        /**
         * Sets a #ClutterTexture from YUV image data. If an error occurred,
         * %FALSE is returned and `error` is set.
         *
         * The YUV support depends on the driver; the format supported by the
         * few drivers exposing this capability are not really useful.
         *
         * The proper way to convert image data in any YUV colorspace to any
         * RGB colorspace is to use a fragment shader associated with the
         * #ClutterTexture material.
         * @param data Image data in YUV type colorspace.
         * @param width Width in pixels of image data.
         * @param height Height in pixels of image data
         * @param flags #ClutterTextureFlags
         * @returns %TRUE if the texture was successfully updated
         */
        set_from_yuv_data(
            data: Uint8Array | string,
            width: number,
            height: number,
            flags: TextureFlags | null,
        ): boolean;
        /**
         * Sets whether `texture` should have a preferred size maintaining
         * the aspect ratio of the underlying image
         * @param keep_aspect %TRUE to maintain aspect ratio
         */
        set_keep_aspect_ratio(keep_aspect: boolean): void;
        /**
         * Sets whether `texture` should use a worker thread to load the data
         * from disk asynchronously. Setting `load_async` to %TRUE will make
         * clutter_texture_set_from_file() return immediately.
         *
         * See the #ClutterTexture:load-async property documentation, and
         * clutter_texture_set_load_data_async().
         * @param load_async %TRUE if the texture should asynchronously load data   from a filename
         */
        set_load_async(load_async: boolean): void;
        /**
         * Sets whether `texture` should use a worker thread to load the data
         * from disk asynchronously. Setting `load_async` to %TRUE will make
         * clutter_texture_set_from_file() block until the #ClutterTexture has
         * determined the width and height of the image data.
         *
         * See the #ClutterTexture:load-async property documentation, and
         * clutter_texture_set_load_async().
         * @param load_async %TRUE if the texture should asynchronously load data   from a filename
         */
        set_load_data_async(load_async: boolean): void;
        /**
         * Sets whether `texture` should have it's shape defined by the alpha
         * channel when picking.
         *
         * Be aware that this is a bit more costly than the default picking
         * due to the texture lookup, extra test against the alpha value and
         * the fact that it will also interrupt the batching of geometry done
         * internally.
         *
         * Also there is currently no control over the threshold used to
         * determine what value of alpha is considered pickable, and so only
         * fully opaque parts of the texture will react to picking.
         * @param pick_with_alpha %TRUE if the alpha channel should affect the   picking shape
         */
        set_pick_with_alpha(pick_with_alpha: boolean): void;
        /**
         * Sets whether the `texture` should repeat horizontally or
         * vertically when the actor size is bigger than the image size
         * @param repeat_x %TRUE if the texture should repeat horizontally
         * @param repeat_y %TRUE if the texture should repeat vertically
         */
        set_repeat(repeat_x: boolean, repeat_y: boolean): void;
        /**
         * Sets whether `texture` should have the same preferred size as the
         * underlying image data.
         * @param sync_size %TRUE if the texture should have the same size of the    underlying image data
         */
        set_sync_size(sync_size: boolean): void;

        // Inherited methods
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         * @returns %TRUE if the value has been validated and can   be applied to the #ClutterAnimatable, and %FALSE otherwise
         */
        animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         * @returns The #GParamSpec for the given property   or %NULL
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         * @returns %TRUE if the interpolation was successful,   and %FALSE otherwise
         */
        interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         */
        vfunc_animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         */
        vfunc_find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        vfunc_get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         */
        vfunc_interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        vfunc_set_final_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        add_actor(actor: Actor): void;
        /**
         * Gets a container specific property of a child of `container,` In general,
         * a copy is made of the property contents and the caller is responsible for
         * freeing the memory by calling g_value_unset().
         *
         * Note that clutter_container_child_set_property() is really intended for
         * language bindings, clutter_container_child_set() is much more convenient
         * for C programming.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_get_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Sets a container-specific property on a child of `container`.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_set_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        destroy_child_meta(actor: Actor): void;
        /**
         * Finds a child actor of a container by its name. Search recurses
         * into any child container.
         * @param child_name the name of the requested child.
         * @returns The child actor with the requested name,   or %NULL if no actor with that name was found.
         */
        find_child_by_name(child_name: string): Actor;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         * @returns the #ClutterChildMeta for the @actor child   of @container or %NULL if the specifiec actor does not exist or the   container is not configured to provide #ClutterChildMeta<!-- -->s
         */
        get_child_meta(actor: Actor): ChildMeta;
        /**
         * Retrieves all the children of `container`.
         * @returns a list   of #ClutterActor<!-- -->s. Use g_list_free() on the returned   list when done.
         */
        get_children(): Actor[];
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        lower_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        raise_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        remove_actor(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        sort_depth_order(): void;
        vfunc_actor_added(actor: Actor): void;
        vfunc_actor_removed(actor: Actor): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        vfunc_add(actor: Actor): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        vfunc_child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_destroy_child_meta(actor: Actor): void;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         */
        vfunc_get_child_meta(actor: Actor): ChildMeta;
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        vfunc_lower(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        vfunc_raise(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        vfunc_remove(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        vfunc_sort_depth_order(): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace TextureNode {
        // Signal signatures
        interface SignalSignatures extends PipelineNode.SignalSignatures {}
    }

    /**
     * The #ClutterTextNode structure is an opaque
     * type whose members cannot be directly accessed.
     */
    class TextureNode extends PipelineNode {
        static $gtype: GObject.GType<TextureNode>;

        // Constructors

        _init(...args: any[]): void;

        static ['new'](
            texture: Cogl.Texture,
            color: Color | null,
            min_filter: ScalingFilter,
            mag_filter: ScalingFilter,
        ): TextureNode;

        // Signals

        connect<K extends keyof TextureNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TextureNode.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TextureNode.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TextureNode.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TextureNode.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TextureNode.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;
    }

    namespace Timeline {
        // Signal signatures
        interface SignalSignatures extends GObject.Object.SignalSignatures {
            completed: () => void;
            'marker-reached': (arg0: string, arg1: number) => void;
            'new-frame': (arg0: number) => void;
            paused: () => void;
            started: () => void;
            stopped: (arg0: boolean) => void;
            'notify::auto-reverse': (pspec: GObject.ParamSpec) => void;
            'notify::delay': (pspec: GObject.ParamSpec) => void;
            'notify::direction': (pspec: GObject.ParamSpec) => void;
            'notify::duration': (pspec: GObject.ParamSpec) => void;
            'notify::loop': (pspec: GObject.ParamSpec) => void;
            'notify::progress-mode': (pspec: GObject.ParamSpec) => void;
            'notify::repeat-count': (pspec: GObject.ParamSpec) => void;
            'marker-reached::auto-reverse': (arg0: string, arg1: number) => void;
            'marker-reached::delay': (arg0: string, arg1: number) => void;
            'marker-reached::direction': (arg0: string, arg1: number) => void;
            'marker-reached::duration': (arg0: string, arg1: number) => void;
            'marker-reached::loop': (arg0: string, arg1: number) => void;
            'marker-reached::progress-mode': (arg0: string, arg1: number) => void;
            'marker-reached::repeat-count': (arg0: string, arg1: number) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps, Scriptable.ConstructorProps {
            auto_reverse: boolean;
            autoReverse: boolean;
            delay: number;
            direction: TimelineDirection;
            duration: number;
            loop: boolean;
            progress_mode: AnimationMode;
            progressMode: AnimationMode;
            repeat_count: number;
            repeatCount: number;
        }
    }

    /**
     * The #ClutterTimeline structure contains only private data
     * and should be accessed using the provided API
     */
    class Timeline extends GObject.Object implements Scriptable {
        static $gtype: GObject.GType<Timeline>;

        // Properties

        /**
         * If the direction of the timeline should be automatically reversed
         * when reaching the end.
         */
        get auto_reverse(): boolean;
        set auto_reverse(val: boolean);
        /**
         * If the direction of the timeline should be automatically reversed
         * when reaching the end.
         */
        get autoReverse(): boolean;
        set autoReverse(val: boolean);
        /**
         * A delay, in milliseconds, that should be observed by the
         * timeline before actually starting.
         */
        get delay(): number;
        set delay(val: number);
        /**
         * The direction of the timeline, either %CLUTTER_TIMELINE_FORWARD or
         * %CLUTTER_TIMELINE_BACKWARD.
         */
        get direction(): TimelineDirection;
        set direction(val: TimelineDirection);
        /**
         * Duration of the timeline in milliseconds, depending on the
         * ClutterTimeline:fps value.
         */
        get duration(): number;
        set duration(val: number);
        /**
         * Whether the timeline should automatically rewind and restart.
         *
         * As a side effect, setting this property to %TRUE will set the
         * #ClutterTimeline:repeat-count property to -1, while setting this
         * property to %FALSE will set the #ClutterTimeline:repeat-count
         * property to 0.
         */
        get loop(): boolean;
        set loop(val: boolean);
        /**
         * Controls the way a #ClutterTimeline computes the normalized progress.
         */
        get progress_mode(): AnimationMode;
        set progress_mode(val: AnimationMode);
        /**
         * Controls the way a #ClutterTimeline computes the normalized progress.
         */
        get progressMode(): AnimationMode;
        set progressMode(val: AnimationMode);
        /**
         * Defines how many times the timeline should repeat.
         *
         * If the repeat count is 0, the timeline does not repeat.
         *
         * If the repeat count is set to -1, the timeline will repeat until it is
         * stopped.
         */
        get repeat_count(): number;
        set repeat_count(val: number);
        /**
         * Defines how many times the timeline should repeat.
         *
         * If the repeat count is 0, the timeline does not repeat.
         *
         * If the repeat count is set to -1, the timeline will repeat until it is
         * stopped.
         */
        get repeatCount(): number;
        set repeatCount(val: number);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Timeline.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Timeline.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](msecs: number): Timeline;

        // Signals

        connect<K extends keyof Timeline.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Timeline.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Timeline.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Timeline.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Timeline.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Timeline.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_completed(): void;
        vfunc_marker_reached(marker_name: string, msecs: number): void;
        vfunc_new_frame(msecs: number): void;
        vfunc_paused(): void;
        vfunc_started(): void;
        vfunc_stopped(is_finished: boolean): void;

        // Methods

        /**
         * Adds a named marker that will be hit when the timeline has reached
         * the specified `progress`.
         *
         * Markers are unique string identifiers for a given position on the
         * timeline. Once `timeline` reaches the given `progress` of its duration,
         * if will emit a ::marker-reached signal for each marker attached to
         * that particular point.
         *
         * A marker can be removed with clutter_timeline_remove_marker(). The
         * timeline can be advanced to a marker using
         * clutter_timeline_advance_to_marker().
         *
         * See also: clutter_timeline_add_marker_at_time()
         * @param marker_name the unique name for this marker
         * @param progress the normalized value of the position of the martke
         */
        add_marker(marker_name: string, progress: number): void;
        /**
         * Adds a named marker that will be hit when the timeline has been
         * running for `msecs` milliseconds.
         *
         * Markers are unique string identifiers for a given position on the
         * timeline. Once `timeline` reaches the given `msecs,` it will emit
         * a ::marker-reached signal for each marker attached to that position.
         *
         * A marker can be removed with clutter_timeline_remove_marker(). The
         * timeline can be advanced to a marker using
         * clutter_timeline_advance_to_marker().
         *
         * See also: clutter_timeline_add_marker()
         * @param marker_name the unique name for this marker
         * @param msecs position of the marker in milliseconds
         */
        add_marker_at_time(marker_name: string, msecs: number): void;
        /**
         * Advance timeline to the requested point. The point is given as a
         * time in milliseconds since the timeline started.
         *
         * The `timeline` will not emit the #ClutterTimeline::new-frame
         * signal for the given time. The first ::new-frame signal after the call to
         * clutter_timeline_advance() will be emit the skipped markers.
         * @param msecs Time to advance to
         */
        advance(msecs: number): void;
        /**
         * Advances `timeline` to the time of the given `marker_name`.
         *
         * Like clutter_timeline_advance(), this function will not
         * emit the #ClutterTimeline::new-frame for the time where `marker_name`
         * is set, nor it will emit #ClutterTimeline::marker-reached for
         * `marker_name`.
         * @param marker_name the name of the marker
         */
        advance_to_marker(marker_name: string): void;
        /**
         * Create a new #ClutterTimeline instance which has property values
         * matching that of supplied timeline. The cloned timeline will not
         * be started and will not be positioned to the current position of
         * the original `timeline:` you will have to start it with
         * clutter_timeline_start().
         *
         * The only cloned properties are:
         *
         *  - #ClutterTimeline:duration
         *  - #ClutterTimeline:loop
         *  - #ClutterTimeline:delay
         *  - #ClutterTimeline:direction
         * @returns a new #ClutterTimeline, cloned   from @timeline
         */
        clone(): Timeline;
        /**
         * Retrieves the value set by clutter_timeline_set_auto_reverse().
         * @returns %TRUE if the timeline should automatically reverse, and   %FALSE otherwise
         */
        get_auto_reverse(): boolean;
        /**
         * Retrieves the control points for the cubic bezier progress mode.
         * @returns %TRUE if the @timeline is using a cubic bezier progress   more, and %FALSE otherwise
         */
        get_cubic_bezier_progress(): [boolean, Point, Point];
        /**
         * Retrieves the current repeat for a timeline.
         *
         * Repeats start at 0.
         * @returns the current repeat
         */
        get_current_repeat(): number;
        /**
         * Retrieves the delay set using clutter_timeline_set_delay().
         * @returns the delay in milliseconds.
         */
        get_delay(): number;
        /**
         * Retrieves the amount of time elapsed since the last
         * ClutterTimeline::new-frame signal.
         *
         * This function is only useful inside handlers for the ::new-frame
         * signal, and its behaviour is undefined if the timeline is not
         * playing.
         * @returns the amount of time in milliseconds elapsed since the last frame
         */
        get_delta(): number;
        /**
         * Retrieves the direction of the timeline set with
         * clutter_timeline_set_direction().
         * @returns the direction of the timeline
         */
        get_direction(): TimelineDirection;
        /**
         * Retrieves the duration of a #ClutterTimeline in milliseconds.
         * See clutter_timeline_set_duration().
         * @returns the duration of the timeline, in milliseconds.
         */
        get_duration(): number;
        /**
         * Retrieves the full duration of the `timeline,` taking into account the
         * current value of the #ClutterTimeline:repeat-count property.
         *
         * If the #ClutterTimeline:repeat-count property is set to -1, this function
         * will return %G_MAXINT64.
         *
         * The returned value is to be considered a hint, and it's only valid
         * as long as the `timeline` hasn't been changed.
         * @returns the full duration of the #ClutterTimeline
         */
        get_duration_hint(): number;
        /**
         * Request the current time position of the timeline.
         * @returns current elapsed time in milliseconds.
         */
        get_elapsed_time(): number;
        /**
         * Gets whether `timeline` is looping
         * @returns %TRUE if the timeline is looping
         */
        get_loop(): boolean;
        /**
         * The position of the timeline in a normalized [-1, 2] interval.
         *
         * The return value of this function is determined by the progress
         * mode set using clutter_timeline_set_progress_mode(), or by the
         * progress function set using clutter_timeline_set_progress_func().
         * @returns the normalized current position in the timeline.
         */
        get_progress(): number;
        /**
         * Retrieves the progress mode set using clutter_timeline_set_progress_mode()
         * or clutter_timeline_set_progress_func().
         * @returns a #ClutterAnimationMode
         */
        get_progress_mode(): AnimationMode;
        /**
         * Retrieves the number set using clutter_timeline_set_repeat_count().
         * @returns the number of repeats
         */
        get_repeat_count(): number;
        /**
         * Retrieves the parameters of the step progress mode used by `timeline`.
         * @returns %TRUE if the @timeline is using a step progress   mode, and %FALSE otherwise
         */
        get_step_progress(): [boolean, number, StepMode];
        /**
         * Checks whether `timeline` has a marker set with the given name.
         * @param marker_name the name of the marker
         * @returns %TRUE if the marker was found
         */
        has_marker(marker_name: string): boolean;
        /**
         * Queries state of a #ClutterTimeline.
         * @returns %TRUE if timeline is currently playing
         */
        is_playing(): boolean;
        /**
         * Retrieves the list of markers at time `msecs`. If `msecs` is a
         * negative integer, all the markers attached to `timeline` will be
         * returned.
         * @param msecs the time to check, or -1
         * @returns a newly allocated, %NULL terminated string array containing the names   of the markers. Use g_strfreev() when done.
         */
        list_markers(msecs: number): string[];
        /**
         * Pauses the #ClutterTimeline on current frame
         */
        pause(): void;
        /**
         * Removes `marker_name,` if found, from `timeline`.
         * @param marker_name the name of the marker to remove
         */
        remove_marker(marker_name: string): void;
        /**
         * Rewinds #ClutterTimeline to the first frame if its direction is
         * %CLUTTER_TIMELINE_FORWARD and the last frame if it is
         * %CLUTTER_TIMELINE_BACKWARD.
         */
        rewind(): void;
        /**
         * Sets whether `timeline` should reverse the direction after the
         * emission of the #ClutterTimeline::completed signal.
         *
         * Setting the #ClutterTimeline:auto-reverse property to %TRUE is the
         * equivalent of connecting a callback to the #ClutterTimeline::completed
         * signal and changing the direction of the timeline from that callback;
         * for instance, this code:
         *
         *
         * ```
         * static void
         * reverse_timeline (ClutterTimeline *timeline)
         * {
         *   ClutterTimelineDirection dir = clutter_timeline_get_direction (timeline);
         *
         *   if (dir == CLUTTER_TIMELINE_FORWARD)
         *     dir = CLUTTER_TIMELINE_BACKWARD;
         *   else
         *     dir = CLUTTER_TIMELINE_FORWARD;
         *
         *   clutter_timeline_set_direction (timeline, dir);
         * }
         * ...
         *   timeline = clutter_timeline_new (1000);
         *   clutter_timeline_set_repeat_count (timeline, -1);
         *   g_signal_connect (timeline, "completed",
         *                     G_CALLBACK (reverse_timeline),
         *                     NULL);
         * ```
         *
         *
         * can be effectively replaced by:
         *
         *
         * ```
         *   timeline = clutter_timeline_new (1000);
         *   clutter_timeline_set_repeat_count (timeline, -1);
         *   clutter_timeline_set_auto_reverse (timeline);
         * ```
         *
         * @param reverse %TRUE if the @timeline should reverse the direction
         */
        set_auto_reverse(reverse: boolean): void;
        /**
         * Sets the #ClutterTimeline:progress-mode of `timeline`
         * to %CLUTTER_CUBIC_BEZIER, and sets the two control
         * points for the cubic bezier.
         *
         * The cubic bezier curve is between (0, 0) and (1, 1). The X coordinate
         * of the two control points must be in the [ 0, 1 ] range, while the
         * Y coordinate of the two control points can exceed this range.
         * @param c_1 the first control point for the cubic bezier
         * @param c_2 the second control point for the cubic bezier
         */
        set_cubic_bezier_progress(c_1: Point, c_2: Point): void;
        /**
         * Sets the delay, in milliseconds, before `timeline` should start.
         * @param msecs delay in milliseconds
         */
        set_delay(msecs: number): void;
        /**
         * Sets the direction of `timeline,` either %CLUTTER_TIMELINE_FORWARD or
         * %CLUTTER_TIMELINE_BACKWARD.
         * @param direction the direction of the timeline
         */
        set_direction(direction: TimelineDirection | null): void;
        /**
         * Sets the duration of the timeline, in milliseconds. The speed
         * of the timeline depends on the ClutterTimeline:fps setting.
         * @param msecs duration of the timeline in milliseconds
         */
        set_duration(msecs: number): void;
        /**
         * Sets whether `timeline` should loop.
         *
         * This function is equivalent to calling clutter_timeline_set_repeat_count()
         * with -1 if `loop` is %TRUE, and with 0 if `loop` is %FALSE.
         * @param loop %TRUE for enable looping
         */
        set_loop(loop: boolean): void;
        /**
         * Sets a custom progress function for `timeline`. The progress function will
         * be called by clutter_timeline_get_progress() and will be used to compute
         * the progress value based on the elapsed time and the total duration of the
         * timeline.
         *
         * If `func` is not %NULL, the #ClutterTimeline:progress-mode property will
         * be set to %CLUTTER_CUSTOM_MODE.
         *
         * If `func` is %NULL, any previously set progress function will be unset, and
         * the #ClutterTimeline:progress-mode property will be set to %CLUTTER_LINEAR.
         * @param func a progress function, or %NULL
         */
        set_progress_func(func?: TimelineProgressFunc | null): void;
        /**
         * Sets the progress function using a value from the #ClutterAnimationMode
         * enumeration. The `mode` cannot be %CLUTTER_CUSTOM_MODE or bigger than
         * %CLUTTER_ANIMATION_LAST.
         * @param mode the progress mode, as a #ClutterAnimationMode
         */
        set_progress_mode(mode: AnimationMode | null): void;
        /**
         * Sets the number of times the `timeline` should repeat.
         *
         * If `count` is 0, the timeline never repeats.
         *
         * If `count` is -1, the timeline will always repeat until
         * it's stopped.
         * @param count the number of times the timeline should repeat
         */
        set_repeat_count(count: number): void;
        /**
         * Sets the #ClutterTimeline:progress-mode of the `timeline` to %CLUTTER_STEPS
         * and provides the parameters of the step function.
         * @param n_steps the number of steps
         * @param step_mode whether the change should happen at the start   or at the end of the step
         */
        set_step_progress(n_steps: number, step_mode: StepMode | null): void;
        /**
         * Advance timeline by the requested time in milliseconds
         * @param msecs Amount of time to skip
         */
        skip(msecs: number): void;
        /**
         * Starts the #ClutterTimeline playing.
         */
        start(): void;
        /**
         * Stops the #ClutterTimeline and moves to frame 0
         */
        stop(): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace Transition {
        // Signal signatures
        interface SignalSignatures extends Timeline.SignalSignatures {
            'notify::animatable': (pspec: GObject.ParamSpec) => void;
            'notify::interval': (pspec: GObject.ParamSpec) => void;
            'notify::remove-on-complete': (pspec: GObject.ParamSpec) => void;
            'notify::auto-reverse': (pspec: GObject.ParamSpec) => void;
            'notify::delay': (pspec: GObject.ParamSpec) => void;
            'notify::direction': (pspec: GObject.ParamSpec) => void;
            'notify::duration': (pspec: GObject.ParamSpec) => void;
            'notify::loop': (pspec: GObject.ParamSpec) => void;
            'notify::progress-mode': (pspec: GObject.ParamSpec) => void;
            'notify::repeat-count': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Timeline.ConstructorProps, Scriptable.ConstructorProps {
            animatable: Animatable;
            interval: Interval;
            remove_on_complete: boolean;
            removeOnComplete: boolean;
        }
    }

    /**
     * The #ClutterTransition structure contains private
     * data and should only be accessed using the provided API.
     */
    abstract class Transition extends Timeline implements Scriptable {
        static $gtype: GObject.GType<Transition>;

        // Properties

        /**
         * The #ClutterAnimatable instance currently being animated.
         */
        get animatable(): Animatable;
        set animatable(val: Animatable);
        /**
         * The #ClutterInterval used to describe the initial and final states
         * of the transition.
         */
        get interval(): Interval;
        set interval(val: Interval);
        /**
         * Whether the #ClutterTransition should be automatically detached
         * from the #ClutterTransition:animatable instance whenever the
         * #ClutterTimeline::stopped signal is emitted.
         *
         * The #ClutterTransition:remove-on-complete property takes into
         * account the value of the #ClutterTimeline:repeat-count property,
         * and it only detaches the transition if the transition is not
         * repeating.
         */
        get remove_on_complete(): boolean;
        set remove_on_complete(val: boolean);
        /**
         * Whether the #ClutterTransition should be automatically detached
         * from the #ClutterTransition:animatable instance whenever the
         * #ClutterTimeline::stopped signal is emitted.
         *
         * The #ClutterTransition:remove-on-complete property takes into
         * account the value of the #ClutterTimeline:repeat-count property,
         * and it only detaches the transition if the transition is not
         * repeating.
         */
        get removeOnComplete(): boolean;
        set removeOnComplete(val: boolean);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: Transition.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<Transition.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        // Signals

        connect<K extends keyof Transition.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Transition.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof Transition.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, Transition.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof Transition.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<Transition.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_attached(animatable: Animatable): void;
        vfunc_compute_value(animatable: Animatable, interval: Interval, progress: number): void;
        vfunc_detached(animatable: Animatable): void;

        // Methods

        /**
         * Retrieves the #ClutterAnimatable set using clutter_transition_set_animatable().
         * @returns a #ClutterAnimatable, or %NULL; the returned   animatable is owned by the #ClutterTransition, and it should not be freed   directly.
         */
        get_animatable(): Animatable;
        /**
         * Retrieves the interval set using clutter_transition_set_interval()
         * @returns a #ClutterInterval, or %NULL; the returned   interval is owned by the #ClutterTransition and it should not be freed   directly
         */
        get_interval(): Interval;
        /**
         * Retrieves the value of the #ClutterTransition:remove-on-complete property.
         * @returns %TRUE if the @transition should be detached when complete,   and %FALSE otherwise
         */
        get_remove_on_complete(): boolean;
        /**
         * Sets the #ClutterTransition:animatable property.
         *
         * The `transition` will acquire a reference to the `animatable` instance,
         * and will call the #ClutterTransitionClass.attached() virtual function.
         *
         * If an existing #ClutterAnimatable is attached to `transition,` the
         * reference will be released, and the #ClutterTransitionClass.detached()
         * virtual function will be called.
         * @param animatable a #ClutterAnimatable, or %NULL
         */
        set_animatable(animatable?: Animatable | null): void;
        /**
         * Sets the initial value of the transition.
         *
         * This is a convenience function that will either create the
         * #ClutterInterval used by `transition,` or will update it if
         * the #ClutterTransition:interval is already set.
         *
         * This function will copy the contents of `value,` so it is
         * safe to call g_value_unset() after it returns.
         *
         * If `transition` already has a #ClutterTransition:interval set,
         * then `value` must hold the same type, or a transformable type,
         * as the interval's #ClutterInterval:value-type property.
         *
         * This function is meant to be used by language bindings.
         * @param value a #GValue with the initial value of the transition
         */
        set_from(value: GObject.Value | any): void;
        /**
         * Sets the #ClutterTransition:interval property using `interval`.
         *
         * The `transition` will acquire a reference on the `interval,` sinking
         * the floating flag on it if necessary.
         * @param interval a #ClutterInterval, or %NULL
         */
        set_interval(interval?: Interval | null): void;
        /**
         * Sets whether `transition` should be detached from the #ClutterAnimatable
         * set using clutter_transition_set_animatable() when the
         * #ClutterTimeline::completed signal is emitted.
         * @param remove_complete whether to detach @transition when complete
         */
        set_remove_on_complete(remove_complete: boolean): void;
        /**
         * Sets the final value of the transition.
         *
         * This is a convenience function that will either create the
         * #ClutterInterval used by `transition,` or will update it if
         * the #ClutterTransition:interval is already set.
         *
         * This function will copy the contents of `value,` so it is
         * safe to call g_value_unset() after it returns.
         *
         * If `transition` already has a #ClutterTransition:interval set,
         * then `value` must hold the same type, or a transformable type,
         * as the interval's #ClutterInterval:value-type property.
         *
         * This function is meant to be used by language bindings.
         * @param value a #GValue with the final value of the transition
         */
        set_to(value: GObject.Value | any): void;

        // Inherited methods
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;
        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace TransitionGroup {
        // Signal signatures
        interface SignalSignatures extends Transition.SignalSignatures {
            'notify::animatable': (pspec: GObject.ParamSpec) => void;
            'notify::interval': (pspec: GObject.ParamSpec) => void;
            'notify::remove-on-complete': (pspec: GObject.ParamSpec) => void;
            'notify::auto-reverse': (pspec: GObject.ParamSpec) => void;
            'notify::delay': (pspec: GObject.ParamSpec) => void;
            'notify::direction': (pspec: GObject.ParamSpec) => void;
            'notify::duration': (pspec: GObject.ParamSpec) => void;
            'notify::loop': (pspec: GObject.ParamSpec) => void;
            'notify::progress-mode': (pspec: GObject.ParamSpec) => void;
            'notify::repeat-count': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends Transition.ConstructorProps, Scriptable.ConstructorProps {}
    }

    /**
     * The #ClutterTransitionGroup structure contains
     * private data and should only be accessed using the provided API.
     */
    class TransitionGroup extends Transition implements Scriptable {
        static $gtype: GObject.GType<TransitionGroup>;

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: TransitionGroup.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<TransitionGroup.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): TransitionGroup;

        // Signals

        connect<K extends keyof TransitionGroup.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TransitionGroup.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof TransitionGroup.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, TransitionGroup.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof TransitionGroup.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<TransitionGroup.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Methods

        /**
         * Adds `transition` to `group`.
         *
         * This function acquires a reference on `transition` that will be released
         * when calling clutter_transition_group_remove_transition().
         * @param transition a #ClutterTransition
         */
        add_transition(transition: Transition): void;
        /**
         * Removes all transitions from `group`.
         *
         * This function releases the reference acquired when calling
         * clutter_transition_group_add_transition().
         */
        remove_all(): void;
        /**
         * Removes `transition` from `group`.
         *
         * This function releases the reference acquired on `transition` when
         * calling clutter_transition_group_add_transition().
         * @param transition a #ClutterTransition
         */
        remove_transition(transition: Transition): void;

        // Inherited methods
        /**
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target`.
         *
         * Whenever the `source_property` is changed the `target_property` is
         * updated using the same value. For instance:
         *
         *
         * ```c
         *   g_object_bind_property (action, "active", widget, "sensitive", 0);
         * ```
         *
         *
         * Will result in the "sensitive" property of the widget #GObject instance to be
         * updated with the same value of the "active" property of the action #GObject
         * instance.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well.
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. To remove the binding without affecting the
         * `source` and the `target` you can just call g_object_unref() on the returned
         * #GBinding instance.
         *
         * Removing the binding by calling g_object_unref() on it must only be done if
         * the binding, `source` and `target` are only used from a single thread and it
         * is clear that both `source` and `target` outlive the binding. Especially it
         * is not safe to rely on this if the binding, `source` or `target` can be
         * finalized from different threads. Keep another reference to the binding and
         * use g_binding_unbind() instead to be on the safe side.
         *
         * A #GObject can have multiple bindings.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
        ): GObject.Binding;
        /**
         * Complete version of g_object_bind_property().
         *
         * Creates a binding between `source_property` on `source` and `target_property`
         * on `target,` allowing you to set the transformation functions to be used by
         * the binding.
         *
         * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
         * if `target_property` on `target` changes then the `source_property` on `source`
         * will be updated as well. The `transform_from` function is only used in case
         * of bidirectional bindings, otherwise it will be ignored
         *
         * The binding will automatically be removed when either the `source` or the
         * `target` instances are finalized. This will release the reference that is
         * being held on the #GBinding instance; if you want to hold on to the
         * #GBinding instance, you will need to hold a reference to it.
         *
         * To remove the binding, call g_binding_unbind().
         *
         * A #GObject can have multiple bindings.
         *
         * The same `user_data` parameter will be used for both `transform_to`
         * and `transform_from` transformation functions; the `notify` function will
         * be called once, when the binding is removed. If you need different data
         * for each transformation function, please use
         * g_object_bind_property_with_closures() instead.
         * @param source_property the property on @source to bind
         * @param target the target #GObject
         * @param target_property the property on @target to bind
         * @param flags flags to pass to #GBinding
         * @param transform_to the transformation function     from the @source to the @target, or %NULL to use the default
         * @param transform_from the transformation function     from the @target to the @source, or %NULL to use the default
         * @param notify a function to call when disposing the binding, to free     resources used by the transformation functions, or %NULL if not required
         * @returns the #GBinding instance representing the     binding between the two #GObject instances. The binding is released     whenever the #GBinding reference count reaches zero.
         */
        bind_property_full(
            source_property: string,
            target: GObject.Object,
            target_property: string,
            flags: GObject.BindingFlags | null,
            transform_to?: GObject.BindingTransformFunc | null,
            transform_from?: GObject.BindingTransformFunc | null,
            notify?: GLib.DestroyNotify | null,
        ): GObject.Binding;
        // Conflicted with GObject.Object.bind_property_full
        bind_property_full(...args: never[]): any;
        /**
         * This function is intended for #GObject implementations to re-enforce
         * a [floating][floating-ref] object reference. Doing this is seldom
         * required: all #GInitiallyUnowneds are created with a floating reference
         * which usually just needs to be sunken by calling g_object_ref_sink().
         */
        force_floating(): void;
        /**
         * Increases the freeze count on `object`. If the freeze count is
         * non-zero, the emission of "notify" signals on `object` is
         * stopped. The signals are queued until the freeze count is decreased
         * to zero. Duplicate notifications are squashed so that at most one
         * #GObject::notify signal is emitted for each property modified while the
         * object is frozen.
         *
         * This is necessary for accessors that modify multiple properties to prevent
         * premature notification while the object is still being modified.
         */
        freeze_notify(): void;
        /**
         * Gets a named field from the objects table of associations (see g_object_set_data()).
         * @param key name of the key for that association
         * @returns the data if found,          or %NULL if no such data exists.
         */
        get_data(key: string): any | null;
        /**
         * Gets a property of an object.
         *
         * The value can be:
         * - an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
         * - a GObject.Value initialized with the expected type of the property
         * - a GObject.Value initialized with a type to which the expected type of the property can be transformed
         *
         * In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.
         *
         * Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.
         * @param property_name The name of the property to get
         * @param value Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type
         */
        get_property(property_name: string, value: GObject.Value | any): any;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        get_qdata(quark: GLib.Quark): any | null;
        /**
         * Gets `n_properties` properties for an `object`.
         * Obtained properties will be set to `values`. All properties must be valid.
         * Warnings will be emitted and undefined behaviour may result if invalid
         * properties are passed in.
         * @param names the names of each property to get
         * @param values the values of each property to get
         */
        getv(names: string[], values: (GObject.Value | any)[]): void;
        /**
         * Checks whether `object` has a [floating][floating-ref] reference.
         * @returns %TRUE if @object has a floating reference
         */
        is_floating(): boolean;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param property_name the name of a property installed on the class of @object.
         */
        notify(property_name: string): void;
        /**
         * Emits a "notify" signal for the property specified by `pspec` on `object`.
         *
         * This function omits the property name lookup, hence it is faster than
         * g_object_notify().
         *
         * One way to avoid using g_object_notify() from within the
         * class that registered the properties, and using g_object_notify_by_pspec()
         * instead, is to store the GParamSpec used with
         * g_object_class_install_property() inside a static array, e.g.:
         *
         *
         * ```c
         *   typedef enum
         *   {
         *     PROP_FOO = 1,
         *     PROP_LAST
         *   } MyObjectProperty;
         *
         *   static GParamSpec *properties[PROP_LAST];
         *
         *   static void
         *   my_object_class_init (MyObjectClass *klass)
         *   {
         *     properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
         *                                              0, 100,
         *                                              50,
         *                                              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
         *     g_object_class_install_property (gobject_class,
         *                                      PROP_FOO,
         *                                      properties[PROP_FOO]);
         *   }
         * ```
         *
         *
         * and then notify a change on the "foo" property with:
         *
         *
         * ```c
         *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
         * ```
         *
         * @param pspec the #GParamSpec of a property installed on the class of @object.
         */
        notify_by_pspec(pspec: GObject.ParamSpec): void;
        /**
         * Increases the reference count of `object`.
         *
         * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
         * of `object` will be propagated to the return type (using the GCC typeof()
         * extension), so any casting the caller needs to do on the return type must be
         * explicit.
         * @returns the same @object
         */
        ref(): GObject.Object;
        /**
         * Increase the reference count of `object,` and possibly remove the
         * [floating][floating-ref] reference, if `object` has a floating reference.
         *
         * In other words, if the object is floating, then this call "assumes
         * ownership" of the floating reference, converting it to a normal
         * reference by clearing the floating flag while leaving the reference
         * count unchanged.  If the object is not floating, then this call
         * adds a new normal reference increasing the reference count by one.
         *
         * Since GLib 2.56, the type of `object` will be propagated to the return type
         * under the same conditions as for g_object_ref().
         * @returns @object
         */
        ref_sink(): GObject.Object;
        /**
         * Releases all references to other objects. This can be used to break
         * reference cycles.
         *
         * This function should only be called from object system implementations.
         */
        run_dispose(): void;
        /**
         * Each object carries around a table of associations from
         * strings to pointers.  This function lets you set an association.
         *
         * If the object already had an association with that name,
         * the old association will be destroyed.
         *
         * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
         * This means a copy of `key` is kept permanently (even after `object` has been
         * finalized)  so it is recommended to only use a small, bounded set of values
         * for `key` in your program, to avoid the #GQuark storage growing unbounded.
         * @param key name of the key
         * @param data data to associate with that key
         */
        set_data(key: string, data?: any | null): void;
        /**
         * Sets a property on an object.
         * @param property_name The name of the property to set
         * @param value The value to set the property to
         */
        set_property(property_name: string, value: GObject.Value | any): void;
        /**
         * Remove a specified datum from the object's data associations,
         * without invoking the association's destroy handler.
         * @param key name of the key
         * @returns the data if found, or %NULL          if no such data exists.
         */
        steal_data(key: string): any | null;
        /**
         * This function gets back user data pointers stored via
         * g_object_set_qdata() and removes the `data` from object
         * without invoking its destroy() function (if any was
         * set).
         * Usually, calling this function is only required to update
         * user data pointers with a destroy notifier, for example:
         *
         * ```c
         * void
         * object_add_to_user_list (GObject     *object,
         *                          const gchar *new_string)
         * {
         *   // the quark, naming the object data
         *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
         *   // retrieve the old string list
         *   GList *list = g_object_steal_qdata (object, quark_string_list);
         *
         *   // prepend new string
         *   list = g_list_prepend (list, g_strdup (new_string));
         *   // this changed 'list', so we need to set it again
         *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
         * }
         * static void
         * free_string_list (gpointer data)
         * {
         *   GList *node, *list = data;
         *
         *   for (node = list; node; node = node->next)
         *     g_free (node->data);
         *   g_list_free (list);
         * }
         * ```
         *
         * Using g_object_get_qdata() in the above example, instead of
         * g_object_steal_qdata() would have left the destroy function set,
         * and thus the partial string list would have been freed upon
         * g_object_set_qdata_full().
         * @param quark A #GQuark, naming the user data pointer
         * @returns The user data pointer set, or %NULL
         */
        steal_qdata(quark: GLib.Quark): any | null;
        /**
         * Reverts the effect of a previous call to
         * g_object_freeze_notify(). The freeze count is decreased on `object`
         * and when it reaches zero, queued "notify" signals are emitted.
         *
         * Duplicate notifications for each property are squashed so that at most one
         * #GObject::notify signal is emitted for each property, in the reverse order
         * in which they have been queued.
         *
         * It is an error to call this function when the freeze count is zero.
         */
        thaw_notify(): void;
        /**
         * Decreases the reference count of `object`. When its reference count
         * drops to 0, the object is finalized (i.e. its memory is freed).
         *
         * If the pointer to the #GObject may be reused in future (for example, if it is
         * an instance variable of another object), it is recommended to clear the
         * pointer to %NULL rather than retain a dangling pointer to a potentially
         * invalid #GObject instance. Use g_clear_object() for this.
         */
        unref(): void;
        /**
         * This function essentially limits the life time of the `closure` to
         * the life time of the object. That is, when the object is finalized,
         * the `closure` is invalidated by calling g_closure_invalidate() on
         * it, in order to prevent invocations of the closure with a finalized
         * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
         * added as marshal guards to the `closure,` to ensure that an extra
         * reference count is held on `object` during invocation of the
         * `closure`.  Usually, this function will be called on closures that
         * use this `object` as closure data.
         * @param closure #GClosure to watch
         */
        watch_closure(closure: GObject.Closure): void;
        /**
         * the `constructed` function is called by g_object_new() as the
         *  final step of the object creation process.  At the point of the call, all
         *  construction properties have been set on the object.  The purpose of this
         *  call is to allow for object initialisation steps that can only be performed
         *  after construction properties have been set.  `constructed` implementors
         *  should chain up to the `constructed` call of their parent class to allow it
         *  to complete its initialisation.
         */
        vfunc_constructed(): void;
        /**
         * emits property change notification for a bunch
         *  of properties. Overriding `dispatch_properties_changed` should be rarely
         *  needed.
         * @param n_pspecs
         * @param pspecs
         */
        vfunc_dispatch_properties_changed(n_pspecs: number, pspecs: GObject.ParamSpec): void;
        /**
         * the `dispose` function is supposed to drop all references to other
         *  objects, but keep the instance otherwise intact, so that client method
         *  invocations still work. It may be run multiple times (due to reference
         *  loops). Before returning, `dispose` should chain up to the `dispose` method
         *  of the parent class.
         */
        vfunc_dispose(): void;
        /**
         * instance finalization function, should finish the finalization of
         *  the instance begun in `dispose` and chain up to the `finalize` method of the
         *  parent class.
         */
        vfunc_finalize(): void;
        /**
         * the generic getter for all properties of this type. Should be
         *  overridden for every type with properties.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_get_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Emits a "notify" signal for the property `property_name` on `object`.
         *
         * When possible, eg. when signaling a property change from within the class
         * that registered the property, you should use g_object_notify_by_pspec()
         * instead.
         *
         * Note that emission of the notify signal may be blocked with
         * g_object_freeze_notify(). In this case, the signal emissions are queued
         * and will be emitted (in reverse order) when g_object_thaw_notify() is
         * called.
         * @param pspec
         */
        vfunc_notify(pspec: GObject.ParamSpec): void;
        /**
         * the generic setter for all properties of this type. Should be
         *  overridden for every type with properties. If implementations of
         *  `set_property` don't emit property change notification explicitly, this will
         *  be done implicitly by the type system. However, if the notify signal is
         *  emitted explicitly, the type system will not emit it a second time.
         * @param property_id
         * @param value
         * @param pspec
         */
        vfunc_set_property(property_id: number, value: GObject.Value | any, pspec: GObject.ParamSpec): void;
        /**
         * Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to.
         * @param id Handler ID of the handler to be disconnected
         */
        disconnect(id: number): void;
        /**
         * Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values.
         * @param properties Object containing the properties to set
         */
        set(properties: { [key: string]: any }): void;
        /**
         * Blocks a handler of an instance so it will not be called during any signal emissions
         * @param id Handler ID of the handler to be blocked
         */
        block_signal_handler(id: number): void;
        /**
         * Unblocks a handler so it will be called again during any signal emissions
         * @param id Handler ID of the handler to be unblocked
         */
        unblock_signal_handler(id: number): void;
        /**
         * Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked.
         * @param detailedName Name of the signal to stop emission of
         */
        stop_emission_by_name(detailedName: string): void;
    }

    namespace ZoomAction {
        // Signal signatures
        interface SignalSignatures extends GestureAction.SignalSignatures {
            zoom: (arg0: Actor, arg1: Point, arg2: number) => boolean | void;
            'notify::zoom-axis': (pspec: GObject.ParamSpec) => void;
            'notify::n-touch-points': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-distance-x': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-distance-y': (pspec: GObject.ParamSpec) => void;
            'notify::threshold-trigger-edge': (pspec: GObject.ParamSpec) => void;
            'notify::actor': (pspec: GObject.ParamSpec) => void;
            'notify::enabled': (pspec: GObject.ParamSpec) => void;
            'notify::name': (pspec: GObject.ParamSpec) => void;
        }

        // Constructor properties interface

        interface ConstructorProps extends GestureAction.ConstructorProps {
            zoom_axis: ZoomAxis;
            zoomAxis: ZoomAxis;
        }
    }

    /**
     * The #ClutterZoomAction structure contains only
     * private data and should be accessed using the provided API
     */
    class ZoomAction extends GestureAction {
        static $gtype: GObject.GType<ZoomAction>;

        // Properties

        /**
         * Constraints the zooming action to the specified axis
         */
        get zoom_axis(): ZoomAxis;
        set zoom_axis(val: ZoomAxis);
        /**
         * Constraints the zooming action to the specified axis
         */
        get zoomAxis(): ZoomAxis;
        set zoomAxis(val: ZoomAxis);

        /**
         * Compile-time signal type information.
         *
         * This instance property is generated only for TypeScript type checking.
         * It is not defined at runtime and should not be accessed in JS code.
         * @internal
         */
        $signals: ZoomAction.SignalSignatures;

        // Constructors

        constructor(properties?: Partial<ZoomAction.ConstructorProps>, ...args: any[]);

        _init(...args: any[]): void;

        static ['new'](): ZoomAction;

        // Signals

        connect<K extends keyof ZoomAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ZoomAction.SignalSignatures[K]>,
        ): number;
        connect(signal: string, callback: (...args: any[]) => any): number;
        connect_after<K extends keyof ZoomAction.SignalSignatures>(
            signal: K,
            callback: GObject.SignalCallback<this, ZoomAction.SignalSignatures[K]>,
        ): number;
        connect_after(signal: string, callback: (...args: any[]) => any): number;
        emit<K extends keyof ZoomAction.SignalSignatures>(
            signal: K,
            ...args: GObject.GjsParameters<ZoomAction.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never
        ): void;
        emit(signal: string, ...args: any[]): void;

        // Virtual methods

        vfunc_zoom(actor: Actor, focal_point: Point, factor: number): boolean;

        // Methods

        /**
         * Retrieves the focal point of the current zoom
         */
        get_focal_point(): Point;
        /**
         * Retrieves the focal point relative to the actor's coordinates of
         * the current zoom
         */
        get_transformed_focal_point(): Point;
        /**
         * Retrieves the axis constraint set by clutter_zoom_action_set_zoom_axis()
         * @returns the axis constraint
         */
        get_zoom_axis(): ZoomAxis;
        /**
         * Restricts the zooming action to a specific axis
         * @param axis the axis to constraint the zooming to
         */
        set_zoom_axis(axis: ZoomAxis | null): void;
    }

    type ActionClass = typeof Action;
    /**
     * Bounding box of an actor. The coordinates of the top left and right bottom
     * corners of an actor. The coordinates of the two points are expressed in
     * pixels with sub-pixel precision
     */
    class ActorBox {
        static $gtype: GObject.GType<ActorBox>;

        // Fields

        x1: number;
        y1: number;
        x2: number;
        y2: number;

        // Constructors

        constructor(
            properties?: Partial<{
                x1: number;
                y1: number;
                x2: number;
                y2: number;
            }>,
        );
        _init(...args: any[]): void;

        static ['new'](x_1: number, y_1: number, x_2: number, y_2: number): ActorBox;

        // Static methods

        /**
         * Allocates a new #ClutterActorBox.
         */
        static alloc(): ActorBox;

        // Methods

        /**
         * Clamps the components of `box` to the nearest integer
         */
        clamp_to_pixel(): void;
        /**
         * Checks whether a point with `x,` `y` coordinates is contained
         * withing `box`
         * @param x X coordinate of the point
         * @param y Y coordinate of the point
         * @returns %TRUE if the point is contained by the #ClutterActorBox
         */
        contains(x: number, y: number): boolean;
        /**
         * Copies `box`
         * @returns a newly allocated copy of #ClutterActorBox. Use   clutter_actor_box_free() to free the allocated resources
         */
        copy(): ActorBox;
        /**
         * Checks `box_a` and `box_b` for equality
         * @param box_b a #ClutterActorBox
         * @returns %TRUE if the passed #ClutterActorBox are equal
         */
        equal(box_b: ActorBox): boolean;
        /**
         * Frees a #ClutterActorBox allocated using clutter_actor_box_new()
         * or clutter_actor_box_copy()
         */
        free(): void;
        /**
         * Calculates the bounding box represented by the four vertices; for details
         * of the vertex array see clutter_actor_get_abs_allocation_vertices().
         * @param verts array of four #ClutterVertex
         */
        from_vertices(verts: Vertex[]): void;
        /**
         * Retrieves the area of `box`
         * @returns the area of a #ClutterActorBox, in pixels
         */
        get_area(): number;
        /**
         * Retrieves the height of the `box`
         * @returns the height of the box
         */
        get_height(): number;
        /**
         * Retrieves the origin of `box`
         */
        get_origin(): [number, number];
        /**
         * Retrieves the size of `box`
         */
        get_size(): [number, number];
        /**
         * Retrieves the width of the `box`
         * @returns the width of the box
         */
        get_width(): number;
        /**
         * Retrieves the X coordinate of the origin of `box`
         * @returns the X coordinate of the origin
         */
        get_x(): number;
        /**
         * Retrieves the Y coordinate of the origin of `box`
         * @returns the Y coordinate of the origin
         */
        get_y(): number;
        /**
         * Initializes `box` with the given coordinates.
         * @param x_1 X coordinate of the top left point
         * @param y_1 Y coordinate of the top left point
         * @param x_2 X coordinate of the bottom right point
         * @param y_2 Y coordinate of the bottom right point
         * @returns the initialized #ClutterActorBox
         */
        init(x_1: number, y_1: number, x_2: number, y_2: number): ActorBox;
        /**
         * Initializes `box` with the given origin and size.
         * @param x X coordinate of the origin
         * @param y Y coordinate of the origin
         * @param width width of the box
         * @param height height of the box
         */
        init_rect(x: number, y: number, width: number, height: number): void;
        /**
         * Interpolates between `initial` and `final` #ClutterActorBox<!-- -->es
         * using `progress`
         * @param _final the final #ClutterActorBox
         * @param progress the interpolation progress
         */
        interpolate(_final: ActorBox, progress: number): ActorBox;
        /**
         * Changes the origin of `box,` maintaining the size of the #ClutterActorBox.
         * @param x the X coordinate of the new origin
         * @param y the Y coordinate of the new origin
         */
        set_origin(x: number, y: number): void;
        /**
         * Sets the size of `box,` maintaining the origin of the #ClutterActorBox.
         * @param width the new width
         * @param height the new height
         */
        set_size(width: number, height: number): void;
        /**
         * Unions the two boxes `a` and `b` and stores the result in `result`.
         * @param b the second #ClutterActorBox
         */
        union(b: ActorBox): ActorBox;
    }

    type ActorClass = typeof Actor;
    /**
     * An iterator structure that allows to efficiently iterate over a
     * section of the scene graph.
     *
     * The contents of the #ClutterActorIter structure
     * are private and should only be accessed using the provided API.
     */
    class ActorIter {
        static $gtype: GObject.GType<ActorIter>;

        // Constructors

        constructor(properties?: Partial<{}>);
        _init(...args: any[]): void;

        // Methods

        /**
         * Safely destroys the #ClutterActor currently pointer to by the iterator
         * from its parent.
         *
         * This function can only be called after clutter_actor_iter_next() or
         * clutter_actor_iter_prev() returned %TRUE, and cannot be called more
         * than once for the same actor.
         *
         * This function will call clutter_actor_destroy() internally.
         */
        destroy(): void;
        /**
         * Initializes a #ClutterActorIter, which can then be used to iterate
         * efficiently over a section of the scene graph, and associates it
         * with `root`.
         *
         * Modifying the scene graph section that contains `root` will invalidate
         * the iterator.
         *
         *
         * ```c
         *   ClutterActorIter iter;
         *   ClutterActor *child;
         *
         *   clutter_actor_iter_init (&iter, container);
         *   while (clutter_actor_iter_next (&iter, &child))
         *     {
         *       // do something with child
         *     }
         * ```
         *
         * @param root a #ClutterActor
         */
        init(root: Actor): void;
        /**
         * Checks whether a #ClutterActorIter is still valid.
         *
         * An iterator is considered valid if it has been initialized, and
         * if the #ClutterActor that it refers to hasn't been modified after
         * the initialization.
         * @returns %TRUE if the iterator is valid, and %FALSE otherwise
         */
        is_valid(): boolean;
        /**
         * Advances the `iter` and retrieves the next child of the root #ClutterActor
         * that was used to initialize the #ClutterActorIterator.
         *
         * If the iterator can advance, this function returns %TRUE and sets the
         * `child` argument.
         *
         * If the iterator cannot advance, this function returns %FALSE, and
         * the contents of `child` are undefined.
         * @returns %TRUE if the iterator could advance, and %FALSE otherwise.
         */
        next(): [boolean, Actor];
        /**
         * Advances the `iter` and retrieves the previous child of the root
         * #ClutterActor that was used to initialize the #ClutterActorIterator.
         *
         * If the iterator can advance, this function returns %TRUE and sets the
         * `child` argument.
         *
         * If the iterator cannot advance, this function returns %FALSE, and
         * the contents of `child` are undefined.
         * @returns %TRUE if the iterator could advance, and %FALSE otherwise.
         */
        prev(): [boolean, Actor];
        /**
         * Safely removes the #ClutterActor currently pointer to by the iterator
         * from its parent.
         *
         * This function can only be called after clutter_actor_iter_next() or
         * clutter_actor_iter_prev() returned %TRUE, and cannot be called more
         * than once for the same actor.
         *
         * This function will call clutter_actor_remove_child() internally.
         */
        remove(): void;
    }

    type ActorMetaClass = typeof ActorMeta;
    abstract class ActorMetaPrivate {
        static $gtype: GObject.GType<ActorMetaPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class ActorPrivate {
        static $gtype: GObject.GType<ActorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type AlignConstraintClass = typeof AlignConstraint;
    type AlphaClass = typeof Alpha;
    abstract class AlphaPrivate {
        static $gtype: GObject.GType<AlphaPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type AnimatableIface = typeof Animatable;
    type AnimationClass = typeof Animation;
    abstract class AnimationPrivate {
        static $gtype: GObject.GType<AnimationPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type AnimatorClass = typeof Animator;
    /**
     * A key frame inside a #ClutterAnimator
     */
    abstract class AnimatorKey {
        static $gtype: GObject.GType<AnimatorKey>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Retrieves the mode of a #ClutterAnimator key, for the first key of a
         * property for an object this represents the whether the animation is
         * open ended and or curved for the remainding keys for the property it
         * represents the easing mode.
         * @returns the mode of a #ClutterAnimatorKey
         */
        get_mode(): number;
        /**
         * Retrieves the object a key applies to.
         * @returns the object an animator_key exist for.
         */
        get_object<T = GObject.Object>(): T;
        /**
         * Retrieves the progress of an clutter_animator_key
         * @returns the progress defined for a #ClutterAnimator key.
         */
        get_progress(): number;
        /**
         * Retrieves the name of the property a key applies to.
         * @returns the name of the property an animator_key exist for.
         */
        get_property_name(): string;
        /**
         * Retrieves the #GType of the property a key applies to
         *
         * You can use this type to initialize the #GValue to pass to
         * clutter_animator_key_get_value()
         * @returns the #GType of the property
         */
        get_property_type(): GObject.GType;
        /**
         * Retrieves a copy of the value for a #ClutterAnimatorKey.
         *
         * The passed in #GValue needs to be already initialized for the value
         * type of the key or to a type that allow transformation from the value
         * type of the key.
         *
         * Use g_value_unset() when done.
         * @param value a #GValue initialized with the correct type for the animator key
         * @returns %TRUE if the passed #GValue was successfully set, and   %FALSE otherwise
         */
        get_value(value: GObject.Value | any): boolean;
    }

    abstract class AnimatorPrivate {
        static $gtype: GObject.GType<AnimatorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Common members for a #ClutterEvent
     */
    class AnyEvent {
        static $gtype: GObject.GType<AnyEvent>;

        // Fields

        type: EventType;
        time: number;
        flags: EventFlags;
        stage: Stage;
        source: Actor;

        // Constructors

        _init(...args: any[]): void;
    }

    type BackendClass = typeof Backend;
    type BehaviourClass = typeof Behaviour;
    type BehaviourDepthClass = typeof BehaviourDepth;
    abstract class BehaviourDepthPrivate {
        static $gtype: GObject.GType<BehaviourDepthPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BehaviourEllipseClass = typeof BehaviourEllipse;
    abstract class BehaviourEllipsePrivate {
        static $gtype: GObject.GType<BehaviourEllipsePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BehaviourOpacityClass = typeof BehaviourOpacity;
    abstract class BehaviourOpacityPrivate {
        static $gtype: GObject.GType<BehaviourOpacityPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BehaviourPathClass = typeof BehaviourPath;
    abstract class BehaviourPathPrivate {
        static $gtype: GObject.GType<BehaviourPathPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class BehaviourPrivate {
        static $gtype: GObject.GType<BehaviourPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BehaviourRotateClass = typeof BehaviourRotate;
    abstract class BehaviourRotatePrivate {
        static $gtype: GObject.GType<BehaviourRotatePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BehaviourScaleClass = typeof BehaviourScale;
    abstract class BehaviourScalePrivate {
        static $gtype: GObject.GType<BehaviourScalePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BinLayoutClass = typeof BinLayout;
    abstract class BinLayoutPrivate {
        static $gtype: GObject.GType<BinLayoutPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BindConstraintClass = typeof BindConstraint;
    type BindingPoolClass = typeof BindingPool;
    type BlurEffectClass = typeof BlurEffect;
    type BoxClass = typeof Box;
    type BoxLayoutClass = typeof BoxLayout;
    abstract class BoxLayoutPrivate {
        static $gtype: GObject.GType<BoxLayoutPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class BoxPrivate {
        static $gtype: GObject.GType<BoxPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type BrightnessContrastEffectClass = typeof BrightnessContrastEffect;
    /**
     * Button event.
     *
     * The event coordinates are relative to the stage that received the
     * event, and can be transformed into actor-relative coordinates by
     * using clutter_actor_transform_stage_point().
     */
    class ButtonEvent {
        static $gtype: GObject.GType<ButtonEvent>;

        // Fields

        type: EventType;
        time: number;
        flags: EventFlags;
        stage: Stage;
        source: Actor;
        x: number;
        y: number;
        modifier_state: ModifierType;
        button: number;
        click_count: number;
        axes: number;
        device: InputDevice;

        // Constructors

        _init(...args: any[]): void;
    }

    type CairoTextureClass = typeof CairoTexture;
    abstract class CairoTexturePrivate {
        static $gtype: GObject.GType<CairoTexturePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type CanvasClass = typeof Canvas;
    abstract class CanvasPrivate {
        static $gtype: GObject.GType<CanvasPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ChildMetaClass = typeof ChildMeta;
    type ClickActionClass = typeof ClickAction;
    abstract class ClickActionPrivate {
        static $gtype: GObject.GType<ClickActionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ClipNodeClass = typeof ClipNode;
    type CloneClass = typeof Clone;
    abstract class ClonePrivate {
        static $gtype: GObject.GType<ClonePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Color representation.
     */
    class Color {
        static $gtype: GObject.GType<Color>;

        // Fields

        red: number;
        green: number;
        blue: number;
        alpha: number;

        // Constructors

        constructor(
            properties?: Partial<{
                red: number;
                green: number;
                blue: number;
                alpha: number;
            }>,
        );
        _init(...args: any[]): void;

        static alloc(): Color;

        static ['new'](red: number, green: number, blue: number, alpha: number): Color;

        // Static methods

        /**
         * Converts a color expressed in HLS (hue, luminance and saturation)
         * values into a #ClutterColor.
         * @param hue hue value, in the 0 .. 360 range
         * @param luminance luminance value, in the 0 .. 1 range
         * @param saturation saturation value, in the 0 .. 1 range
         */
        static from_hls(hue: number, luminance: number, saturation: number): Color;
        /**
         * Converts `pixel` from the packed representation of a four 8 bit channel
         * color to a #ClutterColor.
         * @param pixel a 32 bit packed integer containing a color
         */
        static from_pixel(pixel: number): Color;
        /**
         * Parses a string definition of a color, filling the #ClutterColor.red,
         * #ClutterColor.green, #ClutterColor.blue and #ClutterColor.alpha fields
         * of `color`.
         *
         * The `color` is not allocated.
         *
         * The format of `str` can be either one of:
         *
         *   - a standard name (as taken from the X11 rgb.txt file)
         *   - an hexadecimal value in the form: `#rgb`, `#rrggbb`, `#rgba`, or `#rrggbbaa`
         *   - a RGB color in the form: `rgb(r, g, b)`
         *   - a RGB color in the form: `rgba(r, g, b, a)`
         *   - a HSL color in the form: `hsl(h, s, l)`
         *    -a HSL color in the form: `hsla(h, s, l, a)`
         *
         * where 'r', 'g', 'b' and 'a' are (respectively) the red, green, blue color
         * intensities and the opacity. The 'h', 's' and 'l' are (respectively) the
         * hue, saturation and luminance values.
         *
         * In the rgb() and rgba() formats, the 'r', 'g', and 'b' values are either
         * integers between 0 and 255, or percentage values in the range between 0%
         * and 100%; the percentages require the '%' character. The 'a' value, if
         * specified, can only be a floating point value between 0.0 and 1.0.
         *
         * In the hls() and hlsa() formats, the 'h' value (hue) is an angle between
         * 0 and 360.0 degrees; the 'l' and 's' values (luminance and saturation) are
         * percentage values in the range between 0% and 100%. The 'a' value, if specified,
         * can only be a floating point value between 0.0 and 1.0.
         *
         * Whitespace inside the definitions is ignored; no leading whitespace
         * is allowed.
         *
         * If the alpha component is not specified then it is assumed to be set to
         * be fully opaque.
         * @param str a string specifiying a color
         */
        static from_string(str: string): [boolean, Color];
        /**
         * Retrieves a static color for the given `color` name
         *
         * Static colors are created by Clutter and are guaranteed to always be
         * available and valid
         * @param color the named global color
         */
        static get_static(color: StaticColor): Color;

        // Methods

        /**
         * Adds `a` to `b` and saves the resulting color inside `result`.
         *
         * The alpha channel of `result` is set as as the maximum value
         * between the alpha channels of `a` and `b`.
         * @param b a #ClutterColor
         */
        add(b: Color): Color;
        /**
         * Makes a copy of the color structure.  The result must be
         * freed using clutter_color_free().
         * @returns an allocated copy of @color.
         */
        copy(): Color;
        /**
         * Darkens `color` by a fixed amount, and saves the changed color
         * in `result`.
         */
        darken(): Color;
        /**
         * Compares two #ClutterColor<!-- -->s and checks if they are the same.
         *
         * This function can be passed to g_hash_table_new() as the `key_equal_func`
         * parameter, when using #ClutterColor<!-- -->s as keys in a #GHashTable.
         * @param v2 a #ClutterColor
         * @returns %TRUE if the two colors are the same.
         */
        equal(v2: Color): boolean;
        /**
         * Frees a color structure created with clutter_color_copy().
         */
        free(): void;
        /**
         * Converts a #ClutterColor to a hash value.
         *
         * This function can be passed to g_hash_table_new() as the `hash_func`
         * parameter, when using #ClutterColor<!-- -->s as keys in a #GHashTable.
         * @returns a hash value corresponding to the color
         */
        hash(): number;
        /**
         * Initializes `color` with the given values.
         * @param red red component of the color, between 0 and 255
         * @param green green component of the color, between 0 and 255
         * @param blue blue component of the color, between 0 and 255
         * @param alpha alpha component of the color, between 0 and 255
         * @returns the initialized #ClutterColor
         */
        init(red: number, green: number, blue: number, alpha: number): Color;
        /**
         * Interpolates between `initial` and `final` #ClutterColor<!-- -->s
         * using `progress`
         * @param _final the final #ClutterColor
         * @param progress the interpolation progress
         */
        interpolate(_final: Color, progress: number): Color;
        /**
         * Lightens `color` by a fixed amount, and saves the changed color
         * in `result`.
         */
        lighten(): Color;
        /**
         * Shades `color` by `factor` and saves the modified color into `result`.
         * @param factor the shade factor to apply
         */
        shade(factor: number): Color;
        /**
         * Subtracts `b` from `a` and saves the resulting color inside `result`.
         *
         * This function assumes that the components of `a` are greater than the
         * components of `b;` the result is, otherwise, undefined.
         *
         * The alpha channel of `result` is set as the minimum value
         * between the alpha channels of `a` and `b`.
         * @param b a #ClutterColor
         */
        subtract(b: Color): Color;
        /**
         * Converts `color` to the HLS format.
         *
         * The `hue` value is in the 0 .. 360 range. The `luminance` and
         * `saturation` values are in the 0 .. 1 range.
         */
        to_hls(): [number, number, number];
        /**
         * Converts `color` into a packed 32 bit integer, containing
         * all the four 8 bit channels used by #ClutterColor.
         * @returns a packed color
         */
        to_pixel(): number;
        /**
         * Returns a textual specification of `color` in the hexadecimal form
         * <literal>&num;rrggbbaa</literal>, where <literal>r</literal>,
         * <literal>g</literal>, <literal>b</literal> and <literal>a</literal> are
         * hexadecimal digits representing the red, green, blue and alpha components
         * respectively.
         * @returns a newly-allocated text string
         */
        to_string(): string;
    }

    type ColorNodeClass = typeof ColorNode;
    type ColorizeEffectClass = typeof ColorizeEffect;
    type ConstraintClass = typeof Constraint;
    type ContainerIface = typeof Container;
    type ContentIface = typeof Content;
    /**
     * Event for the movement of the pointer across different actors
     */
    class CrossingEvent {
        static $gtype: GObject.GType<CrossingEvent>;

        // Fields

        type: EventType;
        time: number;
        flags: EventFlags;
        stage: Stage;
        source: Actor;
        x: number;
        y: number;
        device: InputDevice;
        related: Actor;

        // Constructors

        _init(...args: any[]): void;
    }

    type DeformEffectClass = typeof DeformEffect;
    abstract class DeformEffectPrivate {
        static $gtype: GObject.GType<DeformEffectPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DesaturateEffectClass = typeof DesaturateEffect;
    type DeviceManagerClass = typeof DeviceManager;
    abstract class DeviceManagerPrivate {
        static $gtype: GObject.GType<DeviceManagerPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DragActionClass = typeof DragAction;
    abstract class DragActionPrivate {
        static $gtype: GObject.GType<DragActionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type DropActionClass = typeof DropAction;
    abstract class DropActionPrivate {
        static $gtype: GObject.GType<DropActionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type EffectClass = typeof Effect;
    /**
     * The #ClutterEventSequence structure is an opaque
     * type used to denote the event sequence of a touch event.
     */
    abstract class EventSequence {
        static $gtype: GObject.GType<EventSequence>;

        // Constructors

        _init(...args: any[]): void;
    }

    type FixedLayoutClass = typeof FixedLayout;
    type FlowLayoutClass = typeof FlowLayout;
    abstract class FlowLayoutPrivate {
        static $gtype: GObject.GType<FlowLayoutPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Fog settings used to create the depth cueing effect.
     */
    class Fog {
        static $gtype: GObject.GType<Fog>;

        // Fields

        z_near: number;
        z_far: number;

        // Constructors

        constructor(
            properties?: Partial<{
                z_near: number;
                z_far: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    /**
     * The rectangle containing an actor's bounding box, measured in pixels.
     *
     * You should not use #ClutterGeometry, or operate on its fields
     * directly; you should use #cairo_rectangle_int_t or #ClutterRect if you
     * need a rectangle type, depending on the precision required.
     */
    class Geometry {
        static $gtype: GObject.GType<Geometry>;

        // Fields

        x: number;
        y: number;
        width: number;
        height: number;

        // Constructors

        constructor(
            properties?: Partial<{
                x: number;
                y: number;
                width: number;
                height: number;
            }>,
        );
        _init(...args: any[]): void;

        // Methods

        /**
         * Determines if `geometry0` and geometry1 intersect returning %TRUE if
         * they do else %FALSE.
         * @param geometry1 The second geometry to test
         * @returns %TRUE of @geometry0 and geometry1 intersect else %FALSE.
         */
        intersects(geometry1: Geometry): boolean;
        /**
         * Find the union of two rectangles represented as #ClutterGeometry.
         * @param geometry_b another #ClutterGeometry
         */
        union(geometry_b: Geometry): Geometry;
    }

    type GestureActionClass = typeof GestureAction;
    abstract class GestureActionPrivate {
        static $gtype: GObject.GType<GestureActionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type GridLayoutClass = typeof GridLayout;
    abstract class GridLayoutPrivate {
        static $gtype: GObject.GType<GridLayoutPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type GroupClass = typeof Group;
    abstract class GroupPrivate {
        static $gtype: GObject.GType<GroupPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ImageClass = typeof Image;
    abstract class ImagePrivate {
        static $gtype: GObject.GType<ImagePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type InputDeviceClass = typeof InputDevice;
    type IntervalClass = typeof Interval;
    abstract class IntervalPrivate {
        static $gtype: GObject.GType<IntervalPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Key event
     */
    class KeyEvent {
        static $gtype: GObject.GType<KeyEvent>;

        // Fields

        type: EventType;
        time: number;
        flags: EventFlags;
        stage: Stage;
        source: Actor;
        modifier_state: ModifierType;
        keyval: number;
        hardware_keycode: number;
        unicode_value: string;
        device: InputDevice;

        // Constructors

        _init(...args: any[]): void;
    }

    type KeyframeTransitionClass = typeof KeyframeTransition;
    abstract class KeyframeTransitionPrivate {
        static $gtype: GObject.GType<KeyframeTransitionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Point in a path behaviour.
     */
    class Knot {
        static $gtype: GObject.GType<Knot>;

        // Fields

        x: number;
        y: number;

        // Constructors

        constructor(
            properties?: Partial<{
                x: number;
                y: number;
            }>,
        );
        _init(...args: any[]): void;

        // Methods

        /**
         * Makes an allocated copy of a knot.
         * @returns the copied knot.
         */
        copy(): Knot;
        /**
         * Compares to knot and checks if the point to the same location.
         * @param knot_b Second knot
         * @returns %TRUE if the knots point to the same location.
         */
        equal(knot_b: Knot): boolean;
        /**
         * Frees the memory of an allocated knot.
         */
        free(): void;
    }

    type LayoutManagerClass = typeof LayoutManager;
    type LayoutMetaClass = typeof LayoutMeta;
    type ListModelClass = typeof ListModel;
    abstract class ListModelPrivate {
        static $gtype: GObject.GType<ListModelPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A representation of the components of a margin.
     */
    class Margin {
        static $gtype: GObject.GType<Margin>;

        // Fields

        left: number;
        right: number;
        top: number;
        bottom: number;

        // Constructors

        constructor(
            properties?: Partial<{
                left: number;
                right: number;
                top: number;
                bottom: number;
            }>,
        );
        _init(...args: any[]): void;

        static ['new'](): Margin;

        // Methods

        /**
         * Creates a new #ClutterMargin and copies the contents of `margin_` into
         * the newly created structure.
         * @returns a copy of the #ClutterMargin.
         */
        copy(): Margin;
        /**
         * Frees the resources allocated by clutter_margin_new() and
         * clutter_margin_copy().
         */
        free(): void;
    }

    /**
     * A type representing a 4x4 matrix.
     *
     * It is identicaly to #CoglMatrix.
     */
    abstract class Matrix {
        static $gtype: GObject.GType<Matrix>;

        // Constructors

        _init(...args: any[]): void;

        // Static methods

        /**
         * Allocates enough memory to hold a #ClutterMatrix.
         */
        static alloc(): Matrix;

        // Methods

        /**
         * Frees the memory allocated by clutter_matrix_alloc().
         */
        free(): void;
        /**
         * Initializes `matrix` with the contents of a C array of floating point
         * values.
         * @param values a C array of 16 floating point values,   representing a 4x4 matrix, with column-major order
         * @returns the initialzed #ClutterMatrix
         */
        init_from_array(values: number[]): Matrix;
        /**
         * Initializes the #ClutterMatrix `a` with the contents of the
         * #ClutterMatrix `b`.
         * @param b the #ClutterMatrix to copy
         * @returns the initialized #ClutterMatrix
         */
        init_from_matrix(b: Matrix): Matrix;
        /**
         * Initializes `matrix` with the identity matrix, i.e.:
         *
         *
         * ```
         *   .xx = 1.0, .xy = 0.0, .xz = 0.0, .xw = 0.0
         *   .yx = 0.0, .yy = 1.0, .yz = 0.0, .yw = 0.0
         *   .zx = 0.0, .zy = 0.0, .zz = 1.0, .zw = 0.0
         *   .wx = 0.0, .wy = 0.0, .wz = 0.0, .ww = 1.0
         * ```
         *
         * @returns the initialized #ClutterMatrix
         */
        init_identity(): Matrix;
    }

    type MediaIface = typeof Media;
    type ModelClass = typeof Model;
    type ModelIterClass = typeof ModelIter;
    abstract class ModelIterPrivate {
        static $gtype: GObject.GType<ModelIterPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class ModelPrivate {
        static $gtype: GObject.GType<ModelPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Event for the pointer motion
     */
    class MotionEvent {
        static $gtype: GObject.GType<MotionEvent>;

        // Fields

        type: EventType;
        time: number;
        flags: EventFlags;
        stage: Stage;
        source: Actor;
        x: number;
        y: number;
        modifier_state: ModifierType;
        axes: number;
        device: InputDevice;

        // Constructors

        _init(...args: any[]): void;
    }

    type OffscreenEffectClass = typeof OffscreenEffect;
    abstract class OffscreenEffectPrivate {
        static $gtype: GObject.GType<OffscreenEffectPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type PageTurnEffectClass = typeof PageTurnEffect;
    type PaintNodeClass = typeof PaintNode;
    abstract class PaintNodePrivate {
        static $gtype: GObject.GType<PaintNodePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * #ClutterPaintVolume is an opaque structure
     * whose members cannot be directly accessed.
     *
     * A #ClutterPaintVolume represents an
     * a bounding volume whose internal representation isn't defined but
     * can be set and queried in terms of an axis aligned bounding box.
     *
     * A #ClutterPaintVolume for a #ClutterActor
     * is defined to be relative from the current actor modelview matrix.
     *
     * Other internal representation and methods for describing the
     * bounding volume may be added in the future.
     */
    abstract class PaintVolume {
        static $gtype: GObject.GType<PaintVolume>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Copies `pv` into a new #ClutterPaintVolume
         * @returns a newly allocated copy of a #ClutterPaintVolume
         */
        copy(): PaintVolume;
        /**
         * Frees the resources allocated by `pv`
         */
        free(): void;
        /**
         * Retrieves the depth of the volume's, axis aligned, bounding box.
         *
         * In other words; this takes into account what actor's coordinate
         * space `pv` belongs too and conceptually fits an axis aligned box
         * around the volume. It returns the size of that bounding box as
         * measured along the z-axis.
         *
         * If, for example, clutter_actor_get_transformed_paint_volume()
         * is used to transform a 2D child actor that is 100px wide, 100px
         * high and 0px deep into container coordinates then the depth might
         * not simply be 0px if the child actor has a 3D rotation applied to
         * it.
         *
         * Remember: if clutter_actor_get_transformed_paint_volume() is
         * used then the transformed volume will be defined relative to the
         * container actor and in container coordinates a 2D child actor
         * can have a 3D bounding volume.
         *
         * There are no accuracy guarantees for the reported depth,
         * except that it must always be greater than, or equal to, the actor's
         * depth. This is because actors may report simple, loose fitting paint
         * volumes for efficiency.
         * @returns the depth, in units of @pv's local coordinate system.
         */
        get_depth(): number;
        /**
         * Retrieves the height of the volume's, axis aligned, bounding box.
         *
         * In other words; this takes into account what actor's coordinate
         * space `pv` belongs too and conceptually fits an axis aligned box
         * around the volume. It returns the size of that bounding box as
         * measured along the y-axis.
         *
         * If, for example, clutter_actor_get_transformed_paint_volume()
         * is used to transform a 2D child actor that is 100px wide, 100px
         * high and 0px deep into container coordinates then the height might
         * not simply be 100px if the child actor has a 3D rotation applied to
         * it.
         *
         * Remember: if clutter_actor_get_transformed_paint_volume() is
         * used then a transformed child volume will be defined relative to the
         * ancestor container actor and so a 2D child actor
         * can have a 3D bounding volume.
         *
         * There are no accuracy guarantees for the reported height,
         * except that it must always be greater than, or equal to, the actor's
         * height. This is because actors may report simple, loose fitting paint
         * volumes for efficiency.
         * @returns the height, in units of @pv's local coordinate system.
         */
        get_height(): number;
        /**
         * Retrieves the origin of the #ClutterPaintVolume.
         */
        get_origin(): Vertex;
        /**
         * Retrieves the width of the volume's, axis aligned, bounding box.
         *
         * In other words; this takes into account what actor's coordinate
         * space `pv` belongs too and conceptually fits an axis aligned box
         * around the volume. It returns the size of that bounding box as
         * measured along the x-axis.
         *
         * If, for example, clutter_actor_get_transformed_paint_volume()
         * is used to transform a 2D child actor that is 100px wide, 100px
         * high and 0px deep into container coordinates then the width might
         * not simply be 100px if the child actor has a 3D rotation applied to
         * it.
         *
         * Remember: if clutter_actor_get_transformed_paint_volume() is
         * used then a transformed child volume will be defined relative to the
         * ancestor container actor and so a 2D child actor can have a 3D
         * bounding volume.
         *
         * There are no accuracy guarantees for the reported width,
         * except that it must always be greater than, or equal to, the
         * actor's width. This is because actors may report simple, loose
         * fitting paint volumes for efficiency.
         * @returns the width, in units of @pv's local coordinate system.
         */
        get_width(): number;
        /**
         * Sets the depth of the paint volume. The depth is measured along
         * the z axis in the actor coordinates that `pv` is associated with.
         * @param depth the depth of the paint volume, in pixels
         */
        set_depth(depth: number): void;
        /**
         * Sets the #ClutterPaintVolume from the allocation of `actor`.
         *
         * This function should be used when overriding the
         * #ClutterActorClass.get_paint_volume() by #ClutterActor sub-classes
         * that do not paint outside their allocation.
         *
         * A typical example is:
         *
         *
         * ```
         * static gboolean
         * my_actor_get_paint_volume (ClutterActor       *self,
         *                            ClutterPaintVolume *volume)
         * {
         *   return clutter_paint_volume_set_from_allocation (volume, self);
         * }
         * ```
         *
         * @param actor a #ClutterActor
         * @returns %TRUE if the paint volume was successfully set, and %FALSE   otherwise
         */
        set_from_allocation(actor: Actor): boolean;
        /**
         * Sets the height of the paint volume. The height is measured along
         * the y axis in the actor coordinates that `pv` is associated with.
         * @param height the height of the paint volume, in pixels
         */
        set_height(height: number): void;
        /**
         * Sets the origin of the paint volume.
         *
         * The origin is defined as the X, Y and Z coordinates of the top-left
         * corner of an actor's paint volume, in actor coordinates.
         *
         * The default is origin is assumed at: (0, 0, 0)
         * @param origin a #ClutterVertex
         */
        set_origin(origin: Vertex): void;
        /**
         * Sets the width of the paint volume. The width is measured along
         * the x axis in the actor coordinates that `pv` is associated with.
         * @param width the width of the paint volume, in pixels
         */
        set_width(width: number): void;
        /**
         * Updates the geometry of `pv` to encompass `pv` and `another_pv`.
         *
         * There are no guarantees about how precisely the two volumes
         * will be unioned.
         * @param another_pv A second #ClutterPaintVolume to union with @pv
         */
        union(another_pv: PaintVolume): void;
        /**
         * Unions the 2D region represented by `box` to a #ClutterPaintVolume.
         *
         * This function is similar to clutter_paint_volume_union(), but it is
         * specific for 2D regions.
         * @param box a #ClutterActorBox to union to @pv
         */
        union_box(box: ActorBox): void;
    }

    type PanActionClass = typeof PanAction;
    abstract class PanActionPrivate {
        static $gtype: GObject.GType<PanActionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type PathClass = typeof Path;
    type PathConstraintClass = typeof PathConstraint;
    /**
     * Represents a single node of a #ClutterPath.
     *
     * Some of the coordinates in `points` may be unused for some node
     * types. %CLUTTER_PATH_MOVE_TO and %CLUTTER_PATH_LINE_TO use only one
     * pair of coordinates, %CLUTTER_PATH_CURVE_TO uses all three and
     * %CLUTTER_PATH_CLOSE uses none.
     */
    class PathNode {
        static $gtype: GObject.GType<PathNode>;

        // Fields

        type: PathNodeType;
        points: Knot[];

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Makes an allocated copy of a node.
         * @returns the copied node.
         */
        copy(): PathNode;
        /**
         * Compares two nodes and checks if they are the same type with the
         * same coordinates.
         * @param node_b Second node
         * @returns %TRUE if the nodes are the same.
         */
        equal(node_b: PathNode): boolean;
        /**
         * Frees the memory of an allocated node.
         */
        free(): void;
    }

    abstract class PathPrivate {
        static $gtype: GObject.GType<PathPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Stage perspective definition. #ClutterPerspective is only used by
     * the fixed point version of clutter_stage_set_perspective().
     */
    class Perspective {
        static $gtype: GObject.GType<Perspective>;

        // Fields

        fovy: number;
        aspect: number;
        z_near: number;
        z_far: number;

        // Constructors

        constructor(
            properties?: Partial<{
                fovy: number;
                aspect: number;
                z_near: number;
                z_far: number;
            }>,
        );
        _init(...args: any[]): void;
    }

    type PipelineNodeClass = typeof PipelineNode;
    /**
     * A point in 2D space.
     */
    class Point {
        static $gtype: GObject.GType<Point>;

        // Fields

        x: number;
        y: number;

        // Constructors

        constructor(
            properties?: Partial<{
                x: number;
                y: number;
            }>,
        );
        _init(...args: any[]): void;

        static alloc(): Point;

        // Static methods

        /**
         * A point centered at (0, 0).
         *
         * The returned value can be used as a guard.
         */
        static zero(): Point;

        // Methods

        /**
         * Creates a new #ClutterPoint with the same coordinates of `point`.
         * @returns a newly allocated #ClutterPoint.   Use clutter_point_free() to free its resources.
         */
        copy(): Point;
        /**
         * Computes the distance between two #ClutterPoint.
         * @param b a #ClutterPoint
         * @returns the distance between the points.
         */
        distance(b: Point): [number, number, number];
        /**
         * Compares two #ClutterPoint for equality.
         * @param b the second #ClutterPoint to compare
         * @returns %TRUE if the #ClutterPoints are equal
         */
        equals(b: Point): boolean;
        /**
         * Frees the resources allocated for `point`.
         */
        free(): void;
        /**
         * Initializes `point` with the given coordinates.
         * @param x the X coordinate of the point
         * @param y the Y coordinate of the point
         * @returns the initialized #ClutterPoint
         */
        init(x: number, y: number): Point;
    }

    type PropertyTransitionClass = typeof PropertyTransition;
    abstract class PropertyTransitionPrivate {
        static $gtype: GObject.GType<PropertyTransitionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * The location and size of a rectangle.
     *
     * The width and height of a #ClutterRect can be negative; Clutter considers
     * a rectangle with an origin of [ 0.0, 0.0 ] and a size of [ 10.0, 10.0 ] to
     * be equivalent to a rectangle with origin of [ 10.0, 10.0 ] and size of
     * [ -10.0, -10.0 ].
     *
     * Application code can normalize rectangles using clutter_rect_normalize():
     * this function will ensure that the width and height of a #ClutterRect are
     * positive values. All functions taking a #ClutterRect as an argument will
     * implicitly normalize it before computing eventual results. For this reason
     * it is safer to access the contents of a #ClutterRect by using the provided
     * API at all times, instead of directly accessing the structure members.
     */
    class Rect {
        static $gtype: GObject.GType<Rect>;

        // Fields

        origin: Point;
        size: Size;

        // Constructors

        constructor(
            properties?: Partial<{
                origin: Point;
                size: Size;
            }>,
        );
        _init(...args: any[]): void;

        static alloc(): Rect;

        // Static methods

        /**
         * A #ClutterRect with #ClutterRect.origin set at (0, 0) and a size
         * of 0.
         *
         * The returned value can be used as a guard.
         */
        static zero(): Rect;

        // Methods

        /**
         * Rounds the origin of `rect` downwards to the nearest integer, and rounds
         * the size of `rect` upwards to the nearest integer, so that `rect` is
         * updated to the smallest rectangle capable of fully containing the
         * original, fractional rectangle.
         */
        clamp_to_pixel(): void;
        /**
         * Checks whether `point` is contained by `rect,` after normalizing the
         * rectangle.
         * @param point the point to check
         * @returns %TRUE if the @point is contained by @rect.
         */
        contains_point(point: Point): boolean;
        /**
         * Checks whether `a` contains `b`.
         *
         * The first rectangle contains the second if the union of the
         * two #ClutterRect is equal to the first rectangle.
         * @param b a #ClutterRect
         * @returns %TRUE if the first rectangle contains the second.
         */
        contains_rect(b: Rect): boolean;
        /**
         * Copies `rect` into a new #ClutterRect instance.
         * @returns the newly allocate copy of @rect.   Use clutter_rect_free() to free the associated resources
         */
        copy(): Rect;
        /**
         * Checks whether `a` and `b` are equals.
         *
         * This function will normalize both `a` and `b` before comparing
         * their origin and size.
         * @param b a #ClutterRect
         * @returns %TRUE if the rectangles match in origin and size.
         */
        equals(b: Rect): boolean;
        /**
         * Frees the resources allocated by `rect`.
         */
        free(): void;
        /**
         * Retrieves the center of `rect,` after normalizing the rectangle,
         * and updates `center` with the correct coordinates.
         */
        get_center(): Point;
        /**
         * Retrieves the height of `rect`.
         * @returns the height of the rectangle
         */
        get_height(): number;
        /**
         * Retrieves the width of `rect`.
         * @returns the width of the rectangle
         */
        get_width(): number;
        /**
         * Retrieves the X coordinate of the origin of `rect`.
         * @returns the X coordinate of the origin of the rectangle
         */
        get_x(): number;
        /**
         * Retrieves the Y coordinate of the origin of `rect`.
         * @returns the Y coordinate of the origin of the rectangle
         */
        get_y(): number;
        /**
         * Initializes a #ClutterRect with the given origin and size.
         * @param x X coordinate of the origin
         * @param y Y coordinate of the origin
         * @param width width of the rectangle
         * @param height height of the rectangle
         * @returns the updated rectangle
         */
        init(x: number, y: number, width: number, height: number): Rect;
        /**
         * Normalizes the `rect` and offsets its origin by the `d_x` and `d_y` values;
         * the size is adjusted by (2 * `d_x,` 2 * `d_y)`.
         *
         * If `d_x` and `d_y` are positive the size of the rectangle is decreased; if
         * the values are negative, the size of the rectangle is increased.
         *
         * If the resulting rectangle has a negative width or height, the size is
         * set to 0.
         * @param d_x an horizontal value; a positive @d_x will create an inset rectangle,   and a negative value will create a larger rectangle
         * @param d_y a vertical value; a positive @d_x will create an inset rectangle,   and a negative value will create a larger rectangle
         */
        inset(d_x: number, d_y: number): void;
        /**
         * Computes the intersection of `a` and `b,` and places it in `res,` if `res`
         * is not %NULL.
         *
         * This function will normalize both `a` and `b` prior to computing their
         * intersection.
         *
         * This function can be used to simply check if the intersection of `a` and `b`
         * is not empty, by using %NULL for `res`.
         * @param b a #ClutterRect
         * @returns %TRUE if the intersection of @a and @b is not empty
         */
        intersection(b: Rect): [boolean, Rect | null];
        /**
         * Normalizes a #ClutterRect.
         *
         * A #ClutterRect is defined by the area covered by its size; this means
         * that a #ClutterRect with #ClutterRect.origin in [ 0, 0 ] and a
         * #ClutterRect.size of [ 10, 10 ] is equivalent to a #ClutterRect with
         * #ClutterRect.origin in [ 10, 10 ] and a #ClutterRect.size of [ -10, -10 ].
         *
         * This function is useful to ensure that a rectangle has positive width
         * and height; it will modify the passed `rect` and normalize its size.
         */
        normalize(): Rect;
        /**
         * Offsets the origin of `rect` by the given values, after normalizing
         * the rectangle.
         * @param d_x the horizontal offset value
         * @param d_y the vertical offset value
         */
        offset(d_x: number, d_y: number): void;
        /**
         * Computes the smallest possible rectangle capable of fully containing
         * both `a` and `b,` and places it into `res`.
         *
         * This function will normalize both `a` and `b` prior to computing their
         * union.
         * @param b a #ClutterRect
         */
        union(b: Rect): Rect;
    }

    type RectangleClass = typeof Rectangle;
    abstract class RectanglePrivate {
        static $gtype: GObject.GType<RectanglePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type RotateActionClass = typeof RotateAction;
    abstract class RotateActionPrivate {
        static $gtype: GObject.GType<RotateActionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ScoreClass = typeof Score;
    abstract class ScorePrivate {
        static $gtype: GObject.GType<ScorePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ScriptClass = typeof Script;
    abstract class ScriptPrivate {
        static $gtype: GObject.GType<ScriptPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type ScriptableIface = typeof Scriptable;
    type ScrollActorClass = typeof ScrollActor;
    abstract class ScrollActorPrivate {
        static $gtype: GObject.GType<ScrollActorPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Scroll wheel (or similar device) event
     */
    class ScrollEvent {
        static $gtype: GObject.GType<ScrollEvent>;

        // Fields

        type: EventType;
        time: number;
        flags: EventFlags;
        stage: Stage;
        source: Actor;
        x: number;
        y: number;
        direction: ScrollDirection;
        modifier_state: ModifierType;
        axes: number;
        device: InputDevice;
        scroll_source: ScrollSource;
        finish_flags: ScrollFinishFlags;

        // Constructors

        _init(...args: any[]): void;
    }

    type SettingsClass = typeof Settings;
    type ShaderClass = typeof Shader;
    type ShaderEffectClass = typeof ShaderEffect;
    abstract class ShaderEffectPrivate {
        static $gtype: GObject.GType<ShaderEffectPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class ShaderPrivate {
        static $gtype: GObject.GType<ShaderPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * A size, in 2D space.
     */
    class Size {
        static $gtype: GObject.GType<Size>;

        // Fields

        width: number;
        height: number;

        // Constructors

        constructor(
            properties?: Partial<{
                width: number;
                height: number;
            }>,
        );
        _init(...args: any[]): void;

        static alloc(): Size;

        // Methods

        /**
         * Creates a new #ClutterSize and duplicates `size`.
         * @returns the newly allocated #ClutterSize.   Use clutter_size_free() to free its resources.
         */
        copy(): Size;
        /**
         * Compares two #ClutterSize for equality.
         * @param b a #ClutterSize to compare
         * @returns %TRUE if the two #ClutterSize are equal
         */
        equals(b: Size): boolean;
        /**
         * Frees the resources allocated for `size`.
         */
        free(): void;
        /**
         * Initializes a #ClutterSize with the given dimensions.
         * @param width the width
         * @param height the height
         * @returns the initialized #ClutterSize
         */
        init(width: number, height: number): Size;
    }

    type SnapConstraintClass = typeof SnapConstraint;
    type StageClass = typeof Stage;
    type StageManagerClass = typeof StageManager;
    abstract class StagePrivate {
        static $gtype: GObject.GType<StagePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Event signalling a change in the #ClutterStage state.
     */
    class StageStateEvent {
        static $gtype: GObject.GType<StageStateEvent>;

        // Fields

        type: EventType;
        time: number;
        flags: EventFlags;
        stage: Stage;
        source: Actor;
        changed_mask: StageState;
        new_state: StageState;

        // Constructors

        _init(...args: any[]): void;
    }

    type StateClass = typeof State;
    /**
     * #ClutterStateKey is an opaque structure whose
     * members cannot be accessed directly
     */
    abstract class StateKey {
        static $gtype: GObject.GType<StateKey>;

        // Constructors

        _init(...args: any[]): void;

        // Methods

        /**
         * Retrieves the easing mode used for `state_key`.
         * @returns the mode of a #ClutterStateKey
         */
        get_mode(): number;
        /**
         * Retrieves the object instance this #ClutterStateKey applies to.
         * @returns the object this state key applies to.
         */
        get_object<T = GObject.Object>(): T;
        /**
         * Retrieves the duration of the pause after transitioning is complete
         * as a fraction of the total transition time.
         * @returns the post delay, used after doing the transition.
         */
        get_post_delay(): number;
        /**
         * Retrieves the pause before transitioning starts as a fraction of
         * the total transition time.
         * @returns the pre delay used before starting the transition.
         */
        get_pre_delay(): number;
        /**
         * Retrieves the name of the property this #ClutterStateKey applies to
         * @returns the name of the property. The returned string is owned   by the #ClutterStateKey and should never be modified or freed
         */
        get_property_name(): string;
        /**
         * Retrieves the #GType of the property a key applies to
         *
         * You can use this type to initialize the #GValue to pass to
         * clutter_state_key_get_value()
         * @returns the #GType of the property
         */
        get_property_type(): GObject.GType;
        /**
         * Retrieves the name of the source state of the `state_key`
         * @returns the name of the source state for this key, or %NULL   if this is the generic state key for the given property when   transitioning to the target state. The returned string is owned   by the #ClutterStateKey and should never be modified or freed
         */
        get_source_state_name(): string;
        /**
         * Get the name of the source state this #ClutterStateKey contains,
         * or NULL if this is the generic state key for the given property
         * when transitioning to the target state.
         * @returns the name of the source state for this key, or NULL if   the key is generic
         */
        get_target_state_name(): string;
        /**
         * Retrieves a copy of the value for a #ClutterStateKey.
         *
         * The #GValue needs to be already initialized for the value type
         * of the property or to a type that allow transformation from the value
         * type of the key.
         *
         * Use g_value_unset() when done.
         * @param value a #GValue initialized with the correct type for the @state_key
         * @returns %TRUE if the value was successfully retrieved,   and %FALSE otherwise
         */
        get_value(value: GObject.Value | any): boolean;
    }

    abstract class StatePrivate {
        static $gtype: GObject.GType<StatePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type SwipeActionClass = typeof SwipeAction;
    abstract class SwipeActionPrivate {
        static $gtype: GObject.GType<SwipeActionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TableLayoutClass = typeof TableLayout;
    abstract class TableLayoutPrivate {
        static $gtype: GObject.GType<TableLayoutPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TapActionClass = typeof TapAction;
    abstract class TapActionPrivate {
        static $gtype: GObject.GType<TapActionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TextBufferClass = typeof TextBuffer;
    abstract class TextBufferPrivate {
        static $gtype: GObject.GType<TextBufferPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TextClass = typeof Text;
    type TextNodeClass = typeof TextNode;
    abstract class TextPrivate {
        static $gtype: GObject.GType<TextPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TextureClass = typeof Texture;
    type TextureNodeClass = typeof TextureNode;
    abstract class TexturePrivate {
        static $gtype: GObject.GType<TexturePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    type TimelineClass = typeof Timeline;
    abstract class TimelinePrivate {
        static $gtype: GObject.GType<TimelinePrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Used for touch events.
     *
     * The `type` field will be one of %CLUTTER_TOUCH_BEGIN, %CLUTTER_TOUCH_END,
     * %CLUTTER_TOUCH_UPDATE, or %CLUTTER_TOUCH_CANCEL.
     *
     * Touch events are grouped into sequences; each touch sequence will begin
     * with a %CLUTTER_TOUCH_BEGIN event, progress with %CLUTTER_TOUCH_UPDATE
     * events, and end either with a %CLUTTER_TOUCH_END event or with a
     * %CLUTTER_TOUCH_CANCEL event.
     *
     * With multi-touch capable devices there can be multiple event sequence
     * running at the same time.
     */
    class TouchEvent {
        static $gtype: GObject.GType<TouchEvent>;

        // Fields

        type: EventType;
        time: number;
        flags: EventFlags;
        stage: Stage;
        source: Actor;
        x: number;
        y: number;
        modifier_state: ModifierType;
        axes: number;
        device: InputDevice;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Used for touchpad pinch gesture events. The current state of the
     * gesture will be determined by the `phase` field.
     *
     * Each event with phase %CLUTTER_TOUCHPAD_GESTURE_PHASE_BEGIN
     * will report a `scale` of 1.0, all later phases in the gesture
     * report the current scale relative to the initial 1.0 value
     * (eg. 0.5 being half the size, 2.0 twice as big).
     */
    class TouchpadPinchEvent {
        static $gtype: GObject.GType<TouchpadPinchEvent>;

        // Fields

        type: EventType;
        time: number;
        flags: EventFlags;
        stage: Stage;
        source: Actor;
        phase: TouchpadGesturePhase;
        x: number;
        y: number;
        dx: number;
        dy: number;
        angle_delta: number;
        scale: number;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Used for touchpad swipe gesture events. The current state of the
     * gesture will be determined by the `phase` field.
     */
    class TouchpadSwipeEvent {
        static $gtype: GObject.GType<TouchpadSwipeEvent>;

        // Fields

        type: EventType;
        time: number;
        flags: EventFlags;
        stage: Stage;
        source: Actor;
        phase: TouchpadGesturePhase;
        n_fingers: number;
        x: number;
        y: number;
        dx: number;
        dy: number;

        // Constructors

        _init(...args: any[]): void;
    }

    type TransitionClass = typeof Transition;
    type TransitionGroupClass = typeof TransitionGroup;
    abstract class TransitionGroupPrivate {
        static $gtype: GObject.GType<TransitionGroupPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    abstract class TransitionPrivate {
        static $gtype: GObject.GType<TransitionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * An opaque structure, to be used to store sizing and positioning
     * values along with their unit.
     */
    class Units {
        static $gtype: GObject.GType<Units>;

        // Constructors

        _init(...args: any[]): void;

        // Static methods

        /**
         * Stores a value in centimeters inside `units`
         * @param cm centimeters
         */
        static from_cm(cm: number): Units;
        /**
         * Stores a value in em inside `units,` using the default font
         * name as returned by clutter_backend_get_font_name()
         * @param em em
         */
        static from_em(em: number): Units;
        /**
         * Stores a value in em inside `units` using `font_name`
         * @param font_name the font name and size
         * @param em em
         */
        static from_em_for_font(font_name: string | null, em: number): Units;
        /**
         * Stores a value in millimiters inside `units`
         * @param mm millimeters
         */
        static from_mm(mm: number): Units;
        /**
         * Stores a value in pixels inside `units`
         * @param px pixels
         */
        static from_pixels(px: number): Units;
        /**
         * Stores a value in typographic points inside `units`
         * @param pt typographic points
         */
        static from_pt(pt: number): Units;
        /**
         * Parses a value and updates `units` with it
         *
         * A #ClutterUnits expressed in string should match:
         *
         *
         * ```
         *   units: wsp* unit-value wsp* unit-name? wsp*
         *   unit-value: number
         *   unit-name: 'px' | 'pt' | 'mm' | 'em' | 'cm'
         *   number: digit+
         *           | digit* sep digit+
         *   sep: '.' | ','
         *   digit: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
         *   wsp: (#0x20 | #0x9 | #0xA | #0xB | #0xC | #0xD)+
         * ```
         *
         *
         * For instance, these are valid strings:
         *
         *
         * ```
         *   10 px
         *   5.1 em
         *   24 pt
         *   12.6 mm
         *   .3 cm
         * ```
         *
         *
         * While these are not:
         *
         *
         * ```
         *   42 cats
         *   omg!1!ponies
         * ```
         *
         *
         * If no unit is specified, pixels are assumed.
         * @param str the string to convert
         */
        static from_string(str: string): [boolean, Units];

        // Methods

        /**
         * Copies `units`
         * @returns the newly created copy of a   #ClutterUnits structure. Use clutter_units_free() to free   the allocated resources
         */
        copy(): Units;
        /**
         * Frees the resources allocated by `units`
         *
         * You should only call this function on a #ClutterUnits
         * created using clutter_units_copy()
         */
        free(): void;
        /**
         * Retrieves the unit type of the value stored inside `units`
         * @returns a unit type
         */
        get_unit_type(): UnitType;
        /**
         * Retrieves the value stored inside `units`
         * @returns the value stored inside a #ClutterUnits
         */
        get_unit_value(): number;
        /**
         * Converts a value in #ClutterUnits to pixels
         * @returns the value in pixels
         */
        to_pixels(): number;
        /**
         * Converts `units` into a string
         *
         * See clutter_units_from_string() for the units syntax and for
         * examples of output
         *
         * Fractional values are truncated to the second decimal
         * position for em, mm and cm, and to the first decimal position for
         * typographic points. Pixels are integers.
         * @returns a newly allocated string containing the encoded   #ClutterUnits value. Use g_free() to free the string
         */
        to_string(): string;
    }

    /**
     * A point in 3D space, expressed in pixels
     */
    class Vertex {
        static $gtype: GObject.GType<Vertex>;

        // Fields

        x: number;
        y: number;
        z: number;

        // Constructors

        constructor(
            properties?: Partial<{
                x: number;
                y: number;
                z: number;
            }>,
        );
        _init(...args: any[]): void;

        static alloc(): Vertex;

        static ['new'](x: number, y: number, z: number): Vertex;

        // Methods

        /**
         * Copies `vertex`
         * @returns a newly allocated copy of #ClutterVertex.   Use clutter_vertex_free() to free the allocated resources
         */
        copy(): Vertex;
        /**
         * Compares `vertex_a` and `vertex_b` for equality
         * @param vertex_b a #ClutterVertex
         * @returns %TRUE if the passed #ClutterVertex are equal
         */
        equal(vertex_b: Vertex): boolean;
        /**
         * Frees a #ClutterVertex allocated using clutter_vertex_alloc() or
         * clutter_vertex_copy().
         */
        free(): void;
        /**
         * Initializes `vertex` with the given coordinates.
         * @param x X coordinate
         * @param y Y coordinate
         * @param z Z coordinate
         * @returns the initialized #ClutterVertex
         */
        init(x: number, y: number, z: number): Vertex;
    }

    type ZoomActionClass = typeof ZoomAction;
    abstract class ZoomActionPrivate {
        static $gtype: GObject.GType<ZoomActionPrivate>;

        // Constructors

        _init(...args: any[]): void;
    }

    /**
     * Generic event wrapper.
     */
    class Event {
        static $gtype: GObject.GType<Event>;

        // Constructors

        constructor(type: EventType);
        _init(...args: any[]): void;

        static ['new'](type: EventType): Event;

        // Static methods

        /**
         * Adds a function which will be called for all events that Clutter
         * processes. The function will be called before any signals are
         * emitted for the event and it will take precedence over any grabs.
         * @param stage The #ClutterStage to capture events for
         * @param func The callback function which will be passed all events.
         */
        static add_filter(stage: Stage | null, func: EventFilterFunc): number;
        /**
         * Pops an event off the event queue. Applications should not need to call
         * this.
         */
        static get(): Event;
        /**
         * Returns a pointer to the first event from the event queue but
         * does not remove it.
         */
        static peek(): Event;
        /**
         * Removes an event filter that was previously added with
         * clutter_event_add_filter().
         * @param id The ID of the event filter, as returned from clutter_event_add_filter()
         */
        static remove_filter(id: number): void;

        // Methods

        /**
         * Copies `event`.
         * @returns A newly allocated #ClutterEvent
         */
        copy(): Event;
        /**
         * Frees all resources used by `event`.
         */
        free(): void;
        /**
         * Retrieves the angle relative from `source` to `target`.
         *
         * The direction of the angle is from the position X axis towards
         * the positive Y axis.
         * @param target a #ClutterEvent
         * @returns the angle between two #ClutterEvent
         */
        get_angle(target: Event): number;
        /**
         * Retrieves the array of axes values attached to the event.
         * @returns an array of axis values
         */
        get_axes(): [number, number];
        /**
         * Retrieves the button number of `event`
         * @returns the button number
         */
        get_button(): number;
        /**
         * Retrieves the number of clicks of `event`
         * @returns the click count
         */
        get_click_count(): number;
        /**
         * Retrieves the coordinates of `event` and puts them into `x` and `y`.
         */
        get_coords(): [number, number];
        /**
         * Retrieves the #ClutterInputDevice for the event.
         * If you want the physical device the event originated from, use
         * clutter_event_get_source_device().
         *
         * The #ClutterInputDevice structure is completely opaque and should
         * be cast to the platform-specific implementation.
         * @returns the #ClutterInputDevice or %NULL. The   returned device is owned by the #ClutterEvent and it should not   be unreferenced
         */
        get_device(): InputDevice;
        /**
         * Retrieves the events device id if set.
         * @returns A unique identifier for the device or -1 if the event has   no specific device set.
         */
        get_device_id(): number;
        /**
         * Retrieves the type of the device for `event`
         * @returns the #ClutterInputDeviceType for the device, if   any is set
         */
        get_device_type(): InputDeviceType;
        /**
         * Retrieves the distance between two events, a `source` and a `target`.
         * @param target a #ClutterEvent
         * @returns the distance between two #ClutterEvent
         */
        get_distance(target: Event): number;
        /**
         * Retrieves the #ClutterEventSequence of `event`.
         * @returns the event sequence, or %NULL
         */
        get_event_sequence(): EventSequence;
        /**
         * Retrieves the #ClutterEventFlags of `event`
         * @returns the event flags
         */
        get_flags(): EventFlags;
        /**
         * Returns the gesture motion deltas relative to the current pointer
         * position.
         */
        get_gesture_motion_delta(): [number, number];
        /**
         * Returns the phase of the event, See #ClutterTouchpadGesturePhase.
         * @returns the phase of the gesture event.
         */
        get_gesture_phase(): TouchpadGesturePhase;
        /**
         * Returns the angle delta reported by this specific event.
         * @returns The angle delta relative to the previous event.
         */
        get_gesture_pinch_angle_delta(): number;
        /**
         * Returns the current scale as reported by `event,` 1.0 being the original
         * distance at the time the corresponding event with phase
         * %CLUTTER_TOUCHPAD_GESTURE_PHASE_BEGIN is received.
         * is received.
         * @returns the current pinch gesture scale
         */
        get_gesture_pinch_scale(): number;
        /**
         * Returns the number of fingers that is triggering the touchpad gesture.
         * @returns the number of fingers swiping.
         */
        get_gesture_swipe_finger_count(): number;
        /**
         * Retrieves the keycode of the key that caused `event`
         * @returns The keycode representing the key
         */
        get_key_code(): number;
        /**
         * Retrieves the key symbol of `event`
         * @returns the key symbol representing the key
         */
        get_key_symbol(): number;
        /**
         * Retrieves the unicode value for the key that caused `keyev`.
         * @returns The unicode value representing the key
         */
        get_key_unicode(): string;
        /**
         * Retrieves the event coordinates as a #ClutterPoint.
         * @param position a #ClutterPoint
         */
        get_position(position: Point): void;
        /**
         * Retrieves the related actor of a crossing event.
         * @returns the related #ClutterActor, or %NULL
         */
        get_related(): Actor;
        /**
         * Retrieves the precise scrolling information of `event`.
         *
         * The `event` has to have a #ClutterScrollEvent.direction value
         * of %CLUTTER_SCROLL_SMOOTH.
         */
        get_scroll_delta(): [number, number];
        /**
         * Retrieves the direction of the scrolling of `event`
         * @returns the scrolling direction
         */
        get_scroll_direction(): ScrollDirection;
        /**
         * Returns the #ClutterScrollFinishFlags of an scroll event. Those
         * can be used to determine whether post-scroll effects like kinetic
         * scrolling should be applied.
         * @returns The scroll finish flags
         */
        get_scroll_finish_flags(): ScrollFinishFlags;
        /**
         * Returns the #ClutterScrollSource that applies to an scroll event.
         * @returns The source of scroll events
         */
        get_scroll_source(): ScrollSource;
        /**
         * Retrieves the source #ClutterActor the event originated from, or
         * NULL if the event has no source.
         * @returns a #ClutterActor
         */
        get_source(): Actor;
        /**
         * Retrieves the hardware device that originated the event.
         *
         * If you need the virtual device, use clutter_event_get_device().
         *
         * If no hardware device originated this event, this function will
         * return the same device as clutter_event_get_device().
         * @returns a pointer to a #ClutterInputDevice   or %NULL
         */
        get_source_device(): InputDevice;
        /**
         * Retrieves the source #ClutterStage the event originated for, or
         * %NULL if the event has no stage.
         * @returns a #ClutterStage
         */
        get_stage(): Stage;
        /**
         * Retrieves the modifier state of the event. In case the window system
         * supports reporting latched and locked modifiers, this function returns
         * the effective state.
         * @returns the modifier state parameter, or 0
         */
        get_state(): ModifierType;
        /**
         * Retrieves the decomposition of the keyboard state into button, base,
         * latched, locked and effective. This can be used to transmit to other
         * applications, for example when implementing a wayland compositor.
         */
        get_state_full(): [
            ModifierType | null,
            ModifierType | null,
            ModifierType | null,
            ModifierType | null,
            ModifierType | null,
        ];
        /**
         * Retrieves the time of the event.
         * @returns the time of the event, or %CLUTTER_CURRENT_TIME
         */
        get_time(): number;
        /**
         * Checks whether `event` has the Control modifier mask set.
         * @returns %TRUE if the event has the Control modifier mask set
         */
        has_control_modifier(): boolean;
        /**
         * Checks whether `event` has the Shift modifier mask set.
         * @returns %TRUE if the event has the Shift modifier mask set
         */
        has_shift_modifier(): boolean;
        /**
         * Checks whether a pointer `event` has been generated by the windowing
         * system. The returned value can be used to distinguish between events
         * synthesized by the windowing system itself (as opposed by Clutter).
         * @returns %TRUE if the event is pointer emulated
         */
        is_pointer_emulated(): boolean;
        /**
         * Puts a copy of the event on the back of the event queue. The event will
         * have the %CLUTTER_EVENT_FLAG_SYNTHETIC flag set. If the source is set
         * event signals will be emitted for this source and capture/bubbling for
         * its ancestors. If the source is not set it will be generated by picking
         * or use the actor that currently has keyboard focus
         */
        put(): void;
        /**
         * Sets the button number of `event`
         * @param button the button number
         */
        set_button(button: number): void;
        /**
         * Sets the coordinates of the `event`.
         * @param x the X coordinate of the event
         * @param y the Y coordinate of the event
         */
        set_coords(x: number, y: number): void;
        /**
         * Sets the device for `event`.
         * @param device a #ClutterInputDevice, or %NULL
         */
        set_device(device?: InputDevice | null): void;
        /**
         * Sets the #ClutterEventFlags of `event`
         * @param flags a binary OR of #ClutterEventFlags values
         */
        set_flags(flags: EventFlags | null): void;
        /**
         * Sets the keycode of the `event`.
         * @param key_code the keycode representing the key
         */
        set_key_code(key_code: number): void;
        /**
         * Sets the key symbol of `event`.
         * @param key_sym the key symbol representing the key
         */
        set_key_symbol(key_sym: number): void;
        /**
         * Sets the Unicode value of `event`.
         * @param key_unicode the Unicode value representing the key
         */
        set_key_unicode(key_unicode: string): void;
        /**
         * Sets the related actor of a crossing event
         * @param actor a #ClutterActor or %NULL
         */
        set_related(actor?: Actor | null): void;
        /**
         * Sets the precise scrolling information of `event`.
         * @param dx delta on the horizontal axis
         * @param dy delta on the vertical axis
         */
        set_scroll_delta(dx: number, dy: number): void;
        /**
         * Sets the direction of the scrolling of `event`
         * @param direction the scrolling direction
         */
        set_scroll_direction(direction: ScrollDirection | null): void;
        /**
         * Sets the source #ClutterActor of `event`.
         * @param actor a #ClutterActor, or %NULL
         */
        set_source(actor?: Actor | null): void;
        /**
         * Sets the source #ClutterInputDevice for `event`.
         *
         * The #ClutterEvent must have been created using clutter_event_new().
         * @param device a #ClutterInputDevice
         */
        set_source_device(device?: InputDevice | null): void;
        /**
         * Sets the source #ClutterStage of the event.
         * @param stage a #ClutterStage, or %NULL
         */
        set_stage(stage?: Stage | null): void;
        /**
         * Sets the modifier state of the event.
         * @param state the modifier state to set
         */
        set_state(state: ModifierType | null): void;
        /**
         * Sets the time of the event.
         * @param time_ the time of the event
         */
        set_time(time_: number): void;
        /**
         * Retrieves the type of the event.
         * @returns a #ClutterEventType
         */
        type(): EventType;
    }

    namespace Animatable {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface AnimatableNamespace {
        $gtype: GObject.GType<Animatable>;
        prototype: Animatable;
    }
    interface Animatable extends GObject.Object {
        // Methods

        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         * @returns %TRUE if the value has been validated and can   be applied to the #ClutterAnimatable, and %FALSE otherwise
         */
        animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         * @returns The #GParamSpec for the given property   or %NULL
         */
        find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         * @returns %TRUE if the interpolation was successful,   and %FALSE otherwise
         */
        interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        set_final_state(property_name: string, value: GObject.Value | any): void;

        // Virtual methods

        /**
         * Calls the animate_property() virtual function for `animatable`.
         *
         * The `initial_value` and `final_value` #GValue<!-- -->s must contain
         * the same type; `value` must have been initialized to the same
         * type of `initial_value` and `final_value`.
         *
         * All implementation of the #ClutterAnimatable interface must
         * implement this function.
         * @param animation a #ClutterAnimation
         * @param property_name the name of the animated property
         * @param initial_value the initial value of the animation interval
         * @param final_value the final value of the animation interval
         * @param progress the progress factor
         * @param value return location for the animation value
         */
        vfunc_animate_property(
            animation: Animation,
            property_name: string,
            initial_value: GObject.Value | any,
            final_value: GObject.Value | any,
            progress: number,
            value: GObject.Value | any,
        ): boolean;
        /**
         * Finds the #GParamSpec for `property_name`
         * @param property_name the name of the animatable property to find
         */
        vfunc_find_property(property_name: string): GObject.ParamSpec;
        /**
         * Retrieves the current state of `property_name` and sets `value` with it
         * @param property_name the name of the animatable property to retrieve
         * @param value a #GValue initialized to the type of the property to retrieve
         */
        vfunc_get_initial_state(property_name: string, value: GObject.Value | any): void;
        /**
         * Asks a #ClutterAnimatable implementation to interpolate a
         * a named property between the initial and final values of
         * a #ClutterInterval, using `progress` as the interpolation
         * value, and store the result inside `value`.
         *
         * This function should be used for every property animation
         * involving #ClutterAnimatable<!-- -->s.
         *
         * This function replaces clutter_animatable_animate_property().
         * @param property_name the name of the property to interpolate
         * @param interval a #ClutterInterval with the animation range
         * @param progress the progress to use to interpolate between the   initial and final values of the @interval
         */
        vfunc_interpolate_value(property_name: string, interval: Interval, progress: number): [boolean, unknown];
        /**
         * Sets the current state of `property_name` to `value`
         * @param property_name the name of the animatable property to set
         * @param value the value of the animatable property to set
         */
        vfunc_set_final_state(property_name: string, value: GObject.Value | any): void;
    }

    export const Animatable: AnimatableNamespace & {
        new (): Animatable; // This allows `obj instanceof Animatable`
    };

    namespace Container {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ContainerNamespace {
        $gtype: GObject.GType<Container>;
        prototype: Container;

        /**
         * Looks up the #GParamSpec for a child property of `klass`.
         * @param klass a #GObjectClass implementing the #ClutterContainer interface.
         * @param property_name a property name.
         */
        class_find_child_property(klass: typeof GObject.Object, property_name: string): GObject.ParamSpec;
        /**
         * Returns an array of #GParamSpec for all child properties.
         * @param klass a #GObjectClass implementing the #ClutterContainer interface.
         */
        class_list_child_properties(klass: typeof GObject.Object): GObject.ParamSpec[];
    }
    interface Container extends GObject.Object {
        // Methods

        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        add_actor(actor: Actor): void;
        /**
         * Gets a container specific property of a child of `container,` In general,
         * a copy is made of the property contents and the caller is responsible for
         * freeing the memory by calling g_value_unset().
         *
         * Note that clutter_container_child_set_property() is really intended for
         * language bindings, clutter_container_child_set() is much more convenient
         * for C programming.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_get_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Sets a container-specific property on a child of `container`.
         * @param child a #ClutterActor that is a child of @container.
         * @param property the name of the property to set.
         * @param value the value.
         */
        child_set_property(child: Actor, property: string, value: GObject.Value | any): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        destroy_child_meta(actor: Actor): void;
        /**
         * Finds a child actor of a container by its name. Search recurses
         * into any child container.
         * @param child_name the name of the requested child.
         * @returns The child actor with the requested name,   or %NULL if no actor with that name was found.
         */
        find_child_by_name(child_name: string): Actor;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         * @returns the #ClutterChildMeta for the @actor child   of @container or %NULL if the specifiec actor does not exist or the   container is not configured to provide #ClutterChildMeta<!-- -->s
         */
        get_child_meta(actor: Actor): ChildMeta;
        /**
         * Retrieves all the children of `container`.
         * @returns a list   of #ClutterActor<!-- -->s. Use g_list_free() on the returned   list when done.
         */
        get_children(): Actor[];
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        lower_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        raise_child(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        remove_actor(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        sort_depth_order(): void;

        // Virtual methods

        vfunc_actor_added(actor: Actor): void;
        vfunc_actor_removed(actor: Actor): void;
        /**
         * Adds a #ClutterActor to `container`. This function will emit the
         * "actor-added" signal. The actor should be parented to
         * `container`. You cannot add a #ClutterActor to more than one
         * #ClutterContainer.
         *
         * This function will call #ClutterContainerIface.add(), which is a
         * deprecated virtual function. The default implementation will
         * call clutter_actor_add_child().
         * @param actor the first #ClutterActor to add
         */
        vfunc_add(actor: Actor): void;
        /**
         * Calls the #ClutterContainerIface.child_notify() virtual function
         * of #ClutterContainer. The default implementation will emit the
         * #ClutterContainer::child-notify signal.
         * @param child a #ClutterActor
         * @param pspec a #GParamSpec
         */
        vfunc_child_notify(child: Actor, pspec: GObject.ParamSpec): void;
        /**
         * Creates the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if the #ClutterContainerIface::child_meta_type
         * class member is not set to %G_TYPE_INVALID.
         *
         * This function is only useful when adding a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_create_child_meta(actor: Actor): void;
        /**
         * Destroys the #ClutterChildMeta wrapping `actor` inside the
         * `container,` if any.
         *
         * This function is only useful when removing a #ClutterActor to
         * a #ClutterContainer implementation outside of the
         * #ClutterContainer::add() virtual function implementation.
         *
         * Applications should not call this function.
         * @param actor a #ClutterActor
         */
        vfunc_destroy_child_meta(actor: Actor): void;
        /**
         * Calls `callback` for each child of `container` that was added
         * by the application (with clutter_container_add_actor()). Does
         * not iterate over "internal" children that are part of the
         * container's own implementation, if any.
         *
         * This function calls the #ClutterContainerIface.foreach()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach(callback: Callback): void;
        /**
         * Calls `callback` for each child of `container,` including "internal"
         * children built in to the container itself that were never added
         * by the application.
         *
         * This function calls the #ClutterContainerIface.foreach_with_internals()
         * virtual function, which has been deprecated.
         * @param callback a function to be called for each child
         */
        vfunc_foreach_with_internals(callback: Callback): void;
        /**
         * Retrieves the #ClutterChildMeta which contains the data about the
         * `container` specific state for `actor`.
         * @param actor a #ClutterActor that is a child of @container.
         */
        vfunc_get_child_meta(actor: Actor): ChildMeta;
        /**
         * Lowers `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.lower() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_below_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to lower to, or %NULL to lower   to the bottom
         */
        vfunc_lower(actor: Actor, sibling?: Actor | null): void;
        /**
         * Raises `actor` to `sibling` level, in the depth ordering.
         *
         * This function calls the #ClutterContainerIface.raise() virtual function,
         * which has been deprecated. The default implementation will call
         * clutter_actor_set_child_above_sibling().
         * @param actor the actor to raise
         * @param sibling the sibling to raise to, or %NULL to raise   to the top
         */
        vfunc_raise(actor: Actor, sibling?: Actor | null): void;
        /**
         * Removes `actor` from `container`. The actor should be unparented, so
         * if you want to keep it around you must hold a reference to it
         * yourself, using g_object_ref(). When the actor has been removed,
         * the "actor-removed" signal is emitted by `container`.
         *
         * This function will call #ClutterContainerIface.remove(), which is a
         * deprecated virtual function. The default implementation will call
         * clutter_actor_remove_child().
         * @param actor a #ClutterActor
         */
        vfunc_remove(actor: Actor): void;
        /**
         * Sorts a container's children using their depth. This function should not
         * be normally used by applications.
         */
        vfunc_sort_depth_order(): void;
    }

    export const Container: ContainerNamespace & {
        new (): Container; // This allows `obj instanceof Container`
    };

    namespace Content {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ContentNamespace {
        $gtype: GObject.GType<Content>;
        prototype: Content;
    }
    interface Content extends GObject.Object {
        // Methods

        /**
         * Retrieves the natural size of the `content,` if any.
         *
         * The natural size of a #ClutterContent is defined as the size the content
         * would have regardless of the allocation of the actor that is painting it,
         * for instance the size of an image data.
         * @returns %TRUE if the content has a preferred size, and %FALSE   otherwise
         */
        get_preferred_size(): [boolean, number, number];
        /**
         * Invalidates a #ClutterContent.
         *
         * This function should be called by #ClutterContent implementations when
         * they change the way a the content should be painted regardless of the
         * actor state.
         */
        invalidate(): void;

        // Virtual methods

        vfunc_attached(actor: Actor): void;
        vfunc_detached(actor: Actor): void;
        /**
         * Retrieves the natural size of the `content,` if any.
         *
         * The natural size of a #ClutterContent is defined as the size the content
         * would have regardless of the allocation of the actor that is painting it,
         * for instance the size of an image data.
         */
        vfunc_get_preferred_size(): [boolean, number, number];
        /**
         * Invalidates a #ClutterContent.
         *
         * This function should be called by #ClutterContent implementations when
         * they change the way a the content should be painted regardless of the
         * actor state.
         */
        vfunc_invalidate(): void;
        vfunc_paint_content(actor: Actor, node: PaintNode): void;
    }

    export const Content: ContentNamespace & {
        new (): Content; // This allows `obj instanceof Content`
    };

    namespace Media {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {
            audio_volume: number;
            audioVolume: number;
            buffer_fill: number;
            bufferFill: number;
            can_seek: boolean;
            canSeek: boolean;
            duration: number;
            playing: boolean;
            progress: number;
            subtitle_font_name: string;
            subtitleFontName: string;
            subtitle_uri: string;
            subtitleUri: string;
            uri: string;
        }
    }

    export interface MediaNamespace {
        $gtype: GObject.GType<Media>;
        prototype: Media;
    }
    interface Media extends GObject.Object {
        // Properties

        /**
         * The volume of the audio, as a normalized value between
         * 0.0 and 1.0.
         */
        get audio_volume(): number;
        set audio_volume(val: number);
        /**
         * The volume of the audio, as a normalized value between
         * 0.0 and 1.0.
         */
        get audioVolume(): number;
        set audioVolume(val: number);
        /**
         * The fill level of the buffer for the current stream,
         * as a value between 0.0 and 1.0.
         */
        get buffer_fill(): number;
        /**
         * The fill level of the buffer for the current stream,
         * as a value between 0.0 and 1.0.
         */
        get bufferFill(): number;
        /**
         * Whether the current stream is seekable.
         */
        get can_seek(): boolean;
        /**
         * Whether the current stream is seekable.
         */
        get canSeek(): boolean;
        /**
         * The duration of the current stream, in seconds
         */
        get duration(): number;
        /**
         * Whether the #ClutterMedia actor is playing.
         */
        get playing(): boolean;
        set playing(val: boolean);
        /**
         * The current progress of the playback, as a normalized
         * value between 0.0 and 1.0.
         */
        get progress(): number;
        set progress(val: number);
        /**
         * The font used to display subtitles. The font description has to
         * follow the same grammar as the one recognized by
         * pango_font_description_from_string().
         */
        get subtitle_font_name(): string;
        set subtitle_font_name(val: string);
        /**
         * The font used to display subtitles. The font description has to
         * follow the same grammar as the one recognized by
         * pango_font_description_from_string().
         */
        get subtitleFontName(): string;
        set subtitleFontName(val: string);
        /**
         * The location of a subtitle file, expressed as a valid URI.
         */
        get subtitle_uri(): string;
        set subtitle_uri(val: string);
        /**
         * The location of a subtitle file, expressed as a valid URI.
         */
        get subtitleUri(): string;
        set subtitleUri(val: string);
        /**
         * The location of a media file, expressed as a valid URI.
         */
        get uri(): string;
        set uri(val: string);

        // Methods

        /**
         * Retrieves the playback volume of `media`.
         * @returns The playback volume between 0.0 and 1.0
         */
        get_audio_volume(): number;
        /**
         * Retrieves the amount of the stream that is buffered.
         * @returns the fill level, between 0.0 and 1.0
         */
        get_buffer_fill(): number;
        /**
         * Retrieves whether `media` is seekable or not.
         * @returns %TRUE if @media can seek, %FALSE otherwise.
         */
        get_can_seek(): boolean;
        /**
         * Retrieves the duration of the media stream that `media` represents.
         * @returns the duration of the media stream, in seconds
         */
        get_duration(): number;
        /**
         * Retrieves the playing status of `media`.
         * @returns %TRUE if playing, %FALSE if stopped.
         */
        get_playing(): boolean;
        /**
         * Retrieves the playback progress of `media`.
         * @returns the playback progress, between 0.0 and 1.0
         */
        get_progress(): number;
        /**
         * Retrieves the font name currently used.
         * @returns a string containing the font name. Use g_free()   to free the returned string
         */
        get_subtitle_font_name(): string;
        /**
         * Retrieves the URI of the subtitle file in use.
         * @returns the URI of the subtitle file. Use g_free()   to free the returned string
         */
        get_subtitle_uri(): string;
        /**
         * Retrieves the URI from `media`.
         * @returns the URI of the media stream. Use g_free()   to free the returned string
         */
        get_uri(): string;
        /**
         * Sets the playback volume of `media` to `volume`.
         * @param volume the volume as a double between 0.0 and 1.0
         */
        set_audio_volume(volume: number): void;
        /**
         * Sets the source of `media` using a file path.
         * @param filename A filename
         */
        set_filename(filename: string): void;
        /**
         * Starts or stops playing of `media`.
         *
         * The implementation might be asynchronous, so the way to know whether
         * the actual playing state of the `media` is to use the #GObject::notify
         * signal on the #ClutterMedia:playing property and then retrieve the
         * current state with clutter_media_get_playing(). ClutterGstVideoTexture
         * in clutter-gst is an example of such an asynchronous implementation.
         * @param playing %TRUE to start playing
         */
        set_playing(playing: boolean): void;
        /**
         * Sets the playback progress of `media`. The `progress` is
         * a normalized value between 0.0 (begin) and 1.0 (end).
         * @param progress the progress of the playback, between 0.0 and 1.0
         */
        set_progress(progress: number): void;
        /**
         * Sets the font used by the subtitle renderer. The `font_name` string must be
         * either %NULL, which means that the default font name of the underlying
         * implementation will be used; or must follow the grammar recognized by
         * pango_font_description_from_string() like:
         *
         *
         * ```
         *   clutter_media_set_subtitle_font_name (media, "Sans 24pt");
         * ```
         *
         * @param font_name a font name, or %NULL to set the default font name
         */
        set_subtitle_font_name(font_name: string): void;
        /**
         * Sets the location of a subtitle file to display while playing `media`.
         * @param uri the URI of a subtitle file
         */
        set_subtitle_uri(uri: string): void;
        /**
         * Sets the URI of `media` to `uri`.
         * @param uri the URI of the media stream
         */
        set_uri(uri: string): void;

        // Virtual methods

        vfunc_eos(): void;
        vfunc_error(error: GLib.Error): void;
    }

    export const Media: MediaNamespace & {
        new (): Media; // This allows `obj instanceof Media`
    };

    namespace Scriptable {
        // Constructor properties interface

        interface ConstructorProps extends GObject.Object.ConstructorProps {}
    }

    export interface ScriptableNamespace {
        $gtype: GObject.GType<Scriptable>;
        prototype: Scriptable;
    }
    interface Scriptable extends GObject.Object {
        // Methods

        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         * @returns the id of the object. The returned string is owned by   the scriptable object and should never be modified of freed
         */
        get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         * @returns %TRUE if the node was successfully parsed, %FALSE otherwise.
         */
        parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        set_id(id_: string): void;

        // Virtual methods

        /**
         * Retrieves the id of `scriptable` set using clutter_scriptable_set_id().
         */
        vfunc_get_id(): string;
        /**
         * Parses the passed JSON node. The implementation must set the type
         * of the passed #GValue pointer using g_value_init().
         * @param script the #ClutterScript creating the scriptable instance
         * @param value the generic value to be set
         * @param name the name of the node
         * @param node the JSON node to be parsed
         */
        vfunc_parse_custom_node(script: Script, value: GObject.Value | any, name: string, node: Json.Node): boolean;
        /**
         * Overrides the common properties setting. The underlying virtual
         * function should be used when implementing custom properties.
         * @param script the #ClutterScript creating the scriptable instance
         * @param name the name of the property
         * @param value the value of the property
         */
        vfunc_set_custom_property(script: Script, name: string, value: GObject.Value | any): void;
        /**
         * Sets `id_` as the unique Clutter script it for this instance of
         * #ClutterScriptableIface.
         *
         * This name can be used by user interface designer applications to
         * define a unique name for an object constructable using the UI
         * definition language parsed by #ClutterScript.
         * @param id_ the #ClutterScript id of the object
         */
        vfunc_set_id(id_: string): void;
    }

    export const Scriptable: ScriptableNamespace & {
        new (): Scriptable; // This allows `obj instanceof Scriptable`
    };

    /**
     * Name of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188
     */
    const __name__: string;
    /**
     * Version of the imported GIR library
     * `see` https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189
     */
    const __version__: string;
}

export default Clutter;

// END
