/*
 * Type Definitions for node-gtk (https://github.com/romgrk/node-gtk)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in ts-for-gir itself or create a bug report on https://github.com/sammydre/ts-for-gjs
 */
/**
 * Gcr-3
 */

import type Gio from './Gio-2.0';
import type GObject from './GObject-2.0';
import type GLib from './GLib-2.0';
import type Gck from './Gck-1';

export namespace Gcr {

/**
 * The status of a built certificate chain. Will be set to
 * %GCR_CERTIFICATE_CHAIN_UNKNOWN for certificate chains that have not been
 * built.
 */
enum CertificateChainStatus {
    /**
     * The certificate chain's status is unknown.
     * When a chain is not yet built it has this status. If a chain is modified after
     * being built, it has this status.
     */
    UNKNOWN,
    /**
     * A full chain could not be loaded. The
     * chain does not end with a self-signed certificate, a trusted anchor, or a
     * pinned certificate.
     */
    INCOMPLETE,
    /**
     * The certificate chain contains a revoked
     * or otherwise explicitly distrusted certificate. The entire chain should
     * be distrusted.
     */
    DISTRUSTED,
    /**
     * The chain ends with a self-signed
     * certificate. No trust anchor was found.
     */
    SELFSIGNED,
    /**
     * The chain represents a pinned certificate. A
     * pinned certificate is an exception which trusts a given certificate
     * explicitly for a purpose and communication with a certain peer.
     */
    PINNED,
    /**
     * The chain ends with an anchored
     * certificate. The anchored certificate is not necessarily self-signed.
     */
    ANCHORED,
}
/**
 * The format of a certificate request. Currently only PKCS#10 is supported.
 */
enum CertificateRequestFormat {
    /**
     * certificate request is in PKCS#10 format
     */
    CERTIFICATE_REQUEST_PKCS10,
}
/**
 * Values responding to error codes for parsing and serializing data.
 */
enum DataError {
    /**
     * Failed to parse or serialize the data
     */
    FAILURE,
    /**
     * The data was unrecognized or unsupported
     */
    UNRECOGNIZED,
    /**
     * The operation was cancelled
     */
    CANCELLED,
    /**
     * The data was encrypted or locked and could not be unlocked.
     */
    LOCKED,
}
/**
 * The various format identifiers.
 */
enum DataFormat {
    /**
     * Represents all the formats, when enabling or disabling
     */
    ALL,
    /**
     * Not a valid format
     */
    INVALID,
    /**
     * DER encoded private key
     */
    DER_PRIVATE_KEY,
    /**
     * DER encoded RSA private key
     */
    DER_PRIVATE_KEY_RSA,
    /**
     * DER encoded DSA private key
     */
    DER_PRIVATE_KEY_DSA,
    /**
     * DER encoded EC private key
     */
    DER_PRIVATE_KEY_EC,
    /**
     * DER encoded SubjectPublicKeyInfo
     */
    DER_SUBJECT_PUBLIC_KEY,
    /**
     * DER encoded X.509 certificate
     */
    DER_CERTIFICATE_X509,
    /**
     * DER encoded PKCS#7 container file which can contain certificates
     */
    DER_PKCS7,
    /**
     * DER encoded PKCS#8 file which can contain a key
     */
    DER_PKCS8,
    /**
     * Unencrypted DER encoded PKCS#8 file which can contain a key
     */
    DER_PKCS8_PLAIN,
    /**
     * Encrypted DER encoded PKCS#8 file which can contain a key
     */
    DER_PKCS8_ENCRYPTED,
    /**
     * DER encoded PKCS#10 certificate request file
     */
    DER_PKCS10,
    /**
     * DER encoded SPKAC as generated by HTML5 keygen element
     */
    DER_SPKAC,
    /**
     * OpenSSL style SPKAC data
     */
    BASE64_SPKAC,
    /**
     * DER encoded PKCS#12 file which can contain certificates and/or keys
     */
    DER_PKCS12,
    /**
     * OpenSSH v1 or v2 public key
     */
    OPENSSH_PUBLIC,
    /**
     * OpenPGP key packet(s)
     */
    OPENPGP_PACKET,
    /**
     * OpenPGP public or private key armor encoded data
     */
    OPENPGP_ARMOR,
    /**
     * An OpenSSL style PEM file with unspecified contents
     */
    PEM,
    /**
     * An OpenSSL style PEM file with a private RSA key
     */
    PEM_PRIVATE_KEY_RSA,
    /**
     * An OpenSSL style PEM file with a private DSA key
     */
    PEM_PRIVATE_KEY_DSA,
    /**
     * An OpenSSL style PEM file with an X.509 certificate
     */
    PEM_CERTIFICATE_X509,
    /**
     * An OpenSSL style PEM file containing PKCS#7
     */
    PEM_PKCS7,
    /**
     * Unencrypted OpenSSL style PEM file containing PKCS#8
     */
    PEM_PKCS8_PLAIN,
    /**
     * Encrypted OpenSSL style PEM file containing PKCS#8
     */
    PEM_PKCS8_ENCRYPTED,
    /**
     * An OpenSSL style PEM file containing PKCS#12
     */
    PEM_PKCS12,
    /**
     * An OpenSSL style PEM file with a private key
     */
    PEM_PRIVATE_KEY,
    /**
     * An OpenSSL style PEM file containing PKCS#10
     */
    PEM_PKCS10,
    /**
     * An OpenSSL style PEM file with a private EC key
     */
    PEM_PRIVATE_KEY_EC,
    /**
     * An OpenSSL style PEM file containing a SubjectPublicKeyInfo
     */
    PEM_PUBLIC_KEY,
}
/**
 * Various replies returned by [method`Prompt`.confirm] and friends.
 */
enum PromptReply {
    /**
     * the prompt was cancelled
     */
    CANCEL,
    /**
     * the user replied with 'ok'
     */
    CONTINUE,
}
/**
 * No error returned by the #GcrSystemPrompt is suitable for display or
 * to the user.
 * 
 * If the system prompter can only show one prompt at a time, and there is
 * already a prompt being displayed, and the timeout waiting to open the
 * prompt expires, then %GCR_SYSTEM_PROMPT_IN_PROGRESS is returned.
 */
enum SystemPromptError {
    /**
     * another prompt is already in progress
     */
    SYSTEM_PROMPT_IN_PROGRESS,
}
/**
 * The mode for the system prompter. Most system prompters can only show
 * one prompt at a time and would use the %GCR_SYSTEM_PROMPTER_SINGLE mode.
 */
enum SystemPrompterMode {
    /**
     * only one prompt shown at a time
     */
    SINGLE,
    /**
     * more than one prompt shown at a time
     */
    MULTIPLE,
}
/**
 * Flags to be used with the gcr_certificate_chain_build() operation.
 */
enum CertificateChainFlags {
    /**
     * no flags
     */
    NONE,
    /**
     * If this flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11.
     */
    NO_LOOKUPS,
}
enum ColumnFlags {
    NONE,
    HIDDEN,
    SORTABLE,
}
const ICON_CERTIFICATE: string
const ICON_GNUPG: string
const ICON_HOME_DIRECTORY: string
const ICON_KEY: string
const ICON_KEY_PAIR: string
const ICON_PASSWORD: string
const ICON_SMART_CARD: string
/**
 * The major version number of the Gcr library.
 */
const MAJOR_VERSION: number
/**
 * The micro version number of the Gcr library.
 */
const MICRO_VERSION: number
/**
 * The minor version number of the Gcr library.
 */
const MINOR_VERSION: number
/**
 * The purpose used to verify the client certificate in a TLS connection.
 */
const PURPOSE_CLIENT_AUTH: string
/**
 * The purpose used to verify certificate used for the signature on signed code.
 */
const PURPOSE_CODE_SIGNING: string
/**
 * The purpose used to verify certificates that are used in email communication
 * such as S/MIME.
 */
const PURPOSE_EMAIL: string
/**
 * The purpose used to verify the server certificate in a TLS connection. This
 * is the most common purpose in use.
 */
const PURPOSE_SERVER_AUTH: string
/**
 * The current secret exchange protocol. Key agreement is done using DH with the
 * 1536 bit IKE parameter group. Keys are derived using SHA256 with HKDF. The
 * transport encryption is done with 128 bit AES.
 */
const SECRET_EXCHANGE_PROTOCOL_1: string
const UNLOCK_OPTION_ALWAYS: string
const UNLOCK_OPTION_IDLE: string
const UNLOCK_OPTION_SESSION: string
const UNLOCK_OPTION_TIMEOUT: string
function certificateCompare(first?: Comparable | null, other?: Comparable | null): number
function dataErrorGetDomain(): GLib.Quark
function fingerprintFromAttributes(attrs: Gck.Attributes, checksumType: GLib.ChecksumType): Uint8Array | null
function fingerprintFromSubjectPublicKeyInfo(keyInfo: Uint8Array, checksumType: GLib.ChecksumType): Uint8Array | null
function iconForToken(tokenInfo: Gck.TokenInfo): Gio.Icon
function importerCreateForParsed(parsed: Parsed): Importer[]
function importerQueueAndFilterForParsed(importers: Importer[], parsed: Parsed): Importer[]
function importerRegister(importerType: GObject.Type, attrs: Gck.Attributes): void
function importerRegisterWellKnown(): void
function mockPrompterDisconnect(): void
function mockPrompterExpectClose(): void
function mockPrompterExpectConfirmCancel(): void
function mockPrompterExpectPasswordCancel(): void
function mockPrompterGetDelayMsec(): number
function mockPrompterIsExpecting(): boolean
function mockPrompterIsPrompting(): boolean
function mockPrompterSetDelayMsec(delayMsec: number): void
function mockPrompterStart(): string
function mockPrompterStop(): void
function parsedUnref(parsed?: object | null): void
function pkcs11AddModule(module: Gck.Module): void
function pkcs11AddModuleFromFile(modulePath: string, unused?: object | null): boolean
function pkcs11GetModules(): Gck.Module[]
function pkcs11GetTrustLookupSlots(): Gck.Slot[]
function pkcs11GetTrustLookupUris(): string[] | null
function pkcs11GetTrustStoreSlot(): Gck.Slot | null
function pkcs11GetTrustStoreUri(): string | null
function pkcs11Initialize(cancellable?: Gio.Cancellable | null): boolean
function pkcs11InitializeAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
function pkcs11InitializeFinish(result: Gio.AsyncResult): boolean
function pkcs11SetModules(modules: Gck.Module[]): void
function pkcs11SetTrustLookupUris(pkcs11Uris?: string | null): void
function pkcs11SetTrustStoreUri(pkcs11Uri?: string | null): void
function trustAddPinnedCertificate(certificate: Certificate, purpose: string, peer: string, cancellable?: Gio.Cancellable | null): boolean
function trustAddPinnedCertificateAsync(certificate: Certificate, purpose: string, peer: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
function trustAddPinnedCertificateFinish(result: Gio.AsyncResult): boolean
function trustIsCertificateAnchored(certificate: Certificate, purpose: string, cancellable?: Gio.Cancellable | null): boolean
function trustIsCertificateAnchoredAsync(certificate: Certificate, purpose: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
function trustIsCertificateAnchoredFinish(result: Gio.AsyncResult): boolean
function trustIsCertificatePinned(certificate: Certificate, purpose: string, peer: string, cancellable?: Gio.Cancellable | null): boolean
function trustIsCertificatePinnedAsync(certificate: Certificate, purpose: string, peer: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
function trustIsCertificatePinnedFinish(result: Gio.AsyncResult): boolean
function trustRemovePinnedCertificate(certificate: Certificate, purpose: string, peer: string, cancellable?: Gio.Cancellable | null): boolean
function trustRemovePinnedCertificateAsync(certificate: Certificate, purpose: string, peer: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
function trustRemovePinnedCertificateFinish(result: Gio.AsyncResult): boolean
/**
 * A function which is called by [class`FilterCollection]` in order to determine
 * whether an object should show through the filter or not.
 */
interface FilterCollectionFunc {
    (object: GObject.Object): boolean
}
class Certificate {
    /* Properties of Gcr-3.Gcr.Certificate */
    /**
     * A readable description for this certificate
     */
    readonly description: string
    /**
     * The expiry date of the certificate
     */
    readonly expiry: GLib.Date
    /**
     * An icon representing the certificate
     */
    readonly icon: Gio.Icon
    /**
     * Common name part of the certificate issuer
     */
    readonly issuer: string
    /**
     * A readable label for this certificate.
     */
    readonly label: string
    /**
     * GLib markup to describe the certificate
     */
    readonly markup: string
    /**
     * Common name part of the certificate subject
     */
    readonly subject: string
    /* Methods of Gcr-3.Gcr.Certificate */
    /**
     * Get the basic constraints for the certificate if present. If %FALSE is
     * returned then no basic constraints are present and the `is_ca` and
     * `path_len` arguments are not changed.
     */
    getBasicConstraints(): [ /* returnType */ boolean, /* isCa */ boolean | null, /* pathLen */ number | null ]
    /**
     * Gets the raw DER data for an X.509 certificate.
     */
    getDerData(): Uint8Array
    /**
     * Get the expiry date of this certificate.
     * 
     * The #GDate returned should be freed by the caller using
     * g_date_free() when no longer required.
     */
    getExpiryDate(): GLib.Date
    /**
     * Calculate the fingerprint for this certificate.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    getFingerprint(type: GLib.ChecksumType): Uint8Array
    /**
     * Calculate the fingerprint for this certificate, and return it
     * as a hex string.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    getFingerprintHex(type: GLib.ChecksumType): string
    /**
     * Get the issued date of this certificate.
     * 
     * The #GDate returned should be freed by the caller using
     * g_date_free() when no longer required.
     */
    getIssuedDate(): GLib.Date
    /**
     * Get the common name of the issuer of this certificate.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getIssuerCn(): string
    /**
     * Get the full issuer DN of the certificate as a (mostly)
     * readable string.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getIssuerDn(): string
    /**
     * Get a name to represent the issuer of this certificate.
     * 
     * This will try to lookup the common name, orianizational unit,
     * organization in that order.
     */
    getIssuerName(): string
    /**
     * Get a part of the DN of the issuer of this certificate.
     * 
     * Examples of a `part` might be the 'OU' (organizational unit)
     * or the 'CN' (common name). Only the value of that part
     * of the DN is returned.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getIssuerPart(part: string): string | null
    /**
     * Get the raw DER data for the issuer DN of the certificate.
     * 
     * The data should be freed by using g_free() when no longer required.
     */
    getIssuerRaw(): Uint8Array
    /**
     * Get the key size in bits of the public key represented
     * by this certificate.
     */
    getKeySize(): number
    /**
     * Calculate a GMarkup string for displaying this certificate.
     */
    getMarkupText(): string
    /**
     * Get the raw binary serial number of the certificate.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    getSerialNumber(): Uint8Array
    /**
     * Get the serial number of the certificate as a hex string.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    getSerialNumberHex(): string
    /**
     * Get the common name of the subject of this certificate.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getSubjectCn(): string
    /**
     * Get the full subject DN of the certificate as a (mostly)
     * readable string.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getSubjectDn(): string
    /**
     * Get a name to represent the subject of this certificate.
     * 
     * This will try to lookup the common name, orianizational unit,
     * organization in that order.
     */
    getSubjectName(): string
    /**
     * Get a part of the DN of the subject of this certificate.
     * 
     * Examples of a `part` might be the 'OU' (organizational unit)
     * or the 'CN' (common name). Only the value of that part
     * of the DN is returned.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getSubjectPart(part: string): string | null
    /**
     * Get the raw DER data for the subject DN of the certificate.
     * 
     * The data should be freed by using g_free() when no longer required.
     */
    getSubjectRaw(): Uint8Array
    /**
     * Check if `issuer` could be the issuer of this certificate. This is done by
     * comparing the relevant subject and issuer fields. No signature check is
     * done. Proper verification of certificates must be done via a crypto
     * library.
     */
    isIssuer(issuer: Certificate): boolean
    /**
     * Implementers of the #GcrCertificate mixin should call this function to notify
     * when the certificate has changed to emit notifications on the various
     * properties.
     */
    mixinEmitNotify(): void
    /* Methods of Gcr-3.Gcr.Comparable */
    /**
     * Compare whether two objects represent the same thing. The return value can
     * also be used to sort the objects.
     */
    compare(other?: Comparable | null): number
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Compare one certificate against another. If the certificates are equal
     * then zero is returned. If one certificate is %NULL or not a certificate,
     * then a non-zero value is returned.
     * 
     * The return value is useful in a stable sort, but has no user logical
     * meaning.
     */
    static compare(first?: Comparable | null, other?: Comparable | null): number
}
class Collection {
    /* Methods of Gcr-3.Gcr.Collection */
    /**
     * Check whether the collection contains an object or not.
     */
    contains(object: GObject.Object): boolean
    /**
     * Emit the #GcrCollection::added signal for the given object. This function
     * is used by implementors of this interface.
     */
    emitAdded(object: GObject.Object): void
    /**
     * Emit the #GcrCollection::removed signal for the given object. This function
     * is used by implementors of this interface.
     */
    emitRemoved(object: GObject.Object): void
    /**
     * Get the number of objects in this collection.
     */
    getLength(): number
    /**
     * Get a list of the objects in this collection.
     */
    getObjects(): GObject.Object[]
    /* Signals of Gcr-3.Gcr.Collection */
    /**
     * This signal is emitted when an object is added to the collection.
     */
    connect(sigName: "added", callback: ((object: GObject.Object) => void)): number
    on(sigName: "added", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "added", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "added", callback: (object: GObject.Object) => void): NodeJS.EventEmitter
    emit(sigName: "added", object: GObject.Object): void
    /**
     * This signal is emitted when an object is removed from the collection.
     */
    connect(sigName: "removed", callback: ((object: GObject.Object) => void)): number
    on(sigName: "removed", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: (object: GObject.Object) => void): NodeJS.EventEmitter
    emit(sigName: "removed", object: GObject.Object): void
    static name: string
}
class Comparable {
    /* Methods of Gcr-3.Gcr.Comparable */
    /**
     * Compare whether two objects represent the same thing. The return value can
     * also be used to sort the objects.
     */
    compare(other?: Comparable | null): number
    static name: string
}
interface ImportInteraction_ConstructProps extends Gio.TlsInteraction_ConstructProps {
}
class ImportInteraction {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Gcr-3.Gcr.ImportInteraction */
    /**
     * Supplement attributes before import. This means prompting the user for
     * things like labels and the like. The needed attributes will have been passed
     * to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes. If the user or
     * cancellable cancels the operation the error should be set with %G_IO_ERROR_CANCELLED.
     */
    supplement(builder: Gck.Builder, cancellable?: Gio.Cancellable | null): Gio.TlsInteractionResult
    /**
     * Asynchronously supplement attributes before import. This means prompting the
     * user for things like labels and the like. The needed attributes will have
     * been passed to gcr_import_interaction_supplement_prep().
     * 
     * This method prompts the user and fills in the attributes.
     */
    supplementAsync(builder: Gck.Builder, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Complete operation to asynchronously supplement attributes before import.
     * 
     * If the user or cancellable cancels the operation the error should be set
     * with %G_IO_ERROR_CANCELLED.
     */
    supplementFinish(result: Gio.AsyncResult): Gio.TlsInteractionResult
    /**
     * Prepare for supplementing the given attributes before import. This means
     * prompting the user for things like labels and the like. The attributes
     * will contain attributes for values that the importer needs, either empty
     * or prefilled with suggested values.
     * 
     * This method does not prompt the user, but rather just prepares the
     * interaction that these are the attributes that are needed.
     */
    supplementPrep(builder: Gck.Builder): void
    /* Methods of Gio-2.0.Gio.TlsInteraction */
    /**
     * Run synchronous interaction to ask the user for a password. In general,
     * g_tls_interaction_invoke_ask_password() should be used instead of this
     * function.
     * 
     * Derived subclasses usually implement a password prompt, although they may
     * also choose to provide a password from elsewhere. The `password` value will
     * be filled in and then `callback` will be called. Alternatively the user may
     * abort this password request, which will usually abort the TLS connection.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     */
    askPassword(password: Gio.TlsPassword, cancellable?: Gio.Cancellable | null): Gio.TlsInteractionResult
    /**
     * Run asynchronous interaction to ask the user for a password. In general,
     * g_tls_interaction_invoke_ask_password() should be used instead of this
     * function.
     * 
     * Derived subclasses usually implement a password prompt, although they may
     * also choose to provide a password from elsewhere. The `password` value will
     * be filled in and then `callback` will be called. Alternatively the user may
     * abort this password request, which will usually abort the TLS connection.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     * 
     * Certain implementations may not support immediate cancellation.
     */
    askPasswordAsync(password: Gio.TlsPassword, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an ask password user interaction request. This should be once
     * the g_tls_interaction_ask_password_async() completion callback is called.
     * 
     * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
     * to g_tls_interaction_ask_password() will have its password filled in.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code.
     */
    askPasswordFinish(result: Gio.AsyncResult): Gio.TlsInteractionResult
    /**
     * Invoke the interaction to ask the user for a password. It invokes this
     * interaction in the main loop, specifically the #GMainContext returned by
     * g_main_context_get_thread_default() when the interaction is created. This
     * is called by called by #GTlsConnection or #GTlsDatabase to ask the user
     * for a password.
     * 
     * Derived subclasses usually implement a password prompt, although they may
     * also choose to provide a password from elsewhere. The `password` value will
     * be filled in and then `callback` will be called. Alternatively the user may
     * abort this password request, which will usually abort the TLS connection.
     * 
     * The implementation can either be a synchronous (eg: modal dialog) or an
     * asynchronous one (eg: modeless dialog). This function will take care of
     * calling which ever one correctly.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     */
    invokeAskPassword(password: Gio.TlsPassword, cancellable?: Gio.Cancellable | null): Gio.TlsInteractionResult
    /**
     * Invoke the interaction to ask the user to choose a certificate to
     * use with the connection. It invokes this interaction in the main
     * loop, specifically the #GMainContext returned by
     * g_main_context_get_thread_default() when the interaction is
     * created. This is called by called by #GTlsConnection when the peer
     * requests a certificate during the handshake.
     * 
     * Derived subclasses usually implement a certificate selector,
     * although they may also choose to provide a certificate from
     * elsewhere. Alternatively the user may abort this certificate
     * request, which may or may not abort the TLS connection.
     * 
     * The implementation can either be a synchronous (eg: modal dialog) or an
     * asynchronous one (eg: modeless dialog). This function will take care of
     * calling which ever one correctly.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     */
    invokeRequestCertificate(connection: Gio.TlsConnection, flags: Gio.TlsCertificateRequestFlags, cancellable?: Gio.Cancellable | null): Gio.TlsInteractionResult
    /**
     * Run synchronous interaction to ask the user to choose a certificate to use
     * with the connection. In general, g_tls_interaction_invoke_request_certificate()
     * should be used instead of this function.
     * 
     * Derived subclasses usually implement a certificate selector, although they may
     * also choose to provide a certificate from elsewhere. Alternatively the user may
     * abort this certificate request, which will usually abort the TLS connection.
     * 
     * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
     * passed to g_tls_interaction_request_certificate() will have had its
     * #GTlsConnection:certificate filled in.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
     * not support immediate cancellation.
     */
    requestCertificate(connection: Gio.TlsConnection, flags: Gio.TlsCertificateRequestFlags, cancellable?: Gio.Cancellable | null): Gio.TlsInteractionResult
    /**
     * Run asynchronous interaction to ask the user for a certificate to use with
     * the connection. In general, g_tls_interaction_invoke_request_certificate() should
     * be used instead of this function.
     * 
     * Derived subclasses usually implement a certificate selector, although they may
     * also choose to provide a certificate from elsewhere. `callback` will be called
     * when the operation completes. Alternatively the user may abort this certificate
     * request, which will usually abort the TLS connection.
     */
    requestCertificateAsync(connection: Gio.TlsConnection, flags: Gio.TlsCertificateRequestFlags, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Complete a request certificate user interaction request. This should be once
     * the g_tls_interaction_request_certificate_async() completion callback is called.
     * 
     * If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
     * passed to g_tls_interaction_request_certificate_async() will have had its
     * #GTlsConnection:certificate filled in.
     * 
     * If the interaction is cancelled by the cancellation object, or by the
     * user then %G_TLS_INTERACTION_FAILED will be returned with an error that
     * contains a %G_IO_ERROR_CANCELLED error code.
     */
    requestCertificateFinish(result: Gio.AsyncResult): Gio.TlsInteractionResult
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ImportInteraction_ConstructProps)
    _init (config?: ImportInteraction_ConstructProps): void
    static $gtype: GObject.Type
}
class Importer {
    /* Properties of Gcr-3.Gcr.Importer */
    /**
     * The icon for the importer.
     */
    readonly icon: Gio.Icon
    /**
     * The interaction for the importer.
     */
    interaction: Gio.TlsInteraction
    /**
     * The label for the importer.
     */
    readonly label: string
    /**
     * The URI of the location imported to.
     */
    readonly uri: string
    /* Methods of Gcr-3.Gcr.Importer */
    /**
     * Get the interaction used to prompt the user when needed by this
     * importer.
     */
    getInteraction(): Gio.TlsInteraction | null
    /**
     * Import the queued items in the importer. This call will block
     * until the operation completes.
     */
    import(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Import the queued items in the importer. This function returns immediately
     * and completes asynchronously.
     */
    importAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an asynchronous operation to import queued items.
     */
    importFinish(result: Gio.AsyncResult): boolean
    /**
     * Queues an additional item to be imported. The parsed item is represented
     * by the state of the [class`Parser]` at the time of calling this method.
     * 
     * If the parsed item is incompatible with the importer, then this will
     * fail and the item will not be queued.
     */
    queueForParsed(parsed: Parsed): boolean
    /**
     * Set the interaction used to prompt the user when needed by this
     * importer.
     */
    setInteraction(interaction: Gio.TlsInteraction): void
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Create a set of importers which can import this parsed item.
     * The parsed item is represented by the state of the GcrParser at the
     * time of calling this method.
     */
    static createForParsed(parsed: Parsed): Importer[]
    /**
     * Queues an additional item to be imported in all compattible importers
     * in the set. The parsed item is represented by the state of the #GcrParser
     * at the time of calling this method.
     * 
     * If the parsed item is incompatible with an importer, then that the item
     * will not be queued on that importer.
     */
    static queueAndFilterForParsed(importers: Importer[], parsed: Parsed): Importer[]
    /**
     * Register an importer to handle parsed items that match the given attributes.
     * 
     * If `attrs` are a floating reference, then it is consumed.
     */
    static register(importerType: GObject.Type, attrs: Gck.Attributes): void
    /**
     * Register built-in PKCS#11 and GnuPG importers.
     */
    static registerWellKnown(): void
}
class Prompt {
    /* Properties of Gcr-3.Gcr.Prompt */
    /**
     * The string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     * 
     * In X11, this will be a stringified version of the XWindow handle; in
     * Wayland this is the result of an export using the XDG foreign
     * protocol.
     */
    callerWindow: string
    /**
     * The label for the cancel button in the prompt.
     */
    cancelLabel: string
    /**
     * Whether the additional choice is chosen or not.
     * 
     * The additional choice would have been setup using #GcrPrompt:choice-label.
     */
    choiceChosen: boolean
    /**
     * The label for the additional choice.
     * 
     * If this is a non-%NULL value then an additional boolean choice will be
     * displayed by the prompt allowing the user to select or deselect it.
     * 
     * If %NULL, then no additional choice is displayed.
     * 
     * The initial value of the choice can be set with #GcrPrompt:choice-chosen.
     */
    choiceLabel: string
    /**
     * The label for the continue button in the prompt.
     */
    continueLabel: string
    /**
     * The detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * The prompt message should contain relevant information.
     */
    description: string
    /**
     * The prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     */
    message: string
    /**
     * Whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     */
    passwordNew: boolean
    /**
     * Indication of the password strength.
     * 
     * Prompts will return a zero value if the password is empty, and a value
     * greater than zero if the password has any characters.
     * 
     * This is only valid after a successful prompt for a password.
     */
    readonly passwordStrength: number
    /**
     * The title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * #GcrPrompt:message should contain relevant information.
     */
    title: string
    /**
     * A prompt warning displayed on the prompt, or %NULL for no warning.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     */
    warning: string
    /* Methods of Gcr-3.Gcr.Prompt */
    /**
     * Closes the prompt so that in can no longer be used to prompt. The various
     * prompt methods will return results as if the user dismissed the prompt.
     * 
     * The prompt may also be closed by the implementor of the prompt object.
     * 
     * This emits the [signal`Prompt:`:prompt-close] signal on the prompt object.
     */
    close(): void
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this function to
     * represent the question correctly.
     * 
     * This method will block until the a response is returned from the prompter.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     */
    confirm(cancellable?: Gio.Cancellable | null): PromptReply
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this method to
     * represent the question correctly.
     * 
     * This method will return immediately and complete asynchronously.
     */
    confirmAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to prompt for confirmation.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     */
    confirmFinish(result: Gio.AsyncResult): PromptReply
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this function to
     * represent the question correctly.
     * 
     * This method will block until the a response is returned from the prompter
     * and will run a main loop similar to a `gtk_dialog_run()`. The application
     * will remain responsive but care must be taken to handle reentrancy issues.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     */
    confirmRun(cancellable?: Gio.Cancellable | null): PromptReply
    /**
     * Get the string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     */
    getCallerWindow(): string
    /**
     * Get the label for the cancel button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
     * from the prompt.
     */
    getCancelLabel(): string
    /**
     * Get whether the additional choice was chosen or not.
     * 
     * The additional choice would have been setup using
     * gcr_prompt_set_choice_label().
     */
    getChoiceChosen(): boolean
    /**
     * Get the label for the additional choice.
     * 
     * This will be %NULL if no additional choice is being displayed.
     */
    getChoiceLabel(): string
    /**
     * Get the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
     * from the prompt.
     */
    getContinueLabel(): string
    /**
     * Get the detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * The prompt message should contain relevant information.
     */
    getDescription(): string
    /**
     * Gets the prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     */
    getMessage(): string
    /**
     * Get whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     */
    getPasswordNew(): boolean
    /**
     * Get indication of the password strength.
     * 
     * Prompts will return a zero value if the password is empty, and a value
     * greater than zero if the password has any characters.
     * 
     * This is only valid after a successful prompt for a password.
     */
    getPasswordStrength(): number
    /**
     * Gets the title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * prompt message should contain relevant information.
     */
    getTitle(): string
    /**
     * Get a prompt warning displayed on the prompt.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     * 
     * If this string is %NULL then no warning is displayed.
     */
    getWarning(): string
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will block until the a response is returned from the prompter.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     */
    password(cancellable?: Gio.Cancellable | null): string
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will return immediately and complete asynchronously.
     */
    passwordAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to prompt for a password.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     */
    passwordFinish(result: Gio.AsyncResult): string
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will block until the a response is returned from the prompter
     * and will run a main loop similar to a gtk_dialog_run(). The application
     * will remain responsive but care must be taken to handle reentrancy issues.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     */
    passwordRun(cancellable?: Gio.Cancellable | null): string
    /**
     * Reset the contents and properties of the prompt.
     */
    reset(): void
    /**
     * Set the string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     */
    setCallerWindow(windowId: string): void
    /**
     * Set the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
     * from the prompt.
     */
    setCancelLabel(cancelLabel: string): void
    /**
     * Set whether the additional choice is chosen or not.
     * 
     * The additional choice should be set up using gcr_prompt_set_choice_label().
     */
    setChoiceChosen(chosen: boolean): void
    /**
     * Set the label for the additional choice.
     * 
     * If this is a non-%NULL value then an additional boolean choice will be
     * displayed by the prompt allowing the user to select or deselect it.
     * 
     * The initial value of the choice can be set with the
     * gcr_prompt_set_choice_label() method.
     * 
     * If this is %NULL, then no additional choice is being displayed.
     */
    setChoiceLabel(choiceLabel?: string | null): void
    /**
     * Set the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
     * from the prompt.
     */
    setContinueLabel(continueLabel: string): void
    /**
     * Set the detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * Use gcr_prompt_set_message() to set a general message containing relevant
     * information.
     */
    setDescription(description: string): void
    /**
     * Sets the prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     */
    setMessage(message: string): void
    /**
     * Set whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     */
    setPasswordNew(newPassword: boolean): void
    /**
     * Sets the title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * prompt message should contain relevant information.
     */
    setTitle(title: string): void
    /**
     * Set a prompt warning displayed on the prompt.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     * 
     * If this string is %NULL then no warning is displayed.
     */
    setWarning(warning?: string | null): void
    /* Signals of Gcr-3.Gcr.Prompt */
    /**
     * Action signal fired when the prompt is to be closed. After the default
     * handler has run, the prompt is closed. The various prompting methods
     * will return results as if the user dismissed the prompt.
     * 
     * You can use the [method`Prompt`.close] method to emit this signal.
     */
    connect(sigName: "prompt-close", callback: (() => void)): number
    on(sigName: "prompt-close", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "prompt-close", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "prompt-close", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "prompt-close"): void
    static name: string
}
interface CertificateChain_ConstructProps extends GObject.Object_ConstructProps {
}
class CertificateChain {
    /* Properties of Gcr-3.Gcr.CertificateChain */
    /**
     * The length of the certificate chain.
     */
    readonly length: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Gcr-3.Gcr.CertificateChain */
    /**
     * Add `certificate` to the chain. The order of certificates in the chain are
     * important. The first certificate should be the endpoint certificate, and
     * then come the signers (certificate authorities) each in turn. If a root
     * certificate authority is present, it should come last.
     * 
     * Adding a certificate an already built chain (see
     * gcr_certificate_chain_build()) resets the type of the certificate chain
     * to %GCR_CERTIFICATE_CHAIN_UNKNOWN
     */
    add(certificate: Certificate): void
    /**
     * Complete a certificate chain. Once a certificate chain has been built
     * its status can be examined.
     * 
     * This operation will lookup missing certificates in PKCS#11
     * modules and also that each certificate in the chain is the signer of the
     * previous one. If a trust anchor, pinned certificate, or self-signed certificate
     * is found, then the chain is considered built. Any extra certificates are
     * removed from the chain.
     * 
     * It's important to understand that building of a certificate chain does not
     * constitute verifying that chain. This is merely the first step towards
     * trust verification.
     * 
     * The `purpose` is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
     * for which the certificate chain will be used. Trust anchors are looked up
     * for this purpose. This argument is required.
     * 
     * The `peer` is usually the host name of the peer whith which this certificate
     * chain is being used. It is used to look up pinned certificates that have
     * been stored for this peer. If %NULL then no pinned certificates will
     * be considered.
     * 
     * If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11
     * 
     * This call will block, see gcr_certificate_chain_build_async() for the
     * asynchronous version.
     */
    build(purpose: string, peer: string | null, flags: CertificateChainFlags, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Complete a certificate chain. Once a certificate chain has been built
     * its status can be examined.
     * 
     * This will lookup missing certificates in PKCS#11
     * modules and also that each certificate in the chain is the signer of the
     * previous one. If a trust anchor, pinned certificate, or self-signed certificate
     * is found, then the chain is considered built. Any extra certificates are
     * removed from the chain.
     * 
     * It's important to understand that building of a certificate chain does not
     * constitute verifying that chain. This is merely the first step towards
     * trust verification.
     * 
     * The `purpose` is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
     * for which the certificate chain will be used. Trust anchors are looked up
     * for this purpose. This argument is required.
     * 
     * The `peer` is usually the host name of the peer whith which this certificate
     * chain is being used. It is used to look up pinned certificates that have
     * been stored for this peer. If %NULL then no pinned certificates will
     * be considered.
     * 
     * If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
     * lookups for anchors or pinned certificates are done, and the resulting chain
     * will be neither anchored or pinned. Additionally no missing certificate
     * authorities are looked up in PKCS#11
     * 
     * When the operation is finished, `callback` will be called. You can then call
     * gcr_certificate_chain_build_finish() to get the result of the operation.
     */
    buildAsync(purpose: string, peer: string | null, flags: CertificateChainFlags, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an asynchronous operation started by
     * gcr_certificate_chain_build_async().
     */
    buildFinish(result: Gio.AsyncResult): boolean
    /**
     * If the certificate chain has been built and is of status
     * %GCR_CERTIFICATE_CHAIN_ANCHORED, then this will return the anchor
     * certificate that was found. This is not necessarily a root certificate
     * authority. If an intermediate certificate authority in the chain was
     * found to be anchored, then that certificate will be returned.
     * 
     * If an anchor is returned it does not mean that the certificate chain has
     * been verified, but merely that an anchor has been found.
     */
    getAnchor(): Certificate
    /**
     * Get a certificate in the chain. It is an error to call this function
     * with an invalid index.
     */
    getCertificate(index: number): Certificate
    /**
     * Get the endpoint certificate in the chain. This is always the first
     * certificate in the chain. The endpoint certificate cannot be anchored.
     */
    getEndpoint(): Certificate
    /**
     * Get the length of the certificate chain.
     */
    getLength(): number
    /**
     * Get the status of a certificate chain. If the certificate chain has not
     * been built, then the status will be %GCR_CERTIFICATE_CHAIN_UNKNOWN.
     * 
     * A status of %GCR_CERTIFICATE_CHAIN_ANCHORED does not mean that the
     * certificate chain has been verified, but merely that an anchor has been
     * found.
     */
    getStatus(): CertificateChainStatus
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::length", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::length", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::length", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: CertificateChain_ConstructProps)
    _init (config?: CertificateChain_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): CertificateChain
    static $gtype: GObject.Type
}
interface CertificateRequest_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gcr-3.Gcr.CertificateRequest */
    /**
     * The private key that this certificate request is for.
     */
    privateKey?: Gck.Object
}
class CertificateRequest {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Gcr-3.Gcr.CertificateRequest */
    /**
     * Complete and sign a certificate request, so that it can be encoded
     * and sent to a certificate authority.
     * 
     * This call may block as it signs the request using the private key.
     */
    complete(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously complete and sign a certificate request, so that it can
     * be encoded and sent to a certificate authority.
     * 
     * This call will return immediately and complete later.
     */
    completeAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finish an asynchronous operation to complete and sign a certificate
     * request.
     */
    completeFinish(result: Gio.AsyncResult): boolean
    /**
     * Encode the certificate request. It must have been completed with
     * [method`CertificateRequest`.complete] or
     * [method`CertificateRequest`.complete_async].
     * 
     * If `textual` is %FALSE, the output is a DER encoded certificate request.
     * 
     * If `textual` is %TRUE, the output is encoded as text. For PKCS#10 requests
     * this is done using the OpenSSL style PEM encoding.
     */
    encode(textual: boolean): Uint8Array
    /**
     * Get the format of this certificate request.
     */
    getFormat(): CertificateRequestFormat
    /**
     * Get the private key this certificate request is for.
     */
    getPrivateKey(): Gck.Object
    /**
     * Set the common name encoded in the certificate request.
     */
    setCn(cn: string): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: CertificateRequest_ConstructProps)
    _init (config?: CertificateRequest_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Check whether [class`CertificateRequest]` is capable of creating a request
     * for the given `private_key`.
     */
    static capable(privateKey: Gck.Object, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Asynchronously check whether [class`CertificateRequest]` is capable of
     * creating a request for the given `private_key`.
     */
    static capableAsync(privateKey: Gck.Object, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Get the result for asynchronously check whether [class`CertificateRequest]` is
     * capable of creating a request for the given `private_key`.
     */
    static capableFinish(result: Gio.AsyncResult): boolean
    /**
     * Create a new certificate request, in the given format for the private key.
     */
    static prepare(format: CertificateRequestFormat, privateKey: Gck.Object): CertificateRequest
    static $gtype: GObject.Type
}
interface FilterCollection_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gcr-3.Gcr.FilterCollection */
    underlying?: Collection
}
class FilterCollection {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Gcr-3.Gcr.FilterCollection */
    /**
     * Get the collection that is being filtered by this filter collection.
     */
    getUnderlying(): Collection
    /**
     * Refilter all objects in the underlying collection. Call this function if
     * the filter callback function changes its filtering criteria.
     */
    refilter(): void
    /**
     * Set the callback used to filter the objects in the underlying collection.
     * The callback should return %TRUE if an object should appear in the
     * filtered collection.
     * 
     * If a %NULL callback is set, then all underlynig objects will appear in the
     * filtered collection.
     * 
     * This will refilter the collection.
     */
    setCallback(callback: FilterCollectionFunc | null): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Gcr-3.Gcr.Collection */
    /**
     * Check whether the collection contains an object or not.
     */
    contains(object: GObject.Object): boolean
    /**
     * Emit the #GcrCollection::added signal for the given object. This function
     * is used by implementors of this interface.
     */
    emitAdded(object: GObject.Object): void
    /**
     * Emit the #GcrCollection::removed signal for the given object. This function
     * is used by implementors of this interface.
     */
    emitRemoved(object: GObject.Object): void
    /**
     * Get the number of objects in this collection.
     */
    getLength(): number
    /**
     * Get a list of the objects in this collection.
     */
    getObjects(): GObject.Object[]
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gcr-3.Gcr.Collection */
    /**
     * This signal is emitted when an object is added to the collection.
     */
    connect(sigName: "added", callback: ((object: GObject.Object) => void)): number
    on(sigName: "added", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "added", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "added", callback: (object: GObject.Object) => void): NodeJS.EventEmitter
    emit(sigName: "added", object: GObject.Object): void
    /**
     * This signal is emitted when an object is removed from the collection.
     */
    connect(sigName: "removed", callback: ((object: GObject.Object) => void)): number
    on(sigName: "removed", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: (object: GObject.Object) => void): NodeJS.EventEmitter
    emit(sigName: "removed", object: GObject.Object): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: FilterCollection_ConstructProps)
    _init (config?: FilterCollection_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static newWithCallback(underlying: Collection, callback: FilterCollectionFunc | null): FilterCollection
    static $gtype: GObject.Type
}
interface Parser_ConstructProps extends GObject.Object_ConstructProps {
}
class Parser {
    /* Properties of Gcr-3.Gcr.Parser */
    /**
     * Get the attributes that make up the currently parsed item. This is
     * generally only valid during a #GcrParser::parsed signal.
     */
    readonly parsedAttributes: Gck.Attributes
    /**
     * The description of the type of the currently parsed item. This is generally
     * only valid during a #GcrParser::parsed signal.
     */
    readonly parsedDescription: string
    /**
     * The label of the currently parsed item. This is generally
     * only valid during a #GcrParser::parsed signal.
     */
    readonly parsedLabel: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Gcr-3.Gcr.Parser */
    /**
     * Add a password to the set of passwords to try when parsing locked or encrypted
     * items. This is usually called from the #GcrParser::authenticate signal.
     */
    addPassword(password?: string | null): void
    /**
     * Disable parsing of the given format. Use %GCR_FORMAT_ALL to disable all the formats.
     */
    formatDisable(format: DataFormat): void
    /**
     * Enable parsing of the given format. Use %GCR_FORMAT_ALL to enable all the formats.
     */
    formatEnable(format: DataFormat): void
    /**
     * Check whether the given format is supported by the parser.
     */
    formatSupported(format: DataFormat): boolean
    /**
     * Get the filename of the parser item.
     */
    getFilename(): string
    /**
     * Get the currently parsed item
     */
    getParsed(): Parsed
    /**
     * Get the attributes which make up the currently parsed item. This is generally
     * only valid during the #GcrParser::parsed signal.
     */
    getParsedAttributes(): Gck.Attributes | null
    /**
     * Get the raw data block that represents this parsed object. This is only
     * valid during the #GcrParser::parsed signal.
     */
    getParsedBlock(): Uint8Array | null
    /**
     * Get the raw data block that represents this parsed object. This is only
     * valid during the #GcrParser::parsed signal.
     */
    getParsedBytes(): any
    /**
     * Get a description for the type of the currently parsed item. This is generally
     * only valid during the #GcrParser::parsed signal.
     */
    getParsedDescription(): string | null
    /**
     * Get the format of the raw data block that represents this parsed object.
     * This corresponds with the data returned from gcr_parser_get_parsed_block().
     * 
     * This is only valid during the #GcrParser::parsed signal.
     */
    getParsedFormat(): DataFormat
    /**
     * Get the label of the currently parsed item. This is generally only valid
     * during the #GcrParser::parsed signal.
     */
    getParsedLabel(): string | null
    /**
     * Parse the data. The #GcrParser::parsed and #GcrParser::authenticate signals
     * may fire during the parsing.
     */
    parseBytes(data: any): boolean
    /**
     * Parse the data. The #GcrParser::parsed and #GcrParser::authenticate signals
     * may fire during the parsing.
     * 
     * A copy of the data will be made. Use gcr_parser_parse_bytes() to avoid this.
     */
    parseData(data: Uint8Array): boolean
    /**
     * Parse items from the data in a #GInputStream. This function may block while
     * reading from the input stream. Use gcr_parser_parse_stream_async() for
     * a non-blocking variant.
     * 
     * The #GcrParser::parsed and #GcrParser::authenticate signals
     * may fire during the parsing.
     */
    parseStream(input: Gio.InputStream, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Parse items from the data in a #GInputStream. This function completes
     * asyncronously and doesn't block.
     * 
     * The #GcrParser::parsed and #GcrParser::authenticate signals
     * may fire during the parsing.
     */
    parseStreamAsync(input: Gio.InputStream, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to parse a stream.
     */
    parseStreamFinish(result: Gio.AsyncResult): boolean
    /**
     * Sets the filename of the parser item.
     */
    setFilename(filename?: string | null): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Gcr-3.Gcr.Parser */
    /**
     * This signal is emitted when an item needs to be unlocked or decrypted before
     * it can be parsed. The `count` argument specifies the number of times
     * the signal has been emitted for a given item. This can be used to
     * display a message saying the previous password was incorrect.
     * 
     * Typically the gcr_parser_add_password() function is called in
     * response to this signal.
     * 
     * If %FALSE is returned, then the authentication was not handled. If
     * no handlers return %TRUE then the item is not parsed and an error
     * with the code %GCR_ERROR_CANCELLED will be raised.
     */
    connect(sigName: "authenticate", callback: ((count: number) => boolean)): number
    on(sigName: "authenticate", callback: (count: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "authenticate", callback: (count: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "authenticate", callback: (count: number) => void): NodeJS.EventEmitter
    emit(sigName: "authenticate", count: number): void
    /**
     * This signal is emitted when an item is sucessfully parsed. To access
     * the information about the item use the gcr_parser_get_parsed_label(),
     * gcr_parser_get_parsed_attributes() and gcr_parser_get_parsed_description()
     * functions.
     */
    connect(sigName: "parsed", callback: (() => void)): number
    on(sigName: "parsed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "parsed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "parsed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "parsed"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::parsed-attributes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parsed-attributes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::parsed-attributes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::parsed-attributes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::parsed-attributes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::parsed-description", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parsed-description", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::parsed-description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::parsed-description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::parsed-description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::parsed-label", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parsed-label", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::parsed-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::parsed-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::parsed-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Parser_ConstructProps)
    _init (config?: Parser_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): Parser
    static $gtype: GObject.Type
}
interface Pkcs11Certificate_ConstructProps extends Gck.Object_ConstructProps {
    /* Constructor properties of Gcr-3.Gcr.Pkcs11Certificate */
    /**
     * Automatically loaded attributes for this certificate.
     */
    attributes?: Gck.Attributes
}
class Pkcs11Certificate {
    /* Properties of Gcr-3.Gcr.Certificate */
    /**
     * A readable description for this certificate
     */
    readonly description: string
    /**
     * The expiry date of the certificate
     */
    readonly expiry: GLib.Date
    /**
     * An icon representing the certificate
     */
    readonly icon: Gio.Icon
    /**
     * Common name part of the certificate issuer
     */
    readonly issuer: string
    /**
     * A readable label for this certificate.
     */
    readonly label: string
    /**
     * GLib markup to describe the certificate
     */
    readonly markup: string
    /**
     * Common name part of the certificate subject
     */
    readonly subject: string
    /* Fields of Gck-1.Gck.Object */
    readonly parent: GObject.Object
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Gcr-3.Gcr.Pkcs11Certificate */
    /**
     * Access the automatically loaded attributes for this certificate.
     */
    getAttributes(): Gck.Attributes
    /* Methods of Gck-1.Gck.Object */
    /**
     * Lookup attributes in the cache, or retrieve them from the object if necessary.
     * 
     * If `object` is a #GckObjectCache then this will lookup the attributes there
     * first if available, otherwise will read them from the object and update
     * the cache.
     * 
     * If `object` is not a #GckObjectCache, then the attributes will simply be
     * read from the object.
     * 
     * This may block, use the asynchronous version when this is not desirable
     */
    cacheLookup(attrTypes: number[], cancellable?: Gio.Cancellable | null): Gck.Attributes
    /**
     * Lookup attributes in the cache, or retrieve them from the object if necessary.
     * 
     * If `object` is a #GckObjectCache then this will lookup the attributes there
     * first if available, otherwise will read them from the object and update
     * the cache.
     * 
     * If `object` is not a #GckObjectCache, then the attributes will simply be
     * read from the object.
     * 
     * This will return immediately and complete asynchronously
     */
    cacheLookupAsync(attrTypes: number[], cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to lookup attributes in the cache or retrieve them
     * from the object if necessary.
     */
    cacheLookupFinish(result: Gio.AsyncResult): Gck.Attributes
    /**
     * Destroy a PKCS#11 object, deleting it from storage or the session.
     * This call may block for an indefinite period.
     */
    destroy(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Destroy a PKCS#11 object, deleting it from storage or the session.
     * This call will return immediately and complete asynchronously.
     */
    destroyAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Get the status of the operation to destroy a PKCS#11 object, begun with
     * gck_object_destroy_async().
     */
    destroyFinish(result: Gio.AsyncResult): boolean
    /**
     * Checks equality of two objects. Two GckObject objects can point to the same
     * underlying PKCS#11 object.
     */
    equal(object2: Gck.Object): boolean
    /**
     * Get the specified attributes from the object. The attributes will be cleared
     * of their current values, and new attributes will be stored. The attributes
     * should not be accessed in any way except for referencing and unreferencing
     * them until gck_object_get_finish() is called.
     * 
     * This call returns immediately and completes asynchronously.
     */
    getAsync(attrTypes: number[], cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Get the data for the specified attribute from the object. For convenience
     * the returned data has a null terminator.
     * 
     * This call may block for an indefinite period.
     */
    getData(attrType: number, cancellable?: Gio.Cancellable | null): Uint8Array
    /**
     * Get the data for the specified attribute from the object.
     * 
     * This call will return immediately and complete asynchronously.
     */
    getDataAsync(attrType: number, allocator: Gck.Allocator, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Get the result of an operation to get attribute data from
     * an object. For convenience the returned data has an extra null terminator,
     * not included in the returned length.
     */
    getDataFinish(result: Gio.AsyncResult): Uint8Array
    /**
     * Get the result of a get operation and return specified attributes from
     * the object.
     * 
     * No extra references are added to the returned attributes pointer.
     */
    getFinish(result: Gio.AsyncResult): Gck.Attributes
    /**
     * Get the specified attributes from the object. This call may
     * block for an indefinite period.
     * 
     * No extra references are added to the returned attributes pointer.
     * During this call you may not access the attributes in any way.
     */
    getFull(attrTypes: number[], cancellable?: Gio.Cancellable | null): Gck.Attributes
    /**
     * Get the raw PKCS#11 handle of a GckObject.
     */
    getHandle(): number
    /**
     * Get the PKCS#11 module to which this object belongs.
     */
    getModule(): Gck.Module
    /**
     * Get the PKCS#11 session assigned to make calls on when operating
     * on this object.
     * 
     * This will only return a session if it was set explitly on this
     * object. By default an object will open and close sessions
     * appropriate for its calls.
     */
    getSession(): Gck.Session
    /**
     * Get an attribute template from the object. The attr_type must be for
     * an attribute which returns a template.
     * 
     * This call may block for an indefinite period.
     */
    getTemplate(attrType: number, cancellable?: Gio.Cancellable | null): Gck.Attributes
    /**
     * Get an attribute template from the object. The `attr_type` must be for
     * an attribute which returns a template.
     * 
     * This call will return immediately and complete asynchronously.
     */
    getTemplateAsync(attrType: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Get the result of an operation to get attribute template from
     * an object.
     */
    getTemplateFinish(result: Gio.AsyncResult): Gck.Attributes
    /**
     * Create a hash value for the GckObject.
     * 
     * This function is intended for easily hashing a GckObject to add to
     * a GHashTable or similar data structure.
     */
    hash(): number
    /**
     * Set PKCS#11 attributes on an object. This call may block for an indefinite period.
     * 
     * If the `attrs` #GckAttributes is floating, it is consumed.
     */
    set(attrs: Gck.Attributes, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Set PKCS#11 attributes on an object. This call will return
     * immediately and completes asynchronously.
     * 
     * If the `attrs` #GckAttributes is floating, it is consumed.
     */
    setAsync(attrs: Gck.Attributes, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Get the status of the operation to set attributes on a PKCS#11 object,
     * begun with gck_object_set_async().
     */
    setFinish(result: Gio.AsyncResult): boolean
    /**
     * Set an attribute template on the object. The attr_type must be for
     * an attribute which contains a template.
     * 
     * If the `attrs` #GckAttributes is floating, it is consumed.
     * 
     * This call may block for an indefinite period.
     */
    setTemplate(attrType: number, attrs: Gck.Attributes, cancellable?: Gio.Cancellable | null): boolean
    /**
     * Set an attribute template on the object. The attr_type must be for
     * an attribute which contains a template.
     * 
     * If the `attrs` #GckAttributes is floating, it is consumed.
     * 
     * This call will return immediately and complete asynchronously.
     */
    setTemplateAsync(attrType: number, attrs: Gck.Attributes, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Get the result of an operation to set attribute template on
     * an object.
     */
    setTemplateFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Gcr-3.Gcr.Certificate */
    /**
     * Get the basic constraints for the certificate if present. If %FALSE is
     * returned then no basic constraints are present and the `is_ca` and
     * `path_len` arguments are not changed.
     */
    getBasicConstraints(): [ /* returnType */ boolean, /* isCa */ boolean | null, /* pathLen */ number | null ]
    /**
     * Gets the raw DER data for an X.509 certificate.
     */
    getDerData(): Uint8Array
    /**
     * Get the expiry date of this certificate.
     * 
     * The #GDate returned should be freed by the caller using
     * g_date_free() when no longer required.
     */
    getExpiryDate(): GLib.Date
    /**
     * Calculate the fingerprint for this certificate.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    getFingerprint(type: GLib.ChecksumType): Uint8Array
    /**
     * Calculate the fingerprint for this certificate, and return it
     * as a hex string.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    getFingerprintHex(type: GLib.ChecksumType): string
    /**
     * Get the issued date of this certificate.
     * 
     * The #GDate returned should be freed by the caller using
     * g_date_free() when no longer required.
     */
    getIssuedDate(): GLib.Date
    /**
     * Get the common name of the issuer of this certificate.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getIssuerCn(): string
    /**
     * Get the full issuer DN of the certificate as a (mostly)
     * readable string.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getIssuerDn(): string
    /**
     * Get a name to represent the issuer of this certificate.
     * 
     * This will try to lookup the common name, orianizational unit,
     * organization in that order.
     */
    getIssuerName(): string
    /**
     * Get a part of the DN of the issuer of this certificate.
     * 
     * Examples of a `part` might be the 'OU' (organizational unit)
     * or the 'CN' (common name). Only the value of that part
     * of the DN is returned.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getIssuerPart(part: string): string | null
    /**
     * Get the raw DER data for the issuer DN of the certificate.
     * 
     * The data should be freed by using g_free() when no longer required.
     */
    getIssuerRaw(): Uint8Array
    /**
     * Get the key size in bits of the public key represented
     * by this certificate.
     */
    getKeySize(): number
    /**
     * Calculate a GMarkup string for displaying this certificate.
     */
    getMarkupText(): string
    /**
     * Get the raw binary serial number of the certificate.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    getSerialNumber(): Uint8Array
    /**
     * Get the serial number of the certificate as a hex string.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    getSerialNumberHex(): string
    /**
     * Get the common name of the subject of this certificate.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getSubjectCn(): string
    /**
     * Get the full subject DN of the certificate as a (mostly)
     * readable string.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getSubjectDn(): string
    /**
     * Get a name to represent the subject of this certificate.
     * 
     * This will try to lookup the common name, orianizational unit,
     * organization in that order.
     */
    getSubjectName(): string
    /**
     * Get a part of the DN of the subject of this certificate.
     * 
     * Examples of a `part` might be the 'OU' (organizational unit)
     * or the 'CN' (common name). Only the value of that part
     * of the DN is returned.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getSubjectPart(part: string): string | null
    /**
     * Get the raw DER data for the subject DN of the certificate.
     * 
     * The data should be freed by using g_free() when no longer required.
     */
    getSubjectRaw(): Uint8Array
    /**
     * Check if `issuer` could be the issuer of this certificate. This is done by
     * comparing the relevant subject and issuer fields. No signature check is
     * done. Proper verification of certificates must be done via a crypto
     * library.
     */
    isIssuer(issuer: Certificate): boolean
    /**
     * Implementers of the #GcrCertificate mixin should call this function to notify
     * when the certificate has changed to emit notifications on the various
     * properties.
     */
    mixinEmitNotify(): void
    /* Methods of Gcr-3.Gcr.Comparable */
    /**
     * Compare whether two objects represent the same thing. The return value can
     * also be used to sort the objects.
     */
    compare(other?: Comparable | null): number
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::expiry", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::expiry", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::expiry", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::expiry", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::expiry", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::icon", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::icon", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::icon", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::icon", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::issuer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::issuer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::issuer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::issuer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::issuer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::label", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::markup", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::markup", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::markup", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::markup", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::markup", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::subject", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::subject", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::subject", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::subject", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::subject", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Pkcs11Certificate_ConstructProps)
    _init (config?: Pkcs11Certificate_ConstructProps): void
    /* Static methods and pseudo-constructors */
    /**
     * Lookup a the issuer of a `certificate` in the PKCS#11 storage. The
     * lookup is done using the issuer DN of the certificate. No certificate chain
     * verification is done. Use a crypto library to make trust decisions.
     * 
     * This call may block, see gcr_pkcs11_certificate_lookup_issuer() for the
     * non-blocking version.
     * 
     * Will return %NULL if no issuer certificate is found. Use `error` to determine
     * if an error occurred.
     */
    static lookupIssuer(certificate: Certificate, cancellable?: Gio.Cancellable | null): Certificate
    /**
     * Lookup a the issuer of a `certificate` in the PKCS#11 storage. The
     * lookup is done using the issuer DN of the certificate. No certificate chain
     * verification is done. Use a crypto library to make trust decisions.
     * 
     * When the operation is finished, callback will be called. You can then call
     * gcr_pkcs11_certificate_lookup_issuer_finish() to get the result of the
     * operation.
     */
    static lookupIssuerAsync(certificate: Certificate, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes an asynchronous operation started by
     * gcr_pkcs11_certificate_lookup_issuer_async().
     * 
     * Will return %NULL if no issuer certificate is found. Use `error` to determine
     * if an error occurred.
     */
    static lookupIssuerFinish(result: Gio.AsyncResult): Certificate
    /**
     * Compare one certificate against another. If the certificates are equal
     * then zero is returned. If one certificate is %NULL or not a certificate,
     * then a non-zero value is returned.
     * 
     * The return value is useful in a stable sort, but has no user logical
     * meaning.
     */
    static compare(first?: Comparable | null, other?: Comparable | null): number
    static $gtype: GObject.Type
}
interface SecretExchange_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gcr-3.Gcr.SecretExchange */
    /**
     * The protocol being used for the exchange.
     * 
     * Will be %NULL if no protocol was specified when creating this object,
     * and either [method`SecretExchange`.begin] or [method`SecretExchange`.receive]
     * have not been called successfully.
     */
    protocol?: string
}
class SecretExchange {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Gcr-3.Gcr.SecretExchange */
    /**
     * Begin the secret exchange. The resulting string should be sent to the other
     * side of the exchange. The other side should use [method`SecretExchange`.receive]
     * to process the string.
     */
    begin(): string
    /**
     * Will return %NULL if no protocol was specified, and either
     * [method`SecretExchange`.begin] or [method`SecretExchange`.receive] have not
     * been called successfully.
     */
    getProtocol(): string
    /**
     * Returns the last secret received. If no secret has yet been received this
     * will return %NULL. The string is owned by the #GcrSecretExchange object
     * and will be valid until the next time that gcr_secret_exchange_receive()
     * is called on this object, or the object is destroyed.
     * 
     * Depending on the secret passed into the other side of the secret exchange,
     * the result may be a binary string. It does however have a null terminator,
     * so if you're certain that it is does not contain arbitrary binary data,
     * it can be used as a string.
     */
    getSecret(): string[]
    /**
     * Receive a string from the other side of secret exchange. This string will
     * have been created by [method`SecretExchange`.begin] or
     * [method`SecretExchange`.send].
     * 
     * After this call completes successfully the value returned from
     * gcr_secret_exchange_get_secret() will have changed.
     */
    receive(exchange: string): boolean
    /**
     * Send a reply to the other side of the secret exchange, optionally sending a
     * secret.
     * 
     * [method`SecretExchange`.receive] must have been successfully called at least
     * once on this object. In other words this object must have received data
     * from the other side of the secret exchange, before we can send a secret.
     */
    send(secret: string | null, secretLen: number): string
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SecretExchange_ConstructProps)
    _init (config?: SecretExchange_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(protocol?: string | null): SecretExchange
    static $gtype: GObject.Type
}
interface SimpleCertificate_ConstructProps extends GObject.Object_ConstructProps {
}
class SimpleCertificate {
    /* Properties of Gcr-3.Gcr.Certificate */
    /**
     * A readable description for this certificate
     */
    readonly description: string
    /**
     * The expiry date of the certificate
     */
    readonly expiry: GLib.Date
    /**
     * An icon representing the certificate
     */
    readonly icon: Gio.Icon
    /**
     * Common name part of the certificate issuer
     */
    readonly issuer: string
    /**
     * A readable label for this certificate.
     */
    readonly label: string
    /**
     * GLib markup to describe the certificate
     */
    readonly markup: string
    /**
     * Common name part of the certificate subject
     */
    readonly subject: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Gcr-3.Gcr.Certificate */
    /**
     * Get the basic constraints for the certificate if present. If %FALSE is
     * returned then no basic constraints are present and the `is_ca` and
     * `path_len` arguments are not changed.
     */
    getBasicConstraints(): [ /* returnType */ boolean, /* isCa */ boolean | null, /* pathLen */ number | null ]
    /**
     * Gets the raw DER data for an X.509 certificate.
     */
    getDerData(): Uint8Array
    /**
     * Get the expiry date of this certificate.
     * 
     * The #GDate returned should be freed by the caller using
     * g_date_free() when no longer required.
     */
    getExpiryDate(): GLib.Date
    /**
     * Calculate the fingerprint for this certificate.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    getFingerprint(type: GLib.ChecksumType): Uint8Array
    /**
     * Calculate the fingerprint for this certificate, and return it
     * as a hex string.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    getFingerprintHex(type: GLib.ChecksumType): string
    /**
     * Get the issued date of this certificate.
     * 
     * The #GDate returned should be freed by the caller using
     * g_date_free() when no longer required.
     */
    getIssuedDate(): GLib.Date
    /**
     * Get the common name of the issuer of this certificate.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getIssuerCn(): string
    /**
     * Get the full issuer DN of the certificate as a (mostly)
     * readable string.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getIssuerDn(): string
    /**
     * Get a name to represent the issuer of this certificate.
     * 
     * This will try to lookup the common name, orianizational unit,
     * organization in that order.
     */
    getIssuerName(): string
    /**
     * Get a part of the DN of the issuer of this certificate.
     * 
     * Examples of a `part` might be the 'OU' (organizational unit)
     * or the 'CN' (common name). Only the value of that part
     * of the DN is returned.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getIssuerPart(part: string): string | null
    /**
     * Get the raw DER data for the issuer DN of the certificate.
     * 
     * The data should be freed by using g_free() when no longer required.
     */
    getIssuerRaw(): Uint8Array
    /**
     * Get the key size in bits of the public key represented
     * by this certificate.
     */
    getKeySize(): number
    /**
     * Calculate a GMarkup string for displaying this certificate.
     */
    getMarkupText(): string
    /**
     * Get the raw binary serial number of the certificate.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    getSerialNumber(): Uint8Array
    /**
     * Get the serial number of the certificate as a hex string.
     * 
     * The caller should free the returned data using g_free() when
     * it is no longer required.
     */
    getSerialNumberHex(): string
    /**
     * Get the common name of the subject of this certificate.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getSubjectCn(): string
    /**
     * Get the full subject DN of the certificate as a (mostly)
     * readable string.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getSubjectDn(): string
    /**
     * Get a name to represent the subject of this certificate.
     * 
     * This will try to lookup the common name, orianizational unit,
     * organization in that order.
     */
    getSubjectName(): string
    /**
     * Get a part of the DN of the subject of this certificate.
     * 
     * Examples of a `part` might be the 'OU' (organizational unit)
     * or the 'CN' (common name). Only the value of that part
     * of the DN is returned.
     * 
     * The string returned should be freed by the caller when no longer
     * required.
     */
    getSubjectPart(part: string): string | null
    /**
     * Get the raw DER data for the subject DN of the certificate.
     * 
     * The data should be freed by using g_free() when no longer required.
     */
    getSubjectRaw(): Uint8Array
    /**
     * Check if `issuer` could be the issuer of this certificate. This is done by
     * comparing the relevant subject and issuer fields. No signature check is
     * done. Proper verification of certificates must be done via a crypto
     * library.
     */
    isIssuer(issuer: Certificate): boolean
    /**
     * Implementers of the #GcrCertificate mixin should call this function to notify
     * when the certificate has changed to emit notifications on the various
     * properties.
     */
    mixinEmitNotify(): void
    /* Methods of Gcr-3.Gcr.Comparable */
    /**
     * Compare whether two objects represent the same thing. The return value can
     * also be used to sort the objects.
     */
    compare(other?: Comparable | null): number
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::expiry", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::expiry", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::expiry", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::expiry", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::expiry", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::icon", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::icon", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::icon", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::icon", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::issuer", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::issuer", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::issuer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::issuer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::issuer", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::label", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::label", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::markup", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::markup", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::markup", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::markup", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::markup", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::subject", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::subject", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::subject", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::subject", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::subject", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SimpleCertificate_ConstructProps)
    _init (config?: SimpleCertificate_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(data: Uint8Array): SimpleCertificate
    /**
     * Compare one certificate against another. If the certificates are equal
     * then zero is returned. If one certificate is %NULL or not a certificate,
     * then a non-zero value is returned.
     * 
     * The return value is useful in a stable sort, but has no user logical
     * meaning.
     */
    static compare(first?: Comparable | null, other?: Comparable | null): number
    static $gtype: GObject.Type
}
interface SimpleCollection_ConstructProps extends GObject.Object_ConstructProps {
}
class SimpleCollection {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Gcr-3.Gcr.SimpleCollection */
    /**
     * Add an object to this collection
     */
    add(object: GObject.Object): void
    /**
     * Remove an object from the collection.
     */
    remove(object: GObject.Object): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Gcr-3.Gcr.Collection */
    /**
     * Check whether the collection contains an object or not.
     */
    contains(object: GObject.Object): boolean
    /**
     * Emit the #GcrCollection::added signal for the given object. This function
     * is used by implementors of this interface.
     */
    emitAdded(object: GObject.Object): void
    /**
     * Emit the #GcrCollection::removed signal for the given object. This function
     * is used by implementors of this interface.
     */
    emitRemoved(object: GObject.Object): void
    /**
     * Get the number of objects in this collection.
     */
    getLength(): number
    /**
     * Get a list of the objects in this collection.
     */
    getObjects(): GObject.Object[]
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gcr-3.Gcr.Collection */
    /**
     * This signal is emitted when an object is added to the collection.
     */
    connect(sigName: "added", callback: ((object: GObject.Object) => void)): number
    on(sigName: "added", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "added", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "added", callback: (object: GObject.Object) => void): NodeJS.EventEmitter
    emit(sigName: "added", object: GObject.Object): void
    /**
     * This signal is emitted when an object is removed from the collection.
     */
    connect(sigName: "removed", callback: ((object: GObject.Object) => void)): number
    on(sigName: "removed", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: (object: GObject.Object) => void): NodeJS.EventEmitter
    emit(sigName: "removed", object: GObject.Object): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SimpleCollection_ConstructProps)
    _init (config?: SimpleCollection_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): SimpleCollection
    static $gtype: GObject.Type
}
interface SshAskpass_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gcr-3.Gcr.SshAskpass */
    /**
     * The interaction used to prompt for passwords.
     */
    interaction?: Gio.TlsInteraction
}
class SshAskpass {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Gcr-3.Gcr.SshAskpass */
    /**
     * Get the interaction associated with this object.
     */
    getInteraction(): Gio.TlsInteraction
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SshAskpass_ConstructProps)
    _init (config?: SshAskpass_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(interaction: Gio.TlsInteraction): SshAskpass
    /**
     * Use this function as a callback setup function passed to g_spawn_sync(),
     * g_spawn_async(), g_spawn_async_with_pipes().
     */
    static childSetup(askpass?: object | null): void
    static $gtype: GObject.Type
}
interface SystemPrompt_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gcr-3.Gcr.SystemPrompt */
    /**
     * The DBus bus name of the prompter to use for prompting, or %NULL
     * for the default prompter.
     */
    busName?: string
    /**
     * The #GcrSecretExchange to use when transferring passwords. A default
     * secret exchange will be used if this is not set.
     */
    secretExchange?: SecretExchange
    /**
     * The timeout in seconds to wait when opening the prompt.
     */
    timeoutSeconds?: number
    /* Constructor properties of Gcr-3.Gcr.Prompt */
    /**
     * The string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     * 
     * In X11, this will be a stringified version of the XWindow handle; in
     * Wayland this is the result of an export using the XDG foreign
     * protocol.
     */
    callerWindow?: string
    /**
     * The label for the cancel button in the prompt.
     */
    cancelLabel?: string
    /**
     * Whether the additional choice is chosen or not.
     * 
     * The additional choice would have been setup using #GcrPrompt:choice-label.
     */
    choiceChosen?: boolean
    /**
     * The label for the additional choice.
     * 
     * If this is a non-%NULL value then an additional boolean choice will be
     * displayed by the prompt allowing the user to select or deselect it.
     * 
     * If %NULL, then no additional choice is displayed.
     * 
     * The initial value of the choice can be set with #GcrPrompt:choice-chosen.
     */
    choiceLabel?: string
    /**
     * The label for the continue button in the prompt.
     */
    continueLabel?: string
    /**
     * The detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * The prompt message should contain relevant information.
     */
    description?: string
    /**
     * The prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     */
    message?: string
    /**
     * Whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     */
    passwordNew?: boolean
    /**
     * The title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * #GcrPrompt:message should contain relevant information.
     */
    title?: string
    /**
     * A prompt warning displayed on the prompt, or %NULL for no warning.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     */
    warning?: string
}
class SystemPrompt {
    /* Properties of Gcr-3.Gcr.SystemPrompt */
    /**
     * The #GcrSecretExchange to use when transferring passwords. A default
     * secret exchange will be used if this is not set.
     */
    secretExchange: SecretExchange
    /* Properties of Gcr-3.Gcr.Prompt */
    /**
     * The string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     * 
     * In X11, this will be a stringified version of the XWindow handle; in
     * Wayland this is the result of an export using the XDG foreign
     * protocol.
     */
    callerWindow: string
    /**
     * The label for the cancel button in the prompt.
     */
    cancelLabel: string
    /**
     * Whether the additional choice is chosen or not.
     * 
     * The additional choice would have been setup using #GcrPrompt:choice-label.
     */
    choiceChosen: boolean
    /**
     * The label for the additional choice.
     * 
     * If this is a non-%NULL value then an additional boolean choice will be
     * displayed by the prompt allowing the user to select or deselect it.
     * 
     * If %NULL, then no additional choice is displayed.
     * 
     * The initial value of the choice can be set with #GcrPrompt:choice-chosen.
     */
    choiceLabel: string
    /**
     * The label for the continue button in the prompt.
     */
    continueLabel: string
    /**
     * The detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * The prompt message should contain relevant information.
     */
    description: string
    /**
     * The prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     */
    message: string
    /**
     * Whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     */
    passwordNew: boolean
    /**
     * Indication of the password strength.
     * 
     * Prompts will return a zero value if the password is empty, and a value
     * greater than zero if the password has any characters.
     * 
     * This is only valid after a successful prompt for a password.
     */
    readonly passwordStrength: number
    /**
     * The title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * #GcrPrompt:message should contain relevant information.
     */
    title: string
    /**
     * A prompt warning displayed on the prompt, or %NULL for no warning.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     */
    warning: string
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Gcr-3.Gcr.SystemPrompt */
    /**
     * Close this prompt. After calling this function, no further prompts will
     * succeed on this object. The prompt object is not unreferenced by this
     * function, and you must unreference it once done.
     * 
     * This call may block, use the gcr_system_prompt_close_async() to perform
     * this action indefinitely.
     * 
     * Whether or not this function returns %TRUE, the system prompt object is
     * still closed and may not be further used.
     */
    close(cancellable?: Gio.Cancellable | null): boolean
    /**
     * Close this prompt asynchronously. After calling this function, no further
     * methods may be called on this object. The prompt object is not unreferenced
     * by this function, and you must unreference it once done.
     * 
     * This call returns immediately and completes asynchronously.
     */
    closeAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Complete operation to close this prompt.
     * 
     * Whether or not this function returns %TRUE, the system prompt object is
     * still closed and may not be further used.
     */
    closeFinish(result: Gio.AsyncResult): boolean
    /**
     * Get the current [class`SecretExchange]` used to transfer secrets in this prompt.
     */
    getSecretExchange(): SecretExchange
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Gcr-3.Gcr.Prompt */
    /**
     * Closes the prompt so that in can no longer be used to prompt. The various
     * prompt methods will return results as if the user dismissed the prompt.
     * 
     * The prompt may also be closed by the implementor of the prompt object.
     * 
     * This emits the [signal`Prompt:`:prompt-close] signal on the prompt object.
     */
    close(): void
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this function to
     * represent the question correctly.
     * 
     * This method will block until the a response is returned from the prompter.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     */
    confirm(cancellable?: Gio.Cancellable | null): PromptReply
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this method to
     * represent the question correctly.
     * 
     * This method will return immediately and complete asynchronously.
     */
    confirmAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to prompt for confirmation.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     */
    confirmFinish(result: Gio.AsyncResult): PromptReply
    /**
     * Prompts for confirmation asking a cancel/continue style question.
     * Set the various properties on the prompt before calling this function to
     * represent the question correctly.
     * 
     * This method will block until the a response is returned from the prompter
     * and will run a main loop similar to a `gtk_dialog_run()`. The application
     * will remain responsive but care must be taken to handle reentrancy issues.
     * 
     * %GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
     * return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
     * an error occurs. Check the `error` argument to tell the difference.
     */
    confirmRun(cancellable?: Gio.Cancellable | null): PromptReply
    /**
     * Get the string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     */
    getCallerWindow(): string
    /**
     * Get the label for the cancel button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
     * from the prompt.
     */
    getCancelLabel(): string
    /**
     * Get whether the additional choice was chosen or not.
     * 
     * The additional choice would have been setup using
     * gcr_prompt_set_choice_label().
     */
    getChoiceChosen(): boolean
    /**
     * Get the label for the additional choice.
     * 
     * This will be %NULL if no additional choice is being displayed.
     */
    getChoiceLabel(): string
    /**
     * Get the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
     * from the prompt.
     */
    getContinueLabel(): string
    /**
     * Get the detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * The prompt message should contain relevant information.
     */
    getDescription(): string
    /**
     * Gets the prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     */
    getMessage(): string
    /**
     * Get whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     */
    getPasswordNew(): boolean
    /**
     * Get indication of the password strength.
     * 
     * Prompts will return a zero value if the password is empty, and a value
     * greater than zero if the password has any characters.
     * 
     * This is only valid after a successful prompt for a password.
     */
    getPasswordStrength(): number
    /**
     * Gets the title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * prompt message should contain relevant information.
     */
    getTitle(): string
    /**
     * Get a prompt warning displayed on the prompt.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     * 
     * If this string is %NULL then no warning is displayed.
     */
    getWarning(): string
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will block until the a response is returned from the prompter.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     */
    password(cancellable?: Gio.Cancellable | null): string
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will return immediately and complete asynchronously.
     */
    passwordAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to prompt for a password.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     */
    passwordFinish(result: Gio.AsyncResult): string
    /**
     * Prompts for password. Set the various properties on the prompt before calling
     * this method to explain which password should be entered.
     * 
     * This method will block until the a response is returned from the prompter
     * and will run a main loop similar to a gtk_dialog_run(). The application
     * will remain responsive but care must be taken to handle reentrancy issues.
     * 
     * A password will be returned if the user enters a password successfully.
     * The returned password is valid until the next time a method is called
     * to display another prompt.
     * 
     * %NULL will be returned if the user cancels or if an error occurs. Check the
     * `error` argument to tell the difference.
     */
    passwordRun(cancellable?: Gio.Cancellable | null): string
    /**
     * Reset the contents and properties of the prompt.
     */
    reset(): void
    /**
     * Set the string handle of the caller's window.
     * 
     * The caller window indicates to the prompt which window is prompting the
     * user. The prompt may choose to ignore this information or use it in whatever
     * way it sees fit.
     */
    setCallerWindow(windowId: string): void
    /**
     * Set the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
     * from the prompt.
     */
    setCancelLabel(cancelLabel: string): void
    /**
     * Set whether the additional choice is chosen or not.
     * 
     * The additional choice should be set up using gcr_prompt_set_choice_label().
     */
    setChoiceChosen(chosen: boolean): void
    /**
     * Set the label for the additional choice.
     * 
     * If this is a non-%NULL value then an additional boolean choice will be
     * displayed by the prompt allowing the user to select or deselect it.
     * 
     * The initial value of the choice can be set with the
     * gcr_prompt_set_choice_label() method.
     * 
     * If this is %NULL, then no additional choice is being displayed.
     */
    setChoiceLabel(choiceLabel?: string | null): void
    /**
     * Set the label for the continue button.
     * 
     * This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
     * from the prompt.
     */
    setContinueLabel(continueLabel: string): void
    /**
     * Set the detailed description of the prompt.
     * 
     * A prompt implementation may choose not to display this detailed description.
     * Use gcr_prompt_set_message() to set a general message containing relevant
     * information.
     */
    setDescription(description: string): void
    /**
     * Sets the prompt message for the user.
     * 
     * A prompt implementation should always display this message.
     */
    setMessage(message: string): void
    /**
     * Set whether the prompt will prompt for a new password.
     * 
     * This will cause the prompt implementation to ask the user to confirm the
     * password and/or display other relevant user interface for creating a new
     * password.
     */
    setPasswordNew(newPassword: boolean): void
    /**
     * Sets the title of the prompt.
     * 
     * A prompt implementation may choose not to display the prompt title. The
     * prompt message should contain relevant information.
     */
    setTitle(title: string): void
    /**
     * Set a prompt warning displayed on the prompt.
     * 
     * This is a warning like "The password is incorrect." usually displayed to the
     * user about a previous 'unsuccessful' prompt.
     * 
     * If this string is %NULL then no warning is displayed.
     */
    setWarning(warning?: string | null): void
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    /**
     * Starts asynchronous initialization of the object implementing the
     * interface. This must be done before any real use of the object after
     * initial construction. If the object also implements #GInitable you can
     * optionally call g_initable_init() instead.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_async_initable_new_async() should typically be used instead.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_init_finish() to get the result of the
     * initialization.
     * 
     * Implementations may also support cancellation. If `cancellable` is not
     * %NULL, then initialization can be cancelled by triggering the cancellable
     * object from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL, and
     * the object doesn't support cancellable initialization, the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * As with #GInitable, if the object is not initialized, or initialization
     * returns with an error, then all operations on the object except
     * g_object_ref() and g_object_unref() are considered to be invalid, and
     * have undefined behaviour. They will often fail with g_critical() or
     * g_warning(), but this must not be relied on.
     * 
     * Callers should not assume that a class which implements #GAsyncInitable can
     * be initialized multiple times; for more information, see g_initable_init().
     * If a class explicitly supports being initialized multiple times,
     * implementation requires yielding all subsequent calls to init_async() on the
     * results of the first call.
     * 
     * For classes that also support the #GInitable interface, the default
     * implementation of this method will run the g_initable_init() function
     * in a thread, so if you want to support asynchronous initialization via
     * threads, just implement the #GAsyncInitable interface without overriding
     * any interface methods.
     */
    initAsync(ioPriority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Finishes asynchronous initialization and returns the result.
     * See g_async_initable_init_async().
     */
    initFinish(res: Gio.AsyncResult): boolean
    /**
     * Finishes the async construction for the various g_async_initable_new
     * calls, returning the created object or %NULL on error.
     */
    newFinish(res: Gio.AsyncResult): GObject.Object
    /* Methods of Gio-2.0.Gio.Initable */
    /**
     * Initializes the object implementing the interface.
     * 
     * This method is intended for language bindings. If writing in C,
     * g_initable_new() should typically be used instead.
     * 
     * The object must be initialized before any real use after initial
     * construction, either with this function or g_async_initable_init_async().
     * 
     * Implementations may also support cancellation. If `cancellable` is not %NULL,
     * then initialization can be cancelled by triggering the cancellable object
     * from another thread. If the operation was cancelled, the error
     * %G_IO_ERROR_CANCELLED will be returned. If `cancellable` is not %NULL and
     * the object doesn't support cancellable initialization the error
     * %G_IO_ERROR_NOT_SUPPORTED will be returned.
     * 
     * If the object is not initialized, or initialization returns with an
     * error, then all operations on the object except g_object_ref() and
     * g_object_unref() are considered to be invalid, and have undefined
     * behaviour. See the [introduction][ginitable] for more details.
     * 
     * Callers should not assume that a class which implements #GInitable can be
     * initialized multiple times, unless the class explicitly documents itself as
     * supporting this. Generally, a class’ implementation of init() can assume
     * (and assert) that it will only be called once. Previously, this documentation
     * recommended all #GInitable implementations should be idempotent; that
     * recommendation was relaxed in GLib 2.54.
     * 
     * If a class explicitly supports being initialized multiple times, it is
     * recommended that the method is idempotent: multiple calls with the same
     * arguments should return the same results. Only the first call initializes
     * the object; further calls return the result of the first call.
     * 
     * One reason why a class might need to support idempotent initialization is if
     * it is designed to be used via the singleton pattern, with a
     * #GObjectClass.constructor that sometimes returns an existing instance.
     * In this pattern, a caller would expect to be able to call g_initable_init()
     * on the result of g_object_new(), regardless of whether it is in fact a new
     * instance.
     */
    init(cancellable?: Gio.Cancellable | null): boolean
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gcr-3.Gcr.Prompt */
    /**
     * Action signal fired when the prompt is to be closed. After the default
     * handler has run, the prompt is closed. The various prompting methods
     * will return results as if the user dismissed the prompt.
     * 
     * You can use the [method`Prompt`.close] method to emit this signal.
     */
    connect(sigName: "prompt-close", callback: (() => void)): number
    on(sigName: "prompt-close", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "prompt-close", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "prompt-close", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "prompt-close"): void
    connect(sigName: "notify::secret-exchange", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::secret-exchange", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::secret-exchange", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::secret-exchange", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::secret-exchange", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::caller-window", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::caller-window", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::caller-window", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::caller-window", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::caller-window", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cancel-label", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cancel-label", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cancel-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cancel-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cancel-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::choice-chosen", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::choice-chosen", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::choice-chosen", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::choice-chosen", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::choice-chosen", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::choice-label", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::choice-label", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::choice-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::choice-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::choice-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::continue-label", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::continue-label", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::continue-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::continue-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::continue-label", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::message", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-new", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-new", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-new", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-new", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-new", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-strength", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-strength", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-strength", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-strength", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-strength", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::title", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::title", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::title", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::title", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::title", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::warning", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::warning", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::warning", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::warning", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::warning", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SystemPrompt_ConstructProps)
    _init (config?: SystemPrompt_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static errorGetDomain(): GLib.Quark
    /**
     * Opens a system prompt with the default prompter.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this function will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     */
    static open(timeoutSeconds: number, cancellable?: Gio.Cancellable | null): SystemPrompt
    /**
     * Asynchronously open a system prompt with the default system prompter.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this operation will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     */
    static openAsync(timeoutSeconds: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Complete an operation to asynchronously open a system prompt.
     */
    static openFinish(result: Gio.AsyncResult): SystemPrompt
    /**
     * Opens a system prompt. If prompter_name is %NULL, then the default
     * system prompter is used.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this function will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     */
    static openForPrompter(prompterName: string | null, timeoutSeconds: number, cancellable?: Gio.Cancellable | null): SystemPrompt
    /**
     * Opens a system prompt asynchronously. If prompter_name is %NULL, then the
     * default system prompter is used.
     * 
     * Most system prompters only allow showing one prompt at a time, and if
     * another prompt is shown then this method will block for up to
     * `timeout_seconds` seconds. If `timeout_seconds` is equal to -1, then this
     * will block indefinitely until the prompt can be opened. If `timeout_seconds`
     * expires, then this operation will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
     * error.
     */
    static openForPrompterAsync(prompterName: string | null, timeoutSeconds: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GAsyncInitable object. This is
     * similar to g_object_newv() but also initializes the object asynchronously.
     * 
     * When the initialization is finished, `callback` will be called. You can
     * then call g_async_initable_new_finish() to get the new object and check
     * for any errors.
     */
    static newvAsync(objectType: GObject.Type, nParameters: number, parameters: GObject.Parameter, ioPriority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    /**
     * Helper function for constructing #GInitable object. This is
     * similar to g_object_newv() but also initializes the object
     * and returns %NULL, setting an error on failure.
     */
    static newv(objectType: GObject.Type, parameters: GObject.Parameter[], cancellable?: Gio.Cancellable | null): GObject.Object
    static $gtype: GObject.Type
}
interface SystemPrompter_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of Gcr-3.Gcr.SystemPrompter */
    /**
     * The #GType for prompts created by this prompter. This must be a
     * #GcrPrompt implementation.
     */
    promptType?: GObject.Type
}
class SystemPrompter {
    /* Properties of Gcr-3.Gcr.SystemPrompter */
    /**
     * Whether the prompter is prompting or not.
     */
    readonly prompting: boolean
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Gcr-3.Gcr.SystemPrompter */
    /**
     * Get the mode for this prompter.
     * 
     * Most system prompters only display one prompt at a time and therefore
     * return %GCR_SYSTEM_PROMPTER_SINGLE.
     */
    getMode(): SystemPrompterMode
    /**
     * Get the #GType for prompts created by this prompter.
     * 
     * The returned #GType will be a #GcrPrompt implementation.
     */
    getPromptType(): GObject.Type
    /**
     * Get whether prompting or not.
     */
    getPrompting(): boolean
    /**
     * Register this system prompter on the DBus `connection`.
     * 
     * This makes the prompter available for clients to call. The prompter will
     * remain registered until gcr_system_prompter_unregister() is called, or the
     * prompter is unreferenced.
     */
    register(connection: Gio.DBusConnection): void
    /**
     * Unregister this system prompter on the DBus `connection`.
     * 
     * The prompter must have previously been registered with gcr_system_prompter_register().
     * 
     * If `wait` is set then this function will wait until all prompts have been closed
     * or cancelled. This is usually only used by tests.
     */
    unregister(wait: boolean): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Signals of Gcr-3.Gcr.SystemPrompter */
    /**
     * Signal emitted to create a new prompt when needed.
     * 
     * The default implementation of this signal creates a prompt of the type
     * gcr_system_prompter_get_prompt_type().
     */
    connect(sigName: "new-prompt", callback: (() => Prompt)): number
    on(sigName: "new-prompt", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "new-prompt", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "new-prompt", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "new-prompt"): void
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::prompting", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::prompting", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::prompting", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::prompting", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::prompting", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SystemPrompter_ConstructProps)
    _init (config?: SystemPrompter_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(mode: SystemPrompterMode, promptType: GObject.Type): SystemPrompter
    static $gtype: GObject.Type
}
interface UnionCollection_ConstructProps extends GObject.Object_ConstructProps {
}
class UnionCollection {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of Gcr-3.Gcr.UnionCollection */
    /**
     * Add objects from this collection to the union
     */
    add(collection: Collection): void
    /**
     * Get the collections that have been added to this union.
     */
    elements(): Collection[]
    /**
     * Check whether the collection is present in the union.
     */
    have(collection: Collection): boolean
    /**
     * Remove an object from the collection.
     */
    remove(collection: Collection): void
    /**
     * Return the number of collections in this union. This does not reflect
     * the number of objects in the combined collection.
     */
    size(): number
    /**
     * Add objects from this collection to the union. Do not add an additional
     * reference to the collection.
     */
    take(collection: Collection): void
    /* Methods of GObject-2.0.GObject.Object */
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target`.
     * 
     * Whenever the `source_property` is changed the `target_property` is
     * updated using the same value. For instance:
     * 
     * 
     * ```c
     *   g_object_bind_property (action, "active", widget, "sensitive", 0);
     * ```
     * 
     * 
     * Will result in the "sensitive" property of the widget #GObject instance to be
     * updated with the same value of the "active" property of the action #GObject
     * instance.
     * 
     * If `flags` contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
     * if `target_property` on `target` changes then the `source_property` on `source`
     * will be updated as well.
     * 
     * The binding will automatically be removed when either the `source` or the
     * `target` instances are finalized. To remove the binding without affecting the
     * `source` and the `target` you can just call g_object_unref() on the returned
     * #GBinding instance.
     * 
     * Removing the binding by calling g_object_unref() on it must only be done if
     * the binding, `source` and `target` are only used from a single thread and it
     * is clear that both `source` and `target` outlive the binding. Especially it
     * is not safe to rely on this if the binding, `source` or `target` can be
     * finalized from different threads. Keep another reference to the binding and
     * use g_binding_unbind() instead to be on the safe side.
     * 
     * A #GObject can have multiple bindings.
     */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    /**
     * Creates a binding between `source_property` on `source` and `target_property`
     * on `target,` allowing you to set the transformation functions to be used by
     * the binding.
     * 
     * This function is the language bindings friendly version of
     * g_object_bind_property_full(), using #GClosures instead of
     * function pointers.
     */
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    /**
     * This function is intended for #GObject implementations to re-enforce
     * a [floating][floating-ref] object reference. Doing this is seldom
     * required: all #GInitiallyUnowneds are created with a floating reference
     * which usually just needs to be sunken by calling g_object_ref_sink().
     */
    forceFloating(): void
    /**
     * Increases the freeze count on `object`. If the freeze count is
     * non-zero, the emission of "notify" signals on `object` is
     * stopped. The signals are queued until the freeze count is decreased
     * to zero. Duplicate notifications are squashed so that at most one
     * #GObject::notify signal is emitted for each property modified while the
     * object is frozen.
     * 
     * This is necessary for accessors that modify multiple properties to prevent
     * premature notification while the object is still being modified.
     */
    freezeNotify(): void
    /**
     * Gets a named field from the objects table of associations (see g_object_set_data()).
     */
    getData(key: string): object | null
    /**
     * Gets a property of an object.
     * 
     * The `value` can be:
     * 
     *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
     *    automatically initialized with the expected type of the property
     *    (since GLib 2.60)
     *  - a #GValue initialized with the expected type of the property
     *  - a #GValue initialized with a type to which the expected type
     *    of the property can be transformed
     * 
     * In general, a copy is made of the property contents and the caller is
     * responsible for freeing the memory by calling g_value_unset().
     * 
     * Note that g_object_get_property() is really intended for language
     * bindings, g_object_get() is much more convenient for C programming.
     */
    getProperty(propertyName: string, value: any): void
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata().
     */
    getQdata(quark: GLib.Quark): object | null
    /**
     * Gets `n_properties` properties for an `object`.
     * Obtained properties will be set to `values`. All properties must be valid.
     * Warnings will be emitted and undefined behaviour may result if invalid
     * properties are passed in.
     */
    getv(names: string[], values: any[]): void
    /**
     * Checks whether `object` has a [floating][floating-ref] reference.
     */
    isFloating(): boolean
    /**
     * Emits a "notify" signal for the property `property_name` on `object`.
     * 
     * When possible, eg. when signaling a property change from within the class
     * that registered the property, you should use g_object_notify_by_pspec()
     * instead.
     * 
     * Note that emission of the notify signal may be blocked with
     * g_object_freeze_notify(). In this case, the signal emissions are queued
     * and will be emitted (in reverse order) when g_object_thaw_notify() is
     * called.
     */
    notify(propertyName: string): void
    /**
     * Emits a "notify" signal for the property specified by `pspec` on `object`.
     * 
     * This function omits the property name lookup, hence it is faster than
     * g_object_notify().
     * 
     * One way to avoid using g_object_notify() from within the
     * class that registered the properties, and using g_object_notify_by_pspec()
     * instead, is to store the GParamSpec used with
     * g_object_class_install_property() inside a static array, e.g.:
     * 
     * 
     * ```c
     *   enum
     *   {
     *     PROP_0,
     *     PROP_FOO,
     *     PROP_LAST
     *   };
     * 
     *   static GParamSpec *properties[PROP_LAST];
     * 
     *   static void
     *   my_object_class_init (MyObjectClass *klass)
     *   {
     *     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
     *                                              0, 100,
     *                                              50,
     *                                              G_PARAM_READWRITE);
     *     g_object_class_install_property (gobject_class,
     *                                      PROP_FOO,
     *                                      properties[PROP_FOO]);
     *   }
     * ```
     * 
     * 
     * and then notify a change on the "foo" property with:
     * 
     * 
     * ```c
     *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
     * ```
     * 
     */
    notifyByPspec(pspec: GObject.ParamSpec): void
    /**
     * Increases the reference count of `object`.
     * 
     * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
     * of `object` will be propagated to the return type (using the GCC typeof()
     * extension), so any casting the caller needs to do on the return type must be
     * explicit.
     */
    ref(): GObject.Object
    /**
     * Increase the reference count of `object,` and possibly remove the
     * [floating][floating-ref] reference, if `object` has a floating reference.
     * 
     * In other words, if the object is floating, then this call "assumes
     * ownership" of the floating reference, converting it to a normal
     * reference by clearing the floating flag while leaving the reference
     * count unchanged.  If the object is not floating, then this call
     * adds a new normal reference increasing the reference count by one.
     * 
     * Since GLib 2.56, the type of `object` will be propagated to the return type
     * under the same conditions as for g_object_ref().
     */
    refSink(): GObject.Object
    /**
     * Releases all references to other objects. This can be used to break
     * reference cycles.
     * 
     * This function should only be called from object system implementations.
     */
    runDispose(): void
    /**
     * Each object carries around a table of associations from
     * strings to pointers.  This function lets you set an association.
     * 
     * If the object already had an association with that name,
     * the old association will be destroyed.
     * 
     * Internally, the `key` is converted to a #GQuark using g_quark_from_string().
     * This means a copy of `key` is kept permanently (even after `object` has been
     * finalized) — so it is recommended to only use a small, bounded set of values
     * for `key` in your program, to avoid the #GQuark storage growing unbounded.
     */
    setData(key: string, data?: object | null): void
    /**
     * Sets a property on an object.
     */
    setProperty(propertyName: string, value: any): void
    /**
     * Remove a specified datum from the object's data associations,
     * without invoking the association's destroy handler.
     */
    stealData(key: string): object | null
    /**
     * This function gets back user data pointers stored via
     * g_object_set_qdata() and removes the `data` from object
     * without invoking its destroy() function (if any was
     * set).
     * Usually, calling this function is only required to update
     * user data pointers with a destroy notifier, for example:
     * 
     * ```c
     * void
     * object_add_to_user_list (GObject     *object,
     *                          const gchar *new_string)
     * {
     *   // the quark, naming the object data
     *   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
     *   // retrieve the old string list
     *   GList *list = g_object_steal_qdata (object, quark_string_list);
     * 
     *   // prepend new string
     *   list = g_list_prepend (list, g_strdup (new_string));
     *   // this changed 'list', so we need to set it again
     *   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
     * }
     * static void
     * free_string_list (gpointer data)
     * {
     *   GList *node, *list = data;
     * 
     *   for (node = list; node; node = node->next)
     *     g_free (node->data);
     *   g_list_free (list);
     * }
     * ```
     * 
     * Using g_object_get_qdata() in the above example, instead of
     * g_object_steal_qdata() would have left the destroy function set,
     * and thus the partial string list would have been freed upon
     * g_object_set_qdata_full().
     */
    stealQdata(quark: GLib.Quark): object | null
    /**
     * Reverts the effect of a previous call to
     * g_object_freeze_notify(). The freeze count is decreased on `object`
     * and when it reaches zero, queued "notify" signals are emitted.
     * 
     * Duplicate notifications for each property are squashed so that at most one
     * #GObject::notify signal is emitted for each property, in the reverse order
     * in which they have been queued.
     * 
     * It is an error to call this function when the freeze count is zero.
     */
    thawNotify(): void
    /**
     * Decreases the reference count of `object`. When its reference count
     * drops to 0, the object is finalized (i.e. its memory is freed).
     * 
     * If the pointer to the #GObject may be reused in future (for example, if it is
     * an instance variable of another object), it is recommended to clear the
     * pointer to %NULL rather than retain a dangling pointer to a potentially
     * invalid #GObject instance. Use g_clear_object() for this.
     */
    unref(): void
    /**
     * This function essentially limits the life time of the `closure` to
     * the life time of the object. That is, when the object is finalized,
     * the `closure` is invalidated by calling g_closure_invalidate() on
     * it, in order to prevent invocations of the closure with a finalized
     * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
     * added as marshal guards to the `closure,` to ensure that an extra
     * reference count is held on `object` during invocation of the
     * `closure`.  Usually, this function will be called on closures that
     * use this `object` as closure data.
     */
    watchClosure(closure: Function): void
    /* Methods of Gcr-3.Gcr.Collection */
    /**
     * Check whether the collection contains an object or not.
     */
    contains(object: GObject.Object): boolean
    /**
     * Emit the #GcrCollection::added signal for the given object. This function
     * is used by implementors of this interface.
     */
    emitAdded(object: GObject.Object): void
    /**
     * Emit the #GcrCollection::removed signal for the given object. This function
     * is used by implementors of this interface.
     */
    emitRemoved(object: GObject.Object): void
    /**
     * Get the number of objects in this collection.
     */
    getLength(): number
    /**
     * Get a list of the objects in this collection.
     */
    getObjects(): GObject.Object[]
    /* Signals of GObject-2.0.GObject.Object */
    /**
     * The notify signal is emitted on an object when one of its properties has
     * its value set through g_object_set_property(), g_object_set(), et al.
     * 
     * Note that getting this signal doesn’t itself guarantee that the value of
     * the property has actually changed. When it is emitted is determined by the
     * derived GObject class. If the implementor did not create the property with
     * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
     * in ::notify being emitted, even if the new value is the same as the old.
     * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
     * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
     * and common practice is to do that only when the value has actually changed.
     * 
     * This signal is typically used to obtain change notification for a
     * single property, by specifying the property name as a detail in the
     * g_signal_connect() call, like this:
     * 
     * 
     * ```c
     * g_signal_connect (text_view->buffer, "notify::paste-target-list",
     *                   G_CALLBACK (gtk_text_view_target_list_notify),
     *                   text_view)
     * ```
     * 
     * 
     * It is important to note that you must use
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    /* Signals of Gcr-3.Gcr.Collection */
    /**
     * This signal is emitted when an object is added to the collection.
     */
    connect(sigName: "added", callback: ((object: GObject.Object) => void)): number
    on(sigName: "added", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "added", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "added", callback: (object: GObject.Object) => void): NodeJS.EventEmitter
    emit(sigName: "added", object: GObject.Object): void
    /**
     * This signal is emitted when an object is removed from the collection.
     */
    connect(sigName: "removed", callback: ((object: GObject.Object) => void)): number
    on(sigName: "removed", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: (object: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: (object: GObject.Object) => void): NodeJS.EventEmitter
    emit(sigName: "removed", object: GObject.Object): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: UnionCollection_ConstructProps)
    _init (config?: UnionCollection_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): UnionCollection
    static $gtype: GObject.Type
}
abstract class CertificateChainClass {
    /* Fields of Gcr-3.Gcr.CertificateChainClass */
    /**
     * The parent class
     */
    readonly parentClass: GObject.ObjectClass
    static name: string
}
class CertificateChainPrivate {
    static name: string
}
abstract class CertificateIface {
    /* Fields of Gcr-3.Gcr.CertificateIface */
    /**
     * the parent interface type
     */
    readonly parent: GObject.TypeInterface
    readonly getDerData: (self: Certificate) => Uint8Array
    static name: string
}
abstract class CertificateRequestClass {
    /* Fields of Gcr-3.Gcr.CertificateRequestClass */
    readonly parentClass: GObject.ObjectClass
    static name: string
}
abstract class CollectionIface {
    /* Fields of Gcr-3.Gcr.CollectionIface */
    readonly parent: GObject.TypeInterface
    readonly added: (self: Collection, object: GObject.Object) => void
    readonly removed: (self: Collection, object: GObject.Object) => void
    readonly getLength: (self: Collection) => number
    readonly getObjects: (self: Collection) => GObject.Object[]
    readonly contains: (self: Collection, object: GObject.Object) => boolean
    static name: string
}
class Column {
    /* Fields of Gcr-3.Gcr.Column */
    readonly propertyName: string
    readonly propertyType: GObject.Type
    readonly columnType: GObject.Type
    readonly label: string
    readonly flags: ColumnFlags
    readonly transformer: GObject.ValueTransform
    readonly userData: object
    static name: string
}
abstract class ComparableIface {
    /* Fields of Gcr-3.Gcr.ComparableIface */
    /**
     * type interface
     */
    readonly parent: GObject.TypeInterface
    readonly compare: (self: Comparable, other?: Comparable | null) => number
    static name: string
}
abstract class FilterCollectionClass {
    /* Fields of Gcr-3.Gcr.FilterCollectionClass */
    /**
     * the parent class
     */
    readonly parentClass: GObject.ObjectClass
    static name: string
}
class FilterCollectionPrivate {
    static name: string
}
abstract class ImportInteractionIface {
    /* Fields of Gcr-3.Gcr.ImportInteractionIface */
    /**
     * parent interface
     */
    readonly parent: GObject.TypeInterface
    readonly supplementPrep: (interaction: ImportInteraction, builder: Gck.Builder) => void
    readonly supplement: (interaction: ImportInteraction, builder: Gck.Builder, cancellable?: Gio.Cancellable | null) => Gio.TlsInteractionResult
    readonly supplementAsync: (interaction: ImportInteraction, builder: Gck.Builder, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null) => void
    readonly supplementFinish: (interaction: ImportInteraction, result: Gio.AsyncResult) => Gio.TlsInteractionResult
    static name: string
}
abstract class ImporterIface {
    /* Fields of Gcr-3.Gcr.ImporterIface */
    /**
     * parent interface
     */
    readonly parent: GObject.TypeInterface
    readonly queueForParsed: (importer: Importer, parsed: Parsed) => boolean
    readonly importSync: (importer: Importer, cancellable?: Gio.Cancellable | null) => boolean
    readonly importAsync: (importer: Importer, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null) => void
    readonly importFinish: (importer: Importer, result: Gio.AsyncResult) => boolean
    static name: string
}
class Parsed {
    /* Methods of Gcr-3.Gcr.Parsed */
    /**
     * Get the attributes which make up the parsed item.
     */
    getAttributes(): Gck.Attributes | null
    /**
     * Get the raw data block for the parsed item.
     */
    getBytes(): any
    /**
     * Get the raw data block for the parsed item.
     */
    getData(): Uint8Array | null
    /**
     * Get the descirption for a parsed item.
     */
    getDescription(): string | null
    /**
     * Get the filename of the parsed item.
     */
    getFilename(): string
    /**
     * Get the format of the parsed item.
     */
    getFormat(): DataFormat
    /**
     * Get the label for the parsed item.
     */
    getLabel(): string | null
    /**
     * Add a reference to a parsed item. An item may not be shared across threads
     * until it has been referenced at least once.
     */
    ref(): Parsed
    static name: string
    /* Static methods and pseudo-constructors */
    /**
     * Unreferences a parsed item which was referenced with gcr_parsed_ref()
     */
    static unref(parsed?: object | null): void
}
abstract class ParserClass {
    /* Fields of Gcr-3.Gcr.ParserClass */
    /**
     * The parent class
     */
    readonly parentClass: GObject.ObjectClass
    readonly authenticate: (self: Parser, count: number) => boolean
    readonly parsed: (self: Parser) => void
    static name: string
}
class ParserPrivate {
    static name: string
}
abstract class Pkcs11CertificateClass {
    static name: string
}
class Pkcs11CertificatePrivate {
    static name: string
}
abstract class PromptIface {
    /* Fields of Gcr-3.Gcr.PromptIface */
    /**
     * parent interface
     */
    readonly parentIface: GObject.TypeInterface
    readonly promptPasswordAsync: (prompt: Prompt, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null) => void
    readonly promptPasswordFinish: (prompt: Prompt, result: Gio.AsyncResult) => string
    readonly promptConfirmAsync: (prompt: Prompt, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null) => void
    readonly promptConfirmFinish: (prompt: Prompt, result: Gio.AsyncResult) => PromptReply
    readonly promptClose: (prompt: Prompt) => void
    static name: string
}
abstract class SecretExchangeClass {
    /* Fields of Gcr-3.Gcr.SecretExchangeClass */
    readonly generateExchangeKey: (exchange: SecretExchange, scheme: string, publicKey: number, nPublicKey: number) => boolean
    readonly deriveTransportKey: (exchange: SecretExchange, peer: number, nPeer: number) => boolean
    static name: string
}
class SecretExchangePrivate {
    static name: string
}
abstract class SimpleCertificateClass {
    /* Fields of Gcr-3.Gcr.SimpleCertificateClass */
    readonly parentClass: GObject.ObjectClass
    static name: string
}
class SimpleCertificatePrivate {
    static name: string
}
abstract class SimpleCollectionClass {
    /* Fields of Gcr-3.Gcr.SimpleCollectionClass */
    readonly parentClass: GObject.ObjectClass
    static name: string
}
class SimpleCollectionPrivate {
    static name: string
}
abstract class SshAskpassClass {
    /* Fields of Gcr-3.Gcr.SshAskpassClass */
    readonly parentClass: GObject.ObjectClass
    static name: string
}
abstract class SystemPromptClass {
    /* Fields of Gcr-3.Gcr.SystemPromptClass */
    readonly parentClass: GObject.ObjectClass
    static name: string
}
class SystemPromptPrivate {
    static name: string
}
abstract class SystemPrompterClass {
    /* Fields of Gcr-3.Gcr.SystemPrompterClass */
    /**
     * parent class
     */
    readonly parentClass: GObject.ObjectClass
    static name: string
}
class SystemPrompterPrivate {
    static name: string
}
abstract class UnionCollectionClass {
    /* Fields of Gcr-3.Gcr.UnionCollectionClass */
    readonly parentClass: GObject.ObjectClass
    static name: string
}
class UnionCollectionPrivate {
    static name: string
}
}
export default Gcr;